<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 记一次简单计算验证码的识别过程 · 浮萍's Blog</title><meta name="description" content="记一次简单计算验证码的识别过程 - 浮萍"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css"><link rel="search" type="application/opensearchdescription+xml" href="https://fuping.site/atom.xml" title="浮萍's Blog"><script src="//code.jquery.com/jquery-2.2.4.min.js" integrity="sha256-BbhdlvQf/xTY9gja0Dq3HiwQF8LaCRTXxZKRutelT44=" crossorigin="anonymous"></script><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="浮萍's Blog" type="application/atom+xml">
</head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">主页</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">所有文章</a></li><li class="nav-list-item"><a href="/tags" target="_self" class="nav-list-link">标签</a></li><li class="nav-list-item"><a href="/about" target="_self" class="nav-list-link">关于</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li><li class="nav-list-item"><a href="/search" target="_self" class="nav-list-link search"><i class="fa fa-search" aria-hidden="true"></i></a></li></ul></header><main class="container"></main><div class="post"><article class="post-block"><h1 class="post-title">记一次简单计算验证码的识别过程</h1><div class="post-info">Jan 19, 2022<span class="categories"><i class="fa fa-bookmark" aria-hidden="true"></i></span><a href="/categories/%E9%AA%8C%E8%AF%81%E7%A0%81%E8%AF%86%E5%88%AB/" class="post-category">#验证码识别</a></div><div class="post-content"><h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00  前言"></a>0x00  前言</h2><p>某CMS的验证码是简单的计算验证码，都是一位数的加减乘除运算，之前尝试用分割的方法识别，但成功率较低。后来采用了pytorch训练后进行识别，可以达到98%以上的识别率，于是整理一下过程，水一篇文章。</p>
<a id="more"></a>

<h2 id="0x01-验证码的获取"><a href="#0x01-验证码的获取" class="headerlink" title="0x01  验证码的获取"></a>0x01  验证码的获取</h2><p>首先是验证码的获取，由于爬取验证码还要手工标注，比较麻烦，这里可以通过修改程序来批量生成标注好的样本。</p>
<p>主要代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.google.code.kaptcha.Producer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenCalculateCaptcha</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Producer kaptcha = <span class="keyword">new</span> CaptchaConfig().getKaptchaBeanMath();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">            String capText = kaptcha.createText();</span><br><span class="line">            String capStr = capText.substring(<span class="number">0</span>, capText.lastIndexOf(<span class="string">"@"</span>));</span><br><span class="line">            System.out.println(capStr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>执行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">6-1&#x3D;?</span><br><span class="line">9+1&#x3D;?</span><br><span class="line">0+5&#x3D;?</span><br><span class="line">8*6&#x3D;?</span><br><span class="line">6&#x2F;1&#x3D;?</span><br><span class="line">5+7&#x3D;?</span><br><span class="line">9+3&#x3D;?</span><br><span class="line">0&#x2F;5&#x3D;?</span><br><span class="line">1*2&#x3D;?</span><br><span class="line">...</span><br></pre></td></tr></table></figure>



<p>通过执行的结果可以发现，生成的验证码中会出现<code>*</code>、<code>/</code>、<code>?</code>等字符，这些字符在作为文件名时不合法，所以需要进行替换。</p>
<p>例如将除号<code>/</code>替换为<code>÷</code>，乘号<code>*</code>替换为<code>×</code>，问号<code>?</code>替换为<code>？</code>。</p>
<p>同时为了避免生成的验证码重复，生成的文件名拼接了时间戳的md5，并用<code>_</code>连接。</p>
<p>替换的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String newCapStr = capStr.replace(<span class="string">"/"</span>,<span class="string">"÷"</span>).replace(<span class="string">"*"</span>,<span class="string">"×"</span>).replace(<span class="string">"?"</span>,<span class="string">"？"</span>) + <span class="string">"_"</span> + DigestUtils.md5Hex(<span class="string">""</span>+System.currentTimeMillis())+<span class="string">".jpg"</span>;</span><br></pre></td></tr></table></figure>

<p>再次执行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">8×4&#x3D;？_b69426246067db177639de42b77082ab.jpg</span><br><span class="line">3÷1&#x3D;？_d0ad2c5c50b4d8db2736093bdf2c08e8.jpg</span><br><span class="line">6÷3&#x3D;？_d0a992ce88acf8a918f12646bef3a60d.jpg</span><br><span class="line">3×8&#x3D;？_d0a992ce88acf8a918f12646bef3a60d.jpg</span><br><span class="line">9-3&#x3D;？_d0a992ce88acf8a918f12646bef3a60d.jpg</span><br><span class="line">2-0&#x3D;？_d0a992ce88acf8a918f12646bef3a60d.jpg</span><br><span class="line">0+9&#x3D;？_3479d65864cdbbed02d5e9acb8e5fa37.jpg</span><br><span class="line">4-1&#x3D;？_3479d65864cdbbed02d5e9acb8e5fa37.jpg</span><br><span class="line">6+2&#x3D;？_3479d65864cdbbed02d5e9acb8e5fa37.jpg</span><br><span class="line">7×2&#x3D;？_3479d65864cdbbed02d5e9acb8e5fa37.jpg</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>然后就是验证码图片的保存。</p>
<p>主要代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BufferedImage bi = DefaultKaptcha.createImage(capStr);</span><br><span class="line">String fileName = dir.getPath()+File.separator+capStr.replace(<span class="string">"/"</span>,<span class="string">"÷"</span>).replace(<span class="string">"*"</span>,<span class="string">"×"</span>).replace(<span class="string">"?"</span>,<span class="string">"？"</span>) + <span class="string">"_"</span> + DigestUtils.md5Hex(<span class="string">""</span>+System.currentTimeMillis())+<span class="string">".jpg"</span>;</span><br><span class="line">ImageIO.write(bi, <span class="string">"jpg"</span>, <span class="keyword">new</span> File(fileName));</span><br></pre></td></tr></table></figure>



<p>生成的验证码如下：</p>
<p><img src="2%C3%B71=%EF%BC%9F_c893df08dbb80e70e26b7e352af0d4a4.jpg" alt="2/1=?"></p>
<p><img src="3%C3%975=%EF%BC%9F_44385059acbc138515e324c8e08af20c.jpg" alt="3*5=?"></p>
<p>到此获取标注好的验证码已经完成了，下面就开始进行验证码的识别。</p>
<h2 id="0x02-验证码的识别"><a href="#0x02-验证码的识别" class="headerlink" title="0x02  验证码的识别"></a>0x02  验证码的识别</h2><h3 id="1-分割识别"><a href="#1-分割识别" class="headerlink" title="1.分割识别"></a>1.分割识别</h3><p>最早是根据文章《<a href="https://guanqr.com/tech/computer/shangxueba-crack/" target="_blank" rel="noopener">自动识别验证码破解上学吧题目答案</a>》中的方法来进行验证码的识别，但是由于验证码不太规则，导致识别效果较差，后面就放弃了。这里列出简要过程。</p>
<p>验证码图片为 60×160 像素的，两个数字的范围都是 0 到 9。对图片转成灰度图后并进行分割。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">image &#x3D; Image.open(path).convert(&quot;L&quot;)</span><br><span class="line">cropped_image1 &#x3D; image.crop((25, 13, 50, 44))  # 第一个数字的切图</span><br><span class="line">cropped_image2 &#x3D; image.crop((65, 13, 90, 44))  # 第二个数字的切图</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可以自己找比较合适的分割位置。</p>
</blockquote>
<p>分割的效果：</p>
<p><img src="image_corp.png" alt="分割"></p>
<p>然后进行二值化，遍历灰度图的像素点，这里以阈值66为界限，使得图片的像素点要么为纯黑 0，要么为纯白 255，下图是二值化之后的图片：</p>
<p><img src="binarizing.png" alt="二值化"></p>
<p>接着对验证码样本进行批量切图、转灰度图、二值化：</p>
<p>批量对图片进行分割，然后保存格式为<code>数字_md5(时间戳).jpg</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">corpImg</span><span class="params">(name)</span>:</span></span><br><span class="line">    imgPath = <span class="string">"MathCodes/"</span> + name</span><br><span class="line">    fname = name[<span class="number">0</span>:<span class="number">1</span>]</span><br><span class="line">    img = cv2.imread(imgPath, <span class="number">0</span>)  <span class="comment"># 直接读为灰度图像</span></span><br><span class="line">    img1 = img[<span class="number">13</span>:<span class="number">44</span>, <span class="number">28</span>:<span class="number">52</span>] <span class="comment">#分割</span></span><br><span class="line">    cv2.imwrite(fname+<span class="string">"_"</span>+getMd5()+<span class="string">".jpg"</span>, img1)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    names = os.listdir(<span class="string">"MathCodes"</span>)</span><br><span class="line">    <span class="keyword">for</span> name <span class="keyword">in</span> names:</span><br><span class="line">        corpImg(name)</span><br></pre></td></tr></table></figure>

<p><img src="corpImages.png" alt="切图"></p>
<p>从中挑选出噪点去除效果最好图片的作为模板，0 到 9 这 10 个数字各一个。</p>
<p><img src="templets.png" alt="模板"></p>
<p>分别遍历这几个模板图片的像素点并存为 0-1 矩阵：首先创建一个 24列 31 行的二维数组（所有元素都为 0），遇到黑色像素点就将 0 变成 1，此处需要注意二维数组中坐标与像素点坐标是相反的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">num_info = [([<span class="number">0</span>] * <span class="number">24</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">31</span>)]  <span class="comment"># 创建一个宽度为24，高度为31的二维数组</span></span><br><span class="line">pixdata = img.load()</span><br><span class="line"><span class="keyword">for</span> y <span class="keyword">in</span> range(<span class="number">31</span>):</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">24</span>):</span><br><span class="line">        <span class="keyword">if</span> pixdata[x, y] == <span class="number">0</span>:</span><br><span class="line">            <span class="comment"># print(x, y)</span></span><br><span class="line">            num_info[y][x] = <span class="number">1</span>  <span class="comment"># 注意二维数组中坐标是相反的</span></span><br><span class="line">num_info_list.append(num_info)</span><br></pre></td></tr></table></figure>

<p>接下来就是识别了</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">num_info_list = []  <span class="comment"># 这个数组用以存储全部数字的 0-1 矩阵</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    filename = <span class="string">'temp/'</span>+str(i) + <span class="string">'.png'</span></span><br><span class="line">    img = Image.open(filename)</span><br><span class="line"></span><br><span class="line">    num_info = [([<span class="number">0</span>] * <span class="number">24</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">31</span>)]  <span class="comment"># 创建一个宽度为24，高度为31的二维数组</span></span><br><span class="line">    pixdata = img.load()</span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> range(<span class="number">31</span>):</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">24</span>):</span><br><span class="line">            <span class="keyword">if</span> pixdata[x, y] == <span class="number">0</span>:</span><br><span class="line">                <span class="comment"># print(x, y)</span></span><br><span class="line">                num_info[y][x] = <span class="number">1</span>  <span class="comment"># 注意二维数组中坐标是相反的</span></span><br><span class="line">    num_info_list.append(num_info)</span><br><span class="line">img = Image.open(<span class="string">'temp/067_1.jpg'</span>)</span><br><span class="line">img = binarizing(img,<span class="number">66</span>)</span><br><span class="line">img.save(<span class="string">"temp/01111.png"</span>)</span><br><span class="line">count_list = [] <span class="comment"># 记录当前图片像素信息与每一个 0-1 序列的匹配程度</span></span><br><span class="line"></span><br><span class="line">pixdata = img.load()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> range(<span class="number">31</span>):</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">24</span>):</span><br><span class="line">            <span class="keyword">if</span> pixdata[x, y] == <span class="number">0</span> <span class="keyword">and</span> num_info_list[i][y][x] == <span class="number">1</span>: <span class="comment"># 图片中黑色像素点出现的位置对应的矩阵点也是 1</span></span><br><span class="line">                count = count + <span class="number">1</span></span><br><span class="line">    count_list.append(count)</span><br><span class="line"></span><br><span class="line">print(count_list)</span><br><span class="line">print(<span class="string">'当前图片的识别结果：'</span> + str(count_list.index(max(count_list)))) <span class="comment"># 找到匹配数最大的那个元素的序号，而序号和数字是相同的。</span></span><br></pre></td></tr></table></figure>

<p><img src="corp_recogn_result.png" alt="分割识别"></p>
<p>从上面来看识别效果不是太好，所以后面就放弃了这种方法。</p>
<blockquote>
<p>也可以先分割验证码，之后用ddddocr进行识别，中间的运算符可以采用上述的方法进行识别。这里就说一个思路，不具体实现了。一来比较麻烦，二来是运算符处理的效果也不会太好，但最终的结果会比直接分割识别这种方法好。</p>
</blockquote>
<p>这是ddddocr识别效果，有一个没识别出来，不过准确率还挺高。</p>
<p><img src="ddddocr_recogn_result.png" alt="ddddocr识别"></p>
<p>接下来就使用pytorch进行训练。</p>
<h3 id="2-pytorch识别"><a href="#2-pytorch识别" class="headerlink" title="2.pytorch识别"></a>2.pytorch识别</h3><p>pytorch训练验证码的过程都差不多，这里从网上找了一套修改了一下。</p>
<p>样本已经有了，首先对验证码进行分析。验证码字符一共有16种，分别为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0123456789+-×÷&#x3D;？</span><br></pre></td></tr></table></figure>

<p>验证码长度为5</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">captcha_array &#x3D; list(&quot;0123456789+-×÷&#x3D;？&quot;)</span><br><span class="line">captcha_size &#x3D; 5</span><br></pre></td></tr></table></figure>

<p>接下来就是Datasets数据加载。</p>
<p>pytorch有非常方便高效的数据加载模块<code>Dataset</code>和<code>DataLoader</code>。<br>Dataset是数据样本的封装，可以很方便的读取数据。</p>
<p>实现一个Dataset的子类，需要重写<code>__len__</code>和<code>__getitem__</code>方法，<code>__len__</code>需要返回整个数据集的大小，<code>__getitem__</code>提供一个整数索引参数，返回一个样本数据（一个图片张量和一个标签张量）。主要代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyDataset</span><span class="params">(Dataset)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, root_dir)</span>:</span></span><br><span class="line">        super(MyDataset, self).__init__()</span><br><span class="line">        self.image_path = [os.path.join(root_dir, image_name) <span class="keyword">for</span> image_name <span class="keyword">in</span> os.listdir(root_dir)]</span><br><span class="line">        self.transforms = transforms.Compose(</span><br><span class="line">            [</span><br><span class="line">                transforms.ToTensor(),</span><br><span class="line">                transforms.Resize((<span class="number">60</span>, <span class="number">160</span>)),</span><br><span class="line">                transforms.Grayscale()  <span class="comment"># 灰色</span></span><br><span class="line">            ]</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.image_path.__len__()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, index)</span>:</span></span><br><span class="line">        image_path = self.image_path[index]</span><br><span class="line">        <span class="comment"># print(image_path)</span></span><br><span class="line">        image = self.transforms(Image.open(image_path))</span><br><span class="line">        ll = image_path.split(<span class="string">"/"</span>)[<span class="number">-1</span>]</span><br><span class="line">        ll = ll.split(<span class="string">"_"</span>)[<span class="number">0</span>] <span class="comment">#验证码文本</span></span><br><span class="line">        label_tensor = one_hot.text2Vec(ll)  <span class="comment"># [5,16]</span></span><br><span class="line">        label_tensor = label_tensor.view(<span class="number">1</span>, <span class="number">-1</span>)[<span class="number">0</span>]  <span class="comment"># [5*16]</span></span><br><span class="line">        <span class="comment"># print(label)</span></span><br><span class="line">        <span class="keyword">return</span> image, label_tensor</span><br></pre></td></tr></table></figure>



<p>其中<code>text2Vec</code>是将验证码进行onehot编码，这里是变成一个5*16的数组。</p>
<p>主要代码:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">text2Vec</span><span class="params">(text)</span>:</span></span><br><span class="line">    vec = torch.zeros(common.captcha_size, len(common.captcha_array))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(text)):</span><br><span class="line">        vec[i, common.captcha_array.index(text[i])] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> vec</span><br></pre></td></tr></table></figure>

<p>比如说<code>0×4=？</code>转换的结果就如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tensor([[1., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.], # 0</span><br><span class="line">        [0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 1., 0., 0., 0.], # ×</span><br><span class="line">        [0., 0., 0., 0., 1., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.], # 4</span><br><span class="line">        [0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 1., 0.], # &#x3D;</span><br><span class="line">        [0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 1.]]) # ？</span><br></pre></td></tr></table></figure>



<p>对应的还原方法:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">vec2Text</span><span class="params">(vec)</span>:</span></span><br><span class="line">    vec = torch.argmax(vec, dim=<span class="number">1</span>)  <span class="comment"># 取最大值，不是0的取出来</span></span><br><span class="line">    text = <span class="string">''</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> vec:</span><br><span class="line">        text += common.captcha_array[i]</span><br><span class="line">    <span class="keyword">return</span> text</span><br></pre></td></tr></table></figure>



<p>DataLoader是Dataset的进一步封装，Dataset每次通过<code>__getitem__</code>方法取到的是一个样本，经过DataLoader封装为dataloader后，每次取的是一个batch大小的样本批次。</p>
<p>主要代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">transform = transforms.Compose([transforms.ToTensor()])  <span class="comment"># 不做数据增强和标准化了</span></span><br><span class="line">train_dataset = CaptchaData(<span class="string">'./datasets/train/'</span>, transform=transform)</span><br><span class="line">train_data_loader = DataLoader(train_dataset, batch_size=<span class="number">32</span>, num_workers=<span class="number">0</span>, shuffle=<span class="literal">True</span>, drop_last=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">test_data = CaptchaData(<span class="string">'./datasets/test/'</span>, transform=transform)</span><br><span class="line">test_data_loader = DataLoader(test_data, batch_size=<span class="number">128</span>, num_workers=<span class="number">0</span>, shuffle=<span class="literal">True</span>, drop_last=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>transforms</code>是数据预处理操作，一般数据增强就通过transform实现，可以随机亮度，随机翻转，随机缩放等等。此处只使用了<code>ToTensor()</code>，将<code>PIL.Image</code>对象转换成Tensor。</p>
</blockquote>
<p>训练采用了CNN神经网络，CNN主要由卷积层，池化层，激活函数组成，再加上一个BatchNorm，BatchNorm叫做批规范化，可以加速模型的收敛速度。</p>
<p>模型的主要代码:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Net</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super(Net, self).__init__()</span><br><span class="line">        <span class="comment"># 第一层神经网络</span></span><br><span class="line">        <span class="comment"># nn.Sequential: 将里面的模块依次加入到神经网络中</span></span><br><span class="line">        self.layer1 = nn.Sequential(</span><br><span class="line">            nn.Conv2d(<span class="number">3</span>, <span class="number">16</span>, kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>),  <span class="comment"># 3通道变成16通道，图片：60*160</span></span><br><span class="line">            nn.BatchNorm2d(<span class="number">16</span>),</span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.MaxPool2d(<span class="number">2</span>)</span><br><span class="line">        )</span><br><span class="line">        <span class="comment"># 第2层神经网络</span></span><br><span class="line">        self.layer2 = nn.Sequential(</span><br><span class="line">            nn.Conv2d(<span class="number">16</span>, <span class="number">64</span>, kernel_size=<span class="number">3</span>),  <span class="comment"># 16通道变成64通道，图片：30*80</span></span><br><span class="line">            nn.BatchNorm2d(<span class="number">64</span>),</span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.MaxPool2d(<span class="number">2</span>)</span><br><span class="line">        )</span><br><span class="line">        <span class="comment"># 第3层神经网络</span></span><br><span class="line">        self.layer3 = nn.Sequential(</span><br><span class="line">            nn.Conv2d(<span class="number">64</span>, <span class="number">128</span>, kernel_size=<span class="number">3</span>),  <span class="comment"># 64通道变成128通道，图片：14*39</span></span><br><span class="line">            nn.BatchNorm2d(<span class="number">128</span>),</span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.MaxPool2d(<span class="number">2</span>)</span><br><span class="line">        )</span><br><span class="line">        <span class="comment"># 第4层神经网络</span></span><br><span class="line">        self.fc1 = nn.Sequential(</span><br><span class="line">            nn.Linear(<span class="number">13824</span>, <span class="number">1024</span>),</span><br><span class="line">            nn.Dropout(<span class="number">0.2</span>),  <span class="comment"># drop 20% of the neuron</span></span><br><span class="line">            nn.ReLU()</span><br><span class="line">        )</span><br><span class="line">        <span class="comment"># 第5层神经网络</span></span><br><span class="line">        self.fc2 = nn.Linear(<span class="number">1024</span>, common.captcha_size * common.captcha_array.__len__())  <span class="comment"># 5:验证码的长度， 16: 字母列表的长度</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 前向传播</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        x = x.to(device)</span><br><span class="line">        x = self.layer1(x)</span><br><span class="line">        x = self.layer2(x)</span><br><span class="line">        x = self.layer3(x)</span><br><span class="line">        x = x.view(x.size(<span class="number">0</span>), <span class="number">-1</span>)</span><br><span class="line">        x = self.fc1(x)</span><br><span class="line">        x = self.fc2(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure>



<p>nn.Sequential()可以看作模块的有序容器，可以方便快捷的搭建神经网络。<br>网络的输入是一个shape为<code>[batch, 3, 60, 180]</code>的张量，batch代表的是一个批次图片数量，3代表输入的图片是3通道的，即RGB，180和60则分别代表图片的宽和高。</p>
<p>经过上结构的卷积后，得到一个shape为<code>[batch, 128, 6, 18]</code>的张量，<code>x.view(x.size(0), -1)</code>将改变张量的shape为<code>[batch, 128*6*18]</code>，再用一个<code>[1024, 16*5]</code>的全连接层映射为一个<code>[batch, 16*5]</code>张量，这个就是模型的输出，其中<code>16</code>代表字符的种类数量，<code>5</code>代表一张验证码图片含有的字符数量。</p>
<p>接下来就是验证码的训练了：</p>
<p><img src="pytorch_train.png" alt="训练"></p>
<p>这里使用的是CPU进行训练的，训练样本生成了2000张，测试样本200张，刚开始训练准确率就可以到100%，而且速度不是太慢。</p>
<blockquote>
<p>验证码生成的脚本：<a href="https://github.com/fupinglee/Calculate_Captcha" target="_blank" rel="noopener">https://github.com/fupinglee/Calculate_Captcha</a></p>
<p>如果是在GPU下训练，在CPU下使用模型时，需要进行转换：</p>
<p><code>torch.load(model_path, map_location=torch.device(&#39;cpu&#39;))</code></p>
</blockquote>
<p>训练后测试的结果（200张测试准确率是100%，又另外生成了2000张验证码进行测试）：</p>
<p><img src="prtorch_test.png" alt="预测"></p>
<p>经过测试，使用pytorch训练的准确率可以达到99%。</p>
<p>完整代码：<a href="https://github.com/fupinglee/CalculateCaptcha_Recognition" target="_blank" rel="noopener">https://github.com/fupinglee/CalculateCaptcha_Recognition</a></p>
<h2 id="0x03-总结"><a href="#0x03-总结" class="headerlink" title="0x03  总结"></a>0x03  总结</h2><p>本文通过2种方法来对计算验证码进行识别。第一种方法使用简单，但识别率较低，可以针对一些比较简单的验证码（比如验证码未进行扭曲、干扰等）。第二种方法使用简单，但识别率比较依赖样本的数量，前期验证码标注是一件麻烦事，但对于本文这种简单的验证码，少量的样本准确率也会很高。</p>
<h2 id="0x04-参考"><a href="#0x04-参考" class="headerlink" title="0x04  参考"></a>0x04  参考</h2><p>1.<a href="https://guanqr.com/tech/computer/shangxueba-crack/" target="_blank" rel="noopener">自动识别验证码破解上学吧题目答案</a></p>
<p>2.<a href="https://zhuanlan.zhihu.com/p/215700831" target="_blank" rel="noopener">pyTorch – 图形验证码识别</a></p>
<p>3.<a href="https://github.com/fupinglee/Calculate_Captcha" target="_blank" rel="noopener">验证码代码</a></p>
<p>4.<a href="https://github.com/fupinglee/CalculateCaptcha_Recognition" target="_blank" rel="noopener">pytorch识别验证码代码</a></p>
</div><p class="post-tags"><i class="fa fa-tags" aria-hidden="true"></i><a href="/tags/%E9%AA%8C%E8%AF%81%E7%A0%81%E8%AF%86%E5%88%AB/">#验证码识别</a><a href="/tags/%E8%AE%A1%E7%AE%97%E9%AA%8C%E8%AF%81%E7%A0%81/">#计算验证码</a><a href="/tags/pytorch/">#pytorch</a><a href="/tags/%E8%8B%A5%E4%BE%9D%E9%AA%8C%E8%AF%81%E7%A0%81/">#若依验证码</a></p></article></div><footer><div class="paginator"><a href="/2022/07/07/YRX-APP-MATCH/" class="prev">PREV</a><a href="/2021/02/04/IOS-ShortCut-And-Smart-Lock/" class="next">NEXT</a></div><div class="copyright"><p>© 2016 - 2023 <a href="https://fuping.site">浮萍</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-103156844-1",'auto');ga('send','pageview');</script><link rel="stylesheet" href="//cdn.datatables.net/1.10.7/css/jquery.dataTables.min.css" media="screen" type="text/css"><script src="//cdn.datatables.net/1.10.7/js/jquery.dataTables.min.js"></script><script>$(function(){$('.datatable').dataTable( {"order": [[ 0, "desc" ]],"iDisplayLength": -1,"lengthMenu": [[10, 25, 50, -1], [10, 25, 50, "All"]]} );});</script></body></html>