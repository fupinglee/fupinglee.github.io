<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 如何从零写一个病毒专杀工具 · 浮萍's Blog</title><meta name="description" content="如何从零写一个病毒专杀工具 - 浮萍"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css"><link rel="search" type="application/opensearchdescription+xml" href="https://fuping.site/atom.xml" title="浮萍's Blog"><script src="//code.jquery.com/jquery-2.2.4.min.js" integrity="sha256-BbhdlvQf/xTY9gja0Dq3HiwQF8LaCRTXxZKRutelT44=" crossorigin="anonymous"></script><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="浮萍's Blog" type="application/atom+xml">
</head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">主页</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">所有文章</a></li><li class="nav-list-item"><a href="/tags" target="_self" class="nav-list-link">标签</a></li><li class="nav-list-item"><a href="/about" target="_self" class="nav-list-link">关于</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li><li class="nav-list-item"><a href="/search" target="_self" class="nav-list-link search"><i class="fa fa-search" aria-hidden="true"></i></a></li></ul></header><main class="container"></main><div class="post"><article class="post-block"><h1 class="post-title">如何从零写一个病毒专杀工具</h1><div class="post-info">Oct 28, 2022<span class="categories"><i class="fa fa-bookmark" aria-hidden="true"></i></span><a href="/categories/%E7%97%85%E6%AF%92%E6%9F%A5%E6%9D%80/" class="post-category">#病毒查杀</a></div><div class="post-content"><h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>最近有这样一个需求，需要对某病毒写一个专杀工具，针对这款病毒进行查杀。这个病毒样本是今年2月份发现的，该病毒相对来说比较友好，没有采用加密，也没有删除原文件，也没有网络传播行为。只是会感染可执行文件，会将原文件修改名字，生成一个与原文件同名的感染文件，运行后可继续感染其他文件。接下来首先从非专业的角度来简单看一下该病毒是如何运行的。</p>
<a id="more"></a>


<h2 id="0x01-病毒分析"><a href="#0x01-病毒分析" class="headerlink" title="0x01 病毒分析"></a>0x01 病毒分析</h2><p>运行病毒文件，一旦找到可感染的可执行文件，病毒会将其复制为 <code>g&lt;原始文件名&gt;.exe</code>，并将其隐藏。然后用原程序的名称和图标复制自己；如果原文件的资源中不存在该图标，病毒将使用自己的图标，并留下一个0大小的文件<code>g&lt;原始文件名&gt;.ico</code>。生成的文件大小为522k左右。</p>
<p><img src="1666836383554.png" alt="img"></p>
<p>如上图，python.exe感染后会生成gpython.exe（原始程序）并隐藏，此时python.exe（感染程序）相当于一个加载器，运行时会执行病毒程序同时运行gpython.exe。</p>
<p>如果文件夹中文件exe文件是g开头，则不感染。</p>
<p><img src="1666837129684.png" alt="img"></p>
<p>当点击替换后的可执行文件后，病毒会启动恶意主程序ground.exe，感染其他可执行文件，并设置开机启动项。</p>
<p><img src="1666836811133.png" alt="img"></p>
<p>启动项</p>
<p><img src="1666836847856.png" alt="img"></p>
<p>通过非专业的角度对病毒文件的运行进行了简单的分析，病毒查杀的话就是全盘或指定路径扫描可执行文件，根据病毒文件的特征码来判断该文件是否是病毒文件，如果是则进行删除，然后将原文件进行恢复。大致流程如下图：</p>
<p><img src="1666791988659.png" alt="img"></p>
<h2 id="0x02-代码编写"><a href="#0x02-代码编写" class="headerlink" title="0x02 代码编写"></a>0x02 代码编写</h2><p>根据上面的流程图，查杀代码可以分为三部分：1.实现可执行文件的扫描功能；2.实现病毒特征识别功能；3.删除病毒，恢复原文件。语言采用了C++，面向必（C）应（V）编程。</p>
<h3 id="1-文件扫描实现"><a href="#1-文件扫描实现" class="headerlink" title="1.文件扫描实现"></a>1.文件扫描实现</h3><p>其实就是递归遍历目录下的所有可执行文件，这里实现的方式有多种。例如可以采用<code>filesystem</code>（C++17以上）、<code>io.h</code>、<code>winApi</code>等。这里采用的是winApi。</p>
<p>主要代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;  result;</span><br><span class="line"><span class="function"><span class="keyword">bool</span>  <span class="title">search</span><span class="params">(<span class="keyword">const</span>  <span class="keyword">char</span>* path = <span class="string">"C:\\"</span>, <span class="keyword">char</span>* file = <span class="string">"exe"</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        HANDLE hFile;</span><br><span class="line">        <span class="keyword">char</span>   <span class="built_in">buffer</span>[MAX_PATH] = &#123; <span class="number">0</span>, &#125;;</span><br><span class="line">        WIN32_FIND_DATA pNextInfo;  <span class="comment">//搜索得到的文件信息将储存在pNextInfo中;</span></span><br><span class="line">        sprintf_s(<span class="built_in">buffer</span>, <span class="string">"%s\\*.*"</span>, path);</span><br><span class="line">        hFile = FindFirstFile(<span class="built_in">buffer</span>, &amp;pNextInfo);<span class="comment">//请注意是 &amp;pNextInfo , 不是 pNextInfo;</span></span><br><span class="line">        <span class="keyword">if</span> (!hFile) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">string</span>  t;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; buffer &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">while</span> (FindNextFile(hFile, &amp;pNextInfo))</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (pNextInfo.cFileName[<span class="number">0</span>] == <span class="string">'.'</span>)<span class="comment">//过滤.和..</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">//cout &lt;&lt; pNextInfo.cFileName &lt;&lt; endl;</span></span><br><span class="line">            <span class="keyword">if</span> (pNextInfo.dwFileAttributes &amp; FILE_ATTRIBUTE_DIRECTORY)</span><br><span class="line">            &#123;</span><br><span class="line">                ZeroMemory(<span class="built_in">buffer</span>, MAX_PATH);</span><br><span class="line">                sprintf_s(<span class="built_in">buffer</span>, <span class="string">"%s\\%s"</span>, path, pNextInfo.cFileName);</span><br><span class="line">                <span class="comment">//cout &lt;&lt; buffer &lt;&lt; endl;</span></span><br><span class="line">                search(<span class="built_in">buffer</span>, file);</span><br><span class="line">            &#125;</span><br><span class="line">            t.assign(path);</span><br><span class="line">            t += <span class="string">'\\'</span>;</span><br><span class="line">            t.append(pNextInfo.cFileName);</span><br><span class="line">            <span class="keyword">int</span> len = <span class="built_in">strlen</span>(file);</span><br><span class="line">            <span class="keyword">if</span> (t.substr(t.<span class="built_in">size</span>() - len) == file)</span><br><span class="line">            &#123;</span><br><span class="line">                result.push_back(t);<span class="comment">//对t对象进行深复制</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    search(<span class="string">"E:\\"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, result.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要就是递归搜索所有exe后缀的文件，然后存在vector中。</p>
<h3 id="2-病毒特征码提取"><a href="#2-病毒特征码提取" class="headerlink" title="2.病毒特征码提取"></a>2.病毒特征码提取</h3><p>特征码可能是病毒的感染标记，也可能是若干计算机指令组成的一段计算机程序。特征码的提取方式有多种，例如该病毒中存在字符串<code>Groud</code>，可以以此作为特征码。</p>
<p><img src="1666856505117.png" alt="img"></p>
<p>搜索字符串<code>Ground</code>，有多处存在，挑选一处。如上图所示，如果位置<code>0x59B53</code>-<code>0x59B59</code>为<code>47 72 6F 75 6E 64</code>则认为该文件为病毒文件。这是根据字符串特征来搜索的，可能会不太准确，也可以采用病毒查杀的方式来定位特征码。可以使用工具MYCCL3.0或者VirTest5.0。这里使用的是VirTest5.0。</p>
<p>根据工具的使用说明来制作测试文件和载入测试文件。</p>
<p><img src="1666857098976.png" alt="img"></p>
<p>接下来就是定位特征了，这里杀软使用了某绒。</p>
<p><img src="1666857445236.png" alt="img"></p>
<p>最终定位到了偏移0x290-0x294，内容为<code>046AF6EB</code>。我们来验证一下。将偏移0x290-0x294的数据nop后，针对该文件以及该文件感染的文件，用该huorong杀毒扫描，提示无风险。</p>
<p><img src="1666861432606.png" alt="img"></p>
<p>而且执行感染的文件，杀软也不会对其进行拦截。</p>
<p><img src="1666861732742.png" alt="img"></p>
<blockquote>
<p>当然可能由于这里是虚拟机，所以部分杀软某些功能未启动而导致。</p>
</blockquote>
<p>有特征码了，就可以根据该特征码来判断文件是否是病毒文件，当然为了以防万一，可以采用进行多个特征码来进行判断。主要代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 扫描特征码，对比</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">GetPeSignature</span><span class="params">(LPCSTR FilePath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    boolean flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">SIGN</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="keyword">char</span> FileName[<span class="number">64</span>];         <span class="comment">// 存储文件名或特征描述</span></span><br><span class="line">        LONG FileOffset;           <span class="comment">// 存储检测文件偏移地址</span></span><br><span class="line">        BYTE VirusSign[<span class="number">4</span> + <span class="number">1</span>];    <span class="comment">// 存储特征码大小4,其中的1是结束符.</span></span><br><span class="line">    &#125;SIGN, *pSIGN;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义特征码与特征描述信息</span></span><br><span class="line">    SIGN Sign[] = &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"HuoRong"</span>,</span><br><span class="line">            <span class="number">0x2970</span>,</span><br><span class="line">            <span class="string">"\x04\x6a\xf6\xeb"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"360_1"</span>,</span><br><span class="line">            <span class="number">0x61c6b</span>,</span><br><span class="line">            <span class="string">"\x8B\x75\xF0\x8B"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"360_2"</span>,</span><br><span class="line">            <span class="number">0x738E5</span>,</span><br><span class="line">            <span class="string">"\xC4\x07\x00\xBC"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    DWORD dwNum = <span class="number">0</span>;</span><br><span class="line">    BYTE buffer[<span class="number">4</span> + <span class="number">1</span>];</span><br><span class="line">    HANDLE hFile = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取到FilePath路径下文件的句柄信息</span></span><br><span class="line">    hFile = CreateFile(FilePath, GENERIC_READ , <span class="literal">NULL</span>,</span><br><span class="line">        <span class="literal">NULL</span>, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">/*DWORD error = GetLastError();</span></span><br><span class="line"><span class="comment">    cout &lt;&lt; hFile &lt;&lt; error &lt;&lt; endl;*/</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; (<span class="keyword">sizeof</span>(Sign) / <span class="keyword">sizeof</span>(Sign[<span class="number">0</span>])); x++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 将待检测程序的文件指针指向特征码的偏移位置</span></span><br><span class="line">        SetFilePointer(hFile, Sign[x].FileOffset, <span class="literal">NULL</span>, FILE_BEGIN);</span><br><span class="line">        <span class="comment">// 读取目标程序指定位置的特征码到内存中</span></span><br><span class="line">        ReadFile(hFile, buffer, <span class="keyword">sizeof</span>(buffer), &amp;dwNum, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="comment">// 对比内存中两个特征码是否相等</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">memcmp</span>(Sign[x].VirusSign, buffer, <span class="number">4</span>) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            count++;</span><br><span class="line">            <span class="comment">//printf("匹配特征: %s \n", Sign[x].FileName);</span></span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (count == <span class="keyword">sizeof</span>(Sign) / <span class="keyword">sizeof</span>(Sign[<span class="number">0</span>])) &#123;</span><br><span class="line">        flag = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    CloseHandle(hFile);</span><br><span class="line">    <span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-删除病毒，恢复原文件"><a href="#3-删除病毒，恢复原文件" class="headerlink" title="3.删除病毒，恢复原文件"></a>3.删除病毒，恢复原文件</h3><p>接下来就是删除病毒和恢复文件了，可以直接使用<code>remove()</code>来删除文件，但是为了防止删错文件，因此这里将文件删除到了回收站。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">delFiletoRecycle</span><span class="params">(LPCTSTR pszPath, BOOL bDelete<span class="comment">/*=FALSE*/</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SHFILEOPSTRUCT  shDelFile;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;shDelFile, <span class="number">0</span>, <span class="keyword">sizeof</span>(SHFILEOPSTRUCT));</span><br><span class="line">    shDelFile.fFlags |= FOF_SILENT;      <span class="comment">// don't report progress</span></span><br><span class="line">    shDelFile.fFlags |= FOF_NOERRORUI;     <span class="comment">// don't report errors</span></span><br><span class="line">    shDelFile.fFlags |= FOF_NOCONFIRMATION;    <span class="comment">// don't confirm delete</span></span><br><span class="line"></span><br><span class="line">    TCHAR buf[_MAX_PATH + <span class="number">1</span>]; <span class="comment">// allow one more character</span></span><br><span class="line">    strcpy_s(buf, pszPath);   <span class="comment">// copy caller's pathname</span></span><br><span class="line">    buf[<span class="built_in">strlen</span>(buf) + <span class="number">1</span>] = <span class="number">0</span>;   <span class="comment">// need two NULLs at end</span></span><br><span class="line"></span><br><span class="line">                                 <span class="comment">// Set SHFILEOPSTRUCT params for delete operation</span></span><br><span class="line">    shDelFile.wFunc = FO_DELETE;       <span class="comment">// REQUIRED: delete operation</span></span><br><span class="line">    shDelFile.pFrom = buf;         <span class="comment">// REQUIRED: which file(s)</span></span><br><span class="line">    shDelFile.pTo = <span class="literal">NULL</span>;          <span class="comment">// MUST be NULL</span></span><br><span class="line">    <span class="keyword">if</span> (bDelete)</span><br><span class="line">    &#123;         <span class="comment">// if delete requested..</span></span><br><span class="line">        shDelFile.fFlags &amp;= ~FOF_ALLOWUNDO;    <span class="comment">// ..don't use Recycle Bin</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;           <span class="comment">// otherwise..</span></span><br><span class="line">        shDelFile.fFlags |= FOF_ALLOWUNDO;    <span class="comment">// ..send to Recycle Bin</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> SHFileOperation(&amp;shDelFile);    <span class="comment">// do it!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>删除完毕后，如果存在原文件，就将原文件恢复。</p>
<p><img src="1666858868262.png" alt="img"></p>
<p>命令行的话可以使用<code>attirb</code>，这里代码的话采用了<code>SetFileAttributes</code>。并使用<code>rename</code>将原文件恢复原名。主要代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SetFileAttributes(<span class="string">"gtest.exe"</span>, FILE_ATTRIBUTE_NORMAL);</span><br><span class="line">rename(<span class="string">"gtest.exe"</span>, <span class="string">"test.exe"</span>);</span><br></pre></td></tr></table></figure>



<p>然后将上面的代码整合一下运行，添加日志记录。运行效果：</p>
<p><img src="1666860279613.png" alt="img"></p>
<blockquote>
<p>这里执行的是感染后的”专杀”工具，可以看到又起了一个窗口，并执行了专杀工具。最终也会将该文件恢复。图上显示的仍为g开头，需要刷新一下即可。</p>
</blockquote>
<p>可以成功删除病毒文件并恢复原文件。</p>
<p><img src="1666860357983.png" alt="img"></p>
<p>删除的文件放在了回收站中。但从执行情况来看，有删除失败的文件，这是由于病毒文件正在执行，所以未能删除。要删除也可以，找到对应的pid，结束任务，再进行删除。这里就不再进行操作了。</p>
<h2 id="0x03-总结"><a href="#0x03-总结" class="headerlink" title="0x03 总结"></a>0x03 总结</h2><p>本文简单实现了一个病毒专杀工具，用的比较简单和基础的方法，没有涉及太多复杂的内容。可能存在问题较多，还有许多需要完善的地方，不过针对当前这款病毒查杀暂时没多大问题。最重要的一点就是如何去确定病毒的特征码，这将作为能否删除病毒文件的关键。</p>
</div><p class="post-tags"><i class="fa fa-tags" aria-hidden="true"></i><a href="/tags/%E7%97%85%E6%AF%92%E6%9F%A5%E6%9D%80/">#病毒查杀</a><a href="/tags/%E7%89%B9%E5%BE%81%E7%A0%81/">#特征码</a><a href="/tags/%E4%BB%A3%E7%A0%81%E5%BC%80%E5%8F%91/">#代码开发</a></p></article></div><footer><div class="paginator"><a href="/2023/03/07/IOS-Jailbreak-Environment/" class="prev">上一篇</a><a href="/2022/10/21/IOS-Storm-Sniffer-Reverse/" class="next">下一篇</a></div><div class="copyright"><p>© 2016 - 2025 <a href="https://fuping.site">浮萍</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-103156844-1",'auto');ga('send','pageview');</script><link rel="stylesheet" href="//cdn.datatables.net/1.10.7/css/jquery.dataTables.min.css" media="screen" type="text/css"><script src="//cdn.datatables.net/1.10.7/js/jquery.dataTables.min.js"></script><script>$(function(){$('.datatable').dataTable( {"order": [[ 0, "desc" ]],"iDisplayLength": -1,"lengthMenu": [[10, 25, 50, -1], [10, 25, 50, "All"]]} );});</script></body></html>